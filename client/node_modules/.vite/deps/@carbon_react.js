import {
  Add,
  AddFilled,
  AiLabel,
  ArrowRight,
  ArrowUp,
  ArrowsVertical,
  Calendar,
  CaretDown,
  CaretLeft,
  CaretRight,
  Caution,
  Checkbox,
  CheckboxCheckedFilled,
  Checkmark,
  CheckmarkFilled,
  CheckmarkOutline,
  ChevronDown,
  ChevronLeft,
  ChevronRight,
  CircleDash,
  CircleFill,
  CircleStroke,
  Close,
  Copy,
  Critical,
  CriticalSeverity,
  DiamondFill,
  Error as Error2,
  ErrorFilled,
  InProgress,
  Incomplete,
  InformationFilled,
  InformationSquareFilled,
  LowSeverity,
  Menu,
  OverflowMenuHorizontal,
  OverflowMenuVertical,
  PendingFilled,
  RadioButton,
  RadioButtonChecked,
  Search,
  Settings,
  Subtract,
  UndefinedFilled,
  Undo,
  UnknownFilled,
  View,
  ViewOff,
  Warning,
  WarningAltFilled,
  WarningAltInvertedFilled,
  WarningFilled,
  WarningSquareFilled,
  require_prop_types
} from "./chunk-DP2HAZ74.js";
import {
  require_jsx_runtime
} from "./chunk-6PXSGDAH.js";
import {
  require_react_dom
} from "./chunk-PJEEZAML.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = "";
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (arg) {
            classes = appendClass(classes, parseValue(arg));
          }
        }
        return classes;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes = appendClass(classes, key);
          }
        }
        return classes;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy2(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format2 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format2, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy2;
  }
});

// node_modules/downshift/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/downshift/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement4(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement4;
        exports.isForwardRef = isForwardRef2;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/downshift/node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/downshift/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/react-fast-compare/index.js
var require_react_fast_compare = __commonJS({
  "node_modules/react-fast-compare/index.js"(exports, module) {
    var hasElementType = typeof Element !== "undefined";
    var hasMap = typeof Map === "function";
    var hasSet = typeof Set === "function";
    var hasArrayBuffer = typeof ArrayBuffer === "function" && !!ArrayBuffer.isView;
    function equal(a, b2) {
      if (a === b2) return true;
      if (a && b2 && typeof a == "object" && typeof b2 == "object") {
        if (a.constructor !== b2.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b2.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b2[i])) return false;
          return true;
        }
        var it;
        if (hasMap && a instanceof Map && b2 instanceof Map) {
          if (a.size !== b2.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b2.has(i.value[0])) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!equal(i.value[1], b2.get(i.value[0]))) return false;
          return true;
        }
        if (hasSet && a instanceof Set && b2 instanceof Set) {
          if (a.size !== b2.size) return false;
          it = a.entries();
          while (!(i = it.next()).done)
            if (!b2.has(i.value[0])) return false;
          return true;
        }
        if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b2)) {
          length = a.length;
          if (length != b2.length) return false;
          for (i = length; i-- !== 0; )
            if (a[i] !== b2[i]) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b2.source && a.flags === b2.flags;
        if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === "function" && typeof b2.valueOf === "function") return a.valueOf() === b2.valueOf();
        if (a.toString !== Object.prototype.toString && typeof a.toString === "function" && typeof b2.toString === "function") return a.toString() === b2.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b2).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i])) return false;
        if (hasElementType && a instanceof Element) return false;
        for (i = length; i-- !== 0; ) {
          if ((keys[i] === "_owner" || keys[i] === "__v" || keys[i] === "__o") && a.$$typeof) {
            continue;
          }
          if (!equal(a[keys[i]], b2[keys[i]])) return false;
        }
        return true;
      }
      return a !== a && b2 !== b2;
    }
    module.exports = function isEqual8(a, b2) {
      try {
        return equal(a, b2);
      } catch (error2) {
        if ((error2.message || "").match(/stack|recursion/i)) {
          console.warn("react-fast-compare cannot handle circular refs");
          return false;
        }
        throw error2;
      }
    };
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      function typeOf(object) {
        if ("object" === typeof object && null !== object) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object = object.type, object) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object;
                default:
                  switch (object = object && object.$$typeof, object) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object;
                    case REACT_CONSUMER_TYPE:
                      return object;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      exports.ContextConsumer = REACT_CONSUMER_TYPE;
      exports.ContextProvider = REACT_CONTEXT_TYPE;
      exports.Element = REACT_ELEMENT_TYPE;
      exports.ForwardRef = REACT_FORWARD_REF_TYPE;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Lazy = REACT_LAZY_TYPE;
      exports.Memo = REACT_MEMO_TYPE;
      exports.Portal = REACT_PORTAL_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      exports.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
      };
      exports.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      };
      exports.isElement = function(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      };
      exports.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      };
      exports.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      };
      exports.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      };
      exports.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      };
      exports.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      };
      exports.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      };
      exports.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      };
      exports.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      };
      exports.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      };
      exports.isValidElementType = function(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
      };
      exports.typeOf = typeOf;
    })();
  }
});

// node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development2();
    }
  }
});

// node_modules/invariant/browser.js
var require_browser = __commonJS({
  "node_modules/invariant/browser.js"(exports, module) {
    "use strict";
    var invariant3 = function(condition, format, a, b2, c, d, e2, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error2;
        if (format === void 0) {
          error2 = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b2, c, d, e2, f];
          var argIndex = 0;
          error2 = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error2.name = "Invariant Violation";
        }
        error2.framesToPop = 1;
        throw error2;
      }
    };
    module.exports = invariant3;
  }
});

// node_modules/window-or-global/lib/index.js
var require_lib = __commonJS({
  "node_modules/window-or-global/lib/index.js"(exports, module) {
    "use strict";
    module.exports = typeof self === "object" && self.self === self && self || typeof global === "object" && global.global === global && global || exports;
  }
});

// node_modules/flatpickr/dist/l10n/index.js
var require_l10n = __commonJS({
  "node_modules/flatpickr/dist/l10n/index.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.index = {}));
    })(exports, function(exports2) {
      "use strict";
      var __assign3 = function() {
        __assign3 = Object.assign || function __assign4(t3) {
          for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t3[p] = s[p];
          }
          return t3;
        };
        return __assign3.apply(this, arguments);
      };
      var fp = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Arabic = {
        weekdays: {
          shorthand: ["أحد", "اثنين", "ثلاثاء", "أربعاء", "خميس", "جمعة", "سبت"],
          longhand: [
            "الأحد",
            "الاثنين",
            "الثلاثاء",
            "الأربعاء",
            "الخميس",
            "الجمعة",
            "السبت"
          ]
        },
        months: {
          shorthand: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
          longhand: [
            "يناير",
            "فبراير",
            "مارس",
            "أبريل",
            "مايو",
            "يونيو",
            "يوليو",
            "أغسطس",
            "سبتمبر",
            "أكتوبر",
            "نوفمبر",
            "ديسمبر"
          ]
        },
        firstDayOfWeek: 6,
        rangeSeparator: " إلى ",
        weekAbbreviation: "Wk",
        scrollTitle: "قم بالتمرير للزيادة",
        toggleTitle: "اضغط للتبديل",
        amPM: ["ص", "م"],
        yearAriaLabel: "سنة",
        monthAriaLabel: "شهر",
        hourAriaLabel: "ساعة",
        minuteAriaLabel: "دقيقة",
        time_24hr: false
      };
      fp.l10ns.ar = Arabic;
      fp.l10ns;
      var fp$1 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Austria = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
            "Sonntag",
            "Montag",
            "Dienstag",
            "Mittwoch",
            "Donnerstag",
            "Freitag",
            "Samstag"
          ]
        },
        months: {
          shorthand: [
            "Jän",
            "Feb",
            "Mär",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dez"
          ],
          longhand: [
            "Jänner",
            "Februar",
            "März",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Dezember"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum Ändern scrollen",
        toggleTitle: "Zum Umschalten klicken",
        time_24hr: true
      };
      fp$1.l10ns.at = Austria;
      fp$1.l10ns;
      var fp$2 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Azerbaijan = {
        weekdays: {
          shorthand: ["B.", "B.e.", "Ç.a.", "Ç.", "C.a.", "C.", "Ş."],
          longhand: [
            "Bazar",
            "Bazar ertəsi",
            "Çərşənbə axşamı",
            "Çərşənbə",
            "Cümə axşamı",
            "Cümə",
            "Şənbə"
          ]
        },
        months: {
          shorthand: [
            "Yan",
            "Fev",
            "Mar",
            "Apr",
            "May",
            "İyn",
            "İyl",
            "Avq",
            "Sen",
            "Okt",
            "Noy",
            "Dek"
          ],
          longhand: [
            "Yanvar",
            "Fevral",
            "Mart",
            "Aprel",
            "May",
            "İyun",
            "İyul",
            "Avqust",
            "Sentyabr",
            "Oktyabr",
            "Noyabr",
            "Dekabr"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artırmaq üçün sürüşdürün",
        toggleTitle: "Aç / Bağla",
        amPM: ["GƏ", "GS"],
        time_24hr: true
      };
      fp$2.l10ns.az = Azerbaijan;
      fp$2.l10ns;
      var fp$3 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Belarusian = {
        weekdays: {
          shorthand: ["Нд", "Пн", "Аў", "Ср", "Чц", "Пт", "Сб"],
          longhand: [
            "Нядзеля",
            "Панядзелак",
            "Аўторак",
            "Серада",
            "Чацвер",
            "Пятніца",
            "Субота"
          ]
        },
        months: {
          shorthand: [
            "Сту",
            "Лют",
            "Сак",
            "Кра",
            "Тра",
            "Чэр",
            "Ліп",
            "Жні",
            "Вер",
            "Кас",
            "Ліс",
            "Сне"
          ],
          longhand: [
            "Студзень",
            "Люты",
            "Сакавік",
            "Красавік",
            "Травень",
            "Чэрвень",
            "Ліпень",
            "Жнівень",
            "Верасень",
            "Кастрычнік",
            "Лістапад",
            "Снежань"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Тыд.",
        scrollTitle: "Пракруціце для павелічэння",
        toggleTitle: "Націсніце для пераключэння",
        amPM: ["ДП", "ПП"],
        yearAriaLabel: "Год",
        time_24hr: true
      };
      fp$3.l10ns.be = Belarusian;
      fp$3.l10ns;
      var fp$4 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bosnian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
          longhand: [
            "Nedjelja",
            "Ponedjeljak",
            "Utorak",
            "Srijeda",
            "Četvrtak",
            "Petak",
            "Subota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Avg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mart",
            "April",
            "Maj",
            "Juni",
            "Juli",
            "Avgust",
            "Septembar",
            "Oktobar",
            "Novembar",
            "Decembar"
          ]
        },
        time_24hr: true
      };
      fp$4.l10ns.bs = Bosnian;
      fp$4.l10ns;
      var fp$5 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bulgarian = {
        weekdays: {
          shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: [
            "Неделя",
            "Понеделник",
            "Вторник",
            "Сряда",
            "Четвъртък",
            "Петък",
            "Събота"
          ]
        },
        months: {
          shorthand: [
            "Яну",
            "Фев",
            "Март",
            "Апр",
            "Май",
            "Юни",
            "Юли",
            "Авг",
            "Сеп",
            "Окт",
            "Ное",
            "Дек"
          ],
          longhand: [
            "Януари",
            "Февруари",
            "Март",
            "Април",
            "Май",
            "Юни",
            "Юли",
            "Август",
            "Септември",
            "Октомври",
            "Ноември",
            "Декември"
          ]
        },
        time_24hr: true,
        firstDayOfWeek: 1
      };
      fp$5.l10ns.bg = Bulgarian;
      fp$5.l10ns;
      var fp$6 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Bangla = {
        weekdays: {
          shorthand: ["রবি", "সোম", "মঙ্গল", "বুধ", "বৃহস্পতি", "শুক্র", "শনি"],
          longhand: [
            "রবিবার",
            "সোমবার",
            "মঙ্গলবার",
            "বুধবার",
            "বৃহস্পতিবার",
            "শুক্রবার",
            "শনিবার"
          ]
        },
        months: {
          shorthand: [
            "জানু",
            "ফেব্রু",
            "মার্চ",
            "এপ্রিল",
            "মে",
            "জুন",
            "জুলাই",
            "আগ",
            "সেপ্টে",
            "অক্টো",
            "নভে",
            "ডিসে"
          ],
          longhand: [
            "জানুয়ারী",
            "ফেব্রুয়ারী",
            "মার্চ",
            "এপ্রিল",
            "মে",
            "জুন",
            "জুলাই",
            "আগস্ট",
            "সেপ্টেম্বর",
            "অক্টোবর",
            "নভেম্বর",
            "ডিসেম্বর"
          ]
        }
      };
      fp$6.l10ns.bn = Bangla;
      fp$6.l10ns;
      var fp$7 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Catalan = {
        weekdays: {
          shorthand: ["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"],
          longhand: [
            "Diumenge",
            "Dilluns",
            "Dimarts",
            "Dimecres",
            "Dijous",
            "Divendres",
            "Dissabte"
          ]
        },
        months: {
          shorthand: [
            "Gen",
            "Febr",
            "Març",
            "Abr",
            "Maig",
            "Juny",
            "Jul",
            "Ag",
            "Set",
            "Oct",
            "Nov",
            "Des"
          ],
          longhand: [
            "Gener",
            "Febrer",
            "Març",
            "Abril",
            "Maig",
            "Juny",
            "Juliol",
            "Agost",
            "Setembre",
            "Octubre",
            "Novembre",
            "Desembre"
          ]
        },
        ordinal: function(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21)
            return "è";
          switch (s % 10) {
            case 1:
              return "r";
            case 2:
              return "n";
            case 3:
              return "r";
            case 4:
              return "t";
            default:
              return "è";
          }
        },
        firstDayOfWeek: 1,
        rangeSeparator: " a ",
        time_24hr: true
      };
      fp$7.l10ns.cat = fp$7.l10ns.ca = Catalan;
      fp$7.l10ns;
      var fp$8 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Kurdish = {
        weekdays: {
          shorthand: [
            "یەکشەممە",
            "دووشەممە",
            "سێشەممە",
            "چوارشەممە",
            "پێنجشەممە",
            "هەینی",
            "شەممە"
          ],
          longhand: [
            "یەکشەممە",
            "دووشەممە",
            "سێشەممە",
            "چوارشەممە",
            "پێنجشەممە",
            "هەینی",
            "شەممە"
          ]
        },
        months: {
          shorthand: [
            "ڕێبەندان",
            "ڕەشەمە",
            "نەورۆز",
            "گوڵان",
            "جۆزەردان",
            "پووشپەڕ",
            "گەلاوێژ",
            "خەرمانان",
            "ڕەزبەر",
            "گەڵاڕێزان",
            "سەرماوەز",
            "بەفرانبار"
          ],
          longhand: [
            "ڕێبەندان",
            "ڕەشەمە",
            "نەورۆز",
            "گوڵان",
            "جۆزەردان",
            "پووشپەڕ",
            "گەلاوێژ",
            "خەرمانان",
            "ڕەزبەر",
            "گەڵاڕێزان",
            "سەرماوەز",
            "بەفرانبار"
          ]
        },
        firstDayOfWeek: 6,
        ordinal: function() {
          return "";
        }
      };
      fp$8.l10ns.ckb = Kurdish;
      fp$8.l10ns;
      var fp$9 = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Czech = {
        weekdays: {
          shorthand: ["Ne", "Po", "Út", "St", "Čt", "Pá", "So"],
          longhand: [
            "Neděle",
            "Pondělí",
            "Úterý",
            "Středa",
            "Čtvrtek",
            "Pátek",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Led",
            "Ún",
            "Bře",
            "Dub",
            "Kvě",
            "Čer",
            "Čvc",
            "Srp",
            "Zář",
            "Říj",
            "Lis",
            "Pro"
          ],
          longhand: [
            "Leden",
            "Únor",
            "Březen",
            "Duben",
            "Květen",
            "Červen",
            "Červenec",
            "Srpen",
            "Září",
            "Říjen",
            "Listopad",
            "Prosinec"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " do ",
        weekAbbreviation: "Týd.",
        scrollTitle: "Rolujte pro změnu",
        toggleTitle: "Přepnout dopoledne/odpoledne",
        amPM: ["dop.", "odp."],
        yearAriaLabel: "Rok",
        time_24hr: true
      };
      fp$9.l10ns.cs = Czech;
      fp$9.l10ns;
      var fp$a = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Welsh = {
        weekdays: {
          shorthand: ["Sul", "Llun", "Maw", "Mer", "Iau", "Gwe", "Sad"],
          longhand: [
            "Dydd Sul",
            "Dydd Llun",
            "Dydd Mawrth",
            "Dydd Mercher",
            "Dydd Iau",
            "Dydd Gwener",
            "Dydd Sadwrn"
          ]
        },
        months: {
          shorthand: [
            "Ion",
            "Chwef",
            "Maw",
            "Ebr",
            "Mai",
            "Meh",
            "Gorff",
            "Awst",
            "Medi",
            "Hyd",
            "Tach",
            "Rhag"
          ],
          longhand: [
            "Ionawr",
            "Chwefror",
            "Mawrth",
            "Ebrill",
            "Mai",
            "Mehefin",
            "Gorffennaf",
            "Awst",
            "Medi",
            "Hydref",
            "Tachwedd",
            "Rhagfyr"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function(nth) {
          if (nth === 1)
            return "af";
          if (nth === 2)
            return "ail";
          if (nth === 3 || nth === 4)
            return "ydd";
          if (nth === 5 || nth === 6)
            return "ed";
          if (nth >= 7 && nth <= 10 || nth == 12 || nth == 15 || nth == 18 || nth == 20)
            return "fed";
          if (nth == 11 || nth == 13 || nth == 14 || nth == 16 || nth == 17 || nth == 19)
            return "eg";
          if (nth >= 21 && nth <= 39)
            return "ain";
          return "";
        },
        time_24hr: true
      };
      fp$a.l10ns.cy = Welsh;
      fp$a.l10ns;
      var fp$b = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Danish = {
        weekdays: {
          shorthand: ["søn", "man", "tir", "ons", "tors", "fre", "lør"],
          longhand: [
            "søndag",
            "mandag",
            "tirsdag",
            "onsdag",
            "torsdag",
            "fredag",
            "lørdag"
          ]
        },
        months: {
          shorthand: [
            "jan",
            "feb",
            "mar",
            "apr",
            "maj",
            "jun",
            "jul",
            "aug",
            "sep",
            "okt",
            "nov",
            "dec"
          ],
          longhand: [
            "januar",
            "februar",
            "marts",
            "april",
            "maj",
            "juni",
            "juli",
            "august",
            "september",
            "oktober",
            "november",
            "december"
          ]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "uge",
        time_24hr: true
      };
      fp$b.l10ns.da = Danish;
      fp$b.l10ns;
      var fp$c = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var German = {
        weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
            "Sonntag",
            "Montag",
            "Dienstag",
            "Mittwoch",
            "Donnerstag",
            "Freitag",
            "Samstag"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mär",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dez"
          ],
          longhand: [
            "Januar",
            "Februar",
            "März",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Dezember"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "KW",
        rangeSeparator: " bis ",
        scrollTitle: "Zum Ändern scrollen",
        toggleTitle: "Zum Umschalten klicken",
        time_24hr: true
      };
      fp$c.l10ns.de = German;
      fp$c.l10ns;
      var english2 = {
        weekdays: {
          shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
          longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        firstDayOfWeek: 0,
        ordinal: function(nth) {
          var s = nth % 100;
          if (s > 3 && s < 21)
            return "th";
          switch (s % 10) {
            case 1:
              return "st";
            case 2:
              return "nd";
            case 3:
              return "rd";
            default:
              return "th";
          }
        },
        rangeSeparator: " to ",
        weekAbbreviation: "Wk",
        scrollTitle: "Scroll to increment",
        toggleTitle: "Click to toggle",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Year",
        monthAriaLabel: "Month",
        hourAriaLabel: "Hour",
        minuteAriaLabel: "Minute",
        time_24hr: false
      };
      var fp$d = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Esperanto = {
        firstDayOfWeek: 1,
        rangeSeparator: " ĝis ",
        weekAbbreviation: "Sem",
        scrollTitle: "Rulumu por pligrandigi la valoron",
        toggleTitle: "Klaku por ŝalti",
        weekdays: {
          shorthand: ["Dim", "Lun", "Mar", "Mer", "Ĵaŭ", "Ven", "Sab"],
          longhand: [
            "dimanĉo",
            "lundo",
            "mardo",
            "merkredo",
            "ĵaŭdo",
            "vendredo",
            "sabato"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Aŭg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "januaro",
            "februaro",
            "marto",
            "aprilo",
            "majo",
            "junio",
            "julio",
            "aŭgusto",
            "septembro",
            "oktobro",
            "novembro",
            "decembro"
          ]
        },
        ordinal: function() {
          return "-a";
        },
        time_24hr: true
      };
      fp$d.l10ns.eo = Esperanto;
      fp$d.l10ns;
      var fp$e = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Spanish = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"],
          longhand: [
            "Domingo",
            "Lunes",
            "Martes",
            "Miércoles",
            "Jueves",
            "Viernes",
            "Sábado"
          ]
        },
        months: {
          shorthand: [
            "Ene",
            "Feb",
            "Mar",
            "Abr",
            "May",
            "Jun",
            "Jul",
            "Ago",
            "Sep",
            "Oct",
            "Nov",
            "Dic"
          ],
          longhand: [
            "Enero",
            "Febrero",
            "Marzo",
            "Abril",
            "Mayo",
            "Junio",
            "Julio",
            "Agosto",
            "Septiembre",
            "Octubre",
            "Noviembre",
            "Diciembre"
          ]
        },
        ordinal: function() {
          return "º";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " a ",
        time_24hr: true
      };
      fp$e.l10ns.es = Spanish;
      fp$e.l10ns;
      var fp$f = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Estonian = {
        weekdays: {
          shorthand: ["P", "E", "T", "K", "N", "R", "L"],
          longhand: [
            "Pühapäev",
            "Esmaspäev",
            "Teisipäev",
            "Kolmapäev",
            "Neljapäev",
            "Reede",
            "Laupäev"
          ]
        },
        months: {
          shorthand: [
            "Jaan",
            "Veebr",
            "Märts",
            "Apr",
            "Mai",
            "Juuni",
            "Juuli",
            "Aug",
            "Sept",
            "Okt",
            "Nov",
            "Dets"
          ],
          longhand: [
            "Jaanuar",
            "Veebruar",
            "Märts",
            "Aprill",
            "Mai",
            "Juuni",
            "Juuli",
            "August",
            "September",
            "Oktoober",
            "November",
            "Detsember"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        weekAbbreviation: "Näd",
        rangeSeparator: " kuni ",
        scrollTitle: "Keri, et suurendada",
        toggleTitle: "Klõpsa, et vahetada",
        time_24hr: true
      };
      fp$f.l10ns.et = Estonian;
      fp$f.l10ns;
      var fp$g = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Persian = {
        weekdays: {
          shorthand: ["یک", "دو", "سه", "چهار", "پنج", "جمعه", "شنبه"],
          longhand: [
            "یک‌شنبه",
            "دوشنبه",
            "سه‌شنبه",
            "چهارشنبه",
            "پنچ‌شنبه",
            "جمعه",
            "شنبه"
          ]
        },
        months: {
          shorthand: [
            "ژانویه",
            "فوریه",
            "مارس",
            "آوریل",
            "مه",
            "ژوئن",
            "ژوئیه",
            "اوت",
            "سپتامبر",
            "اکتبر",
            "نوامبر",
            "دسامبر"
          ],
          longhand: [
            "ژانویه",
            "فوریه",
            "مارس",
            "آوریل",
            "مه",
            "ژوئن",
            "ژوئیه",
            "اوت",
            "سپتامبر",
            "اکتبر",
            "نوامبر",
            "دسامبر"
          ]
        },
        firstDayOfWeek: 6,
        ordinal: function() {
          return "";
        }
      };
      fp$g.l10ns.fa = Persian;
      fp$g.l10ns;
      var fp$h = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Finnish = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["su", "ma", "ti", "ke", "to", "pe", "la"],
          longhand: [
            "sunnuntai",
            "maanantai",
            "tiistai",
            "keskiviikko",
            "torstai",
            "perjantai",
            "lauantai"
          ]
        },
        months: {
          shorthand: [
            "tammi",
            "helmi",
            "maalis",
            "huhti",
            "touko",
            "kesä",
            "heinä",
            "elo",
            "syys",
            "loka",
            "marras",
            "joulu"
          ],
          longhand: [
            "tammikuu",
            "helmikuu",
            "maaliskuu",
            "huhtikuu",
            "toukokuu",
            "kesäkuu",
            "heinäkuu",
            "elokuu",
            "syyskuu",
            "lokakuu",
            "marraskuu",
            "joulukuu"
          ]
        },
        ordinal: function() {
          return ".";
        },
        time_24hr: true
      };
      fp$h.l10ns.fi = Finnish;
      fp$h.l10ns;
      var fp$i = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Faroese = {
        weekdays: {
          shorthand: ["Sun", "Mán", "Týs", "Mik", "Hós", "Frí", "Ley"],
          longhand: [
            "Sunnudagur",
            "Mánadagur",
            "Týsdagur",
            "Mikudagur",
            "Hósdagur",
            "Fríggjadagur",
            "Leygardagur"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mars",
            "Apríl",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "Septembur",
            "Oktobur",
            "Novembur",
            "Desembur"
          ]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        scrollTitle: "Rulla fyri at broyta",
        toggleTitle: "Trýst fyri at skifta",
        yearAriaLabel: "Ár",
        time_24hr: true
      };
      fp$i.l10ns.fo = Faroese;
      fp$i.l10ns;
      var fp$j = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var French = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: [
            "dimanche",
            "lundi",
            "mardi",
            "mercredi",
            "jeudi",
            "vendredi",
            "samedi"
          ]
        },
        months: {
          shorthand: [
            "janv",
            "févr",
            "mars",
            "avr",
            "mai",
            "juin",
            "juil",
            "août",
            "sept",
            "oct",
            "nov",
            "déc"
          ],
          longhand: [
            "janvier",
            "février",
            "mars",
            "avril",
            "mai",
            "juin",
            "juillet",
            "août",
            "septembre",
            "octobre",
            "novembre",
            "décembre"
          ]
        },
        ordinal: function(nth) {
          if (nth > 1)
            return "";
          return "er";
        },
        rangeSeparator: " au ",
        weekAbbreviation: "Sem",
        scrollTitle: "Défiler pour augmenter la valeur",
        toggleTitle: "Cliquer pour basculer",
        time_24hr: true
      };
      fp$j.l10ns.fr = French;
      fp$j.l10ns;
      var fp$k = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Greek = {
        weekdays: {
          shorthand: ["Κυ", "Δε", "Τρ", "Τε", "Πέ", "Πα", "Σά"],
          longhand: [
            "Κυριακή",
            "Δευτέρα",
            "Τρίτη",
            "Τετάρτη",
            "Πέμπτη",
            "Παρασκευή",
            "Σάββατο"
          ]
        },
        months: {
          shorthand: [
            "Ιαν",
            "Φεβ",
            "Μάρ",
            "Απρ",
            "Μάι",
            "Ιούν",
            "Ιούλ",
            "Αύγ",
            "Σεπ",
            "Οκτ",
            "Νοέ",
            "Δεκ"
          ],
          longhand: [
            "Ιανουάριος",
            "Φεβρουάριος",
            "Μάρτιος",
            "Απρίλιος",
            "Μάιος",
            "Ιούνιος",
            "Ιούλιος",
            "Αύγουστος",
            "Σεπτέμβριος",
            "Οκτώβριος",
            "Νοέμβριος",
            "Δεκέμβριος"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        weekAbbreviation: "Εβδ",
        rangeSeparator: " έως ",
        scrollTitle: "Μετακυλήστε για προσαύξηση",
        toggleTitle: "Κάντε κλικ για αλλαγή",
        amPM: ["ΠΜ", "ΜΜ"],
        yearAriaLabel: "χρόνος",
        monthAriaLabel: "μήνας",
        hourAriaLabel: "ώρα",
        minuteAriaLabel: "λεπτό"
      };
      fp$k.l10ns.gr = Greek;
      fp$k.l10ns;
      var fp$l = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hebrew = {
        weekdays: {
          shorthand: ["א", "ב", "ג", "ד", "ה", "ו", "ש"],
          longhand: ["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"]
        },
        months: {
          shorthand: [
            "ינו׳",
            "פבר׳",
            "מרץ",
            "אפר׳",
            "מאי",
            "יוני",
            "יולי",
            "אוג׳",
            "ספט׳",
            "אוק׳",
            "נוב׳",
            "דצמ׳"
          ],
          longhand: [
            "ינואר",
            "פברואר",
            "מרץ",
            "אפריל",
            "מאי",
            "יוני",
            "יולי",
            "אוגוסט",
            "ספטמבר",
            "אוקטובר",
            "נובמבר",
            "דצמבר"
          ]
        },
        rangeSeparator: " אל ",
        time_24hr: true
      };
      fp$l.l10ns.he = Hebrew;
      fp$l.l10ns;
      var fp$m = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hindi = {
        weekdays: {
          shorthand: ["रवि", "सोम", "मंगल", "बुध", "गुरु", "शुक्र", "शनि"],
          longhand: [
            "रविवार",
            "सोमवार",
            "मंगलवार",
            "बुधवार",
            "गुरुवार",
            "शुक्रवार",
            "शनिवार"
          ]
        },
        months: {
          shorthand: [
            "जन",
            "फर",
            "मार्च",
            "अप्रेल",
            "मई",
            "जून",
            "जूलाई",
            "अग",
            "सित",
            "अक्ट",
            "नव",
            "दि"
          ],
          longhand: [
            "जनवरी ",
            "फरवरी",
            "मार्च",
            "अप्रेल",
            "मई",
            "जून",
            "जूलाई",
            "अगस्त ",
            "सितम्बर",
            "अक्टूबर",
            "नवम्बर",
            "दिसम्बर"
          ]
        }
      };
      fp$m.l10ns.hi = Hindi;
      fp$m.l10ns;
      var fp$n = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Croatian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"],
          longhand: [
            "Nedjelja",
            "Ponedjeljak",
            "Utorak",
            "Srijeda",
            "Četvrtak",
            "Petak",
            "Subota"
          ]
        },
        months: {
          shorthand: [
            "Sij",
            "Velj",
            "Ožu",
            "Tra",
            "Svi",
            "Lip",
            "Srp",
            "Kol",
            "Ruj",
            "Lis",
            "Stu",
            "Pro"
          ],
          longhand: [
            "Siječanj",
            "Veljača",
            "Ožujak",
            "Travanj",
            "Svibanj",
            "Lipanj",
            "Srpanj",
            "Kolovoz",
            "Rujan",
            "Listopad",
            "Studeni",
            "Prosinac"
          ]
        },
        time_24hr: true
      };
      fp$n.l10ns.hr = Croatian;
      fp$n.l10ns;
      var fp$o = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Hungarian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["V", "H", "K", "Sz", "Cs", "P", "Szo"],
          longhand: [
            "Vasárnap",
            "Hétfő",
            "Kedd",
            "Szerda",
            "Csütörtök",
            "Péntek",
            "Szombat"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Már",
            "Ápr",
            "Máj",
            "Jún",
            "Júl",
            "Aug",
            "Szep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Január",
            "Február",
            "Március",
            "Április",
            "Május",
            "Június",
            "Július",
            "Augusztus",
            "Szeptember",
            "Október",
            "November",
            "December"
          ]
        },
        ordinal: function() {
          return ".";
        },
        weekAbbreviation: "Hét",
        scrollTitle: "Görgessen",
        toggleTitle: "Kattintson a váltáshoz",
        rangeSeparator: " - ",
        time_24hr: true
      };
      fp$o.l10ns.hu = Hungarian;
      fp$o.l10ns;
      var fp$p = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Armenian = {
        weekdays: {
          shorthand: ["Կիր", "Երկ", "Երք", "Չրք", "Հնգ", "Ուրբ", "Շբթ"],
          longhand: [
            "Կիրակի",
            "Եկուշաբթի",
            "Երեքշաբթի",
            "Չորեքշաբթի",
            "Հինգշաբթի",
            "Ուրբաթ",
            "Շաբաթ"
          ]
        },
        months: {
          shorthand: [
            "Հնվ",
            "Փտր",
            "Մար",
            "Ապր",
            "Մայ",
            "Հնս",
            "Հլս",
            "Օգս",
            "Սեպ",
            "Հոկ",
            "Նմբ",
            "Դեկ"
          ],
          longhand: [
            "Հունվար",
            "Փետրվար",
            "Մարտ",
            "Ապրիլ",
            "Մայիս",
            "Հունիս",
            "Հուլիս",
            "Օգոստոս",
            "Սեպտեմբեր",
            "Հոկտեմբեր",
            "Նոյեմբեր",
            "Դեկտեմբեր"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "ՇԲՏ",
        scrollTitle: "Ոլորեք՝ մեծացնելու համար",
        toggleTitle: "Սեղմեք՝ փոխելու համար",
        amPM: ["ՄԿ", "ԿՀ"],
        yearAriaLabel: "Տարի",
        monthAriaLabel: "Ամիս",
        hourAriaLabel: "Ժամ",
        minuteAriaLabel: "Րոպե",
        time_24hr: true
      };
      fp$p.l10ns.hy = Armenian;
      fp$p.l10ns;
      var fp$q = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Indonesian = {
        weekdays: {
          shorthand: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"],
          longhand: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mei",
            "Jun",
            "Jul",
            "Agu",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januari",
            "Februari",
            "Maret",
            "April",
            "Mei",
            "Juni",
            "Juli",
            "Agustus",
            "September",
            "Oktober",
            "November",
            "Desember"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        time_24hr: true,
        rangeSeparator: " - "
      };
      fp$q.l10ns.id = Indonesian;
      fp$q.l10ns;
      var fp$r = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Icelandic = {
        weekdays: {
          shorthand: ["Sun", "Mán", "Þri", "Mið", "Fim", "Fös", "Lau"],
          longhand: [
            "Sunnudagur",
            "Mánudagur",
            "Þriðjudagur",
            "Miðvikudagur",
            "Fimmtudagur",
            "Föstudagur",
            "Laugardagur"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maí",
            "Jún",
            "Júl",
            "Ágú",
            "Sep",
            "Okt",
            "Nóv",
            "Des"
          ],
          longhand: [
            "Janúar",
            "Febrúar",
            "Mars",
            "Apríl",
            "Maí",
            "Júní",
            "Júlí",
            "Ágúst",
            "September",
            "Október",
            "Nóvember",
            "Desember"
          ]
        },
        ordinal: function() {
          return ".";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "vika",
        yearAriaLabel: "Ár",
        time_24hr: true
      };
      fp$r.l10ns.is = Icelandic;
      fp$r.l10ns;
      var fp$s = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Italian = {
        weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: [
            "Domenica",
            "Lunedì",
            "Martedì",
            "Mercoledì",
            "Giovedì",
            "Venerdì",
            "Sabato"
          ]
        },
        months: {
          shorthand: [
            "Gen",
            "Feb",
            "Mar",
            "Apr",
            "Mag",
            "Giu",
            "Lug",
            "Ago",
            "Set",
            "Ott",
            "Nov",
            "Dic"
          ],
          longhand: [
            "Gennaio",
            "Febbraio",
            "Marzo",
            "Aprile",
            "Maggio",
            "Giugno",
            "Luglio",
            "Agosto",
            "Settembre",
            "Ottobre",
            "Novembre",
            "Dicembre"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "°";
        },
        rangeSeparator: " al ",
        weekAbbreviation: "Se",
        scrollTitle: "Scrolla per aumentare",
        toggleTitle: "Clicca per cambiare",
        time_24hr: true
      };
      fp$s.l10ns.it = Italian;
      fp$s.l10ns;
      var fp$t = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Japanese = {
        weekdays: {
          shorthand: ["日", "月", "火", "水", "木", "金", "土"],
          longhand: [
            "日曜日",
            "月曜日",
            "火曜日",
            "水曜日",
            "木曜日",
            "金曜日",
            "土曜日"
          ]
        },
        months: {
          shorthand: [
            "1月",
            "2月",
            "3月",
            "4月",
            "5月",
            "6月",
            "7月",
            "8月",
            "9月",
            "10月",
            "11月",
            "12月"
          ],
          longhand: [
            "1月",
            "2月",
            "3月",
            "4月",
            "5月",
            "6月",
            "7月",
            "8月",
            "9月",
            "10月",
            "11月",
            "12月"
          ]
        },
        time_24hr: true,
        rangeSeparator: " から ",
        monthAriaLabel: "月",
        amPM: ["午前", "午後"],
        yearAriaLabel: "年",
        hourAriaLabel: "時間",
        minuteAriaLabel: "分"
      };
      fp$t.l10ns.ja = Japanese;
      fp$t.l10ns;
      var fp$u = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Georgian = {
        weekdays: {
          shorthand: ["კვ", "ორ", "სა", "ოთ", "ხუ", "პა", "შა"],
          longhand: [
            "კვირა",
            "ორშაბათი",
            "სამშაბათი",
            "ოთხშაბათი",
            "ხუთშაბათი",
            "პარასკევი",
            "შაბათი"
          ]
        },
        months: {
          shorthand: [
            "იან",
            "თებ",
            "მარ",
            "აპრ",
            "მაი",
            "ივნ",
            "ივლ",
            "აგვ",
            "სექ",
            "ოქტ",
            "ნოე",
            "დეკ"
          ],
          longhand: [
            "იანვარი",
            "თებერვალი",
            "მარტი",
            "აპრილი",
            "მაისი",
            "ივნისი",
            "ივლისი",
            "აგვისტო",
            "სექტემბერი",
            "ოქტომბერი",
            "ნოემბერი",
            "დეკემბერი"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "კვ.",
        scrollTitle: "დასქროლეთ გასადიდებლად",
        toggleTitle: "დააკლიკეთ გადართვისთვის",
        amPM: ["AM", "PM"],
        yearAriaLabel: "წელი",
        time_24hr: true
      };
      fp$u.l10ns.ka = Georgian;
      fp$u.l10ns;
      var fp$v = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Korean = {
        weekdays: {
          shorthand: ["일", "월", "화", "수", "목", "금", "토"],
          longhand: [
            "일요일",
            "월요일",
            "화요일",
            "수요일",
            "목요일",
            "금요일",
            "토요일"
          ]
        },
        months: {
          shorthand: [
            "1월",
            "2월",
            "3월",
            "4월",
            "5월",
            "6월",
            "7월",
            "8월",
            "9월",
            "10월",
            "11월",
            "12월"
          ],
          longhand: [
            "1월",
            "2월",
            "3월",
            "4월",
            "5월",
            "6월",
            "7월",
            "8월",
            "9월",
            "10월",
            "11월",
            "12월"
          ]
        },
        ordinal: function() {
          return "일";
        },
        rangeSeparator: " ~ ",
        amPM: ["오전", "오후"]
      };
      fp$v.l10ns.ko = Korean;
      fp$v.l10ns;
      var fp$w = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Khmer = {
        weekdays: {
          shorthand: ["អាទិត្យ", "ចន្ទ", "អង្គារ", "ពុធ", "ព្រហស.", "សុក្រ", "សៅរ៍"],
          longhand: [
            "អាទិត្យ",
            "ចន្ទ",
            "អង្គារ",
            "ពុធ",
            "ព្រហស្បតិ៍",
            "សុក្រ",
            "សៅរ៍"
          ]
        },
        months: {
          shorthand: [
            "មករា",
            "កុម្ភះ",
            "មីនា",
            "មេសា",
            "ឧសភា",
            "មិថុនា",
            "កក្កដា",
            "សីហា",
            "កញ្ញា",
            "តុលា",
            "វិច្ឆិកា",
            "ធ្នូ"
          ],
          longhand: [
            "មករា",
            "កុម្ភះ",
            "មីនា",
            "មេសា",
            "ឧសភា",
            "មិថុនា",
            "កក្កដា",
            "សីហា",
            "កញ្ញា",
            "តុលា",
            "វិច្ឆិកា",
            "ធ្នូ"
          ]
        },
        ordinal: function() {
          return "";
        },
        firstDayOfWeek: 1,
        rangeSeparator: " ដល់ ",
        weekAbbreviation: "សប្តាហ៍",
        scrollTitle: "រំកិលដើម្បីបង្កើន",
        toggleTitle: "ចុចដើម្បីផ្លាស់ប្ដូរ",
        yearAriaLabel: "ឆ្នាំ",
        time_24hr: true
      };
      fp$w.l10ns.km = Khmer;
      fp$w.l10ns;
      var fp$x = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Kazakh = {
        weekdays: {
          shorthand: ["Жс", "Дс", "Сc", "Ср", "Бс", "Жм", "Сб"],
          longhand: [
            "Жексенбi",
            "Дүйсенбi",
            "Сейсенбi",
            "Сәрсенбi",
            "Бейсенбi",
            "Жұма",
            "Сенбi"
          ]
        },
        months: {
          shorthand: [
            "Қаң",
            "Ақп",
            "Нау",
            "Сәу",
            "Мам",
            "Мау",
            "Шiл",
            "Там",
            "Қыр",
            "Қаз",
            "Қар",
            "Жел"
          ],
          longhand: [
            "Қаңтар",
            "Ақпан",
            "Наурыз",
            "Сәуiр",
            "Мамыр",
            "Маусым",
            "Шiлде",
            "Тамыз",
            "Қыркүйек",
            "Қазан",
            "Қараша",
            "Желтоқсан"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Апта",
        scrollTitle: "Үлкейту үшін айналдырыңыз",
        toggleTitle: "Ауыстыру үшін басыңыз",
        amPM: ["ТД", "ТК"],
        yearAriaLabel: "Жыл"
      };
      fp$x.l10ns.kz = Kazakh;
      fp$x.l10ns;
      var fp$y = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Lithuanian = {
        weekdays: {
          shorthand: ["S", "Pr", "A", "T", "K", "Pn", "Š"],
          longhand: [
            "Sekmadienis",
            "Pirmadienis",
            "Antradienis",
            "Trečiadienis",
            "Ketvirtadienis",
            "Penktadienis",
            "Šeštadienis"
          ]
        },
        months: {
          shorthand: [
            "Sau",
            "Vas",
            "Kov",
            "Bal",
            "Geg",
            "Bir",
            "Lie",
            "Rgp",
            "Rgs",
            "Spl",
            "Lap",
            "Grd"
          ],
          longhand: [
            "Sausis",
            "Vasaris",
            "Kovas",
            "Balandis",
            "Gegužė",
            "Birželis",
            "Liepa",
            "Rugpjūtis",
            "Rugsėjis",
            "Spalis",
            "Lapkritis",
            "Gruodis"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "-a";
        },
        rangeSeparator: " iki ",
        weekAbbreviation: "Sav",
        scrollTitle: "Keisti laiką pelės rateliu",
        toggleTitle: "Perjungti laiko formatą",
        time_24hr: true
      };
      fp$y.l10ns.lt = Lithuanian;
      fp$y.l10ns;
      var fp$z = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Latvian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Sv", "Pr", "Ot", "Tr", "Ce", "Pk", "Se"],
          longhand: [
            "Svētdiena",
            "Pirmdiena",
            "Otrdiena",
            "Trešdiena",
            "Ceturtdiena",
            "Piektdiena",
            "Sestdiena"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Jūn",
            "Jūl",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Janvāris",
            "Februāris",
            "Marts",
            "Aprīlis",
            "Maijs",
            "Jūnijs",
            "Jūlijs",
            "Augusts",
            "Septembris",
            "Oktobris",
            "Novembris",
            "Decembris"
          ]
        },
        rangeSeparator: " līdz ",
        time_24hr: true
      };
      fp$z.l10ns.lv = Latvian;
      fp$z.l10ns;
      var fp$A = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Macedonian = {
        weekdays: {
          shorthand: ["Не", "По", "Вт", "Ср", "Че", "Пе", "Са"],
          longhand: [
            "Недела",
            "Понеделник",
            "Вторник",
            "Среда",
            "Четврток",
            "Петок",
            "Сабота"
          ]
        },
        months: {
          shorthand: [
            "Јан",
            "Фев",
            "Мар",
            "Апр",
            "Мај",
            "Јун",
            "Јул",
            "Авг",
            "Сеп",
            "Окт",
            "Ное",
            "Дек"
          ],
          longhand: [
            "Јануари",
            "Февруари",
            "Март",
            "Април",
            "Мај",
            "Јуни",
            "Јули",
            "Август",
            "Септември",
            "Октомври",
            "Ноември",
            "Декември"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "Нед.",
        rangeSeparator: " до ",
        time_24hr: true
      };
      fp$A.l10ns.mk = Macedonian;
      fp$A.l10ns;
      var fp$B = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Mongolian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Да", "Мя", "Лх", "Пү", "Ба", "Бя", "Ня"],
          longhand: ["Даваа", "Мягмар", "Лхагва", "Пүрэв", "Баасан", "Бямба", "Ням"]
        },
        months: {
          shorthand: [
            "1-р сар",
            "2-р сар",
            "3-р сар",
            "4-р сар",
            "5-р сар",
            "6-р сар",
            "7-р сар",
            "8-р сар",
            "9-р сар",
            "10-р сар",
            "11-р сар",
            "12-р сар"
          ],
          longhand: [
            "Нэгдүгээр сар",
            "Хоёрдугаар сар",
            "Гуравдугаар сар",
            "Дөрөвдүгээр сар",
            "Тавдугаар сар",
            "Зургаадугаар сар",
            "Долдугаар сар",
            "Наймдугаар сар",
            "Есдүгээр сар",
            "Аравдугаар сар",
            "Арваннэгдүгээр сар",
            "Арванхоёрдугаар сар"
          ]
        },
        rangeSeparator: "-с ",
        time_24hr: true
      };
      fp$B.l10ns.mn = Mongolian;
      fp$B.l10ns;
      var fp$C = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Malaysian = {
        weekdays: {
          shorthand: ["Aha", "Isn", "Sel", "Rab", "Kha", "Jum", "Sab"],
          longhand: ["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mac",
            "Apr",
            "Mei",
            "Jun",
            "Jul",
            "Ogo",
            "Sep",
            "Okt",
            "Nov",
            "Dis"
          ],
          longhand: [
            "Januari",
            "Februari",
            "Mac",
            "April",
            "Mei",
            "Jun",
            "Julai",
            "Ogos",
            "September",
            "Oktober",
            "November",
            "Disember"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        }
      };
      fp$C.l10ns;
      var fp$D = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Burmese = {
        weekdays: {
          shorthand: ["နွေ", "လာ", "ဂါ", "ဟူး", "ကြာ", "သော", "နေ"],
          longhand: [
            "တနင်္ဂနွေ",
            "တနင်္လာ",
            "အင်္ဂါ",
            "ဗုဒ္ဓဟူး",
            "ကြာသပတေး",
            "သောကြာ",
            "စနေ"
          ]
        },
        months: {
          shorthand: [
            "ဇန်",
            "ဖေ",
            "မတ်",
            "ပြီ",
            "မေ",
            "ဇွန်",
            "လိုင်",
            "သြ",
            "စက်",
            "အောက်",
            "နို",
            "ဒီ"
          ],
          longhand: [
            "ဇန်နဝါရီ",
            "ဖေဖော်ဝါရီ",
            "မတ်",
            "ဧပြီ",
            "မေ",
            "ဇွန်",
            "ဇူလိုင်",
            "သြဂုတ်",
            "စက်တင်ဘာ",
            "အောက်တိုဘာ",
            "နိုဝင်ဘာ",
            "ဒီဇင်ဘာ"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        time_24hr: true
      };
      fp$D.l10ns.my = Burmese;
      fp$D.l10ns;
      var fp$E = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Dutch = {
        weekdays: {
          shorthand: ["zo", "ma", "di", "wo", "do", "vr", "za"],
          longhand: [
            "zondag",
            "maandag",
            "dinsdag",
            "woensdag",
            "donderdag",
            "vrijdag",
            "zaterdag"
          ]
        },
        months: {
          shorthand: [
            "jan",
            "feb",
            "mrt",
            "apr",
            "mei",
            "jun",
            "jul",
            "aug",
            "sept",
            "okt",
            "nov",
            "dec"
          ],
          longhand: [
            "januari",
            "februari",
            "maart",
            "april",
            "mei",
            "juni",
            "juli",
            "augustus",
            "september",
            "oktober",
            "november",
            "december"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "wk",
        rangeSeparator: " t/m ",
        scrollTitle: "Scroll voor volgende / vorige",
        toggleTitle: "Klik om te wisselen",
        time_24hr: true,
        ordinal: function(nth) {
          if (nth === 1 || nth === 8 || nth >= 20)
            return "ste";
          return "de";
        }
      };
      fp$E.l10ns.nl = Dutch;
      fp$E.l10ns;
      var fp$F = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var NorwegianNynorsk = {
        weekdays: {
          shorthand: ["Sø.", "Må.", "Ty.", "On.", "To.", "Fr.", "La."],
          longhand: [
            "Søndag",
            "Måndag",
            "Tysdag",
            "Onsdag",
            "Torsdag",
            "Fredag",
            "Laurdag"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mars",
            "Apr",
            "Mai",
            "Juni",
            "Juli",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mars",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Desember"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "Veke",
        scrollTitle: "Scroll for å endre",
        toggleTitle: "Klikk for å veksle",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$F.l10ns.nn = NorwegianNynorsk;
      fp$F.l10ns;
      var fp$G = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Norwegian = {
        weekdays: {
          shorthand: ["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"],
          longhand: [
            "Søndag",
            "Mandag",
            "Tirsdag",
            "Onsdag",
            "Torsdag",
            "Fredag",
            "Lørdag"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Des"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mars",
            "April",
            "Mai",
            "Juni",
            "Juli",
            "August",
            "September",
            "Oktober",
            "November",
            "Desember"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " til ",
        weekAbbreviation: "Uke",
        scrollTitle: "Scroll for å endre",
        toggleTitle: "Klikk for å veksle",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$G.l10ns.no = Norwegian;
      fp$G.l10ns;
      var fp$H = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Punjabi = {
        weekdays: {
          shorthand: ["ਐਤ", "ਸੋਮ", "ਮੰਗਲ", "ਬੁੱਧ", "ਵੀਰ", "ਸ਼ੁੱਕਰ", "ਸ਼ਨਿੱਚਰ"],
          longhand: [
            "ਐਤਵਾਰ",
            "ਸੋਮਵਾਰ",
            "ਮੰਗਲਵਾਰ",
            "ਬੁੱਧਵਾਰ",
            "ਵੀਰਵਾਰ",
            "ਸ਼ੁੱਕਰਵਾਰ",
            "ਸ਼ਨਿੱਚਰਵਾਰ"
          ]
        },
        months: {
          shorthand: [
            "ਜਨ",
            "ਫ਼ਰ",
            "ਮਾਰ",
            "ਅਪ੍ਰੈ",
            "ਮਈ",
            "ਜੂਨ",
            "ਜੁਲਾ",
            "ਅਗ",
            "ਸਤੰ",
            "ਅਕ",
            "ਨਵੰ",
            "ਦਸੰ"
          ],
          longhand: [
            "ਜਨਵਰੀ",
            "ਫ਼ਰਵਰੀ",
            "ਮਾਰਚ",
            "ਅਪ੍ਰੈਲ",
            "ਮਈ",
            "ਜੂਨ",
            "ਜੁਲਾਈ",
            "ਅਗਸਤ",
            "ਸਤੰਬਰ",
            "ਅਕਤੂਬਰ",
            "ਨਵੰਬਰ",
            "ਦਸੰਬਰ"
          ]
        },
        time_24hr: true
      };
      fp$H.l10ns.pa = Punjabi;
      fp$H.l10ns;
      var fp$I = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Polish = {
        weekdays: {
          shorthand: ["Nd", "Pn", "Wt", "Śr", "Cz", "Pt", "So"],
          longhand: [
            "Niedziela",
            "Poniedziałek",
            "Wtorek",
            "Środa",
            "Czwartek",
            "Piątek",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Sty",
            "Lut",
            "Mar",
            "Kwi",
            "Maj",
            "Cze",
            "Lip",
            "Sie",
            "Wrz",
            "Paź",
            "Lis",
            "Gru"
          ],
          longhand: [
            "Styczeń",
            "Luty",
            "Marzec",
            "Kwiecień",
            "Maj",
            "Czerwiec",
            "Lipiec",
            "Sierpień",
            "Wrzesień",
            "Październik",
            "Listopad",
            "Grudzień"
          ]
        },
        rangeSeparator: " do ",
        weekAbbreviation: "tydz.",
        scrollTitle: "Przewiń, aby zwiększyć",
        toggleTitle: "Kliknij, aby przełączyć",
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$I.l10ns.pl = Polish;
      fp$I.l10ns;
      var fp$J = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Portuguese = {
        weekdays: {
          shorthand: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"],
          longhand: [
            "Domingo",
            "Segunda-feira",
            "Terça-feira",
            "Quarta-feira",
            "Quinta-feira",
            "Sexta-feira",
            "Sábado"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Fev",
            "Mar",
            "Abr",
            "Mai",
            "Jun",
            "Jul",
            "Ago",
            "Set",
            "Out",
            "Nov",
            "Dez"
          ],
          longhand: [
            "Janeiro",
            "Fevereiro",
            "Março",
            "Abril",
            "Maio",
            "Junho",
            "Julho",
            "Agosto",
            "Setembro",
            "Outubro",
            "Novembro",
            "Dezembro"
          ]
        },
        rangeSeparator: " até ",
        time_24hr: true
      };
      fp$J.l10ns.pt = Portuguese;
      fp$J.l10ns;
      var fp$K = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Romanian = {
        weekdays: {
          shorthand: ["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sâm"],
          longhand: [
            "Duminică",
            "Luni",
            "Marți",
            "Miercuri",
            "Joi",
            "Vineri",
            "Sâmbătă"
          ]
        },
        months: {
          shorthand: [
            "Ian",
            "Feb",
            "Mar",
            "Apr",
            "Mai",
            "Iun",
            "Iul",
            "Aug",
            "Sep",
            "Oct",
            "Noi",
            "Dec"
          ],
          longhand: [
            "Ianuarie",
            "Februarie",
            "Martie",
            "Aprilie",
            "Mai",
            "Iunie",
            "Iulie",
            "August",
            "Septembrie",
            "Octombrie",
            "Noiembrie",
            "Decembrie"
          ]
        },
        firstDayOfWeek: 1,
        time_24hr: true,
        ordinal: function() {
          return "";
        }
      };
      fp$K.l10ns.ro = Romanian;
      fp$K.l10ns;
      var fp$L = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Russian = {
        weekdays: {
          shorthand: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: [
            "Воскресенье",
            "Понедельник",
            "Вторник",
            "Среда",
            "Четверг",
            "Пятница",
            "Суббота"
          ]
        },
        months: {
          shorthand: [
            "Янв",
            "Фев",
            "Март",
            "Апр",
            "Май",
            "Июнь",
            "Июль",
            "Авг",
            "Сен",
            "Окт",
            "Ноя",
            "Дек"
          ],
          longhand: [
            "Январь",
            "Февраль",
            "Март",
            "Апрель",
            "Май",
            "Июнь",
            "Июль",
            "Август",
            "Сентябрь",
            "Октябрь",
            "Ноябрь",
            "Декабрь"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Нед.",
        scrollTitle: "Прокрутите для увеличения",
        toggleTitle: "Нажмите для переключения",
        amPM: ["ДП", "ПП"],
        yearAriaLabel: "Год",
        time_24hr: true
      };
      fp$L.l10ns.ru = Russian;
      fp$L.l10ns;
      var fp$M = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Sinhala = {
        weekdays: {
          shorthand: ["ඉ", "ස", "අ", "බ", "බ්‍ර", "සි", "සෙ"],
          longhand: [
            "ඉරිදා",
            "සඳුදා",
            "අඟහරුවාදා",
            "බදාදා",
            "බ්‍රහස්පතින්දා",
            "සිකුරාදා",
            "සෙනසුරාදා"
          ]
        },
        months: {
          shorthand: [
            "ජන",
            "පෙබ",
            "මාර්",
            "අප්‍රේ",
            "මැයි",
            "ජුනි",
            "ජූලි",
            "අගෝ",
            "සැප්",
            "ඔක්",
            "නොවැ",
            "දෙසැ"
          ],
          longhand: [
            "ජනවාරි",
            "පෙබරවාරි",
            "මාර්තු",
            "අප්‍රේල්",
            "මැයි",
            "ජුනි",
            "ජූලි",
            "අගෝස්තු",
            "සැප්තැම්බර්",
            "ඔක්තෝබර්",
            "නොවැම්බර්",
            "දෙසැම්බර්"
          ]
        },
        time_24hr: true
      };
      fp$M.l10ns.si = Sinhala;
      fp$M.l10ns;
      var fp$N = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Slovak = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Ut", "Str", "Štv", "Pia", "Sob"],
          longhand: [
            "Nedeľa",
            "Pondelok",
            "Utorok",
            "Streda",
            "Štvrtok",
            "Piatok",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Máj",
            "Jún",
            "Júl",
            "Aug",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Január",
            "Február",
            "Marec",
            "Apríl",
            "Máj",
            "Jún",
            "Júl",
            "August",
            "September",
            "Október",
            "November",
            "December"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$N.l10ns.sk = Slovak;
      fp$N.l10ns;
      var fp$O = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Slovenian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"],
          longhand: [
            "Nedelja",
            "Ponedeljek",
            "Torek",
            "Sreda",
            "Četrtek",
            "Petek",
            "Sobota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Avg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Marec",
            "April",
            "Maj",
            "Junij",
            "Julij",
            "Avgust",
            "September",
            "Oktober",
            "November",
            "December"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " do ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$O.l10ns.sl = Slovenian;
      fp$O.l10ns;
      var fp$P = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Albanian = {
        weekdays: {
          shorthand: ["Di", "Hë", "Ma", "Më", "En", "Pr", "Sh"],
          longhand: [
            "E Diel",
            "E Hënë",
            "E Martë",
            "E Mërkurë",
            "E Enjte",
            "E Premte",
            "E Shtunë"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Shk",
            "Mar",
            "Pri",
            "Maj",
            "Qer",
            "Kor",
            "Gus",
            "Sht",
            "Tet",
            "Nën",
            "Dhj"
          ],
          longhand: [
            "Janar",
            "Shkurt",
            "Mars",
            "Prill",
            "Maj",
            "Qershor",
            "Korrik",
            "Gusht",
            "Shtator",
            "Tetor",
            "Nëntor",
            "Dhjetor"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " deri ",
        weekAbbreviation: "Java",
        yearAriaLabel: "Viti",
        monthAriaLabel: "Muaji",
        hourAriaLabel: "Ora",
        minuteAriaLabel: "Minuta",
        time_24hr: true
      };
      fp$P.l10ns.sq = Albanian;
      fp$P.l10ns;
      var fp$Q = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Serbian = {
        weekdays: {
          shorthand: ["Ned", "Pon", "Uto", "Sre", "Čet", "Pet", "Sub"],
          longhand: [
            "Nedelja",
            "Ponedeljak",
            "Utorak",
            "Sreda",
            "Četvrtak",
            "Petak",
            "Subota"
          ]
        },
        months: {
          shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "Maj",
            "Jun",
            "Jul",
            "Avg",
            "Sep",
            "Okt",
            "Nov",
            "Dec"
          ],
          longhand: [
            "Januar",
            "Februar",
            "Mart",
            "April",
            "Maj",
            "Jun",
            "Jul",
            "Avgust",
            "Septembar",
            "Oktobar",
            "Novembar",
            "Decembar"
          ]
        },
        firstDayOfWeek: 1,
        weekAbbreviation: "Ned.",
        rangeSeparator: " do ",
        time_24hr: true
      };
      fp$Q.l10ns.sr = Serbian;
      fp$Q.l10ns;
      var fp$R = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Swedish = {
        firstDayOfWeek: 1,
        weekAbbreviation: "v",
        weekdays: {
          shorthand: ["sön", "mån", "tis", "ons", "tor", "fre", "lör"],
          longhand: [
            "söndag",
            "måndag",
            "tisdag",
            "onsdag",
            "torsdag",
            "fredag",
            "lördag"
          ]
        },
        months: {
          shorthand: [
            "jan",
            "feb",
            "mar",
            "apr",
            "maj",
            "jun",
            "jul",
            "aug",
            "sep",
            "okt",
            "nov",
            "dec"
          ],
          longhand: [
            "januari",
            "februari",
            "mars",
            "april",
            "maj",
            "juni",
            "juli",
            "augusti",
            "september",
            "oktober",
            "november",
            "december"
          ]
        },
        rangeSeparator: " till ",
        time_24hr: true,
        ordinal: function() {
          return ".";
        }
      };
      fp$R.l10ns.sv = Swedish;
      fp$R.l10ns;
      var fp$S = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Thai = {
        weekdays: {
          shorthand: ["อา", "จ", "อ", "พ", "พฤ", "ศ", "ส"],
          longhand: [
            "อาทิตย์",
            "จันทร์",
            "อังคาร",
            "พุธ",
            "พฤหัสบดี",
            "ศุกร์",
            "เสาร์"
          ]
        },
        months: {
          shorthand: [
            "ม.ค.",
            "ก.พ.",
            "มี.ค.",
            "เม.ย.",
            "พ.ค.",
            "มิ.ย.",
            "ก.ค.",
            "ส.ค.",
            "ก.ย.",
            "ต.ค.",
            "พ.ย.",
            "ธ.ค."
          ],
          longhand: [
            "มกราคม",
            "กุมภาพันธ์",
            "มีนาคม",
            "เมษายน",
            "พฤษภาคม",
            "มิถุนายน",
            "กรกฎาคม",
            "สิงหาคม",
            "กันยายน",
            "ตุลาคม",
            "พฤศจิกายน",
            "ธันวาคม"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " ถึง ",
        scrollTitle: "เลื่อนเพื่อเพิ่มหรือลด",
        toggleTitle: "คลิกเพื่อเปลี่ยน",
        time_24hr: true,
        ordinal: function() {
          return "";
        }
      };
      fp$S.l10ns.th = Thai;
      fp$S.l10ns;
      var fp$T = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Turkish = {
        weekdays: {
          shorthand: ["Paz", "Pzt", "Sal", "Çar", "Per", "Cum", "Cmt"],
          longhand: [
            "Pazar",
            "Pazartesi",
            "Salı",
            "Çarşamba",
            "Perşembe",
            "Cuma",
            "Cumartesi"
          ]
        },
        months: {
          shorthand: [
            "Oca",
            "Şub",
            "Mar",
            "Nis",
            "May",
            "Haz",
            "Tem",
            "Ağu",
            "Eyl",
            "Eki",
            "Kas",
            "Ara"
          ],
          longhand: [
            "Ocak",
            "Şubat",
            "Mart",
            "Nisan",
            "Mayıs",
            "Haziran",
            "Temmuz",
            "Ağustos",
            "Eylül",
            "Ekim",
            "Kasım",
            "Aralık"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return ".";
        },
        rangeSeparator: " - ",
        weekAbbreviation: "Hf",
        scrollTitle: "Artırmak için kaydırın",
        toggleTitle: "Aç/Kapa",
        amPM: ["ÖÖ", "ÖS"],
        time_24hr: true
      };
      fp$T.l10ns.tr = Turkish;
      fp$T.l10ns;
      var fp$U = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Ukrainian = {
        firstDayOfWeek: 1,
        weekdays: {
          shorthand: ["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
          longhand: [
            "Неділя",
            "Понеділок",
            "Вівторок",
            "Середа",
            "Четвер",
            "П'ятниця",
            "Субота"
          ]
        },
        months: {
          shorthand: [
            "Січ",
            "Лют",
            "Бер",
            "Кві",
            "Тра",
            "Чер",
            "Лип",
            "Сер",
            "Вер",
            "Жов",
            "Лис",
            "Гру"
          ],
          longhand: [
            "Січень",
            "Лютий",
            "Березень",
            "Квітень",
            "Травень",
            "Червень",
            "Липень",
            "Серпень",
            "Вересень",
            "Жовтень",
            "Листопад",
            "Грудень"
          ]
        },
        time_24hr: true
      };
      fp$U.l10ns.uk = Ukrainian;
      fp$U.l10ns;
      var fp$V = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Uzbek = {
        weekdays: {
          shorthand: ["Якш", "Душ", "Сеш", "Чор", "Пай", "Жум", "Шан"],
          longhand: [
            "Якшанба",
            "Душанба",
            "Сешанба",
            "Чоршанба",
            "Пайшанба",
            "Жума",
            "Шанба"
          ]
        },
        months: {
          shorthand: [
            "Янв",
            "Фев",
            "Мар",
            "Апр",
            "Май",
            "Июн",
            "Июл",
            "Авг",
            "Сен",
            "Окт",
            "Ноя",
            "Дек"
          ],
          longhand: [
            "Январ",
            "Феврал",
            "Март",
            "Апрел",
            "Май",
            "Июн",
            "Июл",
            "Август",
            "Сентябр",
            "Октябр",
            "Ноябр",
            "Декабр"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Ҳафта",
        scrollTitle: "Катталаштириш учун айлантиринг",
        toggleTitle: "Ўтиш учун босинг",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Йил",
        time_24hr: true
      };
      fp$V.l10ns.uz = Uzbek;
      fp$V.l10ns;
      var fp$W = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var UzbekLatin = {
        weekdays: {
          shorthand: ["Ya", "Du", "Se", "Cho", "Pa", "Ju", "Sha"],
          longhand: [
            "Yakshanba",
            "Dushanba",
            "Seshanba",
            "Chorshanba",
            "Payshanba",
            "Juma",
            "Shanba"
          ]
        },
        months: {
          shorthand: [
            "Yan",
            "Fev",
            "Mar",
            "Apr",
            "May",
            "Iyun",
            "Iyul",
            "Avg",
            "Sen",
            "Okt",
            "Noy",
            "Dek"
          ],
          longhand: [
            "Yanvar",
            "Fevral",
            "Mart",
            "Aprel",
            "May",
            "Iyun",
            "Iyul",
            "Avgust",
            "Sentabr",
            "Oktabr",
            "Noyabr",
            "Dekabr"
          ]
        },
        firstDayOfWeek: 1,
        ordinal: function() {
          return "";
        },
        rangeSeparator: " — ",
        weekAbbreviation: "Hafta",
        scrollTitle: "Kattalashtirish uchun aylantiring",
        toggleTitle: "O‘tish uchun bosing",
        amPM: ["AM", "PM"],
        yearAriaLabel: "Yil",
        time_24hr: true
      };
      fp$W.l10ns["uz_latn"] = UzbekLatin;
      fp$W.l10ns;
      var fp$X = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Vietnamese = {
        weekdays: {
          shorthand: ["CN", "T2", "T3", "T4", "T5", "T6", "T7"],
          longhand: [
            "Chủ nhật",
            "Thứ hai",
            "Thứ ba",
            "Thứ tư",
            "Thứ năm",
            "Thứ sáu",
            "Thứ bảy"
          ]
        },
        months: {
          shorthand: [
            "Th1",
            "Th2",
            "Th3",
            "Th4",
            "Th5",
            "Th6",
            "Th7",
            "Th8",
            "Th9",
            "Th10",
            "Th11",
            "Th12"
          ],
          longhand: [
            "Tháng một",
            "Tháng hai",
            "Tháng ba",
            "Tháng tư",
            "Tháng năm",
            "Tháng sáu",
            "Tháng bảy",
            "Tháng tám",
            "Tháng chín",
            "Tháng mười",
            "Tháng mười một",
            "Tháng mười hai"
          ]
        },
        firstDayOfWeek: 1,
        rangeSeparator: " đến "
      };
      fp$X.l10ns.vn = Vietnamese;
      fp$X.l10ns;
      var fp$Y = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var Mandarin = {
        weekdays: {
          shorthand: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
          longhand: [
            "星期日",
            "星期一",
            "星期二",
            "星期三",
            "星期四",
            "星期五",
            "星期六"
          ]
        },
        months: {
          shorthand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ],
          longhand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ]
        },
        rangeSeparator: " 至 ",
        weekAbbreviation: "周",
        scrollTitle: "滚动切换",
        toggleTitle: "点击切换 12/24 小时时制"
      };
      fp$Y.l10ns.zh = Mandarin;
      fp$Y.l10ns;
      var fp$Z = typeof window !== "undefined" && window.flatpickr !== void 0 ? window.flatpickr : {
        l10ns: {}
      };
      var MandarinTraditional = {
        weekdays: {
          shorthand: ["週日", "週一", "週二", "週三", "週四", "週五", "週六"],
          longhand: [
            "星期日",
            "星期一",
            "星期二",
            "星期三",
            "星期四",
            "星期五",
            "星期六"
          ]
        },
        months: {
          shorthand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ],
          longhand: [
            "一月",
            "二月",
            "三月",
            "四月",
            "五月",
            "六月",
            "七月",
            "八月",
            "九月",
            "十月",
            "十一月",
            "十二月"
          ]
        },
        rangeSeparator: " 至 ",
        weekAbbreviation: "週",
        scrollTitle: "滾動切換",
        toggleTitle: "點擊切換 12/24 小時時制"
      };
      fp$Z.l10ns.zh_tw = MandarinTraditional;
      fp$Z.l10ns;
      var l10n2 = {
        ar: Arabic,
        at: Austria,
        az: Azerbaijan,
        be: Belarusian,
        bg: Bulgarian,
        bn: Bangla,
        bs: Bosnian,
        ca: Catalan,
        ckb: Kurdish,
        cat: Catalan,
        cs: Czech,
        cy: Welsh,
        da: Danish,
        de: German,
        default: __assign3({}, english2),
        en: english2,
        eo: Esperanto,
        es: Spanish,
        et: Estonian,
        fa: Persian,
        fi: Finnish,
        fo: Faroese,
        fr: French,
        gr: Greek,
        he: Hebrew,
        hi: Hindi,
        hr: Croatian,
        hu: Hungarian,
        hy: Armenian,
        id: Indonesian,
        is: Icelandic,
        it: Italian,
        ja: Japanese,
        ka: Georgian,
        ko: Korean,
        km: Khmer,
        kz: Kazakh,
        lt: Lithuanian,
        lv: Latvian,
        mk: Macedonian,
        mn: Mongolian,
        ms: Malaysian,
        my: Burmese,
        nl: Dutch,
        nn: NorwegianNynorsk,
        no: Norwegian,
        pa: Punjabi,
        pl: Polish,
        pt: Portuguese,
        ro: Romanian,
        ru: Russian,
        si: Sinhala,
        sk: Slovak,
        sl: Slovenian,
        sq: Albanian,
        sr: Serbian,
        sv: Swedish,
        th: Thai,
        tr: Turkish,
        uk: Ukrainian,
        vn: Vietnamese,
        zh: Mandarin,
        zh_tw: MandarinTraditional,
        uz: Uzbek,
        uz_latn: UzbekLatin
      };
      exports2.default = l10n2;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/flatpickr/dist/plugins/rangePlugin.js
var require_rangePlugin = __commonJS({
  "node_modules/flatpickr/dist/plugins/rangePlugin.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.rangePlugin = factory());
    })(exports, function() {
      "use strict";
      function __spreadArrays2() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r2[k] = a[j];
        return r2;
      }
      function rangePlugin2(config) {
        if (config === void 0) {
          config = {};
        }
        return function(fp) {
          var dateFormat = "", secondInput, _secondInputFocused, _prevDates;
          var createSecondInput = function() {
            if (config.input) {
              secondInput = config.input instanceof Element ? config.input : window.document.querySelector(config.input);
              if (!secondInput) {
                fp.config.errorHandler(new Error("Invalid input element specified"));
                return;
              }
              if (fp.config.wrap) {
                secondInput = secondInput.querySelector("[data-input]");
              }
            } else {
              secondInput = fp._input.cloneNode();
              secondInput.removeAttribute("id");
              secondInput._flatpickr = void 0;
            }
            if (secondInput.value) {
              var parsedDate = fp.parseDate(secondInput.value);
              if (parsedDate)
                fp.selectedDates.push(parsedDate);
            }
            secondInput.setAttribute("data-fp-omit", "");
            if (fp.config.clickOpens) {
              fp._bind(secondInput, ["focus", "click"], function() {
                if (fp.selectedDates[1]) {
                  fp.latestSelectedDateObj = fp.selectedDates[1];
                  fp._setHoursFromDate(fp.selectedDates[1]);
                  fp.jumpToDate(fp.selectedDates[1]);
                }
                _secondInputFocused = true;
                fp.isOpen = false;
                fp.open(void 0, config.position === "left" ? fp._input : secondInput);
              });
              fp._bind(fp._input, ["focus", "click"], function(e2) {
                e2.preventDefault();
                fp.isOpen = false;
                fp.open();
              });
            }
            if (fp.config.allowInput)
              fp._bind(secondInput, "keydown", function(e2) {
                if (e2.key === "Enter") {
                  fp.setDate([fp.selectedDates[0], secondInput.value], true, dateFormat);
                  secondInput.click();
                }
              });
            if (!config.input)
              fp._input.parentNode && fp._input.parentNode.insertBefore(secondInput, fp._input.nextSibling);
          };
          var plugin = {
            onParseConfig: function() {
              fp.config.mode = "range";
              dateFormat = fp.config.altInput ? fp.config.altFormat : fp.config.dateFormat;
            },
            onReady: function() {
              createSecondInput();
              fp.config.ignoredFocusElements.push(secondInput);
              if (fp.config.allowInput) {
                fp._input.removeAttribute("readonly");
                secondInput.removeAttribute("readonly");
              } else {
                secondInput.setAttribute("readonly", "readonly");
              }
              fp._bind(fp._input, "focus", function() {
                fp.latestSelectedDateObj = fp.selectedDates[0];
                fp._setHoursFromDate(fp.selectedDates[0]);
                _secondInputFocused = false;
                fp.jumpToDate(fp.selectedDates[0]);
              });
              if (fp.config.allowInput)
                fp._bind(fp._input, "keydown", function(e2) {
                  if (e2.key === "Enter")
                    fp.setDate([fp._input.value, fp.selectedDates[1]], true, dateFormat);
                });
              fp.setDate(fp.selectedDates, false);
              plugin.onValueUpdate(fp.selectedDates);
              fp.loadedPlugins.push("range");
            },
            onPreCalendarPosition: function() {
              if (_secondInputFocused) {
                fp._positionElement = secondInput;
                setTimeout(function() {
                  fp._positionElement = fp._input;
                }, 0);
              }
            },
            onChange: function() {
              if (!fp.selectedDates.length) {
                setTimeout(function() {
                  if (fp.selectedDates.length)
                    return;
                  secondInput.value = "";
                  _prevDates = [];
                }, 10);
              }
              if (_secondInputFocused) {
                setTimeout(function() {
                  secondInput.focus();
                }, 0);
              }
            },
            onDestroy: function() {
              if (!config.input)
                secondInput.parentNode && secondInput.parentNode.removeChild(secondInput);
            },
            onValueUpdate: function(selDates) {
              var _a, _b, _c;
              if (!secondInput)
                return;
              _prevDates = !_prevDates || selDates.length >= _prevDates.length ? __spreadArrays2(selDates) : _prevDates;
              if (_prevDates.length > selDates.length) {
                var newSelectedDate = selDates[0];
                var newDates = _secondInputFocused ? [_prevDates[0], newSelectedDate] : [newSelectedDate, _prevDates[1]];
                if (newDates[0].getTime() > newDates[1].getTime()) {
                  if (_secondInputFocused) {
                    newDates[0] = newDates[1];
                  } else {
                    newDates[1] = newDates[0];
                  }
                }
                fp.setDate(newDates, false);
                _prevDates = __spreadArrays2(newDates);
              }
              _a = fp.selectedDates.map(function(d) {
                return fp.formatDate(d, dateFormat);
              }), _b = _a[0], fp._input.value = _b === void 0 ? "" : _b, _c = _a[1], secondInput.value = _c === void 0 ? "" : _c;
            }
          };
          return plugin;
        };
      }
      return rangePlugin2;
    });
  }
});

// node_modules/@carbon/feature-flags/es/index.js
var enabled$1 = {};
try {
  if (process.env.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES) {
    if (process.env.CARBON_ENABLE_CSS_CUSTOM_PROPERTIES === "true") {
      enabled$1.enableCssCustomProperties = true;
    } else {
      enabled$1.enableCssCustomProperties = false;
    }
  } else {
    enabled$1.enableCssCustomProperties = false;
  }
  if (process.env.CARBON_ENABLE_CSS_GRID) {
    if (process.env.CARBON_ENABLE_CSS_GRID === "true") {
      enabled$1.enableCssGrid = true;
    } else {
      enabled$1.enableCssGrid = false;
    }
  } else {
    enabled$1.enableCssGrid = false;
  }
  if (process.env.CARBON_ENABLE_V11_RELEASE) {
    if (process.env.CARBON_ENABLE_V11_RELEASE === "true") {
      enabled$1.enableV11Release = true;
    } else {
      enabled$1.enableV11Release = false;
    }
  } else {
    enabled$1.enableV11Release = true;
  }
  if (process.env.CARBON_ENABLE_EXPERIMENTAL_TILE_CONTRAST) {
    if (process.env.CARBON_ENABLE_EXPERIMENTAL_TILE_CONTRAST === "true") {
      enabled$1.enableExperimentalTileContrast = true;
    } else {
      enabled$1.enableExperimentalTileContrast = false;
    }
  } else {
    enabled$1.enableExperimentalTileContrast = false;
  }
  if (process.env.CARBON_ENABLE_V12_TILE_DEFAULT_ICONS) {
    if (process.env.CARBON_ENABLE_V12_TILE_DEFAULT_ICONS === "true") {
      enabled$1.enableV12TileDefaultIcons = true;
    } else {
      enabled$1.enableV12TileDefaultIcons = false;
    }
  } else {
    enabled$1.enableV12TileDefaultIcons = false;
  }
  if (process.env.CARBON_ENABLE_V12_TILE_RADIO_ICONS) {
    if (process.env.CARBON_ENABLE_V12_TILE_RADIO_ICONS === "true") {
      enabled$1.enableV12TileRadioIcons = true;
    } else {
      enabled$1.enableV12TileRadioIcons = false;
    }
  } else {
    enabled$1.enableV12TileRadioIcons = false;
  }
  if (process.env.CARBON_ENABLE_V12_OVERFLOWMENU) {
    if (process.env.CARBON_ENABLE_V12_OVERFLOWMENU === "true") {
      enabled$1.enableV12Overflowmenu = true;
    } else {
      enabled$1.enableV12Overflowmenu = false;
    }
  } else {
    enabled$1.enableV12Overflowmenu = false;
  }
  if (process.env.CARBON_ENABLE_TREEVIEW_CONTROLLABLE) {
    if (process.env.CARBON_ENABLE_TREEVIEW_CONTROLLABLE === "true") {
      enabled$1.enableTreeviewControllable = true;
    } else {
      enabled$1.enableTreeviewControllable = false;
    }
  } else {
    enabled$1.enableTreeviewControllable = false;
  }
  if (process.env.CARBON_ENABLE_V12_STRUCTURED_LIST_VISIBLE_ICONS) {
    if (process.env.CARBON_ENABLE_V12_STRUCTURED_LIST_VISIBLE_ICONS === "true") {
      enabled$1.enableV12StructuredListVisibleIcons = true;
    } else {
      enabled$1.enableV12StructuredListVisibleIcons = false;
    }
  } else {
    enabled$1.enableV12StructuredListVisibleIcons = false;
  }
  if (process.env.CARBON_ENABLE_EXPERIMENTAL_FOCUS_WRAP_WITHOUT_SENTINELS) {
    if (process.env.CARBON_ENABLE_EXPERIMENTAL_FOCUS_WRAP_WITHOUT_SENTINELS === "true") {
      enabled$1.enableExperimentalFocusWrapWithoutSentinels = true;
    } else {
      enabled$1.enableExperimentalFocusWrapWithoutSentinels = false;
    }
  } else {
    enabled$1.enableExperimentalFocusWrapWithoutSentinels = false;
  }
  if (process.env.CARBON_ENABLE_DIALOG_ELEMENT) {
    if (process.env.CARBON_ENABLE_DIALOG_ELEMENT === "true") {
      enabled$1.enableDialogElement = true;
    } else {
      enabled$1.enableDialogElement = false;
    }
  } else {
    enabled$1.enableDialogElement = false;
  }
  if (process.env.CARBON_ENABLE_V12_DYNAMIC_FLOATING_STYLES) {
    if (process.env.CARBON_ENABLE_V12_DYNAMIC_FLOATING_STYLES === "true") {
      enabled$1.enableV12DynamicFloatingStyles = true;
    } else {
      enabled$1.enableV12DynamicFloatingStyles = false;
    }
  } else {
    enabled$1.enableV12DynamicFloatingStyles = false;
  }
  if (process.env.CARBON_ENABLE_V12_TOGGLE_REDUCED_LABEL_SPACING) {
    if (process.env.CARBON_ENABLE_V12_TOGGLE_REDUCED_LABEL_SPACING === "true") {
      enabled$1.enableV12ToggleReducedLabelSpacing = true;
    } else {
      enabled$1.enableV12ToggleReducedLabelSpacing = false;
    }
  } else {
    enabled$1.enableV12ToggleReducedLabelSpacing = false;
  }
  if (process.env.CARBON_ENABLE_ENHANCED_FILE_UPLOADER) {
    if (process.env.CARBON_ENABLE_ENHANCED_FILE_UPLOADER === "true") {
      enabled$1.enableEnhancedFileUploader = true;
    } else {
      enabled$1.enableEnhancedFileUploader = false;
    }
  } else {
    enabled$1.enableEnhancedFileUploader = false;
  }
} catch (error2) {
  enabled$1.enableCssCustomProperties = false;
  enabled$1.enableCssGrid = false;
  enabled$1.enableV11Release = true;
  enabled$1.enableExperimentalTileContrast = false;
  enabled$1.enableV12TileDefaultIcons = false;
  enabled$1.enableV12TileRadioIcons = false;
  enabled$1.enableV12Overflowmenu = false;
  enabled$1.enableTreeviewControllable = false;
  enabled$1.enableV12StructuredListVisibleIcons = false;
  enabled$1.enableExperimentalFocusWrapWithoutSentinels = false;
  enabled$1.enableDialogElement = false;
  enabled$1.enableV12DynamicFloatingStyles = false;
  enabled$1.enableV12ToggleReducedLabelSpacing = false;
  enabled$1.enableEnhancedFileUploader = false;
}
var featureFlagInfo = [{
  name: "enable-css-custom-properties",
  description: "Describe what the flag does",
  enabled: enabled$1.enableCssCustomProperties
}, {
  name: "enable-css-grid",
  description: "Enable CSS Grid Layout in the Grid and Column React components\n",
  enabled: enabled$1.enableCssGrid
}, {
  name: "enable-v11-release",
  description: "Enable the features and functionality for the v11 Release\n",
  enabled: enabled$1.enableV11Release
}, {
  name: "enable-experimental-tile-contrast",
  description: "Enable the experimental tile improved contrast styles\n",
  enabled: enabled$1.enableExperimentalTileContrast
}, {
  name: "enable-v12-tile-default-icons",
  description: "Enable rendering of default icons in the tile components\n",
  enabled: enabled$1.enableV12TileDefaultIcons
}, {
  name: "enable-v12-tile-radio-icons",
  description: "Enable rendering of radio icons in the RadioTile component\n",
  enabled: enabled$1.enableV12TileRadioIcons
}, {
  name: "enable-v12-overflowmenu",
  description: "Enable the use of the v12 OverflowMenu leveraging the Menu subcomponents\n",
  enabled: enabled$1.enableV12Overflowmenu
}, {
  name: "enable-treeview-controllable",
  description: "Enable the new TreeView controllable API\n",
  enabled: enabled$1.enableTreeviewControllable
}, {
  name: "enable-v12-structured-list-visible-icons",
  description: "Enable rendering of radio icons in the StructuredList component\n",
  enabled: enabled$1.enableV12StructuredListVisibleIcons
}, {
  name: "enable-experimental-focus-wrap-without-sentinels",
  description: "Enable the new focus wrap behavior that doesn't use sentinel nodes\n",
  enabled: enabled$1.enableExperimentalFocusWrapWithoutSentinels
}, {
  name: "enable-dialog-element",
  description: "Enable components to utilize the native dialog element\n",
  enabled: enabled$1.enableDialogElement
}, {
  name: "enable-v12-dynamic-floating-styles",
  description: "Enable dynamic setting of floating styles for components like Popover, Tooltip, etc.\n",
  enabled: enabled$1.enableV12DynamicFloatingStyles
}, {
  name: "enable-v12-toggle-reduced-label-spacing",
  description: "Enable a reduced spacing between the toggle control and its label\n",
  enabled: enabled$1.enableV12ToggleReducedLabelSpacing
}, {
  name: "enable-enhanced-file-uploader",
  description: "Enable enhanced functionality for the FileUploader component, including richer callback data and expanded trigger events for onChange and onDelete.\n",
  enabled: enabled$1.enableEnhancedFileUploader
}];
function _arrayLikeToArray(r2, a) {
  (null == a || a > r2.length) && (a = r2.length);
  for (var e2 = 0, n2 = Array(a); e2 < a; e2++) n2[e2] = r2[e2];
  return n2;
}
function _arrayWithHoles(r2) {
  if (Array.isArray(r2)) return r2;
}
function _classCallCheck(a, n2) {
  if (!(a instanceof n2)) throw new TypeError("Cannot call a class as a function");
}
function _defineProperties(e2, r2) {
  for (var t3 = 0; t3 < r2.length; t3++) {
    var o3 = r2[t3];
    o3.enumerable = o3.enumerable || false, o3.configurable = true, "value" in o3 && (o3.writable = true), Object.defineProperty(e2, _toPropertyKey(o3.key), o3);
  }
}
function _createClass(e2, r2, t3) {
  return r2 && _defineProperties(e2.prototype, r2), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}
function _createForOfIteratorHelper(r2, e2) {
  var t3 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (!t3) {
    if (Array.isArray(r2) || (t3 = _unsupportedIterableToArray(r2)) || e2) {
      t3 && (r2 = t3);
      var n2 = 0, F = function() {
      };
      return {
        s: F,
        n: function() {
          return n2 >= r2.length ? {
            done: true
          } : {
            done: false,
            value: r2[n2++]
          };
        },
        e: function(r3) {
          throw r3;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o3, a = true, u = false;
  return {
    s: function() {
      t3 = t3.call(r2);
    },
    n: function() {
      var r3 = t3.next();
      return a = r3.done, r3;
    },
    e: function(r3) {
      u = true, o3 = r3;
    },
    f: function() {
      try {
        a || null == t3.return || t3.return();
      } finally {
        if (u) throw o3;
      }
    }
  };
}
function _iterableToArrayLimit(r2, l2) {
  var t3 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t3) {
    var e2, n2, i, u, a = [], f = true, o3 = false;
    try {
      if (i = (t3 = t3.call(r2)).next, 0 === l2) ;
      else for (; !(f = (e2 = i.call(t3)).done) && (a.push(e2.value), a.length !== l2); f = true) ;
    } catch (r3) {
      o3 = true, n2 = r3;
    } finally {
      try {
        if (!f && null != t3.return && (u = t3.return(), Object(u) !== u)) return;
      } finally {
        if (o3) throw n2;
      }
    }
    return a;
  }
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(r2, e2) {
  return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
}
function _toPrimitive(t3, r2) {
  if ("object" != typeof t3 || !t3) return t3;
  var e2 = t3[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t3, r2);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(t3);
}
function _toPropertyKey(t3) {
  var i = _toPrimitive(t3, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r2, a) {
  if (r2) {
    if ("string" == typeof r2) return _arrayLikeToArray(r2, a);
    var t3 = {}.toString.call(r2).slice(8, -1);
    return "Object" === t3 && r2.constructor && (t3 = r2.constructor.name), "Map" === t3 || "Set" === t3 ? Array.from(r2) : "Arguments" === t3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t3) ? _arrayLikeToArray(r2, a) : void 0;
  }
}
var FeatureFlagScope = function() {
  function FeatureFlagScope2(flags) {
    var _this = this;
    _classCallCheck(this, FeatureFlagScope2);
    this.flags = /* @__PURE__ */ new Map();
    if (flags) {
      Object.keys(flags).forEach(function(key) {
        _this.flags.set(key, flags[key]);
      });
    }
  }
  return _createClass(FeatureFlagScope2, [{
    key: "checkForFlag",
    value: function checkForFlag(name) {
      if (!this.flags.has(name)) {
        throw new Error("Unable to find a feature flag with the name: `".concat(name, "`"));
      }
    }
    /**
     * Add a feature flag
     * @param {string} name
     * @param {boolean} enabled
     */
  }, {
    key: "add",
    value: function add(name, enabled2) {
      if (this.flags.has(name)) {
        throw new Error("The feature flag: ".concat(name, " already exists"));
      }
      this.flags.set(name, enabled2);
    }
    /**
     * Enable a feature flag
     * @param {string} name
     */
  }, {
    key: "enable",
    value: function enable(name) {
      this.checkForFlag(name);
      this.flags.set(name, true);
    }
    /**
     * Disable a feature flag
     * @param {string} name
     */
  }, {
    key: "disable",
    value: function disable(name) {
      this.checkForFlag(name);
      this.flags.set(name, false);
    }
    /**
     * Merge the given feature flags with the current set of feature flags.
     * Duplicate keys will be set to the value in the given feature flags.
     * @param {object} flags
     */
  }, {
    key: "merge",
    value: function merge2(flags) {
      var _this2 = this;
      Object.keys(flags).forEach(function(key) {
        _this2.flags.set(key, flags[key]);
      });
    }
    /**
     * @param {FeatureFlagScope} scope
     */
  }, {
    key: "mergeWithScope",
    value: function mergeWithScope(scope) {
      var _iterator = _createForOfIteratorHelper(scope.flags), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1];
          if (this.flags.has(key)) {
            continue;
          }
          this.flags.set(key, value);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Check if a feature flag is enabled
     * @param {string} name
     * @returns {boolean}
     */
  }, {
    key: "enabled",
    value: function enabled2(name) {
      this.checkForFlag(name);
      return this.flags.get(name);
    }
  }]);
}();
var FeatureFlags = createScope();
for (i = 0; i < featureFlagInfo.length; i++) {
  featureFlag = featureFlagInfo[i];
  FeatureFlags.add(featureFlag.name, featureFlag.enabled);
}
var featureFlag;
var i;
function createScope(flags) {
  return new FeatureFlagScope(flags);
}
function enabled() {
  return FeatureFlags.enabled.apply(FeatureFlags, arguments);
}
function merge() {
  return FeatureFlags.merge.apply(FeatureFlags, arguments);
}

// node_modules/@carbon/react/es/feature-flags.js
merge({
  "enable-css-custom-properties": true,
  "enable-css-grid": true,
  "enable-v11-release": true,
  "enable-experimental-tile-contrast": false,
  "enable-v12-tile-radio-icons": false,
  "enable-v12-structured-list-visible-icons": false,
  "enable-v12-dynamic-floating-styles": false
});

// node_modules/@carbon/react/es/_virtual/_rollupPluginBabelHelpers.js
function _defineProperty(e2, r2, t3) {
  return (r2 = _toPropertyKey2(r2)) in e2 ? Object.defineProperty(e2, r2, {
    value: t3,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r2] = t3, e2;
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t3 = arguments[e2];
      for (var r2 in t3) ({}).hasOwnProperty.call(t3, r2) && (n2[r2] = t3[r2]);
    }
    return n2;
  }, _extends.apply(null, arguments);
}
function _toPrimitive2(t3, r2) {
  if ("object" != typeof t3 || !t3) return t3;
  var e2 = t3[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t3, r2);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t3);
}
function _toPropertyKey2(t3) {
  var i = _toPrimitive2(t3, "string");
  return "symbol" == typeof i ? i : i + "";
}

// node_modules/@carbon/react/es/components/Accordion/Accordion.js
var import_classnames = __toESM(require_classnames());

// node_modules/@carbon/react/es/internal/usePrefix.js
var import_react = __toESM(require_react());
var PrefixContext = import_react.default.createContext("cds");
function usePrefix() {
  return import_react.default.useContext(PrefixContext);
}

// node_modules/@carbon/react/es/components/Accordion/Accordion.js
var import_prop_types = __toESM(require_prop_types());
var import_react3 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Accordion/AccordionProvider.js
var import_react2 = __toESM(require_react());
var AccordionContext = (0, import_react2.createContext)({
  disabled: false
});
var AccordionProvider = ({
  disabled,
  children
}) => {
  return import_react2.default.createElement(AccordionContext.Provider, {
    value: {
      disabled
    }
  }, children);
};

// node_modules/@carbon/react/es/components/Accordion/Accordion.js
function Accordion({
  align = "end",
  children,
  className: customClassName,
  disabled = false,
  isFlush = false,
  ordered = false,
  size: size4,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames.default)(`${prefix}--accordion`, customClassName, {
    [`${prefix}--accordion--${align}`]: align,
    [`${prefix}--accordion--${size4}`]: size4,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4,
    [`${prefix}--accordion--flush`]: isFlush && align !== "start"
  });
  const ListTag = ordered ? "ol" : "ul";
  return import_react3.default.createElement(AccordionProvider, {
    disabled
  }, import_react3.default.createElement(ListTag, _extends({
    className
  }, rest), children));
}
Accordion.propTypes = {
  /**
   * Specify the alignment of the accordion heading title and chevron.
   */
  align: import_prop_types.default.oneOf(["start", "end"]),
  /**
   * Pass in the children that will be rendered within the Accordion
   */
  children: import_prop_types.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types.default.string,
  /**
   * Specify whether an individual AccordionItem should be disabled
   */
  disabled: import_prop_types.default.bool,
  /**
   * Specify whether Accordion text should be flush, default is false, does not work with align="start"
   */
  isFlush: import_prop_types.default.bool,
  /**
   * Specify if the Accordion should be an ordered list,
   * default is `false`
   */
  ordered: import_prop_types.default.bool,
  /**
   * Specify the size of the Accordion. Currently supports the following:
   */
  size: import_prop_types.default.oneOf(["sm", "md", "lg"])
};

// node_modules/@carbon/react/es/components/Accordion/AccordionItem.js
var import_classnames2 = __toESM(require_classnames());
var import_prop_types4 = __toESM(require_prop_types());
var import_react11 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Text/createTextComponent.js
var import_react6 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Text/Text.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react5 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Text/TextDirectionContext.js
var import_react4 = __toESM(require_react());
var TextDirectionContext = (0, import_react4.createContext)({
  direction: "auto",
  getTextDirection: {
    current: void 0
  }
});

// node_modules/@carbon/react/es/components/Text/Text.js
var TextBase = import_react5.default.forwardRef(({
  as,
  children,
  dir = "auto",
  ...rest
}, ref) => {
  const context = (0, import_react5.useContext)(TextDirectionContext);
  const textProps = {};
  const BaseComponent = as ?? "span";
  const value = {
    ...context
  };
  if (!context) {
    textProps.dir = dir;
    value.direction = dir;
  } else {
    const {
      direction: parentDirection,
      getTextDirection
    } = context;
    if (getTextDirection && getTextDirection.current) {
      const text = getTextFromChildren(children);
      const override = getTextDirection.current(text);
      if (parentDirection !== override) {
        textProps.dir = override;
        value.direction = override;
      } else if (parentDirection === "auto") {
        textProps.dir = override;
      }
    } else if (parentDirection !== dir) {
      textProps.dir = dir;
      value.direction = dir;
    } else if (parentDirection === "auto") {
      textProps.dir = dir;
    }
  }
  return import_react5.default.createElement(TextDirectionContext.Provider, {
    value
  }, import_react5.default.createElement(BaseComponent, _extends({
    ref
  }, rest, textProps), children));
});
var Text = TextBase;
Text.propTypes = {
  /**
   * Provide a custom element type used to render the outermost node
   */
  as: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.string, import_prop_types2.default.elementType]),
  /**
   * Provide child elements or text to be rendered inside of this component
   */
  children: import_prop_types2.default.node.isRequired,
  /**
   * Specify the text direction to be used for this component and any of its
   * children
   */
  dir: import_prop_types2.default.oneOf(["ltr", "rtl", "auto"])
};
var getTextFromChildren = (children) => {
  var _a;
  if (typeof children === "string") {
    return children;
  }
  const text = (_a = import_react5.Children.map(children, (child) => {
    if (typeof child === "string") {
      return child;
    }
    return null;
  })) == null ? void 0 : _a.filter((text2) => {
    return text2 !== null;
  });
  if ((text == null ? void 0 : text.length) === 1) {
    return text[0];
  }
  return text;
};

// node_modules/@carbon/react/es/components/Text/createTextComponent.js
var createTextComponent = (element, displayName) => {
  const TextWrapper = (props) => {
    return import_react6.default.createElement(Text, _extends({
      as: element
    }, props));
  };
  if (true) {
    TextWrapper.displayName = displayName;
  }
  return TextWrapper;
};

// node_modules/@carbon/react/es/components/Text/TextDirection.js
var import_prop_types3 = __toESM(require_prop_types());
var import_react7 = __toESM(require_react());
var TextDirection = ({
  children,
  dir = "auto",
  getTextDirection
}) => {
  const savedCallback = (0, import_react7.useRef)(getTextDirection);
  const value = (0, import_react7.useMemo)(() => {
    return {
      direction: dir,
      getTextDirection: savedCallback
    };
  }, [dir]);
  (0, import_react7.useEffect)(() => {
    savedCallback.current = getTextDirection;
  });
  return import_react7.default.createElement(TextDirectionContext.Provider, {
    value
  }, children);
};
TextDirection.propTypes = {
  /**
   * Provide children to be rendered inside of this component
   */
  children: import_prop_types3.default.node,
  /**
   * Specify the text direction for rendered children
   */
  dir: import_prop_types3.default.oneOf(["ltr", "rtl", "auto"]),
  /**
   * Optionally provide a custom function to get the text direction for a piece
   * of text. Whatever is returned will become the value of the `dir` attribute
   * on a node of text. Should return one of: 'ltr', 'rtl', or 'auto'
   */
  getTextDirection: import_prop_types3.default.func
};

// node_modules/@carbon/react/es/components/Text/index.js
var import_react8 = __toESM(require_react());
createTextComponent("label", "Label");
var Legend = createTextComponent("legend", "Legend");

// node_modules/@carbon/react/es/internal/keyboard/keys.js
var Tab = {
  key: "Tab",
  which: 9,
  keyCode: 9,
  code: "Tab"
};
var Enter = {
  key: "Enter",
  which: 13,
  keyCode: 13,
  code: "Enter"
};
var Escape = {
  key: [
    "Escape",
    // IE11 Escape
    "Esc"
  ],
  which: 27,
  keyCode: 27,
  code: "Esc"
};
var Space = {
  key: " ",
  which: 32,
  keyCode: 32,
  code: "Space"
};
var End = {
  key: "End",
  which: 35,
  keyCode: 35,
  code: "Numpad1"
};
var Home = {
  key: "Home",
  which: 36,
  keyCode: 36,
  code: "Numpad7"
};
var ArrowLeft = {
  key: "ArrowLeft",
  which: 37,
  keyCode: 37,
  code: "ArrowLeft"
};
var ArrowUp2 = {
  key: "ArrowUp",
  which: 38,
  keyCode: 38,
  code: "ArrowUp"
};
var ArrowRight2 = {
  key: "ArrowRight",
  which: 39,
  keyCode: 39,
  code: "ArrowRight"
};
var ArrowDown = {
  key: "ArrowDown",
  which: 40,
  keyCode: 40,
  code: "ArrowDown"
};
var Delete = {
  key: "Delete",
  which: 8,
  keyCode: 8,
  code: "ArrowDecimal"
};

// node_modules/@carbon/react/es/internal/keyboard/match.js
var matches = (event, keysToMatch) => {
  for (let i = 0; i < keysToMatch.length; i++) {
    if (match(event, keysToMatch[i])) {
      return true;
    }
  }
  return false;
};
var match = (eventOrCode, {
  key,
  which,
  keyCode,
  code
}) => {
  if (typeof eventOrCode === "string") {
    return eventOrCode === key;
  }
  if (typeof eventOrCode === "number") {
    return eventOrCode === which || eventOrCode === keyCode;
  }
  if (eventOrCode.key && Array.isArray(key)) {
    return key.includes(eventOrCode.key);
  }
  return eventOrCode.key === key || // TODO: When can these checks for deprecated properties be deleted?
  // Presumably, the `Key` type should also be pruned of these properties.
  eventOrCode.which === which || eventOrCode.keyCode === keyCode || eventOrCode.code === code;
};

// node_modules/@carbon/react/es/internal/useId.js
var import_react10 = __toESM(require_react());

// node_modules/@carbon/react/es/tools/setupGetInstanceId.js
var setupGetInstanceId = () => {
  let instanceId2 = 0;
  return () => ++instanceId2;
};

// node_modules/@carbon/react/es/internal/environment.js
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);

// node_modules/@carbon/react/es/internal/useIdPrefix.js
var import_react9 = __toESM(require_react());
var IdPrefixContext = import_react9.default.createContext(null);
function useIdPrefix() {
  return import_react9.default.useContext(IdPrefixContext);
}

// node_modules/@carbon/react/es/internal/useId.js
var _React = {
  ...import_react10.default
};
var instanceId = setupGetInstanceId();
var useIsomorphicLayoutEffect = canUseDOM ? import_react10.useLayoutEffect : import_react10.useEffect;
var serverHandoffCompleted = false;
var defaultId = "id";
function useCompatibleId(prefix = defaultId) {
  const contextPrefix = useIdPrefix();
  const [id, setId] = (0, import_react10.useState)(() => {
    if (serverHandoffCompleted) {
      return `${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${instanceId()}`;
    }
    return null;
  });
  useIsomorphicLayoutEffect(() => {
    if (id === null) {
      setId(`${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${instanceId()}`);
    }
  }, [instanceId]);
  (0, import_react10.useEffect)(() => {
    if (serverHandoffCompleted === false) {
      serverHandoffCompleted = true;
    }
  }, []);
  return id;
}
function useReactId(prefix = defaultId) {
  const contextPrefix = useIdPrefix();
  return `${contextPrefix ? `${contextPrefix}-` : ``}${prefix}-${_React.useId()}`;
}
var useId = _React.useId ? useReactId : useCompatibleId;
function useFallbackId(id) {
  const fallback = useId();
  return id ?? fallback;
}

// node_modules/@carbon/react/es/internal/noopFn.js
var noopFn = () => {
};

// node_modules/@carbon/react/es/internal/warning.js
var warning = true ? (condition, message) => {
  if (typeof message === "undefined") {
    throw new Error("`warning(condition, message)` requires a warning format argument");
  }
  if (!condition) {
    console.warn("Warning: " + message);
  }
} : noopFn;

// node_modules/@carbon/react/es/prop-types/deprecate.js
var warningCache = /* @__PURE__ */ new Map();
var deprecate = (propType, message) => {
  const checker = (props, propName, componentName, ...rest) => {
    if (typeof props[propName] === "undefined") {
      return;
    }
    if (!warningCache.has(componentName)) {
      warningCache.set(componentName, /* @__PURE__ */ new Set());
    }
    const warnedProps = warningCache.get(componentName);
    if (warnedProps && !warnedProps.has(propName)) {
      warnedProps.add(propName);
      true ? warning(false, message || `The prop \`${propName}\` has been deprecated for the ${componentName} component. It will be removed in the next major release`) : void 0;
    }
    return propType(props, propName, componentName, ...rest);
  };
  return checker;
};

// node_modules/@carbon/react/es/components/Accordion/AccordionItem.js
var defaultRenderToggle = (props) => import_react11.default.createElement("button", _extends({
  type: "button"
}, props));
function AccordionItem({
  children,
  className: customClassName = "",
  open: open2 = false,
  onHeadingClick,
  renderExpando = defaultRenderToggle,
  // remove renderExpando in next major release
  renderToggle,
  title = "title",
  disabled: controlledDisabled,
  handleAnimationEnd,
  ...rest
}) {
  const [isOpen, setIsOpen] = (0, import_react11.useState)(open2);
  const [prevIsOpen, setPrevIsOpen] = (0, import_react11.useState)(open2);
  const accordionState = (0, import_react11.useContext)(AccordionContext);
  const disabledIsControlled = typeof controlledDisabled === "boolean";
  const disabled = disabledIsControlled ? controlledDisabled : accordionState.disabled;
  const id = useId("accordion-item");
  const prefix = usePrefix();
  const className = (0, import_classnames2.default)({
    [`${prefix}--accordion__item`]: true,
    [`${prefix}--accordion__item--active`]: isOpen && !disabled,
    [`${prefix}--accordion__item--disabled`]: disabled,
    [customClassName]: !!customClassName
  });
  const Toggle2 = renderToggle || renderExpando;
  const content = import_react11.default.useCallback((node) => {
    if (!node) {
      return;
    }
    if (isOpen) {
      node.style.maxBlockSize = "";
    }
  }, [isOpen]);
  if (open2 !== prevIsOpen) {
    setIsOpen(open2);
    setPrevIsOpen(open2);
  }
  function onClick(event) {
    const nextValue = !isOpen;
    setIsOpen(nextValue);
    if (onHeadingClick) {
      onHeadingClick({
        isOpen: nextValue,
        event
      });
    }
  }
  function onKeyDown(event) {
    if (isOpen && match(event, Escape)) {
      setIsOpen(false);
    }
  }
  function onAnimationEnd(event) {
    if (handleAnimationEnd) {
      handleAnimationEnd(event);
    }
  }
  return import_react11.default.createElement("li", _extends({
    className
  }, rest), import_react11.default.createElement(Toggle2, {
    disabled,
    "aria-controls": id,
    "aria-expanded": isOpen,
    className: `${prefix}--accordion__heading`,
    onClick,
    onKeyDown,
    type: "button"
  }, import_react11.default.createElement(ChevronRight, {
    className: `${prefix}--accordion__arrow`
  }), import_react11.default.createElement(Text, {
    as: "div",
    className: `${prefix}--accordion__title`
  }, title)), import_react11.default.createElement("div", {
    ref: content,
    className: `${prefix}--accordion__wrapper`,
    onTransitionEnd: onAnimationEnd
  }, import_react11.default.createElement("div", {
    id,
    className: `${prefix}--accordion__content`
  }, children)));
}
AccordionItem.propTypes = {
  /**
   * Provide the contents of your AccordionItem
   */
  children: import_prop_types4.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types4.default.string,
  /**
   * Specify whether an individual AccordionItem should be disabled
   */
  disabled: import_prop_types4.default.bool,
  /**
   * The handler of the massaged `click` event.
   */
  onClick: import_prop_types4.default.func,
  /**
   * The handler of the massaged `click` event on the heading.
   */
  onHeadingClick: import_prop_types4.default.func,
  /**
   * `true` to open the expand.
   */
  open: import_prop_types4.default.bool,
  /**
   * The callback function to render the expand button.
   * Can be a React component class.
   */
  renderExpando: deprecate(import_prop_types4.default.func, "The `renderExpando` prop has been deprecated and will be removed in the next major release of Carbon. Use the `renderToggle` prop instead."),
  /**
   * The callback function to render the expand button.
   * Can be a React component class.
   */
  renderToggle: import_prop_types4.default.func,
  /**
   * The accordion title.
   */
  title: import_prop_types4.default.node
};

// node_modules/@carbon/react/es/components/Accordion/Accordion.Skeleton.js
var import_prop_types6 = __toESM(require_prop_types());
var import_react14 = __toESM(require_react());
var import_classnames4 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/SkeletonText/SkeletonText.js
var import_prop_types5 = __toESM(require_prop_types());
var import_react13 = __toESM(require_react());
var import_classnames3 = __toESM(require_classnames());

// node_modules/@carbon/react/es/internal/useIsomorphicEffect.js
var import_react12 = __toESM(require_react());
var useIsomorphicEffect = typeof window !== "undefined" ? import_react12.useLayoutEffect : import_react12.useEffect;

// node_modules/@carbon/react/es/components/SkeletonText/SkeletonText.js
var randoms = [0.973051493507435, 0.15334737213558558, 0.5671034553053769];
function getRandomInt(min2, max2, n2) {
  return Math.floor(randoms[n2 % 3] * (max2 - min2 + 1)) + min2;
}
var SkeletonText = ({
  paragraph = false,
  lineCount = 3,
  width = "100%",
  heading = false,
  className = "",
  ...rest
}) => {
  const prefix = usePrefix();
  const skeletonTextClasses = (0, import_classnames3.default)({
    [`${prefix}--skeleton__text`]: true,
    [`${prefix}--skeleton__heading`]: heading,
    [className]: className
  });
  const widthNum = parseInt(width, 10);
  const widthPx = width.includes("px");
  const widthPercent = width.includes("%");
  let lineCountNumber = 1;
  if (paragraph) {
    lineCountNumber = lineCount;
  }
  const refs = (0, import_react13.useRef)([]);
  useIsomorphicEffect(() => {
    refs.current.map((item, j) => {
      const randomPercentWidth = getRandomInt(0, 75, j) + "px";
      const randomPxWidth = getRandomInt(Math.max(widthNum - 75, 0), widthNum, j) + "px";
      if (item) {
        if (widthPercent && paragraph) {
          item.style.width = `calc(${width} - ${randomPercentWidth})`;
        } else if (widthPx && paragraph) {
          item.style.width = randomPxWidth;
        } else {
          item.style.width = width;
        }
      }
    });
  }, [lineCountNumber, paragraph, refs, width, widthNum, widthPercent, widthPx]);
  const lines = [];
  for (let i = 0; i < lineCountNumber; i++) {
    lines.push(import_react13.default.createElement("p", _extends({
      className: skeletonTextClasses,
      key: i,
      ref: (el) => {
        refs.current = [...refs.current, el];
      }
    }, rest)));
  }
  if (lineCountNumber !== 1) {
    return import_react13.default.createElement("div", null, lines);
  }
  return import_react13.default.createElement(import_react13.default.Fragment, null, lines);
};
SkeletonText.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types5.default.string,
  /**
   * generates skeleton text at a larger size
   */
  heading: import_prop_types5.default.bool,
  /**
   * the number of lines shown if paragraph is true
   */
  lineCount: import_prop_types5.default.number,
  /**
   * will generate multiple lines of text
   */
  paragraph: import_prop_types5.default.bool,
  /**
   * width (in px or %) of single line of text or max-width of paragraph lines
   */
  width: import_prop_types5.default.string
};

// node_modules/@carbon/react/es/components/Accordion/Accordion.Skeleton.js
var _SkeletonText;
var _SkeletonText2;
var _SkeletonText3;
function AccordionSkeleton({
  align = "end",
  className,
  count: count2 = 4,
  isFlush,
  open: open2 = true,
  ordered = false,
  ...rest
}) {
  const prefix = usePrefix();
  const classes = (0, import_classnames4.default)(`${prefix}--accordion`, `${prefix}--skeleton`, className, {
    [`${prefix}--accordion--${align}`]: align,
    [`${prefix}--accordion--flush`]: isFlush && align !== "start"
  });
  const numSkeletonItems = open2 ? count2 - 1 : count2;
  const ListTag = ordered ? "ol" : "ul";
  return import_react14.default.createElement(ListTag, _extends({
    className: classes
  }, rest), open2 && import_react14.default.createElement("li", {
    className: `${prefix}--accordion__item ${prefix}--accordion__item--active`
  }, import_react14.default.createElement("span", {
    className: `${prefix}--accordion__heading`
  }, import_react14.default.createElement(ChevronRight, {
    className: `${prefix}--accordion__arrow`
  }), import_react14.default.createElement(SkeletonText, {
    className: `${prefix}--accordion__title`
  })), import_react14.default.createElement("div", {
    className: `${prefix}--accordion__content`
  }, _SkeletonText || (_SkeletonText = import_react14.default.createElement(SkeletonText, {
    width: "90%"
  })), _SkeletonText2 || (_SkeletonText2 = import_react14.default.createElement(SkeletonText, {
    width: "80%"
  })), _SkeletonText3 || (_SkeletonText3 = import_react14.default.createElement(SkeletonText, {
    width: "95%"
  })))), Array.from({
    length: numSkeletonItems
  }).map((_, i) => import_react14.default.createElement(AccordionSkeletonItem, {
    key: i
  })));
}
AccordionSkeleton.propTypes = {
  /**
   * Specify the alignment of the accordion heading title and chevron.
   */
  align: import_prop_types6.default.oneOf(["start", "end"]),
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types6.default.string,
  /**
   * Set number of items to render
   */
  count: import_prop_types6.default.number,
  /**
   * Specify whether an individual AccordionItem should be flush, default is false
   */
  isFlush: import_prop_types6.default.bool,
  /**
   * `false` to not display the first item opened
   */
  open: import_prop_types6.default.bool
};
function AccordionSkeletonItem() {
  const prefix = usePrefix();
  return import_react14.default.createElement("li", {
    className: `${prefix}--accordion__item`
  }, import_react14.default.createElement("span", {
    className: `${prefix}--accordion__heading`
  }, import_react14.default.createElement(ChevronRight, {
    className: `${prefix}--accordion__arrow`
  }), import_react14.default.createElement(SkeletonText, {
    className: `${prefix}--accordion__title`
  })));
}

// node_modules/@carbon/react/es/components/AspectRatio/AspectRatio.js
var import_classnames5 = __toESM(require_classnames());
var import_prop_types7 = __toESM(require_prop_types());
var import_react15 = __toESM(require_react());
var AspectRatio = ({
  as: BaseComponent = "div",
  className: containerClassName,
  children,
  ratio = "1x1",
  ...rest
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames5.default)(containerClassName, `${prefix}--aspect-ratio`, `${prefix}--aspect-ratio--${ratio}`);
  return import_react15.default.createElement(BaseComponent, _extends({
    className
  }, rest), children);
};
AspectRatio.propTypes = {
  /**
   * Provide a custom component or string to be rendered as the outermost node
   * of the component. This is useful if you want to deviate from the default
   * `div` tag, where you could specify `section` or `article` instead.
   *
   * ```jsx
   * <AspectRatio as="article">My content</AspectRatio>
   * ```
   */
  as: import_prop_types7.default.elementType,
  /**
   * Specify the content that will be placed in the aspect ratio
   */
  children: import_prop_types7.default.node,
  /**
   * Specify a class name for the outermost node of the component
   */
  className: import_prop_types7.default.string,
  /**
   * Specify the ratio to be used by the aspect ratio container. This will
   * determine what aspect ratio your content will be displayed in.
   */
  ratio: import_prop_types7.default.oneOf(["16x9", "9x16", "2x1", "1x2", "4x3", "3x4", "3x2", "2x3", "1x1"])
};

// node_modules/@carbon/react/es/components/Breadcrumb/Breadcrumb.js
var import_prop_types8 = __toESM(require_prop_types());
var import_react16 = __toESM(require_react());
var import_classnames6 = __toESM(require_classnames());
var Breadcrumb = (0, import_react16.forwardRef)((props, ref) => {
  const {
    "aria-label": ariaLabel,
    children,
    className: customClassNameNav,
    noTrailingSlash,
    size: size4,
    ...rest
  } = props;
  const prefix = usePrefix();
  const className = (0, import_classnames6.default)({
    [`${prefix}--breadcrumb`]: true,
    [`${prefix}--breadcrumb--no-trailing-slash`]: noTrailingSlash,
    [`${prefix}--breadcrumb--sm`]: size4 === "sm"
  });
  return import_react16.default.createElement("nav", _extends({
    className: customClassNameNav,
    "aria-label": ariaLabel ? ariaLabel : "Breadcrumb",
    ref
  }, rest), import_react16.default.createElement("ol", {
    className
  }, children));
});
Breadcrumb.displayName = "Breadcrumb";
Breadcrumb.propTypes = {
  /**
   * Specify the label for the breadcrumb container
   */
  "aria-label": import_prop_types8.default.string,
  /**
   * Pass in the BreadcrumbItem's for your Breadcrumb
   */
  children: import_prop_types8.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types8.default.string,
  /**
   * Optional prop to omit the trailing slash for the breadcrumbs
   */
  noTrailingSlash: import_prop_types8.default.bool,
  /**
   * Specify the size of the Breadcrumb. Currently supports the following:
   */
  size: import_prop_types8.default.oneOf(["sm", "md"])
};

// node_modules/@carbon/react/es/components/Breadcrumb/BreadcrumbItem.js
var import_prop_types10 = __toESM(require_prop_types());
var import_react18 = __toESM(require_react());
var import_classnames8 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Link/Link.js
var import_classnames7 = __toESM(require_classnames());
var import_prop_types9 = __toESM(require_prop_types());
var import_react17 = __toESM(require_react());
var LinkBase = import_react17.default.forwardRef(({
  as: BaseComponent,
  children,
  className: customClassName,
  href,
  disabled = false,
  inline: inline4 = false,
  visited = false,
  renderIcon: Icon,
  size: size4,
  target,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const className = (0, import_classnames7.default)(`${prefix}--link`, customClassName, {
    [`${prefix}--link--disabled`]: disabled,
    [`${prefix}--link--inline`]: inline4,
    [`${prefix}--link--visited`]: visited,
    [`${prefix}--link--${size4}`]: size4
  });
  const rel = target === "_blank" ? "noopener" : void 0;
  const linkProps = {
    className,
    rel,
    target
  };
  if (!disabled) {
    linkProps.href = href;
  } else {
    linkProps.role = "link";
    linkProps["aria-disabled"] = true;
  }
  const BaseComponentAsAny = BaseComponent ?? "a";
  const handleOnClick = (event) => {
    if (disabled) {
      event.preventDefault();
      event.stopPropagation();
    } else {
      if (rest.onClick) {
        rest.onClick(event);
      }
    }
  };
  return import_react17.default.createElement(BaseComponentAsAny, _extends({
    ref
  }, linkProps, rest, {
    onClick: handleOnClick
  }), children, !inline4 && Icon && import_react17.default.createElement("div", {
    className: `${prefix}--link__icon`
  }, import_react17.default.createElement(Icon, null)));
});
var Link = LinkBase;
Link.displayName = "Link";
Link.propTypes = {
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types9.default.elementType,
  /**
   * Provide the content for the Link
   */
  children: import_prop_types9.default.node,
  /**
   * Provide a custom className to be applied to the containing `<a>` node
   */
  className: import_prop_types9.default.string,
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: import_prop_types9.default.bool,
  /**
   * Provide the `href` attribute for the `<a>` node
   */
  href: import_prop_types9.default.string,
  /**
   * Specify whether you want the inline version of this control
   */
  inline: import_prop_types9.default.bool,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types9.default.oneOfType([import_prop_types9.default.func, import_prop_types9.default.object]),
  /**
   * Specify the size of the Link. Currently supports either `sm`, `md` (default) or `lg` as an option.
   */
  size: import_prop_types9.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify whether you want the link to receive visited styles after the link has been clicked
   */
  visited: import_prop_types9.default.bool
};

// node_modules/@carbon/react/es/components/Breadcrumb/BreadcrumbItem.js
var frFn = import_react18.forwardRef;
var BreadcrumbItem = frFn((props, ref) => {
  const {
    "aria-current": ariaCurrent,
    children,
    className: customClassName = "",
    href,
    isCurrentPage,
    ...rest
  } = props;
  const prefix = usePrefix();
  const className = (0, import_classnames8.default)({
    [`${prefix}--breadcrumb-item`]: true,
    // We set the current class only if `isCurrentPage` is passed in and we do
    // not have an `aria-current="page"` set for the breadcrumb item
    [`${prefix}--breadcrumb-item--current`]: isCurrentPage && ariaCurrent !== "page",
    [customClassName]: !!customClassName
  });
  const child = children;
  if (child.type && child.type.displayName !== void 0 && child.type.displayName.includes("OverflowMenu")) {
    const horizontalOverflowIcon = import_react18.default.createElement(OverflowMenuHorizontal, {
      className: `${prefix}--overflow-menu__icon`
    });
    return import_react18.default.createElement("li", _extends({
      className
    }, rest), import_react18.default.cloneElement(child, {
      menuOptionsClass: `${prefix}--breadcrumb-menu-options`,
      menuOffset: {
        top: 10,
        left: 59
      },
      renderIcon: () => horizontalOverflowIcon
    }));
  }
  if (typeof children === "string") {
    return import_react18.default.createElement("li", _extends({
      className,
      ref
    }, rest), href ? import_react18.default.createElement(Link, {
      href,
      "aria-current": ariaCurrent || isCurrentPage
    }, children) : import_react18.default.createElement(Text, {
      "aria-current": ariaCurrent || isCurrentPage,
      className: `${prefix}--link`
    }, children));
  }
  return import_react18.default.createElement("li", _extends({
    className,
    ref
  }, rest), import_react18.default.cloneElement(child, {
    "aria-current": ariaCurrent,
    className: (0, import_classnames8.default)(`${prefix}--link`, child.props.className)
  }));
});
BreadcrumbItem.displayName = "BreadcrumbItem";
BreadcrumbItem.propTypes = {
  "aria-current": import_prop_types10.default.oneOfType([import_prop_types10.default.bool, import_prop_types10.default.oneOf(["false", "true", "page", "step", "location", "date", "time"])]),
  /**
   * Pass in content that will be inside of the BreadcrumbItem
   */
  children: import_prop_types10.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types10.default.string,
  /**
   * Optional string representing the link location for the BreadcrumbItem
   */
  href: import_prop_types10.default.string,
  /**
   * Provide if this breadcrumb item represents the current page
   */
  isCurrentPage: import_prop_types10.default.bool
};

// node_modules/@carbon/react/es/components/Breadcrumb/Breadcrumb.Skeleton.js
var import_prop_types11 = __toESM(require_prop_types());
var import_react19 = __toESM(require_react());
var import_classnames9 = __toESM(require_classnames());
var _Item;
var _Item2;
var _Item3;
function Item() {
  const prefix = usePrefix();
  return import_react19.default.createElement("div", {
    className: `${prefix}--breadcrumb-item`
  }, import_react19.default.createElement("span", {
    className: `${prefix}--link`
  }, " "));
}
function BreadcrumbSkeleton({
  className,
  ...rest
}) {
  const prefix = usePrefix();
  const classes = (0, import_classnames9.default)(`${prefix}--breadcrumb`, `${prefix}--skeleton`, className);
  return import_react19.default.createElement("div", _extends({
    className: classes
  }, rest), _Item || (_Item = import_react19.default.createElement(Item, null)), _Item2 || (_Item2 = import_react19.default.createElement(Item, null)), _Item3 || (_Item3 = import_react19.default.createElement(Item, null)));
}
BreadcrumbSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types11.default.string
};

// node_modules/@carbon/react/es/components/Button/Button.js
var import_prop_types18 = __toESM(require_prop_types());
var import_react34 = __toESM(require_react());

// node_modules/@carbon/react/es/components/IconButton/index.js
var import_prop_types17 = __toESM(require_prop_types());
var import_react33 = __toESM(require_react());
var import_classnames15 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Tooltip/DefinitionTooltip.js
var import_classnames11 = __toESM(require_classnames());
var import_prop_types14 = __toESM(require_prop_types());
var import_react27 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Popover/index.js
var import_classnames10 = __toESM(require_classnames());
var import_prop_types13 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/prop-types/deprecateValuesWithin.js
var didWarnAboutDeprecation = {};
function deprecateValuesWithin(propType, allowedValues, propMappingFunction2) {
  return function checker(props, propName, componentName, ...rest) {
    if (props[propName] === void 0) {
      return;
    }
    if (!didWarnAboutDeprecation[componentName] || !didWarnAboutDeprecation[componentName][propName]) {
      didWarnAboutDeprecation[componentName] = {
        ...didWarnAboutDeprecation[componentName],
        [propName]: true
      };
      const deprecatedValue = props[propName];
      const newValue = propMappingFunction2 ? propMappingFunction2(deprecatedValue) : null;
      if (allowedValues && !allowedValues.includes(deprecatedValue)) {
        const message = propMappingFunction2 ? `"${deprecatedValue}" is a deprecated value for the "${propName}" prop on the "${componentName}" component. Use "${newValue}" instead. "${deprecatedValue}" will be removed in the next major release.` : `"${deprecatedValue}" is a deprecated value for the "${propName}" prop on the "${componentName}" component. Allowed values is/are: ${allowedValues.join(", ")}.  "${deprecatedValue}" will be removed in the next major release. `;
        true ? warning(false, message) : void 0;
      }
    }
    return propType(props, propName, componentName, ...rest);
  };
}

// node_modules/@carbon/react/es/components/Popover/index.js
var import_react25 = __toESM(require_react());

// node_modules/@carbon/react/es/internal/useMergedRefs.js
var import_react20 = __toESM(require_react());
var useMergedRefs = (refs) => {
  const memoizedRefs = (0, import_react20.useMemo)(() => refs, refs);
  return (0, import_react20.useCallback)((node) => {
    memoizedRefs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  }, [memoizedRefs]);
};

// node_modules/@carbon/react/es/internal/useEvent.js
var import_react21 = __toESM(require_react());
var useEvent = (elementOrRef, eventName, callback) => {
  const savedCallback = (0, import_react21.useRef)(null);
  (0, import_react21.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react21.useEffect)(() => {
    const element = "current" in elementOrRef ? elementOrRef.current : elementOrRef;
    if (!element) return;
    const handler = (event) => {
      if (savedCallback.current) {
        savedCallback.current(event);
      }
    };
    element.addEventListener(eventName, handler);
    return () => {
      element.removeEventListener(eventName, handler);
    };
  }, [elementOrRef, eventName]);
};
var useWindowEvent = (eventName, callback) => {
  const savedCallback = (0, import_react21.useRef)(null);
  (0, import_react21.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react21.useEffect)(() => {
    const handler = (event) => {
      if (savedCallback.current) {
        savedCallback.current(event);
      }
    };
    window.addEventListener(eventName, handler);
    return () => {
      window.removeEventListener(eventName, handler);
    };
  }, [eventName]);
};

// node_modules/@carbon/react/es/tools/mapPopoverAlign.js
var popoverAlignMapping = {
  "top-left": "top-start",
  "top-right": "top-end",
  "bottom-left": "bottom-start",
  "bottom-right": "bottom-end",
  "left-bottom": "left-end",
  "left-top": "left-start",
  "right-bottom": "right-end",
  "right-top": "right-start"
};
var mapPopoverAlign = (align) => popoverAlignMapping[align] ?? align;

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var React19 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
var React17 = __toESM(require_react(), 1);
var import_react22 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches2 = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches2.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches2.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a, b2) {
  return a.tabIndex === b2.tabIndex ? a.documentOrder - b2.documentOrder : a.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r2 = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r2;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches2.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches2.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches2.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches2.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");

// node_modules/@floating-ui/react/dist/floating-ui.react.utils.mjs
function getPlatform() {
  const uaData = navigator.userAgentData;
  if (uaData != null && uaData.platform) {
    return uaData.platform;
  }
  return navigator.platform;
}
function getUserAgent() {
  const uaData = navigator.userAgentData;
  if (uaData && Array.isArray(uaData.brands)) {
    return uaData.brands.map((_ref) => {
      let {
        brand,
        version
      } = _ref;
      return brand + "/" + version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isSafari() {
  return /apple/i.test(navigator.vendor);
}
function isAndroid() {
  const re = /android/i;
  return re.test(getPlatform()) || re.test(getUserAgent());
}
function isJSDOM() {
  return getUserAgent().includes("jsdom/");
}
var FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
var TYPEABLE_SELECTOR = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
function activeElement(doc) {
  let activeElement2 = doc.activeElement;
  while (((_activeElement = activeElement2) == null || (_activeElement = _activeElement.shadowRoot) == null ? void 0 : _activeElement.activeElement) != null) {
    var _activeElement;
    activeElement2 = activeElement2.shadowRoot.activeElement;
  }
  return activeElement2;
}
function contains(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getTarget(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function getDocument(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
function isTypeableElement(element) {
  return isHTMLElement(element) && element.matches(TYPEABLE_SELECTOR);
}
function isTypeableCombobox(element) {
  if (!element) return false;
  return element.getAttribute("role") === "combobox" && isTypeableElement(element);
}
function getFloatingFocusElement(floatingElement) {
  if (!floatingElement) {
    return null;
  }
  return floatingElement.hasAttribute(FOCUSABLE_ATTRIBUTE) ? floatingElement : floatingElement.querySelector("[" + FOCUSABLE_ATTRIBUTE + "]") || floatingElement;
}
function getNodeChildren(nodes, id, onlyOpenChildren) {
  if (onlyOpenChildren === void 0) {
    onlyOpenChildren = true;
  }
  const directChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));
  });
  return directChildren.flatMap((child) => [child, ...getNodeChildren(nodes, child.id, onlyOpenChildren)]);
}
function getNodeAncestors(nodes, id) {
  var _nodes$find;
  let allAncestors = [];
  let currentParentId = (_nodes$find = nodes.find((node) => node.id === id)) == null ? void 0 : _nodes$find.parentId;
  while (currentParentId) {
    const currentNode = nodes.find((node) => node.id === currentParentId);
    currentParentId = currentNode == null ? void 0 : currentNode.parentId;
    if (currentNode) {
      allAncestors = allAncestors.concat(currentNode);
    }
  }
  return allAncestors;
}
function stopEvent(event) {
  event.preventDefault();
  event.stopPropagation();
}
function isVirtualClick(event) {
  if (event.mozInputSource === 0 && event.isTrusted) {
    return true;
  }
  if (isAndroid() && event.pointerType) {
    return event.type === "click" && event.buttons === 1;
  }
  return event.detail === 0 && !event.pointerType;
}
function isVirtualPointerEvent(event) {
  if (isJSDOM()) return false;
  return !isAndroid() && event.width === 0 && event.height === 0 || isAndroid() && event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  event.width < 1 && event.height < 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === "touch";
}
function isMouseLikePointerType(pointerType, strict) {
  const values = ["mouse", "pen"];
  if (!strict) {
    values.push("", void 0);
  }
  return values.includes(pointerType);
}
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? import_react22.useLayoutEffect : noop;
var SafeReact = {
  ...React17
};
function useLatestRef(value) {
  const ref = React17.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
var useInsertionEffect = SafeReact.useInsertionEffect;
var useSafeInsertionEffect = useInsertionEffect || ((fn) => fn());
function useEffectEvent(callback) {
  const ref = React17.useRef(() => {
    if (true) {
      throw new Error("Cannot call an event handler while rendering.");
    }
  });
  useSafeInsertionEffect(() => {
    ref.current = callback;
  });
  return React17.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref.current == null ? void 0 : ref.current(...args);
  }, []);
}
function isDifferentGridRow(index3, cols, prevRow) {
  return Math.floor(index3 / cols) !== prevRow;
}
function isIndexOutOfListBounds(listRef, index3) {
  return index3 < 0 || index3 >= listRef.current.length;
}
function getMinListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    disabledIndices
  });
}
function getMaxListIndex(listRef, disabledIndices) {
  return findNonDisabledListIndex(listRef, {
    decrement: true,
    startingIndex: listRef.current.length,
    disabledIndices
  });
}
function findNonDisabledListIndex(listRef, _temp) {
  let {
    startingIndex = -1,
    decrement = false,
    disabledIndices,
    amount = 1
  } = _temp === void 0 ? {} : _temp;
  let index3 = startingIndex;
  do {
    index3 += decrement ? -amount : amount;
  } while (index3 >= 0 && index3 <= listRef.current.length - 1 && isListIndexDisabled(listRef, index3, disabledIndices));
  return index3;
}
function getGridNavigatedIndex(listRef, _ref) {
  let {
    event,
    orientation,
    loop,
    rtl,
    cols,
    disabledIndices,
    minIndex,
    maxIndex,
    prevIndex,
    stopEvent: stop = false
  } = _ref;
  let nextIndex = prevIndex;
  if (event.key === ARROW_UP) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = maxIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: nextIndex,
        amount: cols,
        decrement: true,
        disabledIndices
      });
      if (loop && (prevIndex - cols < minIndex || nextIndex < 0)) {
        const col = prevIndex % cols;
        const maxCol = maxIndex % cols;
        const offset4 = maxIndex - (maxCol - col);
        if (maxCol === col) {
          nextIndex = maxIndex;
        } else {
          nextIndex = maxCol > col ? offset4 : offset4 - cols;
        }
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (event.key === ARROW_DOWN) {
    stop && stopEvent(event);
    if (prevIndex === -1) {
      nextIndex = minIndex;
    } else {
      nextIndex = findNonDisabledListIndex(listRef, {
        startingIndex: prevIndex,
        amount: cols,
        disabledIndices
      });
      if (loop && prevIndex + cols > maxIndex) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex % cols - cols,
          amount: cols,
          disabledIndices
        });
      }
    }
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      nextIndex = prevIndex;
    }
  }
  if (orientation === "both") {
    const prevRow = floor(prevIndex / cols);
    if (event.key === (rtl ? ARROW_LEFT : ARROW_RIGHT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== cols - 1) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex - prevIndex % cols - 1,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    if (event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT)) {
      stop && stopEvent(event);
      if (prevIndex % cols !== 0) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex,
          decrement: true,
          disabledIndices
        });
        if (loop && isDifferentGridRow(nextIndex, cols, prevRow)) {
          nextIndex = findNonDisabledListIndex(listRef, {
            startingIndex: prevIndex + (cols - prevIndex % cols),
            decrement: true,
            disabledIndices
          });
        }
      } else if (loop) {
        nextIndex = findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex + (cols - prevIndex % cols),
          decrement: true,
          disabledIndices
        });
      }
      if (isDifferentGridRow(nextIndex, cols, prevRow)) {
        nextIndex = prevIndex;
      }
    }
    const lastRow = floor(maxIndex / cols) === prevRow;
    if (isIndexOutOfListBounds(listRef, nextIndex)) {
      if (loop && lastRow) {
        nextIndex = event.key === (rtl ? ARROW_RIGHT : ARROW_LEFT) ? maxIndex : findNonDisabledListIndex(listRef, {
          startingIndex: prevIndex - prevIndex % cols - 1,
          disabledIndices
        });
      } else {
        nextIndex = prevIndex;
      }
    }
  }
  return nextIndex;
}
function createGridCellMap(sizes2, cols, dense) {
  const cellMap = [];
  let startIndex = 0;
  sizes2.forEach((_ref2, index3) => {
    let {
      width,
      height
    } = _ref2;
    if (width > cols) {
      if (true) {
        throw new Error("[Floating UI]: Invalid grid - item width at index " + index3 + " is greater than grid columns");
      }
    }
    let itemPlaced = false;
    if (dense) {
      startIndex = 0;
    }
    while (!itemPlaced) {
      const targetCells = [];
      for (let i = 0; i < width; i++) {
        for (let j = 0; j < height; j++) {
          targetCells.push(startIndex + i + j * cols);
        }
      }
      if (startIndex % cols + width <= cols && targetCells.every((cell) => cellMap[cell] == null)) {
        targetCells.forEach((cell) => {
          cellMap[cell] = index3;
        });
        itemPlaced = true;
      } else {
        startIndex++;
      }
    }
  });
  return [...cellMap];
}
function getGridCellIndexOfCorner(index3, sizes2, cellMap, cols, corner) {
  if (index3 === -1) return -1;
  const firstCellIndex = cellMap.indexOf(index3);
  const sizeItem = sizes2[index3];
  switch (corner) {
    case "tl":
      return firstCellIndex;
    case "tr":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + sizeItem.width - 1;
    case "bl":
      if (!sizeItem) {
        return firstCellIndex;
      }
      return firstCellIndex + (sizeItem.height - 1) * cols;
    case "br":
      return cellMap.lastIndexOf(index3);
  }
}
function getGridCellIndices(indices, cellMap) {
  return cellMap.flatMap((index3, cellIndex) => indices.includes(index3) ? [cellIndex] : []);
}
function isListIndexDisabled(listRef, index3, disabledIndices) {
  if (typeof disabledIndices === "function") {
    return disabledIndices(index3);
  } else if (disabledIndices) {
    return disabledIndices.includes(index3);
  }
  const element = listRef.current[index3];
  return element == null || element.hasAttribute("disabled") || element.getAttribute("aria-disabled") === "true";
}
var getTabbableOptions = () => ({
  getShadowRoot: true,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver === "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function getTabbableIn(container, dir) {
  const list = tabbable(container, getTabbableOptions());
  const len = list.length;
  if (len === 0) return;
  const active = activeElement(getDocument(container));
  const index3 = list.indexOf(active);
  const nextIndex = index3 === -1 ? dir === 1 ? 0 : len - 1 : index3 + dir;
  return list[nextIndex];
}
function getNextTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, 1) || referenceElement;
}
function getPreviousTabbable(referenceElement) {
  return getTabbableIn(getDocument(referenceElement).body, -1) || referenceElement;
}
function isOutsideEvent(event, container) {
  const containerElement = container || event.currentTarget;
  const relatedTarget = event.relatedTarget;
  return !relatedTarget || !contains(containerElement, relatedTarget);
}

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var ReactDOM2 = __toESM(require_react_dom(), 1);

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b2) => a.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b2) => a[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b2) {
  return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup2() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup2();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup2;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React18 = __toESM(require_react(), 1);
var import_react23 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var isClient2 = typeof document !== "undefined";
var noop3 = function noop4() {
};
var index2 = isClient2 ? import_react23.useLayoutEffect : noop3;
function deepEqual(a, b2) {
  if (a === b2) {
    return true;
  }
  if (typeof a !== typeof b2) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b2 && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b2.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef2(value) {
  const ref = React18.useRef(value);
  index2(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open: open2
  } = options;
  const [data, setData] = React18.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React18.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React18.useState(null);
  const [_floating, _setFloating] = React18.useState(null);
  const setReference = React18.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React18.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React18.useRef(null);
  const floatingRef = React18.useRef(null);
  const dataRef = React18.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef2(whileElementsMounted);
  const platformRef = useLatestRef2(platform2);
  const openRef = useLatestRef2(open2);
  const update = React18.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index2(() => {
    if (open2 === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open2]);
  const isMountedRef = React18.useRef(false);
  index2(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index2(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React18.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React18.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React18.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React18.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@floating-ui/react/dist/floating-ui.react.mjs
function useMergeRefs(refs) {
  const cleanupRef = React19.useRef(void 0);
  const refEffect = React19.useCallback((instance) => {
    const cleanups = refs.map((ref) => {
      if (ref == null) {
        return;
      }
      if (typeof ref === "function") {
        const refCallback = ref;
        const refCleanup = refCallback(instance);
        return typeof refCleanup === "function" ? refCleanup : () => {
          refCallback(null);
        };
      }
      ref.current = instance;
      return () => {
        ref.current = null;
      };
    });
    return () => {
      cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
    };
  }, refs);
  return React19.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (value) => {
      if (cleanupRef.current) {
        cleanupRef.current();
        cleanupRef.current = void 0;
      }
      if (value != null) {
        cleanupRef.current = refEffect(value);
      }
    };
  }, refs);
}
function sortByDocumentPosition(a, b2) {
  const position = a.compareDocumentPosition(b2);
  if (position & Node.DOCUMENT_POSITION_FOLLOWING || position & Node.DOCUMENT_POSITION_CONTAINED_BY) {
    return -1;
  }
  if (position & Node.DOCUMENT_POSITION_PRECEDING || position & Node.DOCUMENT_POSITION_CONTAINS) {
    return 1;
  }
  return 0;
}
var FloatingListContext = React19.createContext({
  register: () => {
  },
  unregister: () => {
  },
  map: /* @__PURE__ */ new Map(),
  elementsRef: {
    current: []
  }
});
function FloatingList(props) {
  const {
    children,
    elementsRef,
    labelsRef
  } = props;
  const [nodes, setNodes] = React19.useState(() => /* @__PURE__ */ new Set());
  const register = React19.useCallback((node) => {
    setNodes((prevSet) => new Set(prevSet).add(node));
  }, []);
  const unregister = React19.useCallback((node) => {
    setNodes((prevSet) => {
      const set = new Set(prevSet);
      set.delete(node);
      return set;
    });
  }, []);
  const map = React19.useMemo(() => {
    const newMap = /* @__PURE__ */ new Map();
    const sortedNodes = Array.from(nodes.keys()).sort(sortByDocumentPosition);
    sortedNodes.forEach((node, index3) => {
      newMap.set(node, index3);
    });
    return newMap;
  }, [nodes]);
  return (0, import_jsx_runtime.jsx)(FloatingListContext.Provider, {
    value: React19.useMemo(() => ({
      register,
      unregister,
      map,
      elementsRef,
      labelsRef
    }), [register, unregister, map, elementsRef, labelsRef]),
    children
  });
}
function useListItem(props) {
  if (props === void 0) {
    props = {};
  }
  const {
    label
  } = props;
  const {
    register,
    unregister,
    map,
    elementsRef,
    labelsRef
  } = React19.useContext(FloatingListContext);
  const [index3, setIndex] = React19.useState(null);
  const componentRef = React19.useRef(null);
  const ref = React19.useCallback((node) => {
    componentRef.current = node;
    if (index3 !== null) {
      elementsRef.current[index3] = node;
      if (labelsRef) {
        var _node$textContent;
        const isLabelDefined = label !== void 0;
        labelsRef.current[index3] = isLabelDefined ? label : (_node$textContent = node == null ? void 0 : node.textContent) != null ? _node$textContent : null;
      }
    }
  }, [index3, elementsRef, labelsRef, label]);
  index(() => {
    const node = componentRef.current;
    if (node) {
      register(node);
      return () => {
        unregister(node);
      };
    }
  }, [register, unregister]);
  index(() => {
    const index4 = componentRef.current ? map.get(componentRef.current) : null;
    if (index4 != null) {
      setIndex(index4);
    }
  }, [map]);
  return React19.useMemo(() => ({
    ref,
    index: index3 == null ? -1 : index3
  }), [index3, ref]);
}
var FOCUSABLE_ATTRIBUTE2 = "data-floating-ui-focusable";
var ACTIVE_KEY = "active";
var SELECTED_KEY = "selected";
var ARROW_LEFT2 = "ArrowLeft";
var ARROW_RIGHT2 = "ArrowRight";
var ARROW_UP2 = "ArrowUp";
var ARROW_DOWN2 = "ArrowDown";
function renderJsx(render, computedProps) {
  if (typeof render === "function") {
    return render(computedProps);
  }
  if (render) {
    return React19.cloneElement(render, computedProps);
  }
  return (0, import_jsx_runtime.jsx)("div", {
    ...computedProps
  });
}
var CompositeContext = React19.createContext({
  activeIndex: 0,
  onNavigate: () => {
  }
});
var horizontalKeys = [ARROW_LEFT2, ARROW_RIGHT2];
var verticalKeys = [ARROW_UP2, ARROW_DOWN2];
var allKeys = [...horizontalKeys, ...verticalKeys];
var Composite = React19.forwardRef(function Composite2(props, forwardedRef) {
  const {
    render,
    orientation = "both",
    loop = true,
    rtl = false,
    cols = 1,
    disabledIndices,
    activeIndex: externalActiveIndex,
    onNavigate: externalSetActiveIndex,
    itemSizes,
    dense = false,
    ...domProps
  } = props;
  const [internalActiveIndex, internalSetActiveIndex] = React19.useState(0);
  const activeIndex = externalActiveIndex != null ? externalActiveIndex : internalActiveIndex;
  const onNavigate = useEffectEvent(externalSetActiveIndex != null ? externalSetActiveIndex : internalSetActiveIndex);
  const elementsRef = React19.useRef([]);
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const contextValue = React19.useMemo(() => ({
    activeIndex,
    onNavigate
  }), [activeIndex, onNavigate]);
  const isGrid = cols > 1;
  function handleKeyDown(event) {
    if (!allKeys.includes(event.key)) return;
    let nextIndex = activeIndex;
    const minIndex = getMinListIndex(elementsRef, disabledIndices);
    const maxIndex = getMaxListIndex(elementsRef, disabledIndices);
    const horizontalEndKey = rtl ? ARROW_LEFT2 : ARROW_RIGHT2;
    const horizontalStartKey = rtl ? ARROW_RIGHT2 : ARROW_LEFT2;
    if (isGrid) {
      const sizes2 = itemSizes || Array.from({
        length: elementsRef.current.length
      }, () => ({
        width: 1,
        height: 1
      }));
      const cellMap = createGridCellMap(sizes2, cols, dense);
      const minGridIndex = cellMap.findIndex((index3) => index3 != null && !isListIndexDisabled(elementsRef, index3, disabledIndices));
      const maxGridIndex = cellMap.reduce((foundIndex, index3, cellIndex) => index3 != null && !isListIndexDisabled(elementsRef, index3, disabledIndices) ? cellIndex : foundIndex, -1);
      const maybeNextIndex = cellMap[getGridNavigatedIndex({
        current: cellMap.map((itemIndex) => itemIndex ? elementsRef.current[itemIndex] : null)
      }, {
        event,
        orientation,
        loop,
        rtl,
        cols,
        // treat undefined (empty grid spaces) as disabled indices so we
        // don't end up in them
        disabledIndices: getGridCellIndices([...(typeof disabledIndices !== "function" ? disabledIndices : null) || elementsRef.current.map((_, index3) => isListIndexDisabled(elementsRef, index3, disabledIndices) ? index3 : void 0), void 0], cellMap),
        minIndex: minGridIndex,
        maxIndex: maxGridIndex,
        prevIndex: getGridCellIndexOfCorner(
          activeIndex > maxIndex ? minIndex : activeIndex,
          sizes2,
          cellMap,
          cols,
          // use a corner matching the edge closest to the direction we're
          // moving in so we don't end up in the same item. Prefer
          // top/left over bottom/right.
          event.key === ARROW_DOWN2 ? "bl" : event.key === horizontalEndKey ? "tr" : "tl"
        )
      })];
      if (maybeNextIndex != null) {
        nextIndex = maybeNextIndex;
      }
    }
    const toEndKeys = {
      horizontal: [horizontalEndKey],
      vertical: [ARROW_DOWN2],
      both: [horizontalEndKey, ARROW_DOWN2]
    }[orientation];
    const toStartKeys = {
      horizontal: [horizontalStartKey],
      vertical: [ARROW_UP2],
      both: [horizontalStartKey, ARROW_UP2]
    }[orientation];
    const preventedKeys = isGrid ? allKeys : {
      horizontal: horizontalKeys,
      vertical: verticalKeys,
      both: allKeys
    }[orientation];
    if (nextIndex === activeIndex && [...toEndKeys, ...toStartKeys].includes(event.key)) {
      if (loop && nextIndex === maxIndex && toEndKeys.includes(event.key)) {
        nextIndex = minIndex;
      } else if (loop && nextIndex === minIndex && toStartKeys.includes(event.key)) {
        nextIndex = maxIndex;
      } else {
        nextIndex = findNonDisabledListIndex(elementsRef, {
          startingIndex: nextIndex,
          decrement: toStartKeys.includes(event.key),
          disabledIndices
        });
      }
    }
    if (nextIndex !== activeIndex && !isIndexOutOfListBounds(elementsRef, nextIndex)) {
      var _elementsRef$current$;
      event.stopPropagation();
      if (preventedKeys.includes(event.key)) {
        event.preventDefault();
      }
      onNavigate(nextIndex);
      (_elementsRef$current$ = elementsRef.current[nextIndex]) == null || _elementsRef$current$.focus();
    }
  }
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: forwardedRef,
    "aria-orientation": orientation === "both" ? void 0 : orientation,
    onKeyDown(e2) {
      domProps.onKeyDown == null || domProps.onKeyDown(e2);
      renderElementProps.onKeyDown == null || renderElementProps.onKeyDown(e2);
      handleKeyDown(e2);
    }
  };
  return (0, import_jsx_runtime.jsx)(CompositeContext.Provider, {
    value: contextValue,
    children: (0, import_jsx_runtime.jsx)(FloatingList, {
      elementsRef,
      children: renderJsx(render, computedProps)
    })
  });
});
var CompositeItem = React19.forwardRef(function CompositeItem2(props, forwardedRef) {
  const {
    render,
    ...domProps
  } = props;
  const renderElementProps = render && typeof render !== "function" ? render.props : {};
  const {
    activeIndex,
    onNavigate
  } = React19.useContext(CompositeContext);
  const {
    ref,
    index: index3
  } = useListItem();
  const mergedRef = useMergeRefs([ref, forwardedRef, renderElementProps.ref]);
  const isActive = activeIndex === index3;
  const computedProps = {
    ...domProps,
    ...renderElementProps,
    ref: mergedRef,
    tabIndex: isActive ? 0 : -1,
    "data-active": isActive ? "" : void 0,
    onFocus(e2) {
      domProps.onFocus == null || domProps.onFocus(e2);
      renderElementProps.onFocus == null || renderElementProps.onFocus(e2);
      onNavigate(index3);
    }
  };
  return renderJsx(render, computedProps);
});
var SafeReact2 = {
  ...React19
};
var serverHandoffComplete = false;
var count = 0;
var genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [id, setId] = React19.useState(() => serverHandoffComplete ? genId() : void 0);
  index(() => {
    if (id == null) {
      setId(genId());
    }
  }, []);
  React19.useEffect(() => {
    serverHandoffComplete = true;
  }, []);
  return id;
}
var useReactId2 = SafeReact2.useId;
var useId2 = useReactId2 || useFloatingId;
var devMessageSet;
if (true) {
  devMessageSet = /* @__PURE__ */ new Set();
}
function warn() {
  var _devMessageSet;
  for (var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++) {
    messages[_key] = arguments[_key];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet = devMessageSet) != null && _devMessageSet.has(message))) {
    var _devMessageSet2;
    (_devMessageSet2 = devMessageSet) == null || _devMessageSet2.add(message);
    console.warn(message);
  }
}
function error() {
  var _devMessageSet3;
  for (var _len2 = arguments.length, messages = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    messages[_key2] = arguments[_key2];
  }
  const message = "Floating UI: " + messages.join(" ");
  if (!((_devMessageSet3 = devMessageSet) != null && _devMessageSet3.has(message))) {
    var _devMessageSet4;
    (_devMessageSet4 = devMessageSet) == null || _devMessageSet4.add(message);
    console.error(message);
  }
}
var FloatingArrow = React19.forwardRef(function FloatingArrow2(props, ref) {
  const {
    context: {
      placement,
      elements: {
        floating
      },
      middlewareData: {
        arrow: arrow4,
        shift: shift4
      }
    },
    width = 14,
    height = 7,
    tipRadius = 0,
    strokeWidth = 0,
    staticOffset,
    stroke,
    d,
    style: {
      transform,
      ...restStyle
    } = {},
    ...rest
  } = props;
  if (true) {
    if (!ref) {
      warn("The `ref` prop is required for `FloatingArrow`.");
    }
  }
  const clipPathId = useId2();
  const [isRTL2, setIsRTL] = React19.useState(false);
  index(() => {
    if (!floating) return;
    const isRTL3 = getComputedStyle2(floating).direction === "rtl";
    if (isRTL3) {
      setIsRTL(true);
    }
  }, [floating]);
  if (!floating) {
    return null;
  }
  const [side, alignment] = placement.split("-");
  const isVerticalSide = side === "top" || side === "bottom";
  let computedStaticOffset = staticOffset;
  if (isVerticalSide && shift4 != null && shift4.x || !isVerticalSide && shift4 != null && shift4.y) {
    computedStaticOffset = null;
  }
  const computedStrokeWidth = strokeWidth * 2;
  const halfStrokeWidth = computedStrokeWidth / 2;
  const svgX = width / 2 * (tipRadius / -8 + 1);
  const svgY = height / 2 * tipRadius / 4;
  const isCustomShape = !!d;
  const yOffsetProp = computedStaticOffset && alignment === "end" ? "bottom" : "top";
  let xOffsetProp = computedStaticOffset && alignment === "end" ? "right" : "left";
  if (computedStaticOffset && isRTL2) {
    xOffsetProp = alignment === "end" ? "left" : "right";
  }
  const arrowX = (arrow4 == null ? void 0 : arrow4.x) != null ? computedStaticOffset || arrow4.x : "";
  const arrowY = (arrow4 == null ? void 0 : arrow4.y) != null ? computedStaticOffset || arrow4.y : "";
  const dValue = d || "M0,0" + (" H" + width) + (" L" + (width - svgX) + "," + (height - svgY)) + (" Q" + width / 2 + "," + height + " " + svgX + "," + (height - svgY)) + " Z";
  const rotation = {
    top: isCustomShape ? "rotate(180deg)" : "",
    left: isCustomShape ? "rotate(90deg)" : "rotate(-90deg)",
    bottom: isCustomShape ? "" : "rotate(180deg)",
    right: isCustomShape ? "rotate(-90deg)" : "rotate(90deg)"
  }[side];
  return (0, import_jsx_runtime.jsxs)("svg", {
    ...rest,
    "aria-hidden": true,
    ref,
    width: isCustomShape ? width : width + computedStrokeWidth,
    height: width,
    viewBox: "0 0 " + width + " " + (height > width ? height : width),
    style: {
      position: "absolute",
      pointerEvents: "none",
      [xOffsetProp]: arrowX,
      [yOffsetProp]: arrowY,
      [side]: isVerticalSide || isCustomShape ? "100%" : "calc(100% - " + computedStrokeWidth / 2 + "px)",
      transform: [rotation, transform].filter((t3) => !!t3).join(" "),
      ...restStyle
    },
    children: [computedStrokeWidth > 0 && (0, import_jsx_runtime.jsx)("path", {
      clipPath: "url(#" + clipPathId + ")",
      fill: "none",
      stroke,
      strokeWidth: computedStrokeWidth + (d ? 0 : 1),
      d: dValue
    }), (0, import_jsx_runtime.jsx)("path", {
      stroke: computedStrokeWidth && !d ? rest.fill : "none",
      d: dValue
    }), (0, import_jsx_runtime.jsx)("clipPath", {
      id: clipPathId,
      children: (0, import_jsx_runtime.jsx)("rect", {
        x: -halfStrokeWidth,
        y: halfStrokeWidth * (isCustomShape ? -1 : 1),
        width: width + computedStrokeWidth,
        height: width
      })
    })]
  });
});
function createEventEmitter() {
  const map = /* @__PURE__ */ new Map();
  return {
    emit(event, data) {
      var _map$get;
      (_map$get = map.get(event)) == null || _map$get.forEach((listener) => listener(data));
    },
    on(event, listener) {
      if (!map.has(event)) {
        map.set(event, /* @__PURE__ */ new Set());
      }
      map.get(event).add(listener);
    },
    off(event, listener) {
      var _map$get2;
      (_map$get2 = map.get(event)) == null || _map$get2.delete(listener);
    }
  };
}
var FloatingNodeContext = React19.createContext(null);
var FloatingTreeContext = React19.createContext(null);
var useFloatingParentNodeId = () => {
  var _React$useContext;
  return ((_React$useContext = React19.useContext(FloatingNodeContext)) == null ? void 0 : _React$useContext.id) || null;
};
var useFloatingTree = () => React19.useContext(FloatingTreeContext);
function createAttribute(name) {
  return "data-floating-ui-" + name;
}
function clearTimeoutIfSet(timeoutRef) {
  if (timeoutRef.current !== -1) {
    clearTimeout(timeoutRef.current);
    timeoutRef.current = -1;
  }
}
var safePolygonIdentifier = createAttribute("safe-polygon");
function getDelay(value, prop, pointerType) {
  if (pointerType && !isMouseLikePointerType(pointerType)) {
    return 0;
  }
  if (typeof value === "number") {
    return value;
  }
  if (typeof value === "function") {
    const result = value();
    if (typeof result === "number") {
      return result;
    }
    return result == null ? void 0 : result[prop];
  }
  return value == null ? void 0 : value[prop];
}
function getRestMs(value) {
  if (typeof value === "function") {
    return value();
  }
  return value;
}
function useHover(context, props) {
  if (props === void 0) {
    props = {};
  }
  const {
    open: open2,
    onOpenChange,
    dataRef,
    events,
    elements
  } = context;
  const {
    enabled: enabled2 = true,
    delay = 0,
    handleClose = null,
    mouseOnly = false,
    restMs = 0,
    move = true
  } = props;
  const tree = useFloatingTree();
  const parentId = useFloatingParentNodeId();
  const handleCloseRef = useLatestRef(handleClose);
  const delayRef = useLatestRef(delay);
  const openRef = useLatestRef(open2);
  const restMsRef = useLatestRef(restMs);
  const pointerTypeRef = React19.useRef();
  const timeoutRef = React19.useRef(-1);
  const handlerRef = React19.useRef();
  const restTimeoutRef = React19.useRef(-1);
  const blockMouseMoveRef = React19.useRef(true);
  const performedPointerEventsMutationRef = React19.useRef(false);
  const unbindMouseMoveRef = React19.useRef(() => {
  });
  const restTimeoutPendingRef = React19.useRef(false);
  const isHoverOpen = useEffectEvent(() => {
    var _dataRef$current$open;
    const type = (_dataRef$current$open = dataRef.current.openEvent) == null ? void 0 : _dataRef$current$open.type;
    return (type == null ? void 0 : type.includes("mouse")) && type !== "mousedown";
  });
  React19.useEffect(() => {
    if (!enabled2) return;
    function onOpenChange2(_ref) {
      let {
        open: open3
      } = _ref;
      if (!open3) {
        clearTimeoutIfSet(timeoutRef);
        clearTimeoutIfSet(restTimeoutRef);
        blockMouseMoveRef.current = true;
        restTimeoutPendingRef.current = false;
      }
    }
    events.on("openchange", onOpenChange2);
    return () => {
      events.off("openchange", onOpenChange2);
    };
  }, [enabled2, events]);
  React19.useEffect(() => {
    if (!enabled2) return;
    if (!handleCloseRef.current) return;
    if (!open2) return;
    function onLeave(event) {
      if (isHoverOpen()) {
        onOpenChange(false, event, "hover");
      }
    }
    const html = getDocument(elements.floating).documentElement;
    html.addEventListener("mouseleave", onLeave);
    return () => {
      html.removeEventListener("mouseleave", onLeave);
    };
  }, [elements.floating, open2, onOpenChange, enabled2, handleCloseRef, isHoverOpen]);
  const closeWithDelay = React19.useCallback(function(event, runElseBranch, reason) {
    if (runElseBranch === void 0) {
      runElseBranch = true;
    }
    if (reason === void 0) {
      reason = "hover";
    }
    const closeDelay = getDelay(delayRef.current, "close", pointerTypeRef.current);
    if (closeDelay && !handlerRef.current) {
      clearTimeoutIfSet(timeoutRef);
      timeoutRef.current = window.setTimeout(() => onOpenChange(false, event, reason), closeDelay);
    } else if (runElseBranch) {
      clearTimeoutIfSet(timeoutRef);
      onOpenChange(false, event, reason);
    }
  }, [delayRef, onOpenChange]);
  const cleanupMouseMoveHandler = useEffectEvent(() => {
    unbindMouseMoveRef.current();
    handlerRef.current = void 0;
  });
  const clearPointerEvents = useEffectEvent(() => {
    if (performedPointerEventsMutationRef.current) {
      const body = getDocument(elements.floating).body;
      body.style.pointerEvents = "";
      body.removeAttribute(safePolygonIdentifier);
      performedPointerEventsMutationRef.current = false;
    }
  });
  const isClickLikeOpenEvent = useEffectEvent(() => {
    return dataRef.current.openEvent ? ["click", "mousedown"].includes(dataRef.current.openEvent.type) : false;
  });
  React19.useEffect(() => {
    if (!enabled2) return;
    function onReferenceMouseEnter(event) {
      clearTimeoutIfSet(timeoutRef);
      blockMouseMoveRef.current = false;
      if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current) || getRestMs(restMsRef.current) > 0 && !getDelay(delayRef.current, "open")) {
        return;
      }
      const openDelay = getDelay(delayRef.current, "open", pointerTypeRef.current);
      if (openDelay) {
        timeoutRef.current = window.setTimeout(() => {
          if (!openRef.current) {
            onOpenChange(true, event, "hover");
          }
        }, openDelay);
      } else if (!open2) {
        onOpenChange(true, event, "hover");
      }
    }
    function onReferenceMouseLeave(event) {
      if (isClickLikeOpenEvent()) {
        clearPointerEvents();
        return;
      }
      unbindMouseMoveRef.current();
      const doc = getDocument(elements.floating);
      clearTimeoutIfSet(restTimeoutRef);
      restTimeoutPendingRef.current = false;
      if (handleCloseRef.current && dataRef.current.floatingContext) {
        if (!open2) {
          clearTimeoutIfSet(timeoutRef);
        }
        handlerRef.current = handleCloseRef.current({
          ...dataRef.current.floatingContext,
          tree,
          x: event.clientX,
          y: event.clientY,
          onClose() {
            clearPointerEvents();
            cleanupMouseMoveHandler();
            if (!isClickLikeOpenEvent()) {
              closeWithDelay(event, true, "safe-polygon");
            }
          }
        });
        const handler = handlerRef.current;
        doc.addEventListener("mousemove", handler);
        unbindMouseMoveRef.current = () => {
          doc.removeEventListener("mousemove", handler);
        };
        return;
      }
      const shouldClose = pointerTypeRef.current === "touch" ? !contains(elements.floating, event.relatedTarget) : true;
      if (shouldClose) {
        closeWithDelay(event);
      }
    }
    function onScrollMouseLeave(event) {
      if (isClickLikeOpenEvent()) return;
      if (!dataRef.current.floatingContext) return;
      handleCloseRef.current == null || handleCloseRef.current({
        ...dataRef.current.floatingContext,
        tree,
        x: event.clientX,
        y: event.clientY,
        onClose() {
          clearPointerEvents();
          cleanupMouseMoveHandler();
          if (!isClickLikeOpenEvent()) {
            closeWithDelay(event);
          }
        }
      })(event);
    }
    function onFloatingMouseEnter() {
      clearTimeoutIfSet(timeoutRef);
    }
    function onFloatingMouseLeave(event) {
      if (!isClickLikeOpenEvent()) {
        closeWithDelay(event, false);
      }
    }
    if (isElement(elements.domReference)) {
      const reference2 = elements.domReference;
      const floating = elements.floating;
      if (open2) {
        reference2.addEventListener("mouseleave", onScrollMouseLeave);
      }
      if (move) {
        reference2.addEventListener("mousemove", onReferenceMouseEnter, {
          once: true
        });
      }
      reference2.addEventListener("mouseenter", onReferenceMouseEnter);
      reference2.addEventListener("mouseleave", onReferenceMouseLeave);
      if (floating) {
        floating.addEventListener("mouseleave", onScrollMouseLeave);
        floating.addEventListener("mouseenter", onFloatingMouseEnter);
        floating.addEventListener("mouseleave", onFloatingMouseLeave);
      }
      return () => {
        if (open2) {
          reference2.removeEventListener("mouseleave", onScrollMouseLeave);
        }
        if (move) {
          reference2.removeEventListener("mousemove", onReferenceMouseEnter);
        }
        reference2.removeEventListener("mouseenter", onReferenceMouseEnter);
        reference2.removeEventListener("mouseleave", onReferenceMouseLeave);
        if (floating) {
          floating.removeEventListener("mouseleave", onScrollMouseLeave);
          floating.removeEventListener("mouseenter", onFloatingMouseEnter);
          floating.removeEventListener("mouseleave", onFloatingMouseLeave);
        }
      };
    }
  }, [elements, enabled2, context, mouseOnly, move, closeWithDelay, cleanupMouseMoveHandler, clearPointerEvents, onOpenChange, open2, openRef, tree, delayRef, handleCloseRef, dataRef, isClickLikeOpenEvent, restMsRef]);
  index(() => {
    var _handleCloseRef$curre;
    if (!enabled2) return;
    if (open2 && (_handleCloseRef$curre = handleCloseRef.current) != null && (_handleCloseRef$curre = _handleCloseRef$curre.__options) != null && _handleCloseRef$curre.blockPointerEvents && isHoverOpen()) {
      performedPointerEventsMutationRef.current = true;
      const floatingEl = elements.floating;
      if (isElement(elements.domReference) && floatingEl) {
        var _tree$nodesRef$curren;
        const body = getDocument(elements.floating).body;
        body.setAttribute(safePolygonIdentifier, "");
        const ref = elements.domReference;
        const parentFloating = tree == null || (_tree$nodesRef$curren = tree.nodesRef.current.find((node) => node.id === parentId)) == null || (_tree$nodesRef$curren = _tree$nodesRef$curren.context) == null ? void 0 : _tree$nodesRef$curren.elements.floating;
        if (parentFloating) {
          parentFloating.style.pointerEvents = "";
        }
        body.style.pointerEvents = "none";
        ref.style.pointerEvents = "auto";
        floatingEl.style.pointerEvents = "auto";
        return () => {
          body.style.pointerEvents = "";
          ref.style.pointerEvents = "";
          floatingEl.style.pointerEvents = "";
        };
      }
    }
  }, [enabled2, open2, parentId, elements, tree, handleCloseRef, isHoverOpen]);
  index(() => {
    if (!open2) {
      pointerTypeRef.current = void 0;
      restTimeoutPendingRef.current = false;
      cleanupMouseMoveHandler();
      clearPointerEvents();
    }
  }, [open2, cleanupMouseMoveHandler, clearPointerEvents]);
  React19.useEffect(() => {
    return () => {
      cleanupMouseMoveHandler();
      clearTimeoutIfSet(timeoutRef);
      clearTimeoutIfSet(restTimeoutRef);
      clearPointerEvents();
    };
  }, [enabled2, elements.domReference, cleanupMouseMoveHandler, clearPointerEvents]);
  const reference = React19.useMemo(() => {
    function setPointerRef(event) {
      pointerTypeRef.current = event.pointerType;
    }
    return {
      onPointerDown: setPointerRef,
      onPointerEnter: setPointerRef,
      onMouseMove(event) {
        const {
          nativeEvent
        } = event;
        function handleMouseMove() {
          if (!blockMouseMoveRef.current && !openRef.current) {
            onOpenChange(true, nativeEvent, "hover");
          }
        }
        if (mouseOnly && !isMouseLikePointerType(pointerTypeRef.current)) {
          return;
        }
        if (open2 || getRestMs(restMsRef.current) === 0) {
          return;
        }
        if (restTimeoutPendingRef.current && event.movementX ** 2 + event.movementY ** 2 < 2) {
          return;
        }
        clearTimeoutIfSet(restTimeoutRef);
        if (pointerTypeRef.current === "touch") {
          handleMouseMove();
        } else {
          restTimeoutPendingRef.current = true;
          restTimeoutRef.current = window.setTimeout(handleMouseMove, getRestMs(restMsRef.current));
        }
      }
    };
  }, [mouseOnly, onOpenChange, open2, openRef, restMsRef]);
  return React19.useMemo(() => enabled2 ? {
    reference
  } : {}, [enabled2, reference]);
}
var NOOP = () => {
};
var FloatingDelayGroupContext = React19.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: NOOP,
  setState: NOOP,
  isInstantPhase: false
});
var NextFloatingDelayGroupContext = React19.createContext({
  hasProvider: false,
  timeoutMs: 0,
  delayRef: {
    current: 0
  },
  initialDelayRef: {
    current: 0
  },
  timeoutIdRef: {
    current: -1
  },
  currentIdRef: {
    current: null
  },
  currentContextRef: {
    current: null
  }
});
var rafId = 0;
function enqueueFocus(el, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    preventScroll = false,
    cancelPrevious = true,
    sync = false
  } = options;
  cancelPrevious && cancelAnimationFrame(rafId);
  const exec = () => el == null ? void 0 : el.focus({
    preventScroll
  });
  if (sync) {
    exec();
  } else {
    rafId = requestAnimationFrame(exec);
  }
}
function contains2(parent, child) {
  if (!parent || !child) {
    return false;
  }
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent.contains(child)) {
    return true;
  }
  if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    while (next) {
      if (parent === next) {
        return true;
      }
      next = next.parentNode || next.host;
    }
  }
  return false;
}
function getTarget2(event) {
  if ("composedPath" in event) {
    return event.composedPath()[0];
  }
  return event.target;
}
function getDocument2(node) {
  return (node == null ? void 0 : node.ownerDocument) || document;
}
var counters = {
  inert: /* @__PURE__ */ new WeakMap(),
  "aria-hidden": /* @__PURE__ */ new WeakMap(),
  none: /* @__PURE__ */ new WeakMap()
};
function getCounterMap(control) {
  if (control === "inert") return counters.inert;
  if (control === "aria-hidden") return counters["aria-hidden"];
  return counters.none;
}
var uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
var markerMap = {};
var lockCount$1 = 0;
var supportsInert = () => typeof HTMLElement !== "undefined" && "inert" in HTMLElement.prototype;
var unwrapHost = (node) => node && (node.host || unwrapHost(node.parentNode));
var correctElements = (parent, targets) => targets.map((target) => {
  if (parent.contains(target)) {
    return target;
  }
  const correctedTarget = unwrapHost(target);
  if (parent.contains(correctedTarget)) {
    return correctedTarget;
  }
  return null;
}).filter((x) => x != null);
function applyAttributeToOthers(uncorrectedAvoidElements, body, ariaHidden, inert) {
  const markerName = "data-floating-ui-inert";
  const controlAttribute = inert ? "inert" : ariaHidden ? "aria-hidden" : null;
  const avoidElements = correctElements(body, uncorrectedAvoidElements);
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(avoidElements);
  const hiddenElements = [];
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  avoidElements.forEach(keep);
  deep(body);
  elementsToKeep.clear();
  function keep(el) {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    el.parentNode && keep(el.parentNode);
  }
  function deep(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    [].forEach.call(parent.children, (node) => {
      if (getNodeName(node) === "script") return;
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr2 = controlAttribute ? node.getAttribute(controlAttribute) : null;
        const alreadyHidden = attr2 !== null && attr2 !== "false";
        const counterMap = getCounterMap(controlAttribute);
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenElements.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledElementsSet.add(node);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "");
        }
        if (!alreadyHidden && controlAttribute) {
          node.setAttribute(controlAttribute, controlAttribute === "inert" ? "" : "true");
        }
      }
    });
  }
  lockCount$1++;
  return () => {
    hiddenElements.forEach((element) => {
      const counterMap = getCounterMap(controlAttribute);
      const currentCounterValue = counterMap.get(element) || 0;
      const counterValue = currentCounterValue - 1;
      const markerValue = (markerCounter.get(element) || 0) - 1;
      counterMap.set(element, counterValue);
      markerCounter.set(element, markerValue);
      if (!counterValue) {
        if (!uncontrolledElementsSet.has(element) && controlAttribute) {
          element.removeAttribute(controlAttribute);
        }
        uncontrolledElementsSet.delete(element);
      }
      if (!markerValue) {
        element.removeAttribute(markerName);
      }
    });
    lockCount$1--;
    if (!lockCount$1) {
      counters.inert = /* @__PURE__ */ new WeakMap();
      counters["aria-hidden"] = /* @__PURE__ */ new WeakMap();
      counters.none = /* @__PURE__ */ new WeakMap();
      uncontrolledElementsSet = /* @__PURE__ */ new WeakSet();
      markerMap = {};
    }
  };
}
function markOthers(avoidElements, ariaHidden, inert) {
  if (ariaHidden === void 0) {
    ariaHidden = false;
  }
  if (inert === void 0) {
    inert = false;
  }
  const body = getDocument2(avoidElements[0]).body;
  return applyAttributeToOthers(avoidElements.concat(Array.from(body.querySelectorAll('[aria-live],[role="status"],output'))), body, ariaHidden, inert);
}
var HIDDEN_STYLES = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
};
var FocusGuard = React19.forwardRef(function FocusGuard2(props, ref) {
  const [role, setRole] = React19.useState();
  index(() => {
    if (isSafari()) {
      setRole("button");
    }
  }, []);
  const restProps = {
    ref,
    tabIndex: 0,
    // Role is only for VoiceOver
    role,
    "aria-hidden": role ? void 0 : true,
    [createAttribute("focus-guard")]: "",
    style: HIDDEN_STYLES
  };
  return (0, import_jsx_runtime.jsx)("span", {
    ...props,
    ...restProps
  });
});
var PortalContext = React19.createContext(null);
var attr = createAttribute("portal");
var usePortalContext = () => React19.useContext(PortalContext);
function useLiteMergeRefs(refs) {
  return React19.useMemo(() => {
    return (value) => {
      refs.forEach((ref) => {
        if (ref) {
          ref.current = value;
        }
      });
    };
  }, refs);
}
var LIST_LIMIT = 20;
var previouslyFocusedElements = [];
function clearDisconnectedPreviouslyFocusedElements() {
  previouslyFocusedElements = previouslyFocusedElements.filter((el) => el.isConnected);
}
function addPreviouslyFocusedElement(element) {
  clearDisconnectedPreviouslyFocusedElements();
  if (element && getNodeName(element) !== "body") {
    previouslyFocusedElements.push(element);
    if (previouslyFocusedElements.length > LIST_LIMIT) {
      previouslyFocusedElements = previouslyFocusedElements.slice(-20);
    }
  }
}
function getPreviouslyFocusedElement() {
  clearDisconnectedPreviouslyFocusedElements();
  return previouslyFocusedElements[previouslyFocusedElements.length - 1];
}
function getFirstTabbableElement(container) {
  const tabbableOptions = getTabbableOptions();
  if (isTabbable(container, tabbableOptions)) {
    return container;
  }
  return tabbable(container, tabbableOptions)[0] || container;
}
function handleTabIndex(floatingFocusElement, orderRef) {
  var _floatingFocusElement;
  if (!orderRef.current.includes("floating") && !((_floatingFocusElement = floatingFocusElement.getAttribute("role")) != null && _floatingFocusElement.includes("dialog"))) {
    return;
  }
  const options = getTabbableOptions();
  const focusableElements = focusable(floatingFocusElement, options);
  const tabbableContent = focusableElements.filter((element) => {
    const dataTabIndex = element.getAttribute("data-tabindex") || "";
    return isTabbable(element, options) || element.hasAttribute("data-tabindex") && !dataTabIndex.startsWith("-");
  });
  const tabIndex = floatingFocusElement.getAttribute("tabindex");
  if (orderRef.current.includes("floating") || tabbableContent.length === 0) {
    if (tabIndex !== "0") {
      floatingFocusElement.setAttribute("tabindex", "0");
    }
  } else if (tabIndex !== "-1" || floatingFocusElement.hasAttribute("data-tabindex") && floatingFocusElement.getAttribute("data-tabindex") !== "-1") {
    floatingFocusElement.setAttribute("tabindex", "-1");
    floatingFocusElement.setAttribute("data-tabindex", "-1");
  }
}
var VisuallyHiddenDismiss = React19.forwardRef(function VisuallyHiddenDismiss2(props, ref) {
  return (0, import_jsx_runtime.jsx)("button", {
    ...props,
    type: "button",
    ref,
    tabIndex: -1,
    style: HIDDEN_STYLES
  });
});
function FloatingFocusManager(props) {
  const {
    context,
    children,
    disabled = false,
    order = ["content"],
    guards: _guards = true,
    initialFocus = 0,
    returnFocus = true,
    restoreFocus = false,
    modal = true,
    visuallyHiddenDismiss = false,
    closeOnFocusOut = true,
    outsideElementsInert = false,
    getInsideElements: _getInsideElements = () => []
  } = props;
  const {
    open: open2,
    onOpenChange,
    events,
    dataRef,
    elements: {
      domReference,
      floating
    }
  } = context;
  const getNodeId = useEffectEvent(() => {
    var _dataRef$current$floa;
    return (_dataRef$current$floa = dataRef.current.floatingContext) == null ? void 0 : _dataRef$current$floa.nodeId;
  });
  const getInsideElements = useEffectEvent(_getInsideElements);
  const ignoreInitialFocus = typeof initialFocus === "number" && initialFocus < 0;
  const isUntrappedTypeableCombobox = isTypeableCombobox(domReference) && ignoreInitialFocus;
  const inertSupported = supportsInert();
  const guards = inertSupported ? _guards : true;
  const useInert = !guards || inertSupported && outsideElementsInert;
  const orderRef = useLatestRef(order);
  const initialFocusRef = useLatestRef(initialFocus);
  const returnFocusRef = useLatestRef(returnFocus);
  const tree = useFloatingTree();
  const portalContext = usePortalContext();
  const startDismissButtonRef = React19.useRef(null);
  const endDismissButtonRef = React19.useRef(null);
  const preventReturnFocusRef = React19.useRef(false);
  const isPointerDownRef = React19.useRef(false);
  const tabbableIndexRef = React19.useRef(-1);
  const blurTimeoutRef = React19.useRef(-1);
  const isInsidePortal = portalContext != null;
  const floatingFocusElement = getFloatingFocusElement(floating);
  const getTabbableContent = useEffectEvent(function(container) {
    if (container === void 0) {
      container = floatingFocusElement;
    }
    return container ? tabbable(container, getTabbableOptions()) : [];
  });
  const getTabbableElements = useEffectEvent((container) => {
    const content = getTabbableContent(container);
    return orderRef.current.map((type) => {
      if (domReference && type === "reference") {
        return domReference;
      }
      if (floatingFocusElement && type === "floating") {
        return floatingFocusElement;
      }
      return content;
    }).filter(Boolean).flat();
  });
  React19.useEffect(() => {
    if (disabled) return;
    if (!modal) return;
    function onKeyDown(event) {
      if (event.key === "Tab") {
        if (contains(floatingFocusElement, activeElement(getDocument(floatingFocusElement))) && getTabbableContent().length === 0 && !isUntrappedTypeableCombobox) {
          stopEvent(event);
        }
        const els = getTabbableElements();
        const target = getTarget(event);
        if (orderRef.current[0] === "reference" && target === domReference) {
          stopEvent(event);
          if (event.shiftKey) {
            enqueueFocus(els[els.length - 1]);
          } else {
            enqueueFocus(els[1]);
          }
        }
        if (orderRef.current[1] === "floating" && target === floatingFocusElement && event.shiftKey) {
          stopEvent(event);
          enqueueFocus(els[0]);
        }
      }
    }
    const doc = getDocument(floatingFocusElement);
    doc.addEventListener("keydown", onKeyDown);
    return () => {
      doc.removeEventListener("keydown", onKeyDown);
    };
  }, [disabled, domReference, floatingFocusElement, modal, orderRef, isUntrappedTypeableCombobox, getTabbableContent, getTabbableElements]);
  React19.useEffect(() => {
    if (disabled) return;
    if (!floating) return;
    function handleFocusIn(event) {
      const target = getTarget(event);
      const tabbableContent = getTabbableContent();
      const tabbableIndex = tabbableContent.indexOf(target);
      if (tabbableIndex !== -1) {
        tabbableIndexRef.current = tabbableIndex;
      }
    }
    floating.addEventListener("focusin", handleFocusIn);
    return () => {
      floating.removeEventListener("focusin", handleFocusIn);
    };
  }, [disabled, floating, getTabbableContent]);
  React19.useEffect(() => {
    if (disabled) return;
    if (!closeOnFocusOut) return;
    function handlePointerDown() {
      isPointerDownRef.current = true;
      setTimeout(() => {
        isPointerDownRef.current = false;
      });
    }
    function handleFocusOutside(event) {
      const relatedTarget = event.relatedTarget;
      const currentTarget = event.currentTarget;
      const target = getTarget(event);
      queueMicrotask(() => {
        const nodeId = getNodeId();
        const movedToUnrelatedNode = !(contains(domReference, relatedTarget) || contains(floating, relatedTarget) || contains(relatedTarget, floating) || contains(portalContext == null ? void 0 : portalContext.portalNode, relatedTarget) || relatedTarget != null && relatedTarget.hasAttribute(createAttribute("focus-guard")) || tree && (getNodeChildren(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context, _node$context2;
          return contains((_node$context = node.context) == null ? void 0 : _node$context.elements.floating, relatedTarget) || contains((_node$context2 = node.context) == null ? void 0 : _node$context2.elements.domReference, relatedTarget);
        }) || getNodeAncestors(tree.nodesRef.current, nodeId).find((node) => {
          var _node$context3, _node$context4, _node$context5;
          return [(_node$context3 = node.context) == null ? void 0 : _node$context3.elements.floating, getFloatingFocusElement((_node$context4 = node.context) == null ? void 0 : _node$context4.elements.floating)].includes(relatedTarget) || ((_node$context5 = node.context) == null ? void 0 : _node$context5.elements.domReference) === relatedTarget;
        })));
        if (currentTarget === domReference && floatingFocusElement) {
          handleTabIndex(floatingFocusElement, orderRef);
        }
        if (restoreFocus && currentTarget !== domReference && !(target != null && target.isConnected) && activeElement(getDocument(floatingFocusElement)) === getDocument(floatingFocusElement).body) {
          if (isHTMLElement(floatingFocusElement)) {
            floatingFocusElement.focus();
          }
          const prevTabbableIndex = tabbableIndexRef.current;
          const tabbableContent = getTabbableContent();
          const nodeToFocus = tabbableContent[prevTabbableIndex] || tabbableContent[tabbableContent.length - 1] || floatingFocusElement;
          if (isHTMLElement(nodeToFocus)) {
            nodeToFocus.focus();
          }
        }
        if (dataRef.current.insideReactTree) {
          dataRef.current.insideReactTree = false;
          return;
        }
        if ((isUntrappedTypeableCombobox ? true : !modal) && relatedTarget && movedToUnrelatedNode && !isPointerDownRef.current && // Fix React 18 Strict Mode returnFocus due to double rendering.
        relatedTarget !== getPreviouslyFocusedElement()) {
          preventReturnFocusRef.current = true;
          onOpenChange(false, event, "focus-out");
        }
      });
    }
    const shouldHandleBlurCapture = Boolean(!tree && portalContext);
    function markInsideReactTree() {
      clearTimeoutIfSet(blurTimeoutRef);
      dataRef.current.insideReactTree = true;
      blurTimeoutRef.current = window.setTimeout(() => {
        dataRef.current.insideReactTree = false;
      });
    }
    if (floating && isHTMLElement(domReference)) {
      domReference.addEventListener("focusout", handleFocusOutside);
      domReference.addEventListener("pointerdown", handlePointerDown);
      floating.addEventListener("focusout", handleFocusOutside);
      if (shouldHandleBlurCapture) {
        floating.addEventListener("focusout", markInsideReactTree, true);
      }
      return () => {
        domReference.removeEventListener("focusout", handleFocusOutside);
        domReference.removeEventListener("pointerdown", handlePointerDown);
        floating.removeEventListener("focusout", handleFocusOutside);
        if (shouldHandleBlurCapture) {
          floating.removeEventListener("focusout", markInsideReactTree, true);
        }
      };
    }
  }, [disabled, domReference, floating, floatingFocusElement, modal, tree, portalContext, onOpenChange, closeOnFocusOut, restoreFocus, getTabbableContent, isUntrappedTypeableCombobox, getNodeId, orderRef, dataRef]);
  const beforeGuardRef = React19.useRef(null);
  const afterGuardRef = React19.useRef(null);
  const mergedBeforeGuardRef = useLiteMergeRefs([beforeGuardRef, portalContext == null ? void 0 : portalContext.beforeInsideRef]);
  const mergedAfterGuardRef = useLiteMergeRefs([afterGuardRef, portalContext == null ? void 0 : portalContext.afterInsideRef]);
  React19.useEffect(() => {
    var _portalContext$portal, _ancestors$find;
    if (disabled) return;
    if (!floating) return;
    const portalNodes = Array.from((portalContext == null || (_portalContext$portal = portalContext.portalNode) == null ? void 0 : _portalContext$portal.querySelectorAll("[" + createAttribute("portal") + "]")) || []);
    const ancestors = tree ? getNodeAncestors(tree.nodesRef.current, getNodeId()) : [];
    const rootAncestorComboboxDomReference = (_ancestors$find = ancestors.find((node) => {
      var _node$context6;
      return isTypeableCombobox(((_node$context6 = node.context) == null ? void 0 : _node$context6.elements.domReference) || null);
    })) == null || (_ancestors$find = _ancestors$find.context) == null ? void 0 : _ancestors$find.elements.domReference;
    const insideElements = [floating, rootAncestorComboboxDomReference, ...portalNodes, ...getInsideElements(), startDismissButtonRef.current, endDismissButtonRef.current, beforeGuardRef.current, afterGuardRef.current, portalContext == null ? void 0 : portalContext.beforeOutsideRef.current, portalContext == null ? void 0 : portalContext.afterOutsideRef.current, orderRef.current.includes("reference") || isUntrappedTypeableCombobox ? domReference : null].filter((x) => x != null);
    const cleanup2 = modal || isUntrappedTypeableCombobox ? markOthers(insideElements, !useInert, useInert) : markOthers(insideElements);
    return () => {
      cleanup2();
    };
  }, [disabled, domReference, floating, modal, orderRef, portalContext, isUntrappedTypeableCombobox, guards, useInert, tree, getNodeId, getInsideElements]);
  index(() => {
    if (disabled || !isHTMLElement(floatingFocusElement)) return;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    queueMicrotask(() => {
      const focusableElements = getTabbableElements(floatingFocusElement);
      const initialFocusValue = initialFocusRef.current;
      const elToFocus = (typeof initialFocusValue === "number" ? focusableElements[initialFocusValue] : initialFocusValue.current) || floatingFocusElement;
      const focusAlreadyInsideFloatingEl = contains(floatingFocusElement, previouslyFocusedElement);
      if (!ignoreInitialFocus && !focusAlreadyInsideFloatingEl && open2) {
        enqueueFocus(elToFocus, {
          preventScroll: elToFocus === floatingFocusElement
        });
      }
    });
  }, [disabled, open2, floatingFocusElement, ignoreInitialFocus, getTabbableElements, initialFocusRef]);
  index(() => {
    if (disabled || !floatingFocusElement) return;
    const doc = getDocument(floatingFocusElement);
    const previouslyFocusedElement = activeElement(doc);
    addPreviouslyFocusedElement(previouslyFocusedElement);
    function onOpenChange2(_ref) {
      let {
        reason,
        event,
        nested
      } = _ref;
      if (["hover", "safe-polygon"].includes(reason) && event.type === "mouseleave") {
        preventReturnFocusRef.current = true;
      }
      if (reason !== "outside-press") return;
      if (nested) {
        preventReturnFocusRef.current = false;
      } else if (isVirtualClick(event) || isVirtualPointerEvent(event)) {
        preventReturnFocusRef.current = false;
      } else {
        let isPreventScrollSupported = false;
        document.createElement("div").focus({
          get preventScroll() {
            isPreventScrollSupported = true;
            return false;
          }
        });
        if (isPreventScrollSupported) {
          preventReturnFocusRef.current = false;
        } else {
          preventReturnFocusRef.current = true;
        }
      }
    }
    events.on("openchange", onOpenChange2);
    const fallbackEl = doc.createElement("span");
    fallbackEl.setAttribute("tabindex", "-1");
    fallbackEl.setAttribute("aria-hidden", "true");
    Object.assign(fallbackEl.style, HIDDEN_STYLES);
    if (isInsidePortal && domReference) {
      domReference.insertAdjacentElement("afterend", fallbackEl);
    }
    function getReturnElement() {
      if (typeof returnFocusRef.current === "boolean") {
        const el = domReference || getPreviouslyFocusedElement();
        return el && el.isConnected ? el : fallbackEl;
      }
      return returnFocusRef.current.current || fallbackEl;
    }
    return () => {
      events.off("openchange", onOpenChange2);
      const activeEl = activeElement(doc);
      const isFocusInsideFloatingTree = contains(floating, activeEl) || tree && getNodeChildren(tree.nodesRef.current, getNodeId(), false).some((node) => {
        var _node$context7;
        return contains((_node$context7 = node.context) == null ? void 0 : _node$context7.elements.floating, activeEl);
      });
      const returnElement = getReturnElement();
      queueMicrotask(() => {
        const tabbableReturnElement = getFirstTabbableElement(returnElement);
        if (
          // eslint-disable-next-line react-hooks/exhaustive-deps
          returnFocusRef.current && !preventReturnFocusRef.current && isHTMLElement(tabbableReturnElement) && // If the focus moved somewhere else after mount, avoid returning focus
          // since it likely entered a different element which should be
          // respected: https://github.com/floating-ui/floating-ui/issues/2607
          (tabbableReturnElement !== activeEl && activeEl !== doc.body ? isFocusInsideFloatingTree : true)
        ) {
          tabbableReturnElement.focus({
            preventScroll: true
          });
        }
        fallbackEl.remove();
      });
    };
  }, [disabled, floating, floatingFocusElement, returnFocusRef, dataRef, events, tree, isInsidePortal, domReference, getNodeId]);
  React19.useEffect(() => {
    queueMicrotask(() => {
      preventReturnFocusRef.current = false;
    });
    return () => {
      queueMicrotask(clearDisconnectedPreviouslyFocusedElements);
    };
  }, [disabled]);
  index(() => {
    if (disabled) return;
    if (!portalContext) return;
    portalContext.setFocusManagerState({
      modal,
      closeOnFocusOut,
      open: open2,
      onOpenChange,
      domReference
    });
    return () => {
      portalContext.setFocusManagerState(null);
    };
  }, [disabled, portalContext, modal, open2, onOpenChange, closeOnFocusOut, domReference]);
  index(() => {
    if (disabled) return;
    if (!floatingFocusElement) return;
    handleTabIndex(floatingFocusElement, orderRef);
  }, [disabled, floatingFocusElement, orderRef]);
  function renderDismissButton(location) {
    if (disabled || !visuallyHiddenDismiss || !modal) {
      return null;
    }
    return (0, import_jsx_runtime.jsx)(VisuallyHiddenDismiss, {
      ref: location === "start" ? startDismissButtonRef : endDismissButtonRef,
      onClick: (event) => onOpenChange(false, event.nativeEvent),
      children: typeof visuallyHiddenDismiss === "string" ? visuallyHiddenDismiss : "Dismiss"
    });
  }
  const shouldRenderGuards = !disabled && guards && (modal ? !isUntrappedTypeableCombobox : true) && (isInsidePortal || modal);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, {
    children: [shouldRenderGuards && (0, import_jsx_runtime.jsx)(FocusGuard, {
      "data-type": "inside",
      ref: mergedBeforeGuardRef,
      onFocus: (event) => {
        if (modal) {
          const els = getTabbableElements();
          enqueueFocus(order[0] === "reference" ? els[0] : els[els.length - 1]);
        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
          preventReturnFocusRef.current = false;
          if (isOutsideEvent(event, portalContext.portalNode)) {
            const nextTabbable = getNextTabbable(domReference);
            nextTabbable == null || nextTabbable.focus();
          } else {
            var _portalContext$before;
            (_portalContext$before = portalContext.beforeOutsideRef.current) == null || _portalContext$before.focus();
          }
        }
      }
    }), !isUntrappedTypeableCombobox && renderDismissButton("start"), children, renderDismissButton("end"), shouldRenderGuards && (0, import_jsx_runtime.jsx)(FocusGuard, {
      "data-type": "inside",
      ref: mergedAfterGuardRef,
      onFocus: (event) => {
        if (modal) {
          enqueueFocus(getTabbableElements()[0]);
        } else if (portalContext != null && portalContext.preserveTabOrder && portalContext.portalNode) {
          if (closeOnFocusOut) {
            preventReturnFocusRef.current = true;
          }
          if (isOutsideEvent(event, portalContext.portalNode)) {
            const prevTabbable = getPreviousTabbable(domReference);
            prevTabbable == null || prevTabbable.focus();
          } else {
            var _portalContext$afterO;
            (_portalContext$afterO = portalContext.afterOutsideRef.current) == null || _portalContext$afterO.focus();
          }
        }
      }
    })]
  });
}
var lockCount = 0;
var scrollbarProperty = "--floating-ui-scrollbar-width";
function enableScrollLock() {
  const platform2 = getPlatform();
  const isIOS = /iP(hone|ad|od)|iOS/.test(platform2) || // iPads can claim to be MacIntel
  platform2 === "MacIntel" && navigator.maxTouchPoints > 1;
  const bodyStyle = document.body.style;
  const scrollbarX = Math.round(document.documentElement.getBoundingClientRect().left) + document.documentElement.scrollLeft;
  const paddingProp = scrollbarX ? "paddingLeft" : "paddingRight";
  const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
  const scrollX = bodyStyle.left ? parseFloat(bodyStyle.left) : window.scrollX;
  const scrollY = bodyStyle.top ? parseFloat(bodyStyle.top) : window.scrollY;
  bodyStyle.overflow = "hidden";
  bodyStyle.setProperty(scrollbarProperty, scrollbarWidth + "px");
  if (scrollbarWidth) {
    bodyStyle[paddingProp] = scrollbarWidth + "px";
  }
  if (isIOS) {
    var _window$visualViewpor, _window$visualViewpor2;
    const offsetLeft = ((_window$visualViewpor = window.visualViewport) == null ? void 0 : _window$visualViewpor.offsetLeft) || 0;
    const offsetTop = ((_window$visualViewpor2 = window.visualViewport) == null ? void 0 : _window$visualViewpor2.offsetTop) || 0;
    Object.assign(bodyStyle, {
      position: "fixed",
      top: -(scrollY - Math.floor(offsetTop)) + "px",
      left: -(scrollX - Math.floor(offsetLeft)) + "px",
      right: "0"
    });
  }
  return () => {
    Object.assign(bodyStyle, {
      overflow: "",
      [paddingProp]: ""
    });
    bodyStyle.removeProperty(scrollbarProperty);
    if (isIOS) {
      Object.assign(bodyStyle, {
        position: "",
        top: "",
        left: "",
        right: ""
      });
      window.scrollTo(scrollX, scrollY);
    }
  };
}
var cleanup = () => {
};
var FloatingOverlay = React19.forwardRef(function FloatingOverlay2(props, ref) {
  const {
    lockScroll = false,
    ...rest
  } = props;
  index(() => {
    if (!lockScroll) return;
    lockCount++;
    if (lockCount === 1) {
      cleanup = enableScrollLock();
    }
    return () => {
      lockCount--;
      if (lockCount === 0) {
        cleanup();
      }
    };
  }, [lockScroll]);
  return (0, import_jsx_runtime.jsx)("div", {
    ref,
    ...rest,
    style: {
      position: "fixed",
      overflow: "auto",
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      ...rest.style
    }
  });
});
function useFloatingRootContext(options) {
  const {
    open: open2 = false,
    onOpenChange: onOpenChangeProp,
    elements: elementsProp
  } = options;
  const floatingId = useId2();
  const dataRef = React19.useRef({});
  const [events] = React19.useState(() => createEventEmitter());
  const nested = useFloatingParentNodeId() != null;
  if (true) {
    const optionDomReference = elementsProp.reference;
    if (optionDomReference && !isElement(optionDomReference)) {
      error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
    }
  }
  const [positionReference, setPositionReference] = React19.useState(elementsProp.reference);
  const onOpenChange = useEffectEvent((open3, event, reason) => {
    dataRef.current.openEvent = open3 ? event : void 0;
    events.emit("openchange", {
      open: open3,
      event,
      reason,
      nested
    });
    onOpenChangeProp == null || onOpenChangeProp(open3, event, reason);
  });
  const refs = React19.useMemo(() => ({
    setPositionReference
  }), []);
  const elements = React19.useMemo(() => ({
    reference: positionReference || elementsProp.reference || null,
    floating: elementsProp.floating || null,
    domReference: elementsProp.reference
  }), [positionReference, elementsProp.reference, elementsProp.floating]);
  return React19.useMemo(() => ({
    dataRef,
    open: open2,
    onOpenChange,
    elements,
    events,
    floatingId,
    refs
  }), [open2, onOpenChange, elements, events, floatingId, refs]);
}
function useFloating2(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    nodeId
  } = options;
  const internalRootContext = useFloatingRootContext({
    ...options,
    elements: {
      reference: null,
      floating: null,
      ...options.elements
    }
  });
  const rootContext = options.rootContext || internalRootContext;
  const computedElements = rootContext.elements;
  const [_domReference, setDomReference] = React19.useState(null);
  const [positionReference, _setPositionReference] = React19.useState(null);
  const optionDomReference = computedElements == null ? void 0 : computedElements.domReference;
  const domReference = optionDomReference || _domReference;
  const domReferenceRef = React19.useRef(null);
  const tree = useFloatingTree();
  index(() => {
    if (domReference) {
      domReferenceRef.current = domReference;
    }
  }, [domReference]);
  const position = useFloating({
    ...options,
    elements: {
      ...computedElements,
      ...positionReference && {
        reference: positionReference
      }
    }
  });
  const setPositionReference = React19.useCallback((node) => {
    const computedPositionReference = isElement(node) ? {
      getBoundingClientRect: () => node.getBoundingClientRect(),
      getClientRects: () => node.getClientRects(),
      contextElement: node
    } : node;
    _setPositionReference(computedPositionReference);
    position.refs.setReference(computedPositionReference);
  }, [position.refs]);
  const setReference = React19.useCallback((node) => {
    if (isElement(node) || node === null) {
      domReferenceRef.current = node;
      setDomReference(node);
    }
    if (isElement(position.refs.reference.current) || position.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    node !== null && !isElement(node)) {
      position.refs.setReference(node);
    }
  }, [position.refs]);
  const refs = React19.useMemo(() => ({
    ...position.refs,
    setReference,
    setPositionReference,
    domReference: domReferenceRef
  }), [position.refs, setReference, setPositionReference]);
  const elements = React19.useMemo(() => ({
    ...position.elements,
    domReference
  }), [position.elements, domReference]);
  const context = React19.useMemo(() => ({
    ...position,
    ...rootContext,
    refs,
    elements,
    nodeId
  }), [position, refs, elements, nodeId, rootContext]);
  index(() => {
    rootContext.dataRef.current.floatingContext = context;
    const node = tree == null ? void 0 : tree.nodesRef.current.find((node2) => node2.id === nodeId);
    if (node) {
      node.context = context;
    }
  });
  return React19.useMemo(() => ({
    ...position,
    context,
    refs,
    elements
  }), [position, refs, elements, context]);
}
function mergeProps(userProps, propsList, elementKey) {
  const map = /* @__PURE__ */ new Map();
  const isItem = elementKey === "item";
  let domUserProps = userProps;
  if (isItem && userProps) {
    const {
      [ACTIVE_KEY]: _,
      [SELECTED_KEY]: __,
      ...validProps
    } = userProps;
    domUserProps = validProps;
  }
  return {
    ...elementKey === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE2]: ""
    },
    ...domUserProps,
    ...propsList.map((value) => {
      const propsOrGetProps = value ? value[elementKey] : null;
      if (typeof propsOrGetProps === "function") {
        return userProps ? propsOrGetProps(userProps) : null;
      }
      return propsOrGetProps;
    }).concat(userProps).reduce((acc, props) => {
      if (!props) {
        return acc;
      }
      Object.entries(props).forEach((_ref) => {
        let [key, value] = _ref;
        if (isItem && [ACTIVE_KEY, SELECTED_KEY].includes(key)) {
          return;
        }
        if (key.indexOf("on") === 0) {
          if (!map.has(key)) {
            map.set(key, []);
          }
          if (typeof value === "function") {
            var _map$get;
            (_map$get = map.get(key)) == null || _map$get.push(value);
            acc[key] = function() {
              var _map$get2;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return (_map$get2 = map.get(key)) == null ? void 0 : _map$get2.map((fn) => fn(...args)).find((val) => val !== void 0);
            };
          }
        } else {
          acc[key] = value;
        }
      });
      return acc;
    }, {})
  };
}
function useInteractions(propsList) {
  if (propsList === void 0) {
    propsList = [];
  }
  const referenceDeps = propsList.map((key) => key == null ? void 0 : key.reference);
  const floatingDeps = propsList.map((key) => key == null ? void 0 : key.floating);
  const itemDeps = propsList.map((key) => key == null ? void 0 : key.item);
  const getReferenceProps = React19.useCallback(
    (userProps) => mergeProps(userProps, propsList, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    referenceDeps
  );
  const getFloatingProps = React19.useCallback(
    (userProps) => mergeProps(userProps, propsList, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    floatingDeps
  );
  const getItemProps = React19.useCallback(
    (userProps) => mergeProps(userProps, propsList, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    itemDeps
  );
  return React19.useMemo(() => ({
    getReferenceProps,
    getFloatingProps,
    getItemProps
  }), [getReferenceProps, getFloatingProps, getItemProps]);
}
function getNodeChildren2(nodes, id, onlyOpenChildren) {
  if (onlyOpenChildren === void 0) {
    onlyOpenChildren = true;
  }
  const directChildren = nodes.filter((node) => {
    var _node$context;
    return node.parentId === id && (!onlyOpenChildren || ((_node$context = node.context) == null ? void 0 : _node$context.open));
  });
  return directChildren.flatMap((child) => [child, ...getNodeChildren2(nodes, child.id, onlyOpenChildren)]);
}
function isPointInPolygon(point, polygon) {
  const [x, y] = point;
  let isInside2 = false;
  const length = polygon.length;
  for (let i = 0, j = length - 1; i < length; j = i++) {
    const [xi, yi] = polygon[i] || [0, 0];
    const [xj, yj] = polygon[j] || [0, 0];
    const intersect = yi >= y !== yj >= y && x <= (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      isInside2 = !isInside2;
    }
  }
  return isInside2;
}
function isInside(point, rect) {
  return point[0] >= rect.x && point[0] <= rect.x + rect.width && point[1] >= rect.y && point[1] <= rect.y + rect.height;
}
function safePolygon(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    buffer = 0.5,
    blockPointerEvents = false,
    requireIntent = true
  } = options;
  const timeoutRef = {
    current: -1
  };
  let hasLanded = false;
  let lastX = null;
  let lastY = null;
  let lastCursorTime = typeof performance !== "undefined" ? performance.now() : 0;
  function getCursorSpeed(x, y) {
    const currentTime = performance.now();
    const elapsedTime = currentTime - lastCursorTime;
    if (lastX === null || lastY === null || elapsedTime === 0) {
      lastX = x;
      lastY = y;
      lastCursorTime = currentTime;
      return null;
    }
    const deltaX = x - lastX;
    const deltaY = y - lastY;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    const speed = distance / elapsedTime;
    lastX = x;
    lastY = y;
    lastCursorTime = currentTime;
    return speed;
  }
  const fn = (_ref) => {
    let {
      x,
      y,
      placement,
      elements,
      onClose,
      nodeId,
      tree
    } = _ref;
    return function onMouseMove(event) {
      function close() {
        clearTimeoutIfSet(timeoutRef);
        onClose();
      }
      clearTimeoutIfSet(timeoutRef);
      if (!elements.domReference || !elements.floating || placement == null || x == null || y == null) {
        return;
      }
      const {
        clientX,
        clientY
      } = event;
      const clientPoint = [clientX, clientY];
      const target = getTarget2(event);
      const isLeave = event.type === "mouseleave";
      const isOverFloatingEl = contains2(elements.floating, target);
      const isOverReferenceEl = contains2(elements.domReference, target);
      const refRect = elements.domReference.getBoundingClientRect();
      const rect = elements.floating.getBoundingClientRect();
      const side = placement.split("-")[0];
      const cursorLeaveFromRight = x > rect.right - rect.width / 2;
      const cursorLeaveFromBottom = y > rect.bottom - rect.height / 2;
      const isOverReferenceRect = isInside(clientPoint, refRect);
      const isFloatingWider = rect.width > refRect.width;
      const isFloatingTaller = rect.height > refRect.height;
      const left = (isFloatingWider ? refRect : rect).left;
      const right = (isFloatingWider ? refRect : rect).right;
      const top = (isFloatingTaller ? refRect : rect).top;
      const bottom = (isFloatingTaller ? refRect : rect).bottom;
      if (isOverFloatingEl) {
        hasLanded = true;
        if (!isLeave) {
          return;
        }
      }
      if (isOverReferenceEl) {
        hasLanded = false;
      }
      if (isOverReferenceEl && !isLeave) {
        hasLanded = true;
        return;
      }
      if (isLeave && isElement(event.relatedTarget) && contains2(elements.floating, event.relatedTarget)) {
        return;
      }
      if (tree && getNodeChildren2(tree.nodesRef.current, nodeId).length) {
        return;
      }
      if (side === "top" && y >= refRect.bottom - 1 || side === "bottom" && y <= refRect.top + 1 || side === "left" && x >= refRect.right - 1 || side === "right" && x <= refRect.left + 1) {
        return close();
      }
      let rectPoly = [];
      switch (side) {
        case "top":
          rectPoly = [[left, refRect.top + 1], [left, rect.bottom - 1], [right, rect.bottom - 1], [right, refRect.top + 1]];
          break;
        case "bottom":
          rectPoly = [[left, rect.top + 1], [left, refRect.bottom - 1], [right, refRect.bottom - 1], [right, rect.top + 1]];
          break;
        case "left":
          rectPoly = [[rect.right - 1, bottom], [rect.right - 1, top], [refRect.left + 1, top], [refRect.left + 1, bottom]];
          break;
        case "right":
          rectPoly = [[refRect.right - 1, bottom], [refRect.right - 1, top], [rect.left + 1, top], [rect.left + 1, bottom]];
          break;
      }
      function getPolygon(_ref2) {
        let [x2, y2] = _ref2;
        switch (side) {
          case "top": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 + buffer + 1];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.bottom - buffer : isFloatingWider ? rect.bottom - buffer : rect.top], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.bottom - buffer : rect.top : rect.bottom - buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "bottom": {
            const cursorPointOne = [isFloatingWider ? x2 + buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const cursorPointTwo = [isFloatingWider ? x2 - buffer / 2 : cursorLeaveFromRight ? x2 + buffer * 4 : x2 - buffer * 4, y2 - buffer];
            const commonPoints = [[rect.left, cursorLeaveFromRight ? rect.top + buffer : isFloatingWider ? rect.top + buffer : rect.bottom], [rect.right, cursorLeaveFromRight ? isFloatingWider ? rect.top + buffer : rect.bottom : rect.top + buffer]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
          case "left": {
            const cursorPointOne = [x2 + buffer + 1, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 + buffer + 1, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.right - buffer : isFloatingTaller ? rect.right - buffer : rect.left, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.right - buffer : rect.left : rect.right - buffer, rect.bottom]];
            return [...commonPoints, cursorPointOne, cursorPointTwo];
          }
          case "right": {
            const cursorPointOne = [x2 - buffer, isFloatingTaller ? y2 + buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const cursorPointTwo = [x2 - buffer, isFloatingTaller ? y2 - buffer / 2 : cursorLeaveFromBottom ? y2 + buffer * 4 : y2 - buffer * 4];
            const commonPoints = [[cursorLeaveFromBottom ? rect.left + buffer : isFloatingTaller ? rect.left + buffer : rect.right, rect.top], [cursorLeaveFromBottom ? isFloatingTaller ? rect.left + buffer : rect.right : rect.left + buffer, rect.bottom]];
            return [cursorPointOne, cursorPointTwo, ...commonPoints];
          }
        }
      }
      if (isPointInPolygon([clientX, clientY], rectPoly)) {
        return;
      }
      if (hasLanded && !isOverReferenceRect) {
        return close();
      }
      if (!isLeave && requireIntent) {
        const cursorSpeed = getCursorSpeed(event.clientX, event.clientY);
        const cursorSpeedThreshold = 0.1;
        if (cursorSpeed !== null && cursorSpeed < cursorSpeedThreshold) {
          return close();
        }
      }
      if (!isPointInPolygon([clientX, clientY], getPolygon([x, y]))) {
        close();
      } else if (!hasLanded && requireIntent) {
        timeoutRef.current = window.setTimeout(close, 40);
      }
    };
  };
  fn.__options = {
    blockPointerEvents
  };
  return fn;
}

// node_modules/@carbon/react/es/components/FeatureFlags/index.js
var import_prop_types12 = __toESM(require_prop_types());
var import_react24 = __toESM(require_react());
var FeatureFlagContext = (0, import_react24.createContext)(FeatureFlags);
function FeatureFlags2({
  children,
  flags = {},
  enableV12TileDefaultIcons = false,
  enableV12TileRadioIcons = false,
  enableV12Overflowmenu = false,
  enableTreeviewControllable = false,
  enableExperimentalFocusWrapWithoutSentinels = false,
  enableDialogElement = false,
  enableV12DynamicFloatingStyles = false,
  enableEnhancedFileUploader = false
}) {
  const parentScope = (0, import_react24.useContext)(FeatureFlagContext);
  const [prevParentScope, setPrevParentScope] = (0, import_react24.useState)(parentScope);
  const combinedFlags = {
    "enable-v12-tile-default-icons": enableV12TileDefaultIcons,
    "enable-v12-tile-radio-icons": enableV12TileRadioIcons,
    "enable-v12-overflowmenu": enableV12Overflowmenu,
    "enable-treeview-controllable": enableTreeviewControllable,
    "enable-experimental-focus-wrap-without-sentinels": enableExperimentalFocusWrapWithoutSentinels,
    "enable-dialog-element": enableDialogElement,
    "enable-v12-dynamic-floating-styles": enableV12DynamicFloatingStyles,
    "enable-enhanced-file-uploader": enableEnhancedFileUploader,
    ...flags
  };
  const [scope, updateScope] = (0, import_react24.useState)(() => {
    const scope2 = createScope(combinedFlags);
    scope2.mergeWithScope(parentScope);
    return scope2;
  });
  if (parentScope !== prevParentScope) {
    const scope2 = createScope(combinedFlags);
    scope2.mergeWithScope(parentScope);
    updateScope(scope2);
    setPrevParentScope(parentScope);
  }
  useChangedValue(combinedFlags, isEqual, (changedFlags) => {
    const scope2 = createScope(changedFlags);
    scope2.mergeWithScope(parentScope);
    updateScope(scope2);
  });
  return import_react24.default.createElement(FeatureFlagContext.Provider, {
    value: scope
  }, children);
}
FeatureFlags2.propTypes = {
  children: import_prop_types12.default.node,
  /**
   * Provide the feature flags to enabled or disabled in the current Rea,ct tree
   */
  flags: deprecate(import_prop_types12.default.objectOf(import_prop_types12.default.bool), `The \`flags\` prop for \`FeatureFlag\` has been deprecated. Please run the \`featureflag-deprecate-flags-prop\` codemod to migrate to individual boolean props.npx @carbon/upgrade migrate featureflag-deprecate-flags-prop --write`),
  enableV12TileDefaultIcons: import_prop_types12.default.bool,
  enableV12TileRadioIcons: import_prop_types12.default.bool,
  enableV12Overflowmenu: import_prop_types12.default.bool,
  enableTreeviewControllable: import_prop_types12.default.bool,
  enableExperimentalFocusWrapWithoutSentinels: import_prop_types12.default.bool,
  enableDialogElement: import_prop_types12.default.bool,
  enableV12DynamicFloatingStyles: import_prop_types12.default.bool,
  enableEnhancedFileUploader: import_prop_types12.default.bool
};
function useChangedValue(value, compare2, callback) {
  const initialRender = (0, import_react24.useRef)(false);
  const savedCallback = (0, import_react24.useRef)(callback);
  const [prevValue, setPrevValue] = (0, import_react24.useState)(value);
  if (!compare2(prevValue, value)) {
    setPrevValue(value);
  }
  (0, import_react24.useEffect)(() => {
    savedCallback.current = callback;
  });
  (0, import_react24.useEffect)(() => {
    if (initialRender.current) {
      savedCallback.current(prevValue);
    }
  }, [prevValue]);
  (0, import_react24.useEffect)(() => {
    initialRender.current = true;
  }, []);
}
function useFeatureFlag(flag) {
  const scope = (0, import_react24.useContext)(FeatureFlagContext);
  return scope.enabled(flag);
}
function useFeatureFlags() {
  return (0, import_react24.useContext)(FeatureFlagContext);
}
function isEqual(a, b2) {
  if (a === b2) {
    return true;
  }
  for (const key of Object.keys(a)) {
    if (a[key] !== b2[key]) {
      return false;
    }
  }
  for (const key of Object.keys(b2)) {
    if (b2[key] !== a[key]) {
      return false;
    }
  }
  return true;
}

// node_modules/@carbon/react/es/components/Popover/index.js
var PopoverContext = import_react25.default.createContext({
  setFloating: {
    current: null
  },
  caretRef: {
    current: null
  },
  autoAlign: null
});
var Popover = import_react25.default.forwardRef(function PopoverRenderFunction({
  isTabTip,
  align: initialAlign = isTabTip ? "bottom-start" : "bottom",
  as: BaseComponent = "span",
  autoAlign = false,
  autoAlignBoundary,
  caret = isTabTip ? false : true,
  className: customClassName,
  children,
  dropShadow = true,
  highContrast = false,
  onRequestClose,
  open: open2,
  alignmentAxisOffset,
  ...rest
}, forwardRef36) {
  var _a;
  const prefix = usePrefix();
  const floating = (0, import_react25.useRef)(null);
  const caretRef = (0, import_react25.useRef)(null);
  const popover = (0, import_react25.useRef)(null);
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  let align = mapPopoverAlign(initialAlign);
  useEvent(popover, "focusout", (event) => {
    var _a2;
    const relatedTarget = event.relatedTarget;
    if (!relatedTarget) {
      onRequestClose == null ? void 0 : onRequestClose();
      return;
    }
    const isOutsideMainContainer = !((_a2 = popover.current) == null ? void 0 : _a2.contains(relatedTarget));
    const isOutsideFloating = enableFloatingStyles && refs.floating.current ? !refs.floating.current.contains(relatedTarget) : true;
    if (isOutsideMainContainer && isOutsideFloating) {
      onRequestClose == null ? void 0 : onRequestClose();
    }
  });
  useWindowEvent("click", ({
    target
  }) => {
    var _a2;
    if (open2 && target instanceof Node && !((_a2 = popover.current) == null ? void 0 : _a2.contains(target))) {
      onRequestClose == null ? void 0 : onRequestClose();
    }
  });
  const initialCaretHeight = import_react25.default.Children.toArray(children).some((x) => {
    var _a2, _b, _c, _d;
    return ((_b = (_a2 = x == null ? void 0 : x.props) == null ? void 0 : _a2.className) == null ? void 0 : _b.includes("slug")) || ((_d = (_c = x == null ? void 0 : x.props) == null ? void 0 : _c.className) == null ? void 0 : _d.includes("ai-label"));
  }) ? 7 : 6;
  const popoverDimensions = (0, import_react25.useRef)({
    offset: 10,
    caretHeight: initialCaretHeight
  });
  useIsomorphicEffect(() => {
    if (caret && popover.current) {
      const getStyle = window.getComputedStyle(popover.current, null);
      const offsetProperty = getStyle.getPropertyValue("--cds-popover-offset");
      const caretProperty = getStyle.getPropertyValue("--cds-popover-caret-height");
      if (offsetProperty) {
        popoverDimensions.current.offset = offsetProperty.includes("px") ? Number(offsetProperty.split("px", 1)[0]) * 1 : Number(offsetProperty.split("rem", 1)[0]) * 16;
      }
      if (caretProperty) {
        popoverDimensions.current.caretHeight = caretProperty.includes("px") ? Number(caretProperty.split("px", 1)[0]) * 1 : Number(caretProperty.split("rem", 1)[0]) * 16;
      }
    }
  });
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2(
    enableFloatingStyles ? {
      placement: align,
      // The floating element is positioned relative to its nearest
      // containing block (usually the viewport). It will in many cases also
      // “break” the floating element out of a clipping ancestor.
      // https://floating-ui.com/docs/misc#clipping
      strategy: "fixed",
      // Middleware order matters, arrow should be last
      middleware: [offset3(!isTabTip ? {
        alignmentAxis: alignmentAxisOffset,
        mainAxis: (_a = popoverDimensions == null ? void 0 : popoverDimensions.current) == null ? void 0 : _a.offset
      } : 0), autoAlign && flip3({
        fallbackPlacements: isTabTip ? align.includes("bottom") ? ["bottom-start", "bottom-end", "top-start", "top-end"] : ["top-start", "top-end", "bottom-start", "bottom-end"] : align.includes("bottom") ? ["bottom", "bottom-start", "bottom-end", "right", "right-start", "right-end", "left", "left-start", "left-end", "top", "top-start", "top-end"] : ["top", "top-start", "top-end", "left", "left-start", "left-end", "right", "right-start", "right-end", "bottom", "bottom-start", "bottom-end"],
        fallbackStrategy: "initialPlacement",
        fallbackAxisSideDirection: "start",
        boundary: autoAlignBoundary
      }), arrow3({
        element: caretRef
      }), autoAlign && hide3()],
      whileElementsMounted: autoUpdate
    } : {}
    // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not
    // enabled, floating-ui will not be used
  );
  const value = (0, import_react25.useMemo)(() => {
    return {
      floating,
      setFloating: refs.setFloating,
      caretRef,
      autoAlign
    };
  }, [refs.setFloating, autoAlign]);
  if (isTabTip) {
    const tabTipAlignments = ["bottom-start", "bottom-end"];
    if (!tabTipAlignments.includes(align)) {
      align = "bottom-start";
    }
  }
  (0, import_react25.useEffect)(() => {
    var _a2, _b;
    if (enableFloatingStyles) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
      if (caret && middlewareData && middlewareData.arrow && (caretRef == null ? void 0 : caretRef.current)) {
        const {
          x,
          y
        } = middlewareData.arrow;
        const staticSide = {
          top: "bottom",
          right: "left",
          bottom: "top",
          left: "right"
        }[placement.split("-")[0]];
        caretRef.current.style.left = x != null ? `${x}px` : "";
        caretRef.current.style.top = y != null ? `${y}px` : "";
        caretRef.current.style.right = "";
        caretRef.current.style.bottom = "";
        if (staticSide) {
          caretRef.current.style[staticSide] = `${-((_b = popoverDimensions == null ? void 0 : popoverDimensions.current) == null ? void 0 : _b.caretHeight)}px`;
        }
      }
    }
  }, [floatingStyles, refs.floating, enableFloatingStyles, middlewareData, placement, caret]);
  const ref = useMergedRefs([forwardRef36, popover]);
  const currentAlignment = autoAlign && placement !== align ? placement : align;
  const className = (0, import_classnames10.default)({
    [`${prefix}--popover-container`]: true,
    [`${prefix}--popover--caret`]: caret,
    [`${prefix}--popover--drop-shadow`]: dropShadow,
    [`${prefix}--popover--high-contrast`]: highContrast,
    [`${prefix}--popover--open`]: open2,
    [`${prefix}--popover--auto-align ${prefix}--autoalign`]: enableFloatingStyles,
    [`${prefix}--popover--${currentAlignment}`]: true,
    [`${prefix}--popover--tab-tip`]: isTabTip
  }, customClassName);
  const mappedChildren = import_react25.default.Children.map(children, (child) => {
    var _a2, _b;
    const item = child;
    const displayName = (_a2 = item == null ? void 0 : item.type) == null ? void 0 : _a2.displayName;
    const isTriggerElement = (item == null ? void 0 : item.type) === "button";
    const isTriggerComponent = enableFloatingStyles && displayName && ["ToggletipButton"].includes(displayName);
    const isAllowedTriggerComponent = enableFloatingStyles && !["ToggletipContent", "PopoverContent"].includes(displayName);
    if (import_react25.default.isValidElement(item) && (isTriggerElement || isTriggerComponent || isAllowedTriggerComponent)) {
      const className2 = (_b = item == null ? void 0 : item.props) == null ? void 0 : _b.className;
      const ref2 = (item == null ? void 0 : item.props).ref;
      const tabTipClasses = (0, import_classnames10.default)(`${prefix}--popover--tab-tip__button`, className2);
      return import_react25.default.cloneElement(item, {
        className: isTabTip && (item == null ? void 0 : item.type) === "button" ? tabTipClasses : className2 || "",
        // With cloneElement, if you pass a `ref`, it overrides the original ref.
        // https://react.dev/reference/react/cloneElement#parameters
        // The block below works around this and ensures that the original ref is still
        // called while allowing the floating-ui reference element to be set as well.
        // `useMergedRefs` can't be used here because hooks can't be called from within a callback.
        // More here: https://github.com/facebook/react/issues/8873#issuecomment-489579878
        ref: (node) => {
          if (enableFloatingStyles && (item == null ? void 0 : item.type) !== PopoverContent || enableFloatingStyles && (item == null ? void 0 : item.type["displayName"]) === "ToggletipButton") {
            refs.setReference(node);
          }
          if (typeof ref2 === "function") {
            ref2(node);
          } else if (ref2 !== null && ref2 !== void 0) {
            ref2.current = node;
          }
        }
      });
    } else {
      return item;
    }
  });
  const BaseComponentAsAny = BaseComponent;
  return import_react25.default.createElement(PopoverContext.Provider, {
    value
  }, import_react25.default.createElement(BaseComponentAsAny, _extends({}, rest, {
    className,
    ref
  }), enableFloatingStyles || isTabTip ? mappedChildren : children));
});
if (true) {
  Popover.displayName = "Popover";
}
Popover.propTypes = {
  /**
   * Specify how the popover should align with the trigger element
   */
  align: deprecateValuesWithin(import_prop_types13.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * **Experimental:** Provide an offset value for alignment axis. Only takes effect when `autoalign` is enabled.
   */
  alignmentAxisOffset: import_prop_types13.default.number,
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types13.default.oneOfType([import_prop_types13.default.string, import_prop_types13.default.elementType]),
  /**
   * Will auto-align the popover on first render if it is not visible. This prop
   * is currently experimental and is subject to future changes. Requires
   * React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types13.default.bool,
  /**
   * Specify a bounding element to be used for autoAlign calculations. The viewport is used by default. This prop is currently experimental and is subject to future changes.
   */
  autoAlignBoundary: import_prop_types13.default.oneOfType([import_prop_types13.default.oneOf(["clippingAncestors"]), import_prop_types13.default.elementType, import_prop_types13.default.arrayOf(import_prop_types13.default.elementType), import_prop_types13.default.exact({
    x: import_prop_types13.default.number.isRequired,
    y: import_prop_types13.default.number.isRequired,
    width: import_prop_types13.default.number.isRequired,
    height: import_prop_types13.default.number.isRequired
  })]),
  /**
   * Specify whether a caret should be rendered
   */
  caret: import_prop_types13.default.bool,
  /**
   * Provide elements to be rendered inside of the component
   */
  children: import_prop_types13.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types13.default.string,
  /**
   * Specify whether a drop shadow should be rendered on the popover
   */
  dropShadow: import_prop_types13.default.bool,
  /**
   * Render the component using the high-contrast variant
   */
  highContrast: import_prop_types13.default.bool,
  /**
   * Render the component using the tab tip variant
   */
  isTabTip: import_prop_types13.default.bool,
  /**
   * Specify a handler for closing popover.
   * The handler should take care of closing the popover, e.g. changing the `open` prop.
   */
  onRequestClose: import_prop_types13.default.func,
  /**
   * Specify whether the component is currently open or closed
   */
  open: import_prop_types13.default.bool.isRequired
};
function PopoverContentRenderFunction({
  className,
  children,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const {
    setFloating,
    caretRef,
    autoAlign
  } = import_react25.default.useContext(PopoverContext);
  const ref = useMergedRefs([setFloating, forwardRef36]);
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  return import_react25.default.createElement("span", _extends({}, rest, {
    className: `${prefix}--popover`
  }), import_react25.default.createElement("span", {
    className: (0, import_classnames10.default)(`${prefix}--popover-content`, className),
    ref
  }, children, enableFloatingStyles && import_react25.default.createElement("span", {
    className: (0, import_classnames10.default)({
      [`${prefix}--popover-caret`]: true,
      [`${prefix}--popover--auto-align`]: true
    }),
    ref: caretRef
  })), !enableFloatingStyles && import_react25.default.createElement("span", {
    className: (0, import_classnames10.default)({
      [`${prefix}--popover-caret`]: true
    }),
    ref: caretRef
  }));
}
var PopoverContent = import_react25.default.forwardRef(PopoverContentRenderFunction);
PopoverContent.displayName = "PopoverContent";
PopoverContent.propTypes = {
  /**
   * Provide elements to be rendered inside of the component
   */
  children: import_prop_types13.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types13.default.string
};

// node_modules/@carbon/react/es/components/Tooltip/DefinitionTooltip.js
var DefinitionTooltip = ({
  align = "bottom",
  autoAlign,
  className,
  children,
  definition,
  defaultOpen = false,
  id,
  openOnHover,
  tooltipText,
  triggerClassName,
  ...rest
}) => {
  const [isOpen, setOpen] = (0, import_react27.useState)(defaultOpen);
  const prefix = usePrefix();
  const tooltipId = useFallbackId(id);
  function onKeyDown(event) {
    if (isOpen && match(event, Escape)) {
      event.stopPropagation();
      setOpen(false);
    }
  }
  return import_react27.default.createElement(Popover, {
    align,
    className,
    autoAlign,
    dropShadow: false,
    highContrast: true,
    onMouseLeave: () => {
      setOpen(false);
    },
    onMouseEnter: () => {
      openOnHover ? setOpen(true) : null;
    },
    onFocus: () => {
      setOpen(true);
    },
    open: isOpen
  }, import_react27.default.createElement("button", _extends({}, rest, {
    className: (0, import_classnames11.default)(`${prefix}--definition-term`, triggerClassName),
    "aria-controls": tooltipId,
    "aria-describedby": tooltipId,
    "aria-expanded": isOpen,
    onBlur: () => {
      setOpen(false);
    },
    onMouseDown: (event) => {
      if (event.button === 0) setOpen(!isOpen);
    },
    onKeyDown,
    type: "button"
  }), children), import_react27.default.createElement(PopoverContent, {
    className: `${prefix}--definition-tooltip`,
    id: tooltipId
  }, tooltipText ?? definition));
};
DefinitionTooltip.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: import_prop_types14.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]),
  /**
   * Will auto-align the popover. This prop is currently experimental and is
   * subject to future changes. Requires React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types14.default.bool,
  /**
   * The `children` prop will be used as the value that is being defined
   */
  children: import_prop_types14.default.node.isRequired,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types14.default.string,
  /**
   * Specify whether the tooltip should be open when it first renders
   */
  defaultOpen: import_prop_types14.default.bool,
  /**
   * The `definition` prop is used as the content inside of the tooltip that
   * appears when a user interacts with the element rendered by the `children`
   * prop
   */
  definition: import_prop_types14.default.node.isRequired,
  /**
   * Provide a value that will be assigned as the id of the tooltip
   */
  id: import_prop_types14.default.string,
  /**
   * Specifies whether or not the `DefinitionTooltip` should open on hover or not
   */
  openOnHover: import_prop_types14.default.bool,
  /**
   * [Deprecated in v11] Please use the `definition` prop instead.
   *
   * Provide the text that will be displayed in the tooltip when it is rendered.
   */
  tooltipText: deprecate(import_prop_types14.default.node, "The tooltipText prop has been deprecated. Please use the `definition` prop instead."),
  /**
   * The CSS class name of the trigger element
   */
  triggerClassName: import_prop_types14.default.string
};

// node_modules/@carbon/react/es/components/Tooltip/Tooltip.js
var import_classnames12 = __toESM(require_classnames());
var import_prop_types15 = __toESM(require_prop_types());
var import_react30 = __toESM(require_react());

// node_modules/@carbon/react/es/internal/useDelayedState.js
var import_react28 = __toESM(require_react());
function useDelayedState(initialState) {
  const [state, setState] = (0, import_react28.useState)(initialState);
  const timeoutId = (0, import_react28.useRef)(null);
  const setStateWithDelay = (0, import_react28.useCallback)((stateToSet, delayMs = 0) => {
    window.clearTimeout(timeoutId.current ?? void 0);
    timeoutId.current = null;
    if (delayMs === 0) {
      setState(stateToSet);
      return;
    }
    timeoutId.current = window.setTimeout(() => {
      setState(stateToSet);
      timeoutId.current = null;
    }, delayMs);
  }, []);
  (0, import_react28.useEffect)(() => {
    return () => {
      window.clearTimeout(timeoutId.current ?? void 0);
    };
  }, []);
  return [state, setStateWithDelay];
}

// node_modules/@carbon/react/es/internal/useNoInteractiveChildren.js
var import_react29 = __toESM(require_react());
var useNoInteractiveChildren = (ref, message = "component should have no interactive child nodes") => {
  if (true) {
    (0, import_react29.useEffect)(() => {
      const node = ref.current ? getInteractiveContent(ref.current) : false;
      if (node) {
        const errorMessage = `Error: ${message}.

Instead found: ${node.outerHTML}`;
        console.error(errorMessage);
        throw new Error(errorMessage);
      }
    }, []);
  }
};
var useInteractiveChildrenNeedDescription = (ref, message = `interactive child node(s) should have an \`aria-describedby\` property`) => {
  if (true) {
    (0, import_react29.useEffect)(() => {
      const node = ref.current ? getInteractiveContent(ref.current) : false;
      if (node && !node.hasAttribute("aria-describedby")) {
        throw new Error(`Error: ${message}.

Instead found: ${node.outerHTML}`);
      }
    });
  }
};
var getInteractiveContent = (node) => {
  if (!node || !node.childNodes) {
    return null;
  }
  if (isFocusable(node)) {
    return node;
  }
  for (const childNode of node.childNodes) {
    if (childNode instanceof HTMLElement) {
      const interactiveNode = getInteractiveContent(childNode);
      if (interactiveNode) {
        return interactiveNode;
      }
    }
  }
  return null;
};
var getRoleContent = (node) => {
  if (!node || !node.childNodes) {
    return null;
  }
  if (node.getAttribute("role") && node.getAttribute("role") !== "") {
    return node;
  }
  for (const childNode of node.childNodes) {
    if (childNode instanceof HTMLElement) {
      const roleNode = getRoleContent(childNode);
      if (roleNode) {
        return roleNode;
      }
    }
  }
  return null;
};
var isFocusable = (element) => {
  if (element.tabIndex === void 0 || element.tabIndex < 0) {
    return false;
  }
  if (element instanceof HTMLButtonElement || element instanceof HTMLInputElement || element instanceof HTMLSelectElement || element instanceof HTMLTextAreaElement) {
    if (element.disabled) {
      return false;
    }
  }
  switch (element.nodeName) {
    case "A":
      return element instanceof HTMLAnchorElement && !!element.href && element.rel !== "ignore";
    case "INPUT":
      return element instanceof HTMLInputElement && element.type !== "hidden";
    default:
      return true;
  }
};

// node_modules/@carbon/react/es/components/Tooltip/Tooltip.js
var DRAG_STOP_EVENT_TYPES = /* @__PURE__ */ new Set(["mouseup", "touchend", "touchcancel"]);
var Tooltip = import_react30.default.forwardRef(({
  as,
  align = "top",
  className: customClassName,
  children,
  label,
  description,
  enterDelayMs = 100,
  leaveDelayMs = 300,
  defaultOpen = false,
  closeOnActivation = false,
  dropShadow = false,
  highContrast = true,
  ...rest
}, ref) => {
  const tooltipRef = (0, import_react30.useRef)(null);
  const [open2, setOpen] = useDelayedState(defaultOpen);
  const [isDragging, setIsDragging] = (0, import_react30.useState)(false);
  const [focusByMouse, setFocusByMouse] = (0, import_react30.useState)(false);
  const [isPointerIntersecting, setIsPointerIntersecting] = (0, import_react30.useState)(false);
  const id = useId("tooltip");
  const prefix = usePrefix();
  const child = import_react30.default.Children.only(children);
  const {
    "aria-labelledby": ariaLabelledBy,
    "aria-describedby": ariaDescribedBy
  } = (child == null ? void 0 : child.props) ?? {};
  const hasLabel = !!label;
  const labelledBy = ariaLabelledBy ?? (hasLabel ? id : void 0);
  const describedBy = ariaDescribedBy ?? (!hasLabel ? id : void 0);
  const triggerProps = {
    onFocus: () => !focusByMouse && setOpen(true),
    onBlur: () => {
      setOpen(false);
      setFocusByMouse(false);
    },
    onClick: () => closeOnActivation && setOpen(false),
    // This should be placed on the trigger in case the element is disabled
    onMouseEnter,
    onMouseLeave,
    onMouseDown,
    onMouseMove,
    onTouchStart: onDragStart,
    "aria-labelledby": labelledBy,
    "aria-describedby": describedBy
  };
  function getChildEventHandlers(childProps) {
    const eventHandlerFunctions = Object.keys(triggerProps).filter((prop) => prop.startsWith("on"));
    const eventHandlers = {};
    eventHandlerFunctions.forEach((functionName) => {
      eventHandlers[functionName] = (evt) => {
        triggerProps[functionName](evt);
        if (childProps == null ? void 0 : childProps[functionName]) {
          childProps == null ? void 0 : childProps[functionName](evt);
        }
      };
    });
    return eventHandlers;
  }
  const onKeyDown = (0, import_react30.useCallback)((event) => {
    if (open2 && match(event, Escape)) {
      event.stopPropagation();
      setOpen(false);
    }
    if (open2 && closeOnActivation && (match(event, Enter) || match(event, Space))) {
      setOpen(false);
    }
  }, [closeOnActivation, open2, setOpen]);
  useIsomorphicEffect(() => {
    if (!open2) {
      return void 0;
    }
    function handleKeyDown(event) {
      if (match(event, Escape)) {
        onKeyDown(event);
      }
    }
    document.addEventListener("keydown", handleKeyDown);
    return () => {
      document.removeEventListener("keydown", handleKeyDown);
    };
  }, [open2, onKeyDown]);
  function onMouseEnter() {
    if (!(rest == null ? void 0 : rest.onMouseEnter)) {
      setIsPointerIntersecting(true);
      setOpen(true, enterDelayMs);
    }
  }
  function onMouseDown() {
    setFocusByMouse(true);
    onDragStart();
  }
  function onMouseLeave() {
    setIsPointerIntersecting(false);
    if (isDragging) {
      return;
    }
    setOpen(false, leaveDelayMs);
  }
  function onMouseMove(evt) {
    if (evt.buttons === 1) {
      setIsDragging(true);
    } else {
      setIsDragging(false);
    }
  }
  function onDragStart() {
    setIsDragging(true);
  }
  const onDragStop = (0, import_react30.useCallback)(() => {
    setIsDragging(false);
    if (!isPointerIntersecting) {
      setOpen(false, leaveDelayMs);
    }
  }, [isPointerIntersecting, leaveDelayMs, setOpen]);
  useNoInteractiveChildren(tooltipRef, "The Tooltip component must have no interactive content rendered by the`label` or `description` prop");
  (0, import_react30.useEffect)(() => {
    if (isDragging) {
      DRAG_STOP_EVENT_TYPES.forEach((eventType) => {
        document.addEventListener(eventType, onDragStop);
      });
    }
    return () => {
      DRAG_STOP_EVENT_TYPES.forEach((eventType) => {
        document.removeEventListener(eventType, onDragStop);
      });
    };
  }, [isDragging, onDragStop]);
  return import_react30.default.createElement(Popover, _extends({
    as,
    ref
  }, rest, {
    align,
    className: (0, import_classnames12.default)(`${prefix}--tooltip`, customClassName),
    dropShadow,
    highContrast,
    onKeyDown,
    onMouseLeave,
    open: open2
  }), import_react30.default.createElement("div", {
    className: `${prefix}--tooltip-trigger__wrapper`
  }, typeof child !== "undefined" ? import_react30.default.cloneElement(child, {
    ...triggerProps,
    ...getChildEventHandlers(child.props)
  }) : null), import_react30.default.createElement(PopoverContent, {
    "aria-hidden": open2 ? "false" : "true",
    className: `${prefix}--tooltip-content`,
    id,
    onMouseEnter,
    role: "tooltip"
  }, label || description));
});
Tooltip.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: import_prop_types15.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]),
  /**
   * Pass in the child to which the tooltip will be applied
   */
  children: import_prop_types15.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types15.default.string,
  /**
   * Determines wether the tooltip should close when inner content is activated (click, Enter or Space)
   */
  closeOnActivation: import_prop_types15.default.bool,
  /**
   * Specify whether the tooltip should be open when it first renders
   */
  defaultOpen: import_prop_types15.default.bool,
  /**
   * Provide the description to be rendered inside of the Tooltip. The
   * description will use `aria-describedby` and will describe the child node
   * in addition to the text rendered inside of the child. This means that if you
   * have text in the child node, that it will be announced alongside the
   * description to the screen reader.
   *
   * Note: if label and description are both provided, label will be used and
   * description will not be used
   */
  description: import_prop_types15.default.node,
  /**
   * Specify whether a drop shadow should be rendered
   */
  dropShadow: import_prop_types15.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip
   */
  enterDelayMs: import_prop_types15.default.number,
  /**
   * Render the component using the high-contrast theme
   */
  highContrast: import_prop_types15.default.bool,
  /**
   * Provide the label to be rendered inside of the Tooltip. The label will use
   * `aria-labelledby` and will fully describe the child node that is provided.
   * This means that if you have text in the child node, that it will not be
   * announced to the screen reader.
   *
   * Note: if label and description are both provided, description will not be
   * used
   */
  label: import_prop_types15.default.node,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types15.default.number
};

// node_modules/@carbon/react/es/components/Button/ButtonBase.js
var import_react31 = __toESM(require_react());
var import_classnames13 = __toESM(require_classnames());
var ButtonBase = import_react31.default.forwardRef(function ButtonBase2({
  as,
  children,
  className,
  dangerDescription = "danger",
  disabled = false,
  hasIconOnly = false,
  href,
  iconDescription,
  isExpressive = false,
  isSelected,
  kind = "primary",
  onBlur,
  onClick,
  onFocus,
  onMouseEnter,
  onMouseLeave,
  renderIcon: ButtonImageElement,
  size: size4,
  tabIndex,
  type = "button",
  ...rest
}, ref) {
  const prefix = usePrefix();
  const buttonClasses = (0, import_classnames13.default)(className, {
    [`${prefix}--btn`]: true,
    [`${prefix}--btn--xs`]: size4 === "xs" && !isExpressive,
    // TODO: V12 - Remove this class
    [`${prefix}--btn--sm`]: size4 === "sm" && !isExpressive,
    // TODO: V12 - Remove this class
    [`${prefix}--btn--md`]: size4 === "md" && !isExpressive,
    // TODO: V12 - Remove this class
    [`${prefix}--btn--lg`]: size4 === "lg" && !isExpressive,
    // TODO: V12 - Remove this class
    [`${prefix}--btn--xl`]: size4 === "xl",
    // TODO: V12 - Remove this class
    [`${prefix}--btn--2xl`]: size4 === "2xl",
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4,
    [`${prefix}--btn--${kind}`]: kind,
    [`${prefix}--btn--disabled`]: disabled,
    [`${prefix}--btn--expressive`]: isExpressive,
    [`${prefix}--btn--icon-only`]: hasIconOnly,
    [`${prefix}--btn--selected`]: hasIconOnly && isSelected && kind === "ghost"
  });
  const commonProps = {
    tabIndex,
    className: buttonClasses,
    ref
  };
  const buttonImage = !ButtonImageElement ? null : import_react31.default.createElement(ButtonImageElement, {
    "aria-label": iconDescription,
    className: `${prefix}--btn__icon`,
    "aria-hidden": "true"
  });
  const dangerButtonVariants = ["danger", "danger--tertiary", "danger--ghost"];
  let component = "button";
  const assistiveId = useId("danger-description");
  const {
    "aria-pressed": ariaPressed,
    "aria-describedby": ariaDescribedBy
  } = rest;
  let otherProps = {
    disabled,
    type,
    "aria-describedby": dangerButtonVariants.includes(kind) ? assistiveId : ariaDescribedBy || void 0,
    "aria-pressed": ariaPressed ?? (hasIconOnly && kind === "ghost" ? isSelected : void 0)
  };
  const anchorProps = {
    href
  };
  let assistiveText = null;
  if (dangerButtonVariants.includes(kind)) {
    assistiveText = import_react31.default.createElement("span", {
      id: assistiveId,
      className: `${prefix}--visually-hidden`
    }, dangerDescription);
  }
  if (as) {
    component = as;
    otherProps = {
      ...otherProps,
      ...anchorProps
    };
  } else if (href && !disabled) {
    component = "a";
    otherProps = anchorProps;
  }
  return import_react31.default.createElement(component, {
    onMouseEnter,
    onMouseLeave,
    onFocus,
    onBlur,
    onClick,
    ...rest,
    ...commonProps,
    ...otherProps
  }, assistiveText, children, buttonImage);
});

// node_modules/@carbon/react/es/components/BadgeIndicator/index.js
var import_prop_types16 = __toESM(require_prop_types());
var import_react32 = __toESM(require_react());
var import_classnames14 = __toESM(require_classnames());
var BadgeIndicator = import_react32.default.forwardRef(function BadgeIndicatorContent({
  className: customClassName,
  count: count2,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames14.default)(`${prefix}--badge-indicator`, customClassName, {
    [`${prefix}--badge-indicator--count`]: count2
  });
  const displayCount = count2 && count2 > 999 ? "999+" : count2;
  return import_react32.default.createElement("div", _extends({
    className: classNames,
    ref
  }, rest), displayCount);
});
BadgeIndicator.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types16.default.string,
  /**
   * Count of badge indicator
   */
  count: import_prop_types16.default.number,
  /**
   * Provide an `id` to uniquely identify the BadgeIndidcator
   */
  id: import_prop_types16.default.string
};

// node_modules/@carbon/react/es/components/IconButton/index.js
var IconButtonKinds = ["primary", "secondary", "ghost", "tertiary"];
var IconButton = import_react33.default.forwardRef(function IconButton2({
  align,
  autoAlign = false,
  badgeCount,
  children,
  className,
  closeOnActivation = true,
  defaultOpen = false,
  disabled,
  dropShadow = false,
  enterDelayMs = 100,
  highContrast = true,
  kind,
  label,
  leaveDelayMs = 100,
  wrapperClasses,
  size: size4,
  isSelected,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const tooltipClasses = (0, import_classnames15.default)(wrapperClasses, `${prefix}--icon-tooltip`, {
    [`${prefix}--icon-tooltip--disabled`]: disabled
  });
  if (badgeCount && (kind !== "ghost" || size4 !== "lg")) {
    console.warn("The prop BadgeCount must be used with hasIconOnly=true, kind='ghost' and size='lg'");
  }
  const badgeId = useId("badge-indicator");
  return import_react33.default.createElement(Tooltip, {
    align,
    autoAlign,
    closeOnActivation,
    className: tooltipClasses,
    defaultOpen,
    dropShadow,
    enterDelayMs,
    highContrast,
    label,
    leaveDelayMs
  }, import_react33.default.createElement(ButtonBase, _extends({}, rest, {
    disabled,
    kind,
    ref,
    size: size4,
    isSelected,
    hasIconOnly: true,
    className,
    "aria-describedby": rest["aria-describedby"] || badgeCount && badgeId
  }), children, !disabled && badgeCount !== void 0 && import_react33.default.createElement(BadgeIndicator, {
    id: badgeId,
    count: badgeCount > 0 ? badgeCount : void 0
  })));
});
IconButton.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(import_prop_types17.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip. Requires
   * React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types17.default.bool,
  /**
   * **Experimental**: Display a badge on the button. An empty/dot badge if 0, a numbered badge if > 0.
   * Must be used with size="lg", kind="ghost" and hasIconOnly=true
   */
  badgeCount: import_prop_types17.default.number,
  /**
   * Optionally specify an href for your IconButton to become an `<a>` element
   */
  href: import_prop_types17.default.string,
  /**
   * Provide an icon or asset to be rendered inside of the IconButton
   */
  children: import_prop_types17.default.node,
  /**
   * Specify an optional className to be added to your Button
   */
  className: import_prop_types17.default.string,
  /**
   * Determines whether the tooltip should close when inner content is activated (click, Enter or Space)
   */
  closeOnActivation: import_prop_types17.default.bool,
  /**
   * Specify whether the tooltip should be open when it first renders
   */
  defaultOpen: import_prop_types17.default.bool,
  /**
   * Specify whether a drop shadow should be rendered on the tooltip
   */
  dropShadow: import_prop_types17.default.bool,
  /**
   * Specify whether the Button should be disabled, or not
   */
  disabled: import_prop_types17.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip
   */
  enterDelayMs: import_prop_types17.default.number,
  /**
   * Specify whether the IconButton is currently selected
   */
  isSelected: import_prop_types17.default.bool,
  /**
   * Render the tooltip using the high-contrast theme
   */
  highContrast: import_prop_types17.default.bool,
  /**
   * Specify the type of button to be used as the base for the IconButton
   */
  kind: import_prop_types17.default.oneOf(IconButtonKinds),
  /**
   * Provide the label to be rendered inside of the Tooltip. The label will use
   * `aria-labelledby` and will fully describe the child node that is provided.
   * This means that if you have text in the child node it will not be
   * announced to the screen reader.
   * If using `badgeCount={0}`, make sure the label explains that there is a
   * new notification.
   */
  label: import_prop_types17.default.node.isRequired,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types17.default.number,
  /**
   * Optionally specify a `rel` when using an `<a>` element.
   */
  rel: import_prop_types17.default.string,
  /**
   * Specify the size of the Button.
   */
  size: import_prop_types17.default.oneOf(["sm", "md", "lg"]),
  /**
   * Optionally specify a `target` when using an `<a>` element.
   */
  target: import_prop_types17.default.string,
  /**
   * Specify an optional className to be added to your Tooltip wrapper
   */
  wrapperClasses: import_prop_types17.default.string
};

// node_modules/@carbon/react/es/components/Button/Button.js
var ButtonKinds = ["primary", "secondary", "danger", "ghost", "danger--primary", "danger--ghost", "danger--tertiary", "tertiary"];
var ButtonSizes = ["xs", "sm", "md", "lg", "xl", "2xl"];
var ButtonTooltipAlignments = ["start", "center", "end"];
var ButtonTooltipPositions = ["top", "right", "bottom", "left"];
function isIconOnlyButton(hasIconOnly, _kind) {
  if (hasIconOnly === true) {
    return true;
  }
  return false;
}
var Button = import_react34.default.forwardRef((props, ref) => {
  const {
    as,
    autoAlign = false,
    children,
    hasIconOnly = false,
    tooltipHighContrast = true,
    tooltipDropShadow = false,
    iconDescription,
    kind = "primary",
    onBlur,
    onClick,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    renderIcon: ButtonImageElement,
    size: size4,
    tooltipAlignment = "center",
    tooltipPosition = "top",
    ...rest
  } = props;
  if (ButtonImageElement && !children && !iconDescription) {
    console.error("Button: renderIcon property specified without also providing an iconDescription property. This may impact accessibility for screen reader users.");
  }
  const iconOnlyImage = !ButtonImageElement ? null : import_react34.default.createElement(ButtonImageElement, null);
  if (!isIconOnlyButton(hasIconOnly)) {
    const {
      tooltipAlignment: tooltipAlignment2,
      ...propsWithoutTooltipAlignment
    } = props;
    return import_react34.default.createElement(ButtonBase, _extends({
      ref
    }, propsWithoutTooltipAlignment));
  } else {
    let align = void 0;
    if (tooltipPosition === "top" || tooltipPosition === "bottom") {
      if (tooltipAlignment === "center") {
        align = tooltipPosition;
      }
      if (tooltipAlignment === "end") {
        align = `${tooltipPosition}-end`;
      }
      if (tooltipAlignment === "start") {
        align = `${tooltipPosition}-start`;
      }
    }
    if (tooltipPosition === "right" || tooltipPosition === "left") {
      align = tooltipPosition;
    }
    return (
      // @ts-expect-error - `IconButton` does not support all `size`s that
      // `Button` supports.
      //
      // TODO: What should be done here?
      // 1. Should the `IconButton` not be rendered if the `size` is not
      //    supported?
      // 2. Should an error be thrown?
      // 3. Something else?
      import_react34.default.createElement(IconButton, _extends({}, rest, {
        ref,
        as,
        align,
        label: iconDescription,
        kind,
        size: size4,
        highContrast: tooltipHighContrast,
        dropShadow: tooltipDropShadow,
        onMouseEnter,
        onMouseLeave,
        onFocus,
        onBlur,
        autoAlign,
        onClick,
        renderIcon: iconOnlyImage ? null : ButtonImageElement
        // avoid doubling the icon.
      }), iconOnlyImage ?? children)
    );
  }
});
Button.displayName = "Button";
Button.propTypes = {
  /**
   * Specify how the button itself should be rendered.
   * Make sure to apply all props to the root node and render children appropriately
   */
  as: import_prop_types18.default.oneOfType([import_prop_types18.default.func, import_prop_types18.default.string, import_prop_types18.default.elementType]),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip. Requires
   * React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types18.default.bool,
  /**
   * Specify the content of your Button
   */
  children: import_prop_types18.default.node,
  /**
   * Specify an optional className to be added to your Button
   */
  className: import_prop_types18.default.string,
  /**
   * Specify the message read by screen readers for the danger button variant
   */
  dangerDescription: import_prop_types18.default.string,
  /**
   * Specify whether the Button should be disabled, or not
   */
  disabled: import_prop_types18.default.bool,
  /**
   * Specify if the button is an icon-only button
   */
  hasIconOnly: import_prop_types18.default.bool,
  /**
   * Optionally specify an href for your Button to become an `<a>` element
   */
  href: import_prop_types18.default.string,
  /**
   * If specifying the `renderIcon` prop, provide a description for that icon that can
   * be read by screen readers
   */
  iconDescription: (props) => {
    if (props.renderIcon && !props.children && !props.iconDescription) {
      return new Error("renderIcon property specified without also providing an iconDescription property.");
    }
    return null;
  },
  /**
   * Specify whether the Button is expressive, or not
   */
  isExpressive: import_prop_types18.default.bool,
  /**
   * Specify whether the Button is currently selected. Only applies to the Ghost variant.
   */
  isSelected: import_prop_types18.default.bool,
  /**
   * Specify the kind of Button you want to create
   */
  kind: (props, propName, componentName) => {
    const {
      hasIconOnly
    } = props;
    const validKinds = hasIconOnly ? IconButtonKinds : ButtonKinds;
    if (props[propName] === void 0) {
      return null;
    }
    if (!validKinds.includes(props[propName])) {
      return new Error(`Invalid prop \`${propName}\` supplied to \`${componentName}\`. Expected one of ${validKinds.join(", ")}.`);
    }
    return null;
  },
  /**
   * Provide an optional function to be called when the button element
   * loses focus
   */
  onBlur: import_prop_types18.default.func,
  /**
   * Provide an optional function to be called when the button element
   * is clicked
   */
  onClick: import_prop_types18.default.func,
  /**
   * Provide an optional function to be called when the button element
   * receives focus
   */
  onFocus: import_prop_types18.default.func,
  /**
   * Provide an optional function to be called when the mouse
   * enters the button element
   */
  onMouseEnter: import_prop_types18.default.func,
  /**
   * Provide an optional function to be called when the mouse
   * leaves the button element
   */
  onMouseLeave: import_prop_types18.default.func,
  /**
   * Optionally specify a `rel` when using an `<a>` element.
   */
  rel: import_prop_types18.default.string,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types18.default.oneOfType([import_prop_types18.default.func, import_prop_types18.default.object]),
  /**
   * Optional prop to specify the role of the Button
   */
  role: import_prop_types18.default.string,
  /**
   * Specify the size of the button, from the following list of sizes:
   */
  size: import_prop_types18.default.oneOf(["xs", "sm", "md", "lg", "xl", "2xl"]),
  /**
   * Optional prop to specify the tabIndex of the Button
   */
  tabIndex: import_prop_types18.default.number,
  /**
   * Optionally specify a `target` when using an `<a>` element.
   */
  target: import_prop_types18.default.string,
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types18.default.oneOf(["start", "center", "end"]),
  /**
   * Enable drop shadow for tooltips for icon-only buttons.
   */
  tooltipDropShadow: import_prop_types18.default.bool,
  /**
   * Enable high-contrast theme for tooltips for icon-only buttons.
   * Defaults to true.
   */
  tooltipHighContrast: import_prop_types18.default.bool,
  /**
   * Specify the direction of the tooltip for icon-only buttons.
   * Can be either top, right, bottom, or left.
   */
  tooltipPosition: import_prop_types18.default.oneOf(["top", "right", "bottom", "left"]),
  /**
   * Optional prop to specify the type of the Button
   */
  type: import_prop_types18.default.oneOf(["button", "reset", "submit"])
};

// node_modules/@carbon/react/es/components/Button/Button.Skeleton.js
var import_prop_types19 = __toESM(require_prop_types());
var import_react35 = __toESM(require_react());
var import_classnames16 = __toESM(require_classnames());
var ButtonSkeleton = ({
  className,
  small = false,
  href,
  size: size4 = "lg",
  ...rest
}) => {
  const prefix = usePrefix();
  const buttonClasses = (0, import_classnames16.default)(className, {
    [`${prefix}--skeleton`]: true,
    [`${prefix}--btn`]: true,
    [`${prefix}--btn--xs`]: size4 === "xs",
    [`${prefix}--btn--sm`]: small || size4 === "sm",
    [`${prefix}--btn--md`]: size4 === "md",
    [`${prefix}--btn--lg`]: size4 === "lg",
    [`${prefix}--btn--xl`]: size4 === "xl",
    [`${prefix}--btn--2xl`]: size4 === "2xl"
  });
  const commonProps = {
    className: buttonClasses,
    ...rest
  };
  const button = import_react35.default.createElement("div", commonProps);
  const anchor = import_react35.default.createElement("a", _extends({}, commonProps, {
    href,
    role: "button"
  }));
  return href ? anchor : button;
};
ButtonSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types19.default.string,
  /**
   * Optionally specify an href for your Button to become an `<a>` element
   */
  href: import_prop_types19.default.string,
  /**
   * Specify the size of the button, from a list of available sizes.
   * For `default` buttons, this prop can remain unspecified or use `default`.
   * In the next major release of Carbon, `default`, `field`, and `small` will be removed
   */
  size: import_prop_types19.default.oneOf(["xs", "sm", "md", "lg", "xl", "2xl"]),
  /**
   * @deprecated This property will be removed in the next major Carbon version,
   * use size={sm} instead.
   *
   * Specify whether the Button should be a small variant
   */
  small: import_prop_types19.default.bool
};

// node_modules/@carbon/react/es/components/ButtonSet/ButtonSet.js
var import_react36 = __toESM(require_react());
var import_prop_types20 = __toESM(require_prop_types());
var import_classnames17 = __toESM(require_classnames());
var ButtonSet = (0, import_react36.forwardRef)((props, ref) => {
  const {
    children,
    className,
    stacked,
    ...rest
  } = props;
  const prefix = usePrefix();
  const buttonSetClasses = (0, import_classnames17.default)(className, `${prefix}--btn-set`, {
    [`${prefix}--btn-set--stacked`]: stacked
  });
  return import_react36.default.createElement("div", _extends({}, rest, {
    className: buttonSetClasses,
    ref
  }), children);
});
ButtonSet.displayName = "ButtonSet";
ButtonSet.propTypes = {
  /**
   * Specify the content of your ButtonSet
   */
  children: import_prop_types20.default.node,
  /**
   * Specify an optional className to be added to your ButtonSet
   */
  className: import_prop_types20.default.string,
  /**
   * Specify the button arrangement of the set (vertically stacked or
   * horizontal)
   */
  stacked: import_prop_types20.default.bool
};

// node_modules/@carbon/react/es/components/Checkbox/Checkbox.js
var import_prop_types23 = __toESM(require_prop_types());
var import_react40 = __toESM(require_react());
var import_classnames20 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/AILabel/index.js
var import_classnames19 = __toESM(require_classnames());
var import_prop_types22 = __toESM(require_prop_types());
var import_react38 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Toggletip/index.js
var import_classnames18 = __toESM(require_classnames());
var import_prop_types21 = __toESM(require_prop_types());
var import_react37 = __toESM(require_react());
function ToggletipLabel({
  as: BaseComponent = "span",
  children,
  className: customClassName,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames18.default)(`${prefix}--toggletip-label`, customClassName);
  const BaseComponentAsAny = BaseComponent;
  return import_react37.default.createElement(BaseComponentAsAny, _extends({
    className
  }, rest), children);
}
ToggletipLabel.propTypes = {
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types21.default.elementType,
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types21.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types21.default.string
};
var ToggletipContext = import_react37.default.createContext(void 0);
function useToggletip() {
  return (0, import_react37.useContext)(ToggletipContext);
}
function Toggletip({
  align,
  as,
  autoAlign,
  className: customClassName,
  children,
  defaultOpen = false,
  ...rest
}) {
  const ref = (0, import_react37.useRef)(null);
  const [open2, setOpen] = (0, import_react37.useState)(defaultOpen);
  const prefix = usePrefix();
  const id = useId();
  const className = (0, import_classnames18.default)(`${prefix}--toggletip`, customClassName, {
    [`${prefix}--toggletip--open`]: open2,
    [`${prefix}--autoalign`]: autoAlign
  });
  const actions = {
    toggle: () => {
      setOpen(!open2);
    },
    close: () => {
      setOpen(false);
    }
  };
  const value = {
    buttonProps: {
      "aria-expanded": open2,
      "aria-controls": id,
      "aria-describedby": open2 ? id : void 0,
      onClick: actions.toggle
    },
    contentProps: {
      id
    },
    onClick: {
      onClick: actions.toggle
    }
  };
  const onKeyDown = (event) => {
    var _a;
    if (open2 && match(event, Escape)) {
      event.stopPropagation();
      actions.close();
      const button = (_a = ref.current) == null ? void 0 : _a.children[0];
      if (button instanceof HTMLButtonElement) {
        button.focus();
      }
    }
  };
  const handleBlur = (event) => {
    if (open2 && event.relatedTarget === null) {
      return;
    }
    if (!event.currentTarget.contains(event.relatedTarget)) {
      actions.close();
    }
  };
  useWindowEvent("blur", () => {
    if (open2) {
      actions.close();
    }
  });
  useWindowEvent("click", ({
    target
  }) => {
    var _a;
    if (open2 && target instanceof Node && !((_a = ref.current) == null ? void 0 : _a.contains(target))) {
      actions.close();
    }
  });
  return import_react37.default.createElement(ToggletipContext.Provider, {
    value
  }, import_react37.default.createElement(Popover, _extends({
    align,
    as,
    caret: true,
    className,
    dropShadow: false,
    highContrast: true,
    open: open2,
    onKeyDown,
    onBlur: handleBlur,
    ref,
    autoAlign
  }, rest), children));
}
var {
  open,
  ...popoverNonOpenPropTypes
} = Popover.propTypes ?? {};
Toggletip.propTypes = {
  // Has all of Popover's PropTypes except for "open".
  ...popoverNonOpenPropTypes,
  /**
   * Specify if the toggletip should be open by default
   */
  defaultOpen: import_prop_types21.default.bool
};
var ToggletipButton = import_react37.default.forwardRef(function ToggletipButton2({
  children,
  className: customClassName,
  label = "Show information",
  as: BaseComponent,
  ...rest
}, ref) {
  const toggletip = useToggletip();
  const prefix = usePrefix();
  const className = (0, import_classnames18.default)(`${prefix}--toggletip-button`, customClassName);
  const ComponentToggle = BaseComponent ?? "button";
  if (ComponentToggle !== "button") {
    return import_react37.default.createElement(ComponentToggle, _extends({}, toggletip == null ? void 0 : toggletip.onClick, {
      className
    }, rest), children);
  }
  return import_react37.default.createElement("button", _extends({}, toggletip == null ? void 0 : toggletip.buttonProps, {
    "aria-label": label,
    type: "button",
    className,
    ref
  }, rest), children);
});
ToggletipButton.propTypes = {
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types21.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types21.default.string,
  /**
   * Provide an accessible label for this button
   */
  label: import_prop_types21.default.string
};
ToggletipButton.displayName = "ToggletipButton";
var ToggletipContent = import_react37.default.forwardRef(function ToggletipContent2({
  children,
  className: customClassName
}, ref) {
  const toggletip = useToggletip();
  const prefix = usePrefix();
  return import_react37.default.createElement(PopoverContent, _extends({
    className: customClassName
  }, toggletip == null ? void 0 : toggletip.contentProps, {
    ref
  }), import_react37.default.createElement("div", {
    className: `${prefix}--toggletip-content`
  }, children));
});
ToggletipContent.propTypes = {
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types21.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types21.default.string
};
ToggletipContent.displayName = "ToggletipContent";
function ToggletipActions({
  children,
  className: customClassName
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames18.default)(`${prefix}--toggletip-actions`, customClassName);
  return import_react37.default.createElement("div", {
    className
  }, children);
}
ToggletipActions.propTypes = {
  /**
   * Custom children to be rendered as the content of the label
   */
  children: import_prop_types21.default.node,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types21.default.string
};

// node_modules/@carbon/react/es/components/AILabel/index.js
var _Undo;
var AILabelContent = import_react38.default.forwardRef(function AILabelContent2({
  className,
  children,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const hasAILabelActions = import_react38.default.Children.toArray(children).some((child) => {
    const item = child;
    item.type === AILabelActions;
  });
  const aiLabelContentClasses = (0, import_classnames19.default)(className, {
    [`${prefix}--ai-label-content`]: true,
    [`${prefix}--ai-label-content--with-actions`]: hasAILabelActions
  });
  return import_react38.default.createElement(ToggletipContent, {
    className: aiLabelContentClasses
  }, children);
});
AILabelContent.displayName = "AILabelContent";
AILabelContent.propTypes = {
  /**
   * Specify the content you want rendered inside the AILabel ToggleTip
   */
  children: import_prop_types22.default.node,
  /**
   * Specify an optional className to be added to the AILabel callout
   */
  className: import_prop_types22.default.string
};
var AILabelActions = import_react38.default.forwardRef(function AILabelActions2({
  className,
  children,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const aiLabelActionsClasses = (0, import_classnames19.default)(className, {
    [`${prefix}--ai-label-actions`]: true
  });
  return import_react38.default.createElement(ToggletipActions, {
    className: aiLabelActionsClasses
  }, children);
});
AILabelActions.displayName = "AILabelActions";
AILabelActions.propTypes = {
  /**
   * Specify the content you want rendered inside the AILabel callout toolbar
   */
  children: import_prop_types22.default.node,
  /**
   * Specify an optional className to be added to the AILabel toolbar
   */
  className: import_prop_types22.default.string
};
var AILabel = import_react38.default.forwardRef(function AILabel2({
  aiText = "AI",
  aiTextLabel,
  textLabel,
  align,
  autoAlign = true,
  children,
  className,
  kind = "default",
  onRevertClick,
  revertActive,
  revertLabel = "Revert to AI input",
  slugLabel = "Show information",
  ["aria-label"]: ariaLabel = "Show information",
  size: size4 = "xs",
  ...rest
}, ref) {
  const prefix = usePrefix();
  const id = useId("AILabel");
  const aiLabelClasses = (0, import_classnames19.default)(className, {
    [`${prefix}--ai-label`]: true,
    [`${prefix}--ai-label--revert`]: revertActive
  });
  const aiLabelButtonClasses = (0, import_classnames19.default)({
    [`${prefix}--ai-label__button`]: true,
    [`${prefix}--ai-label__button--${size4}`]: size4,
    [`${prefix}--ai-label__button--${kind}`]: kind,
    [`${prefix}--ai-label__button--inline-with-content`]: kind === "inline" && (aiTextLabel || textLabel)
  });
  const handleOnRevertClick = (evt) => {
    if (onRevertClick) {
      onRevertClick(evt);
    }
  };
  const ariaLabelText = !aiTextLabel && !textLabel ? `${aiText} ${slugLabel || ariaLabel}` : `${aiText} ${aiTextLabel || textLabel}`;
  const isSmallIcon = ["xs", "2xs", "mini"].includes(size4);
  return import_react38.default.createElement("div", {
    className: aiLabelClasses,
    ref,
    id
  }, revertActive ? import_react38.default.createElement(IconButton, _extends({
    onClick: handleOnRevertClick,
    kind: "ghost",
    size: "sm",
    label: revertLabel
  }, rest), _Undo || (_Undo = import_react38.default.createElement(Undo, null))) : import_react38.default.createElement(Toggletip, _extends({
    align,
    autoAlign,
    alignmentAxisOffset: isSmallIcon ? -24 : 0
  }, rest), import_react38.default.createElement(ToggletipButton, {
    className: aiLabelButtonClasses,
    label: kind === "inline" ? "" : ariaLabelText
  }, import_react38.default.createElement("span", {
    className: `${prefix}--ai-label__text`
  }, aiText), kind === "inline" && (aiTextLabel || textLabel) && import_react38.default.createElement("span", {
    className: `${prefix}--ai-label__additional-text`
  }, aiTextLabel || textLabel)), children));
});
AILabel.displayName = "AILabel";
AILabel.propTypes = {
  ...Toggletip.propTypes,
  /**
   * Specify the content you want rendered inside the `AILabel` ToggleTip
   */
  AILabelContent: import_prop_types22.default.node,
  /**
   * Specify the correct translation of the AI text
   */
  aiText: import_prop_types22.default.string,
  /**
   * @deprecated
   * Specify additional text to be rendered next to the AI label in the inline variant
   */
  aiTextLabel: deprecate(import_prop_types22.default.string, "`aiTextLabel` on `AILabel` has been deprecated - Please use the `textLabel` prop instead"),
  /**
   * Specify the text that will be provided to the aria-label of the `AILabel` button
   */
  "aria-label": import_prop_types22.default.string,
  /**
   * Specify the type of `AILabel`, from the following list of types:
   */
  kind: import_prop_types22.default.oneOf(["default", "inline"]),
  /**
   * Callback function that fires when the revert button is clicked
   */
  onRevertClick: import_prop_types22.default.func,
  /**
   * Specify whether the revert button should be visible
   */
  revertActive: import_prop_types22.default.bool,
  /**
   * Specify the text that should be shown when the revert button is hovered
   */
  revertLabel: import_prop_types22.default.string,
  /**
   * Specify the size of the button, from the following list of sizes:
   */
  size: import_prop_types22.default.oneOf(["mini", "2xs", "xs", "sm", "md", "lg", "xl"]),
  /**
   * @deprecated
   * Specify the text that will be provided to the aria-label of the `AILabel` button
   */
  slugLabel: deprecate(import_prop_types22.default.string, "`slugLabel` on `AILabel` has been deprecated - Please use the `ariaLabel` prop instead"),
  /**
   * Specify additional text to be rendered next to the AI label in the inline variant
   */
  textLabel: import_prop_types22.default.string
};

// node_modules/@carbon/react/es/internal/utils.js
var import_react39 = __toESM(require_react());
var isComponentElement = (element, component) => (0, import_react39.isValidElement)(element) && element.type === component;

// node_modules/@carbon/react/es/components/Checkbox/Checkbox.js
var Checkbox2 = import_react40.default.forwardRef(({
  className,
  decorator,
  helperText,
  id,
  labelText,
  onChange = noopFn,
  onClick,
  indeterminate = false,
  invalid,
  invalidText,
  hideLabel,
  readOnly,
  title = "",
  warn: warn2,
  warnText,
  slug,
  ...other
}, ref) => {
  const prefix = usePrefix();
  const showWarning = !readOnly && !invalid && warn2;
  const showHelper = !invalid && !warn2;
  const checkboxGroupInstanceId = useId();
  const helperId = !helperText ? void 0 : `checkbox-helper-text-${checkboxGroupInstanceId}`;
  const helper = helperText ? import_react40.default.createElement("div", {
    id: helperId,
    className: `${prefix}--form__helper-text`
  }, helperText) : null;
  const wrapperClasses = (0, import_classnames20.default)(`${prefix}--form-item`, `${prefix}--checkbox-wrapper`, className, {
    [`${prefix}--checkbox-wrapper--readonly`]: readOnly,
    [`${prefix}--checkbox-wrapper--invalid`]: !readOnly && invalid,
    [`${prefix}--checkbox-wrapper--warning`]: showWarning,
    [`${prefix}--checkbox-wrapper--slug`]: slug,
    [`${prefix}--checkbox-wrapper--decorator`]: decorator
  });
  const innerLabelClasses = (0, import_classnames20.default)(`${prefix}--checkbox-label-text`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react40.cloneElement)(candidate, {
    size: candidate.props.kind === "inline" ? "md" : "mini"
  }) : null;
  return import_react40.default.createElement("div", {
    className: wrapperClasses
  }, import_react40.default.createElement("input", _extends({}, other, {
    type: "checkbox",
    "data-invalid": invalid ? true : void 0,
    onChange: (evt) => {
      if (!readOnly && onChange) {
        onChange(evt, {
          checked: evt.target.checked,
          id
        });
      }
    },
    className: `${prefix}--checkbox`,
    id,
    ref: (el) => {
      if (el) {
        el.indeterminate = indeterminate ?? false;
      }
      if (typeof ref === "function") {
        ref(el);
      } else if (ref && "current" in ref) {
        ref.current = el;
      }
    },
    "aria-readonly": readOnly,
    onClick: (evt) => {
      if (readOnly) {
        evt.preventDefault();
      }
      if (onClick) {
        onClick(evt);
      }
    }
  })), import_react40.default.createElement("label", {
    htmlFor: id,
    className: `${prefix}--checkbox-label`,
    title
  }, import_react40.default.createElement(Text, {
    className: innerLabelClasses
  }, labelText, slug ? normalizedDecorator : decorator ? import_react40.default.createElement("div", {
    className: `${prefix}--checkbox-wrapper-inner--decorator`
  }, normalizedDecorator) : "")), import_react40.default.createElement("div", {
    className: `${prefix}--checkbox__validation-msg`
  }, !readOnly && invalid && import_react40.default.createElement(import_react40.default.Fragment, null, import_react40.default.createElement(WarningFilled, {
    className: `${prefix}--checkbox__invalid-icon`
  }), import_react40.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalidText)), showWarning && import_react40.default.createElement(import_react40.default.Fragment, null, import_react40.default.createElement(WarningAltFilled, {
    className: `${prefix}--checkbox__invalid-icon ${prefix}--checkbox__invalid-icon--warning`
  }), import_react40.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, warnText))), showHelper && helper);
});
Checkbox2.propTypes = {
  /**
   * Specify whether the underlying input should be checked
   */
  checked: import_prop_types23.default.bool,
  /**
   * Specify an optional className to be applied to the <label> node
   */
  className: import_prop_types23.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `Checkbox` component
   */
  decorator: import_prop_types23.default.node,
  /**
   * Specify whether the underlying input should be checked by default
   */
  defaultChecked: import_prop_types23.default.bool,
  /**
   * Specify whether the Checkbox should be disabled
   */
  disabled: import_prop_types23.default.bool,
  /**
   * Provide text for the form group for additional help
   */
  helperText: import_prop_types23.default.node,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types23.default.bool,
  /**
   * Provide an `id` to uniquely identify the Checkbox input
   */
  id: import_prop_types23.default.string.isRequired,
  /**
   * Specify whether the Checkbox is in an indeterminate state
   */
  indeterminate: import_prop_types23.default.bool,
  /**
   * Specify whether the Checkbox is currently invalid
   */
  invalid: import_prop_types23.default.bool,
  /**
   * Provide the text that is displayed when the Checkbox is in an invalid state
   */
  invalidText: import_prop_types23.default.node,
  /**
   * Provide a label to provide a description of the Checkbox input that you are
   * exposing to the user
   */
  labelText: import_prop_types23.default.node.isRequired,
  /**
   * Provide an optional handler that is called when the internal state of
   * Checkbox changes. This handler is called with event and state info.
   * `(event, { checked, id }) => void`
   */
  onChange: import_prop_types23.default.func,
  /**
   * Specify whether the Checkbox is read-only
   */
  readOnly: import_prop_types23.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `Checkbox` component
   */
  slug: deprecate(import_prop_types23.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify a title for the <label> node for the Checkbox
   */
  title: import_prop_types23.default.string,
  /**
   * Specify whether the Checkbox is currently in warning state
   */
  warn: import_prop_types23.default.bool,
  /**
   * Provide the text that is displayed when the Checkbox is in warning state
   */
  warnText: import_prop_types23.default.node
};
Checkbox2.displayName = "Checkbox";

// node_modules/@carbon/react/es/components/Checkbox/Checkbox.Skeleton.js
var import_prop_types24 = __toESM(require_prop_types());
var import_react41 = __toESM(require_react());
var import_classnames21 = __toESM(require_classnames());
var CheckboxSkeleton = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  return import_react41.default.createElement("div", _extends({
    className: (0, import_classnames21.default)(`${prefix}--form-item`, `${prefix}--checkbox-wrapper`, `${prefix}--checkbox-skeleton`, className)
  }, rest), import_react41.default.createElement("div", {
    className: `${prefix}--checkbox-label`
  }, import_react41.default.createElement("span", {
    className: `${prefix}--checkbox-label-text ${prefix}--skeleton`
  })));
};
CheckboxSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types24.default.string
};

// node_modules/@carbon/react/es/components/CheckboxGroup/CheckboxGroup.js
var import_prop_types25 = __toESM(require_prop_types());
var import_react42 = __toESM(require_react());
var import_classnames22 = __toESM(require_classnames());
var CheckboxGroup = ({
  children,
  className,
  decorator,
  helperText,
  invalid,
  invalidText,
  legendId,
  legendText,
  readOnly,
  warn: warn2,
  warnText,
  slug,
  orientation = "vertical",
  ...rest
}) => {
  const prefix = usePrefix();
  const showWarning = !readOnly && !invalid && warn2;
  const showHelper = !invalid && !warn2;
  const checkboxGroupInstanceId = useId();
  const helperId = !helperText ? void 0 : `checkbox-group-helper-text-${checkboxGroupInstanceId}`;
  const helper = helperText ? import_react42.default.createElement("div", {
    id: helperId,
    className: `${prefix}--form__helper-text`
  }, helperText) : null;
  const fieldsetClasses = (0, import_classnames22.default)(`${prefix}--checkbox-group`, className, {
    [`${prefix}--checkbox-group--${orientation}`]: orientation === "horizontal",
    [`${prefix}--checkbox-group--readonly`]: readOnly,
    [`${prefix}--checkbox-group--invalid`]: !readOnly && invalid,
    [`${prefix}--checkbox-group--warning`]: showWarning,
    [`${prefix}--checkbox-group--slug`]: slug,
    [`${prefix}--checkbox-group--decorator`]: decorator
  });
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react42.cloneElement)(candidate, {
    size: "mini",
    kind: "default"
  }) : null;
  return import_react42.default.createElement("fieldset", _extends({
    className: fieldsetClasses,
    "data-invalid": invalid ? true : void 0,
    "aria-labelledby": rest["aria-labelledby"] || legendId,
    "aria-readonly": readOnly,
    "aria-describedby": !invalid && !warn2 && helper ? helperId : void 0
  }, rest), import_react42.default.createElement("legend", {
    className: `${prefix}--label`,
    id: legendId || rest["aria-labelledby"]
  }, legendText, slug ? normalizedDecorator : decorator ? import_react42.default.createElement("div", {
    className: `${prefix}--checkbox-group-inner--decorator`
  }, normalizedDecorator) : ""), children, import_react42.default.createElement("div", {
    className: `${prefix}--checkbox-group__validation-msg`
  }, !readOnly && invalid && import_react42.default.createElement(import_react42.default.Fragment, null, import_react42.default.createElement(WarningFilled, {
    className: `${prefix}--checkbox__invalid-icon`
  }), import_react42.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalidText)), showWarning && import_react42.default.createElement(import_react42.default.Fragment, null, import_react42.default.createElement(WarningAltFilled, {
    className: `${prefix}--checkbox__invalid-icon ${prefix}--checkbox__invalid-icon--warning`
  }), import_react42.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, warnText))), showHelper && helper);
};
CheckboxGroup.propTypes = {
  /**
   * Provide the children form elements to be rendered inside of the <fieldset>
   */
  children: import_prop_types25.default.node,
  /**
   * Provide a custom className to be applied to the containing <fieldset> node
   */
  className: import_prop_types25.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `CheckboxGroup` component
   */
  decorator: import_prop_types25.default.node,
  /**
   * Provide text for the form group for additional help
   */
  helperText: import_prop_types25.default.node,
  /**
   * Specify whether the form group is currently invalid
   */
  invalid: import_prop_types25.default.bool,
  /**
   * Provide the text that is displayed when the form group is in an invalid state
   */
  invalidText: import_prop_types25.default.node,
  /**
   * Provide id for the fieldset <legend> which corresponds to the fieldset
   * `aria-labelledby`
   */
  legendId: import_prop_types25.default.node,
  /**
   * Provide the text to be rendered inside of the fieldset <legend>
   */
  legendText: import_prop_types25.default.node.isRequired,
  /**
   * Provide the orientation for how the checkbox should be displayed
   */
  orientation: import_prop_types25.default.oneOf(["horizontal", "vertical"]),
  /**
   * Whether the CheckboxGroup should be read-only
   */
  readOnly: import_prop_types25.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `CheckboxGroup` component
   */
  slug: deprecate(import_prop_types25.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify whether the form group is currently in warning state
   */
  warn: import_prop_types25.default.bool,
  /**
   * Provide the text that is displayed when the form group is in warning state
   */
  warnText: import_prop_types25.default.node
};

// node_modules/@carbon/react/es/components/ClassPrefix/index.js
var import_prop_types26 = __toESM(require_prop_types());
var import_react43 = __toESM(require_react());
function ClassPrefix({
  children,
  prefix
}) {
  return import_react43.default.createElement(PrefixContext.Provider, {
    value: prefix
  }, children);
}
ClassPrefix.propTypes = {
  children: import_prop_types26.default.node,
  /**
   * The value used to prefix the CSS selectors used by Carbon components
   */
  prefix: import_prop_types26.default.string.isRequired
};

// node_modules/@carbon/react/es/components/CodeSnippet/CodeSnippet.js
var import_prop_types30 = __toESM(require_prop_types());
var import_react48 = __toESM(require_react());
var import_classnames26 = __toESM(require_classnames());

// node_modules/@carbon/react/es/internal/useResizeObserver.js
var import_react44 = __toESM(require_react());
var useResizeObserver = ({
  ref,
  onResize
}) => {
  const [width, setWidth] = (0, import_react44.useState)(-1);
  const [height, setHeight] = (0, import_react44.useState)(-1);
  const entriesToHandle = (0, import_react44.useRef)(null);
  const cb = (0, import_react44.useRef)(onResize);
  (0, import_react44.useEffect)(() => {
    cb.current = onResize;
  }, [onResize]);
  (0, import_react44.useEffect)(() => {
    const getInitialSize = () => {
      var _a, _b;
      if (ref.current) {
        const refComputedStyle = window.getComputedStyle(ref.current);
        const initialWidth = (((_a = ref.current) == null ? void 0 : _a.offsetWidth) ?? 0) - (typeof (refComputedStyle == null ? void 0 : refComputedStyle.paddingLeft) === "string" && (refComputedStyle == null ? void 0 : refComputedStyle.paddingLeft.length) ? parseFloat(refComputedStyle == null ? void 0 : refComputedStyle.paddingLeft) : 0) - (typeof (refComputedStyle == null ? void 0 : refComputedStyle.paddingRight) === "string" && (refComputedStyle == null ? void 0 : refComputedStyle.paddingRight.length) ? parseFloat(refComputedStyle == null ? void 0 : refComputedStyle.paddingRight) : 0);
        const initialHeight = (((_b = ref.current) == null ? void 0 : _b.offsetHeight) ?? 0) - (typeof (refComputedStyle == null ? void 0 : refComputedStyle.paddingTop) === "string" && (refComputedStyle == null ? void 0 : refComputedStyle.paddingTop.length) ? parseFloat(refComputedStyle == null ? void 0 : refComputedStyle.paddingTop) : 0) - (typeof (refComputedStyle == null ? void 0 : refComputedStyle.paddingBottom) === "string" && (refComputedStyle == null ? void 0 : refComputedStyle.paddingBottom.length) ? parseFloat(refComputedStyle == null ? void 0 : refComputedStyle.paddingBottom) : 0);
        setWidth(initialWidth);
        setHeight(initialHeight);
      }
    };
    if (!(ref == null ? void 0 : ref.current) || width >= 0 && height >= 0) {
      return;
    }
    getInitialSize();
  }, [width, height]);
  (0, import_react44.useLayoutEffect)(() => {
    if (!(ref == null ? void 0 : ref.current)) {
      return;
    }
    const doCallbacks = () => {
      if (!(ref == null ? void 0 : ref.current) || !Array.isArray(entriesToHandle == null ? void 0 : entriesToHandle.current)) {
        return;
      }
      const entry = entriesToHandle.current[0];
      setWidth(entry.contentRect.width);
      setHeight(entry.contentRect.height);
      cb.current && cb.current(entry.contentRect);
    };
    const observer = new ResizeObserver((entries) => {
      entriesToHandle.current = entries;
      window.requestAnimationFrame(() => {
        doCallbacks();
      });
    });
    observer.observe(ref.current);
    return () => {
      observer.disconnect();
    };
  }, []);
  return {
    width,
    height
  };
};

// node_modules/@carbon/react/es/components/Copy/Copy.js
var import_prop_types27 = __toESM(require_prop_types());
var import_react45 = __toESM(require_react());
var import_classnames23 = __toESM(require_classnames());

// node_modules/@carbon/react/es/tools/events.js
var composeEventHandlers = (handlers) => (event, ...args) => {
  for (const handler of handlers) {
    if (event.defaultPrevented) {
      break;
    }
    if (typeof handler === "function") {
      handler(event, ...args);
    }
  }
};

// node_modules/@carbon/react/es/node_modules/es-toolkit/dist/function/debounce.js
function debounce(func, debounceMs, { signal, edges } = {}) {
  let pendingThis = void 0;
  let pendingArgs = null;
  const leading = edges != null && edges.includes("leading");
  const trailing = edges == null || edges.includes("trailing");
  const invoke = () => {
    if (pendingArgs !== null) {
      func.apply(pendingThis, pendingArgs);
      pendingThis = void 0;
      pendingArgs = null;
    }
  };
  const onTimerEnd = () => {
    if (trailing) {
      invoke();
    }
    cancel();
  };
  let timeoutId = null;
  const schedule = () => {
    if (timeoutId != null) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(() => {
      timeoutId = null;
      onTimerEnd();
    }, debounceMs);
  };
  const cancelTimer = () => {
    if (timeoutId !== null) {
      clearTimeout(timeoutId);
      timeoutId = null;
    }
  };
  const cancel = () => {
    cancelTimer();
    pendingThis = void 0;
    pendingArgs = null;
  };
  const flush = () => {
    cancelTimer();
    invoke();
  };
  const debounced = function(...args) {
    if (signal == null ? void 0 : signal.aborted) {
      return;
    }
    pendingThis = this;
    pendingArgs = args;
    const isFirstCall = timeoutId == null;
    schedule();
    if (leading && isFirstCall) {
      invoke();
    }
  };
  debounced.schedule = schedule;
  debounced.cancel = cancel;
  debounced.flush = flush;
  signal == null ? void 0 : signal.addEventListener("abort", cancel, { once: true });
  return debounced;
}

// node_modules/@carbon/react/es/node_modules/es-toolkit/dist/compat/function/debounce.js
function debounce2(func, debounceMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { signal, leading = false, trailing = true, maxWait } = options;
  const edges = Array(2);
  if (leading) {
    edges[0] = "leading";
  }
  if (trailing) {
    edges[1] = "trailing";
  }
  let result = void 0;
  let pendingAt = null;
  const _debounced = debounce(function(...args) {
    result = func.apply(this, args);
    pendingAt = null;
  }, debounceMs, { signal, edges });
  const debounced = function(...args) {
    if (maxWait != null) {
      if (pendingAt === null) {
        pendingAt = Date.now();
      } else {
        if (Date.now() - pendingAt >= maxWait) {
          result = func.apply(this, args);
          pendingAt = Date.now();
          _debounced.cancel();
          _debounced.schedule();
          return result;
        }
      }
    }
    _debounced.apply(this, args);
    return result;
  };
  const flush = () => {
    _debounced.flush();
    return result;
  };
  debounced.cancel = _debounced.cancel;
  debounced.flush = flush;
  return debounced;
}

// node_modules/@carbon/react/es/components/Copy/Copy.js
function Copy2({
  align = "bottom",
  autoAlign = false,
  children,
  className,
  feedback = "Copied!",
  feedbackTimeout = 2e3,
  onAnimationEnd,
  onClick = noopFn,
  ...other
}) {
  const [animation, setAnimation] = (0, import_react45.useState)("");
  const prefix = usePrefix();
  const classNames = (0, import_classnames23.default)(className, `${prefix}--copy`, {
    [`${prefix}--copy-btn--animating`]: animation,
    [`${prefix}--copy-btn--${animation}`]: animation
  });
  const handleFadeOut = (0, import_react45.useCallback)(debounce2(() => {
    setAnimation("fade-out");
  }, feedbackTimeout), [feedbackTimeout]);
  const handleClick2 = (0, import_react45.useCallback)(() => {
    setAnimation("fade-in");
    handleFadeOut();
  }, [handleFadeOut]);
  const handleAnimationEnd = (event) => {
    if (event.animationName === `${prefix}--hide-feedback`) {
      setAnimation("");
    }
  };
  (0, import_react45.useEffect)(() => () => {
    handleFadeOut.cancel();
  }, [handleFadeOut]);
  const initialLabel = other["aria-label"] ?? "";
  return import_react45.default.createElement(IconButton, _extends({
    closeOnActivation: false,
    align,
    autoAlign,
    className: classNames,
    label: animation ? feedback : initialLabel,
    leaveDelayMs: animation ? feedbackTimeout : void 0,
    onClick: composeEventHandlers([onClick, handleClick2]),
    onAnimationEnd: composeEventHandlers([onAnimationEnd, handleAnimationEnd])
  }, other, {
    "aria-label": !children && (animation ? feedback : other["aria-label"]) || void 0
  }), children);
}
Copy2.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(import_prop_types27.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip. Requires
   * React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types27.default.bool,
  /**
   * Pass in content to be rendered in the underlying `<button>`
   */
  children: import_prop_types27.default.node,
  /**
   * Specify an optional className to be applied to the underlying `<button>`
   */
  className: import_prop_types27.default.string,
  /**
   * Specify the string that is displayed when the button is clicked and the
   * content is copied
   */
  feedback: import_prop_types27.default.string,
  /**
   * Specify the time it takes for the feedback message to timeout
   */
  feedbackTimeout: import_prop_types27.default.number,
  /**
   * Specify an optional `onAnimationEnd` handler that is called when the underlying
   * animation ends
   */
  onAnimationEnd: import_prop_types27.default.func,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * `<button>` is clicked
   */
  onClick: import_prop_types27.default.func
};

// node_modules/@carbon/react/es/components/CopyButton/CopyButton.js
var import_prop_types29 = __toESM(require_prop_types());
var import_react47 = __toESM(require_react());
var import_classnames25 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Layout/index.js
var import_classnames24 = __toESM(require_classnames());
var import_prop_types28 = __toESM(require_prop_types());
var import_react46 = __toESM(require_react());
var sizes = ["xs", "sm", "md", "lg", "xl", "2xl"];
var densities = ["condensed", "normal"];
var Layout = import_react46.default.forwardRef(function Layout2({
  as: BaseComponent = "div",
  children,
  className,
  density,
  size: size4,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const classes = (0, import_classnames24.default)(className, `${prefix}--layout`, {
    [`${prefix}--layout--size-${size4}`]: size4 && sizes.includes(size4),
    [`${prefix}--layout--density-${density}`]: density && densities.includes(density)
  });
  return import_react46.default.createElement(BaseComponent, _extends({}, rest, {
    ref: forwardRef36,
    className: classes
  }), children);
});
Layout.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types28.default.oneOfType([import_prop_types28.default.func, import_prop_types28.default.string, import_prop_types28.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `Layout`
   */
  children: import_prop_types28.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types28.default.string,
  /**
   * Specify the desired density of components within this layout
   */
  density: import_prop_types28.default.oneOf(densities),
  /**
   * Specify the desired size of components within this layout
   */
  size: import_prop_types28.default.oneOf(sizes)
};
var LayoutConstraint = import_react46.default.forwardRef(function Layout3({
  as: BaseComponent = "div",
  children,
  className,
  density,
  size: size4,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const classes = (0, import_classnames24.default)(className, Object.entries({
    size: size4,
    density
  }).map(([group, constraints]) => ({
    [`${prefix}--layout-constraint--${group}__default-${constraints == null ? void 0 : constraints.default}`]: constraints == null ? void 0 : constraints.default,
    [`${prefix}--layout-constraint--${group}__min-${constraints == null ? void 0 : constraints.min}`]: constraints == null ? void 0 : constraints.min,
    [`${prefix}--layout-constraint--${group}__max-${constraints == null ? void 0 : constraints.max}`]: constraints == null ? void 0 : constraints.max
  })));
  return import_react46.default.createElement(BaseComponent, _extends({}, rest, {
    ref: forwardRef36,
    className: classes
  }), children);
});
LayoutConstraint.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types28.default.oneOfType([import_prop_types28.default.func, import_prop_types28.default.string, import_prop_types28.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `LayoutConstraint`
   */
  children: import_prop_types28.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types28.default.string,
  /**
   * Specify the desired layout density constraints of this element's children
   */
  density: import_prop_types28.default.shape({
    min: import_prop_types28.default.oneOf(densities),
    default: import_prop_types28.default.oneOf(densities),
    max: import_prop_types28.default.oneOf(densities)
  }),
  /**
   * Specify the desired layout size constraints of this element's children
   */
  size: import_prop_types28.default.shape({
    min: import_prop_types28.default.oneOf(sizes),
    default: import_prop_types28.default.oneOf(sizes),
    max: import_prop_types28.default.oneOf(sizes)
  })
};

// node_modules/@carbon/react/es/components/CopyButton/CopyButton.js
function CopyButton({
  align = "bottom",
  autoAlign = false,
  feedback = "Copied!",
  feedbackTimeout = 2e3,
  iconDescription = "Copy to clipboard",
  className,
  onClick = noopFn,
  ...other
}) {
  const prefix = usePrefix();
  return import_react47.default.createElement(LayoutConstraint, {
    size: {
      default: "md",
      max: "lg"
    }
  }, import_react47.default.createElement(Copy2, _extends({
    feedback,
    feedbackTimeout,
    onClick,
    align,
    autoAlign,
    className: (0, import_classnames25.default)(className, `${prefix}--copy-btn`),
    "aria-label": iconDescription
  }, other), import_react47.default.createElement(Copy, {
    className: `${prefix}--snippet__icon`
  })));
}
CopyButton.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(import_prop_types29.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip. Requires
   * React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types29.default.bool,
  /**
   * Specify an optional className to be applied to the underlying `<button>`
   */
  className: import_prop_types29.default.string,
  /**
   * Specify the string that is displayed when the button is clicked and the
   * content is copied
   */
  feedback: import_prop_types29.default.string,
  /**
   * Specify the time it takes for the feedback message to timeout
   */
  feedbackTimeout: import_prop_types29.default.number,
  /**
   * Provide a description for the icon representing the copy action that can
   * be read by screen readers
   */
  iconDescription: import_prop_types29.default.string,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * `<button>` is clicked
   */
  onClick: import_prop_types29.default.func
};

// node_modules/@carbon/react/es/components/CodeSnippet/CodeSnippet.js
var import_copy_to_clipboard = __toESM(require_copy_to_clipboard());
var rowHeightInPixels = 16;
var defaultMaxCollapsedNumberOfRows = 15;
var defaultMaxExpandedNumberOfRows = 0;
var defaultMinCollapsedNumberOfRows = 3;
var defaultMinExpandedNumberOfRows = 16;
function CodeSnippet({
  align = "bottom",
  autoAlign = false,
  className,
  type = "single",
  children,
  disabled,
  feedback,
  feedbackTimeout,
  onClick,
  ["aria-label"]: ariaLabel = "Copy to clipboard",
  ariaLabel: deprecatedAriaLabel,
  copyText,
  copyButtonDescription,
  light,
  showMoreText = "Show more",
  showLessText = "Show less",
  hideCopyButton,
  wrapText = false,
  maxCollapsedNumberOfRows = defaultMaxCollapsedNumberOfRows,
  maxExpandedNumberOfRows = defaultMaxExpandedNumberOfRows,
  minCollapsedNumberOfRows = defaultMinCollapsedNumberOfRows,
  minExpandedNumberOfRows = defaultMinExpandedNumberOfRows,
  ...rest
}) {
  const [expandedCode, setExpandedCode] = (0, import_react48.useState)(false);
  const [shouldShowMoreLessBtn, setShouldShowMoreLessBtn] = (0, import_react48.useState)(false);
  const {
    current: uid
  } = (0, import_react48.useRef)(useId());
  const codeContentRef = (0, import_react48.useRef)(null);
  const codeContainerRef = (0, import_react48.useRef)(null);
  const innerCodeRef = (0, import_react48.useRef)(null);
  const [hasLeftOverflow, setHasLeftOverflow] = (0, import_react48.useState)(false);
  const [hasRightOverflow, setHasRightOverflow] = (0, import_react48.useState)(false);
  const getCodeRef = (0, import_react48.useCallback)(() => {
    if (type === "single") {
      return codeContainerRef;
    }
    if (type === "multi") {
      return codeContentRef;
    } else {
      return innerCodeRef;
    }
  }, [type]);
  const prefix = usePrefix();
  const getCodeRefDimensions = (0, import_react48.useCallback)(() => {
    const {
      clientWidth: codeClientWidth = 0,
      scrollLeft: codeScrollLeft = 0,
      scrollWidth: codeScrollWidth = 0
    } = getCodeRef().current || {};
    return {
      horizontalOverflow: codeScrollWidth > codeClientWidth,
      codeClientWidth,
      codeScrollWidth,
      codeScrollLeft
    };
  }, [getCodeRef]);
  const handleScroll = (0, import_react48.useCallback)(() => {
    if (type === "inline" || type === "single" && !(codeContainerRef == null ? void 0 : codeContainerRef.current) || type === "multi" && !(codeContentRef == null ? void 0 : codeContentRef.current)) {
      return;
    }
    const {
      horizontalOverflow,
      codeClientWidth,
      codeScrollWidth,
      codeScrollLeft
    } = getCodeRefDimensions();
    setHasLeftOverflow(horizontalOverflow && !!codeScrollLeft);
    setHasRightOverflow(horizontalOverflow && codeScrollLeft + codeClientWidth !== codeScrollWidth);
  }, [type, getCodeRefDimensions]);
  useResizeObserver({
    ref: getCodeRef(),
    onResize: () => {
      if ((codeContentRef == null ? void 0 : codeContentRef.current) && type === "multi") {
        const {
          height
        } = codeContentRef.current.getBoundingClientRect();
        if (maxCollapsedNumberOfRows > 0 && (maxExpandedNumberOfRows <= 0 || maxExpandedNumberOfRows > maxCollapsedNumberOfRows) && height > maxCollapsedNumberOfRows * rowHeightInPixels) {
          setShouldShowMoreLessBtn(true);
        } else {
          setShouldShowMoreLessBtn(false);
        }
        if (expandedCode && minExpandedNumberOfRows > 0 && height <= minExpandedNumberOfRows * rowHeightInPixels) {
          setExpandedCode(false);
        }
      }
      if ((codeContentRef == null ? void 0 : codeContentRef.current) && type === "multi" || (codeContainerRef == null ? void 0 : codeContainerRef.current) && type === "single") {
        handleScroll();
      }
    }
  });
  (0, import_react48.useEffect)(() => {
    handleScroll();
  }, [handleScroll]);
  const handleCopyClick = (evt) => {
    var _a;
    if (copyText || (innerCodeRef == null ? void 0 : innerCodeRef.current)) {
      (0, import_copy_to_clipboard.default)(copyText ?? ((_a = innerCodeRef == null ? void 0 : innerCodeRef.current) == null ? void 0 : _a.innerText) ?? "");
    }
    if (onClick) {
      onClick(evt);
    }
  };
  const codeSnippetClasses = (0, import_classnames26.default)(className, `${prefix}--snippet`, {
    [`${prefix}--snippet--${type}`]: type,
    [`${prefix}--snippet--disabled`]: type !== "inline" && disabled,
    [`${prefix}--snippet--expand`]: expandedCode,
    [`${prefix}--snippet--light`]: light,
    [`${prefix}--snippet--no-copy`]: hideCopyButton,
    [`${prefix}--snippet--wraptext`]: wrapText,
    [`${prefix}--snippet--has-right-overflow`]: type == "multi" && hasRightOverflow
  });
  const expandCodeBtnText = expandedCode ? showLessText : showMoreText;
  if (type === "inline") {
    if (hideCopyButton) {
      return import_react48.default.createElement("span", {
        className: codeSnippetClasses
      }, import_react48.default.createElement("code", {
        id: uid,
        ref: innerCodeRef
      }, children));
    }
    return import_react48.default.createElement(Copy2, _extends({}, rest, {
      align,
      autoAlign,
      onClick: handleCopyClick,
      "aria-label": deprecatedAriaLabel || ariaLabel,
      "aria-describedby": uid,
      className: codeSnippetClasses,
      disabled,
      feedback,
      feedbackTimeout
    }), import_react48.default.createElement("code", {
      id: uid,
      ref: innerCodeRef
    }, children));
  }
  const containerStyle = {};
  if (type === "multi") {
    const styles = {};
    if (expandedCode) {
      if (maxExpandedNumberOfRows > 0) {
        styles.maxHeight = maxExpandedNumberOfRows * rowHeightInPixels;
      }
      if (minExpandedNumberOfRows > 0) {
        styles.minHeight = minExpandedNumberOfRows * rowHeightInPixels;
      }
    } else {
      if (maxCollapsedNumberOfRows > 0) {
        styles.maxHeight = maxCollapsedNumberOfRows * rowHeightInPixels;
      }
      if (minCollapsedNumberOfRows > 0) {
        styles.minHeight = minCollapsedNumberOfRows * rowHeightInPixels;
      }
    }
    if (Object.keys(styles).length) {
      containerStyle.style = styles;
    }
  }
  return import_react48.default.createElement("div", _extends({}, rest, {
    className: codeSnippetClasses
  }), import_react48.default.createElement("div", _extends({
    ref: codeContainerRef,
    role: type === "single" || type === "multi" ? "textbox" : void 0,
    tabIndex: (type === "single" || type === "multi") && !disabled ? 0 : void 0,
    className: `${prefix}--snippet-container`,
    "aria-label": deprecatedAriaLabel || ariaLabel || "code-snippet",
    "aria-readonly": type === "single" || type === "multi" ? true : void 0,
    "aria-multiline": type === "multi" ? true : void 0,
    onScroll: type === "single" && handleScroll || void 0
  }, containerStyle), import_react48.default.createElement("pre", {
    ref: codeContentRef,
    onScroll: type === "multi" && handleScroll || void 0
  }, import_react48.default.createElement("code", {
    ref: innerCodeRef
  }, children))), hasLeftOverflow && import_react48.default.createElement("div", {
    className: `${prefix}--snippet__overflow-indicator--left`
  }), hasRightOverflow && type !== "multi" && import_react48.default.createElement("div", {
    className: `${prefix}--snippet__overflow-indicator--right`
  }), !hideCopyButton && import_react48.default.createElement(CopyButton, {
    align,
    autoAlign,
    size: type === "multi" ? "sm" : "md",
    disabled,
    onClick: handleCopyClick,
    feedback,
    feedbackTimeout,
    iconDescription: copyButtonDescription
  }), shouldShowMoreLessBtn && import_react48.default.createElement(Button, {
    kind: "ghost",
    size: "sm",
    className: `${prefix}--snippet-btn--expand`,
    disabled,
    onClick: () => setExpandedCode(!expandedCode)
  }, import_react48.default.createElement("span", {
    className: `${prefix}--snippet-btn--text`
  }, expandCodeBtnText), import_react48.default.createElement(ChevronDown, {
    className: `${prefix}--icon-chevron--down ${prefix}--snippet__icon`,
    name: "chevron--down",
    role: "img"
  })));
}
CodeSnippet.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(import_prop_types30.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * Specify a label to be read by screen readers on the containing textbox
   * node
   */
  ["aria-label"]: import_prop_types30.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the containing textbox
   * node
   */
  ariaLabel: deprecate(import_prop_types30.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * **Experimental**: Will attempt to automatically align the tooltip. Requires
   * React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types30.default.bool,
  /**
   * Provide the content of your CodeSnippet as a node or string
   */
  children: import_prop_types30.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types30.default.string,
  /**
   * Specify the description for the Copy Button
   */
  copyButtonDescription: import_prop_types30.default.string,
  /**
   * Optional text to copy. If not specified, the `children` node's `innerText`
   * will be used as the copy value.
   */
  copyText: import_prop_types30.default.string,
  /**
   * Specify whether or not the CodeSnippet should be disabled
   */
  disabled: import_prop_types30.default.bool,
  /**
   * Specify the string displayed when the snippet is copied
   */
  feedback: import_prop_types30.default.string,
  /**
   * Specify the time it takes for the feedback message to timeout
   */
  feedbackTimeout: import_prop_types30.default.number,
  /**
   * Specify whether or not a copy button should be used/rendered.
   */
  hideCopyButton: import_prop_types30.default.bool,
  /**
   * Specify whether you are using the light variant of the Code Snippet,
   * typically used for inline snippet to display an alternate color
   */
  light: deprecate(import_prop_types30.default.bool, "The `light` prop for `CodeSnippet` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the maximum number of rows to be shown when in collapsed view
   */
  maxCollapsedNumberOfRows: import_prop_types30.default.number,
  /**
   * Specify the maximum number of rows to be shown when in expanded view
   */
  maxExpandedNumberOfRows: import_prop_types30.default.number,
  /**
   * Specify the minimum number of rows to be shown when in collapsed view
   */
  minCollapsedNumberOfRows: import_prop_types30.default.number,
  /**
   * Specify the minimum number of rows to be shown when in expanded view
   */
  minExpandedNumberOfRows: import_prop_types30.default.number,
  /**
   * An optional handler to listen to the `onClick` even fired by the Copy
   * Button
   */
  onClick: import_prop_types30.default.func,
  /**
   * Specify a string that is displayed when the Code Snippet has been
   * interacted with to show more lines
   */
  showLessText: import_prop_types30.default.string,
  /**
   * Specify a string that is displayed when the Code Snippet text is more
   * than 15 lines
   */
  showMoreText: import_prop_types30.default.string,
  /**
   * Provide the type of Code Snippet
   */
  type: import_prop_types30.default.oneOf(["single", "inline", "multi"]),
  /**
   * Specify whether or not to wrap the text.
   */
  wrapText: import_prop_types30.default.bool
};

// node_modules/@carbon/react/es/components/CodeSnippet/CodeSnippet.Skeleton.js
var import_classnames27 = __toESM(require_classnames());
var import_prop_types31 = __toESM(require_prop_types());
var import_react49 = __toESM(require_react());
var _span;
var _span2;
var _span3;
var _span4;
function CodeSnippetSkeleton({
  className: containerClassName,
  type = "single",
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames27.default)(containerClassName, {
    [`${prefix}--snippet`]: true,
    [`${prefix}--skeleton`]: true,
    [`${prefix}--snippet--single`]: type === "single",
    [`${prefix}--snippet--multi`]: type === "multi"
  });
  if (type === "single") {
    return import_react49.default.createElement("div", _extends({
      className
    }, rest), import_react49.default.createElement("div", {
      className: `${prefix}--snippet-container`
    }, _span || (_span = import_react49.default.createElement("span", null))));
  }
  if (type === "multi") {
    return import_react49.default.createElement("div", _extends({
      className
    }, rest), import_react49.default.createElement("div", {
      className: `${prefix}--snippet-container`
    }, _span2 || (_span2 = import_react49.default.createElement("span", null)), _span3 || (_span3 = import_react49.default.createElement("span", null)), _span4 || (_span4 = import_react49.default.createElement("span", null))));
  }
}
CodeSnippetSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types31.default.string,
  /**
   * The type of the code snippet, including single or multi
   */
  type: import_prop_types31.default.oneOf(["single", "multi"])
};

// node_modules/@carbon/react/es/components/ComboBox/ComboBox.js
var import_classnames36 = __toESM(require_classnames());

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r2, e2) {
  if (null == r2) return {};
  var t3 = {};
  for (var n2 in r2) if ({}.hasOwnProperty.call(r2, n2)) {
    if (-1 !== e2.indexOf(n2)) continue;
    t3[n2] = r2[n2];
  }
  return t3;
}

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n2) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t3 = arguments[e2];
      for (var r2 in t3) ({}).hasOwnProperty.call(t3, r2) && (n2[r2] = t3[r2]);
    }
    return n2;
  }, _extends2.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t3, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t4, e3) {
    return t4.__proto__ = e3, t4;
  }, _setPrototypeOf(t3, e2);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t3, o3) {
  t3.prototype = Object.create(o3.prototype), t3.prototype.constructor = t3, _setPrototypeOf(t3, o3);
}

// node_modules/downshift/dist/downshift.esm.js
var import_prop_types32 = __toESM(require_prop_types());
var import_react50 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());

// node_modules/compute-scroll-into-view/dist/index.js
var t = (t3) => "object" == typeof t3 && null != t3 && 1 === t3.nodeType;
var e = (t3, e2) => (!e2 || "hidden" !== t3) && ("visible" !== t3 && "clip" !== t3);
var n = (t3, n2) => {
  if (t3.clientHeight < t3.scrollHeight || t3.clientWidth < t3.scrollWidth) {
    const o3 = getComputedStyle(t3, null);
    return e(o3.overflowY, n2) || e(o3.overflowX, n2) || ((t4) => {
      const e2 = ((t5) => {
        if (!t5.ownerDocument || !t5.ownerDocument.defaultView) return null;
        try {
          return t5.ownerDocument.defaultView.frameElement;
        } catch (t6) {
          return null;
        }
      })(t4);
      return !!e2 && (e2.clientHeight < t4.scrollHeight || e2.clientWidth < t4.scrollWidth);
    })(t3);
  }
  return false;
};
var o = (t3, e2, n2, o3, l2, r2, i, s) => r2 < t3 && i > e2 || r2 > t3 && i < e2 ? 0 : r2 <= t3 && s <= n2 || i >= e2 && s >= n2 ? r2 - t3 - o3 : i > e2 && s < n2 || r2 < t3 && s > n2 ? i - e2 + l2 : 0;
var l = (t3) => {
  const e2 = t3.parentElement;
  return null == e2 ? t3.getRootNode().host || null : e2;
};
var r = (e2, r2) => {
  var i, s, d, h;
  if ("undefined" == typeof document) return [];
  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = "function" == typeof a ? a : (t3) => t3 !== a;
  if (!t(e2)) throw new TypeError("Invalid target");
  const m = document.scrollingElement || document.documentElement, w2 = [];
  let W = e2;
  for (; t(W) && p(W); ) {
    if (W = l(W), W === m) {
      w2.push(W);
      break;
    }
    null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w2.push(W);
  }
  const b2 = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v2, width: E, top: x, right: C, bottom: I, left: R } = e2.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t3) => {
    const e3 = window.getComputedStyle(t3);
    return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };
  })(e2);
  let k = "start" === f || "nearest" === f ? x - T : "end" === f ? I + F : x + v2 / 2 - T + F, D = "center" === u ? R + E / 2 - V + B : "end" === u ? C + B : R - V;
  const L2 = [];
  for (let t3 = 0; t3 < w2.length; t3++) {
    const e3 = w2[t3], { height: l2, width: r3, top: i2, right: s2, bottom: d2, left: h2 } = e3.getBoundingClientRect();
    if ("if-needed" === c && x >= 0 && R >= 0 && I <= H && C <= b2 && (e3 === m && !n(e3) || x >= i2 && I <= d2 && R >= h2 && C <= s2)) return L2;
    const a2 = getComputedStyle(e3), g2 = parseInt(a2.borderLeftWidth, 10), p2 = parseInt(a2.borderTopWidth, 10), W2 = parseInt(a2.borderRightWidth, 10), T2 = parseInt(a2.borderBottomWidth, 10);
    let B2 = 0, F2 = 0;
    const V2 = "offsetWidth" in e3 ? e3.offsetWidth - e3.clientWidth - g2 - W2 : 0, S = "offsetHeight" in e3 ? e3.offsetHeight - e3.clientHeight - p2 - T2 : 0, X = "offsetWidth" in e3 ? 0 === e3.offsetWidth ? 0 : r3 / e3.offsetWidth : 0, Y = "offsetHeight" in e3 ? 0 === e3.offsetHeight ? 0 : l2 / e3.offsetHeight : 0;
    if (m === e3) B2 = "start" === f ? k : "end" === f ? k - H : "nearest" === f ? o(M, M + H, H, p2, T2, M + k, M + k + v2, v2) : k - H / 2, F2 = "start" === u ? D : "center" === u ? D - b2 / 2 : "end" === u ? D - b2 : o(y, y + b2, b2, g2, W2, y + D, y + D + E, E), B2 = Math.max(0, B2 + M), F2 = Math.max(0, F2 + y);
    else {
      B2 = "start" === f ? k - i2 - p2 : "end" === f ? k - d2 + T2 + S : "nearest" === f ? o(i2, d2, l2, p2, T2 + S, k, k + v2, v2) : k - (i2 + l2 / 2) + S / 2, F2 = "start" === u ? D - h2 - g2 : "center" === u ? D - (h2 + r3 / 2) + V2 / 2 : "end" === u ? D - s2 + W2 + V2 : o(h2, s2, r3, g2, W2 + V2, D, D + E, E);
      const { scrollLeft: t4, scrollTop: n2 } = e3;
      B2 = 0 === Y ? 0 : Math.max(0, Math.min(n2 + B2 / Y, e3.scrollHeight - l2 / Y + S)), F2 = 0 === X ? 0 : Math.max(0, Math.min(t4 + F2 / X, e3.scrollWidth - r3 / X + V2)), k += n2 - B2, D += t4 - F2;
    }
    L2.push({ el: e3, top: B2, left: F2 });
  }
  return L2;
};

// node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign3(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t3[p] = s[p];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};

// node_modules/downshift/dist/downshift.esm.js
var idCounter = 0;
function cbToCb(cb) {
  return typeof cb === "function" ? cb : noop5;
}
function noop5() {
}
function scrollIntoView(node, menuNode) {
  if (!node) {
    return;
  }
  var actions = r(node, {
    boundary: menuNode,
    block: "nearest",
    scrollMode: "if-needed"
  });
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}
function isOrContainsNode(parent, child, environment) {
  var result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);
  return result;
}
function debounce3(fn, time) {
  var timeoutId;
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId = setTimeout(function() {
      timeoutId = null;
      fn.apply(void 0, args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some(function(fn) {
      if (fn) {
        fn.apply(void 0, [event].concat(args));
      }
      return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return function(node) {
    refs.forEach(function(ref) {
      if (typeof ref === "function") {
        ref(node);
      } else if (ref) {
        ref.current = node;
      }
    });
  };
}
function generateId() {
  return String(idCounter++);
}
function getA11yStatusMessage(_ref2) {
  var isOpen = _ref2.isOpen, resultCount = _ref2.resultCount, previousResultCount = _ref2.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return resultCount + " result" + (resultCount === 1 ? " is" : "s are") + " available, use up and down arrow keys to navigate. Press Enter key to select.";
  }
  return "";
}
function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ? (
    /* istanbul ignore next (preact) */
    arg[0]
  ) : arg;
  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}
function isDOMElement(element) {
  return typeof element.type === "string";
}
function getElementProps(element) {
  return element.props;
}
function requiredProp(fnName, propName) {
  console.error('The property "' + propName + '" is required in "' + fnName + '"');
}
var stateKeys = ["highlightedIndex", "inputValue", "isOpen", "selectedItem", "type"];
function pickState(state) {
  if (state === void 0) {
    state = {};
  }
  var result = {};
  stateKeys.forEach(function(k) {
    if (state.hasOwnProperty(k)) {
      result[k] = state[k];
    }
  });
  return result;
}
function getState(state, props) {
  if (!state || !props) {
    return state;
  }
  return Object.keys(state).reduce(function(prevState, key) {
    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
    return prevState;
  }, {});
}
function isControlledProp(props, key) {
  return props[key] !== void 0;
}
function normalizeArrowKey(event) {
  var key = event.key, keyCode = event.keyCode;
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
    return "Arrow" + key;
  }
  return key;
}
function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function getHighlightedIndex(start, offset4, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count2 = items.length;
  if (count2 === 0) {
    return -1;
  }
  var itemsLastIndex = count2 - 1;
  if (typeof start !== "number" || start < 0 || start > itemsLastIndex) {
    start = offset4 > 0 ? -1 : itemsLastIndex + 1;
  }
  var current = start + offset4;
  if (current < 0) {
    current = circular ? itemsLastIndex : 0;
  } else if (current > itemsLastIndex) {
    current = circular ? 0 : itemsLastIndex;
  }
  var highlightedIndex = getNonDisabledIndex(current, offset4 < 0, items, isItemDisabled2, circular);
  if (highlightedIndex === -1) {
    return start >= count2 ? -1 : start;
  }
  return highlightedIndex;
}
function getNonDisabledIndex(start, backwards, items, isItemDisabled2, circular) {
  if (circular === void 0) {
    circular = false;
  }
  var count2 = items.length;
  if (backwards) {
    for (var index3 = start; index3 >= 0; index3--) {
      if (!isItemDisabled2(items[index3], index3)) {
        return index3;
      }
    }
  } else {
    for (var _index = start; _index < count2; _index++) {
      if (!isItemDisabled2(items[_index], _index)) {
        return _index;
      }
    }
  }
  if (circular) {
    return getNonDisabledIndex(backwards ? count2 - 1 : 0, backwards, items, isItemDisabled2);
  }
  return -1;
}
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return environment && downshiftElements.some(function(contextNode) {
    return contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment));
  });
}
var validateControlledUnchanged = noop5;
if (true) {
  validateControlledUnchanged = function validateControlledUnchanged2(state, prevProps, nextProps) {
    var warningDescription = "This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props";
    Object.keys(state).forEach(function(propKey) {
      if (prevProps[propKey] !== void 0 && nextProps[propKey] === void 0) {
        console.error('downshift: A component has changed the controlled prop "' + propKey + '" to be uncontrolled. ' + warningDescription);
      } else if (prevProps[propKey] === void 0 && nextProps[propKey] !== void 0) {
        console.error('downshift: A component has changed the uncontrolled prop "' + propKey + '" to be controlled. ' + warningDescription);
      }
    });
  };
}
var cleanupStatus = debounce3(function(documentProp) {
  getStatusDiv(documentProp).textContent = "";
}, 500);
function getStatusDiv(documentProp) {
  var statusDiv = documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement("div");
  statusDiv.setAttribute("id", "a11y-status-message");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.setAttribute("aria-relevant", "additions text");
  Object.assign(statusDiv.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
function setStatus(status, documentProp) {
  if (!status || !documentProp) {
    return;
  }
  var div = getStatusDiv(documentProp);
  div.textContent = status;
  cleanupStatus(documentProp);
}
function cleanupStatusDiv(documentProp) {
  var statusDiv = documentProp == null ? void 0 : documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    statusDiv.remove();
  }
}
var unknown = true ? "__autocomplete_unknown__" : 0;
var mouseUp = true ? "__autocomplete_mouseup__" : 1;
var itemMouseEnter = true ? "__autocomplete_item_mouseenter__" : 2;
var keyDownArrowUp = true ? "__autocomplete_keydown_arrow_up__" : 3;
var keyDownArrowDown = true ? "__autocomplete_keydown_arrow_down__" : 4;
var keyDownEscape = true ? "__autocomplete_keydown_escape__" : 5;
var keyDownEnter = true ? "__autocomplete_keydown_enter__" : 6;
var keyDownHome = true ? "__autocomplete_keydown_home__" : 7;
var keyDownEnd = true ? "__autocomplete_keydown_end__" : 8;
var clickItem = true ? "__autocomplete_click_item__" : 9;
var blurInput = true ? "__autocomplete_blur_input__" : 10;
var changeInput = true ? "__autocomplete_change_input__" : 11;
var keyDownSpaceButton = true ? "__autocomplete_keydown_space_button__" : 12;
var clickButton = true ? "__autocomplete_click_button__" : 13;
var blurButton = true ? "__autocomplete_blur_button__" : 14;
var controlledPropUpdatedSelectedItem = true ? "__autocomplete_controlled_prop_updated_selected_item__" : 15;
var touchEnd = true ? "__autocomplete_touchend__" : 16;
var stateChangeTypes$3 = Object.freeze({
  __proto__: null,
  blurButton,
  blurInput,
  changeInput,
  clickButton,
  clickItem,
  controlledPropUpdatedSelectedItem,
  itemMouseEnter,
  keyDownArrowDown,
  keyDownArrowUp,
  keyDownEnd,
  keyDownEnter,
  keyDownEscape,
  keyDownHome,
  keyDownSpaceButton,
  mouseUp,
  touchEnd,
  unknown
});
var _excluded$3 = ["refKey", "ref"];
var _excluded2$3 = ["onClick", "onPress", "onKeyDown", "onKeyUp", "onBlur"];
var _excluded3$2 = ["onKeyDown", "onBlur", "onChange", "onInput", "onChangeText"];
var _excluded4$2 = ["refKey", "ref"];
var _excluded5 = ["onMouseMove", "onMouseDown", "onClick", "onPress", "index", "item"];
var Downshift = function() {
  var Downshift2 = function(_Component) {
    function Downshift3(_props) {
      var _this;
      _this = _Component.call(this, _props) || this;
      _this.id = _this.props.id || "downshift-" + generateId();
      _this.menuId = _this.props.menuId || _this.id + "-menu";
      _this.labelId = _this.props.labelId || _this.id + "-label";
      _this.inputId = _this.props.inputId || _this.id + "-input";
      _this.getItemId = _this.props.getItemId || function(index3) {
        return _this.id + "-item-" + index3;
      };
      _this.items = [];
      _this.itemCount = null;
      _this.previousResultCount = 0;
      _this.timeoutIds = [];
      _this.internalSetTimeout = function(fn, time) {
        var id = setTimeout(function() {
          _this.timeoutIds = _this.timeoutIds.filter(function(i) {
            return i !== id;
          });
          fn();
        }, time);
        _this.timeoutIds.push(id);
      };
      _this.setItemCount = function(count2) {
        _this.itemCount = count2;
      };
      _this.unsetItemCount = function() {
        _this.itemCount = null;
      };
      _this.isItemDisabled = function(_item, index3) {
        var currentElementNode = _this.getItemNodeFromIndex(index3);
        return currentElementNode && currentElementNode.hasAttribute("disabled");
      };
      _this.setHighlightedIndex = function(highlightedIndex, otherStateToSet) {
        if (highlightedIndex === void 0) {
          highlightedIndex = _this.props.defaultHighlightedIndex;
        }
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends2({
          highlightedIndex
        }, otherStateToSet));
      };
      _this.clearSelection = function(cb) {
        _this.internalSetState({
          selectedItem: null,
          inputValue: "",
          highlightedIndex: _this.props.defaultHighlightedIndex,
          isOpen: _this.props.defaultIsOpen
        }, cb);
      };
      _this.selectItem = function(item, otherStateToSet, cb) {
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(_extends2({
          isOpen: _this.props.defaultIsOpen,
          highlightedIndex: _this.props.defaultHighlightedIndex,
          selectedItem: item,
          inputValue: _this.props.itemToString(item)
        }, otherStateToSet), cb);
      };
      _this.selectItemAtIndex = function(itemIndex, otherStateToSet, cb) {
        var item = _this.items[itemIndex];
        if (item == null) {
          return;
        }
        _this.selectItem(item, otherStateToSet, cb);
      };
      _this.selectHighlightedItem = function(otherStateToSet, cb) {
        return _this.selectItemAtIndex(_this.getState().highlightedIndex, otherStateToSet, cb);
      };
      _this.internalSetState = function(stateToSet, cb) {
        var isItemSelected, onChangeArg;
        var onStateChangeArg = {};
        var isStateToSetFunction = typeof stateToSet === "function";
        if (!isStateToSetFunction && stateToSet.hasOwnProperty("inputValue")) {
          _this.props.onInputValueChange(stateToSet.inputValue, _extends2({}, _this.getStateAndHelpers(), stateToSet));
        }
        return _this.setState(function(state) {
          var _newStateToSet;
          state = _this.getState(state);
          var newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet;
          newStateToSet = _this.props.stateReducer(state, newStateToSet);
          isItemSelected = newStateToSet.hasOwnProperty("selectedItem");
          var nextState = {};
          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
            onChangeArg = newStateToSet.selectedItem;
          }
          (_newStateToSet = newStateToSet).type || (_newStateToSet.type = unknown);
          Object.keys(newStateToSet).forEach(function(key) {
            if (state[key] !== newStateToSet[key]) {
              onStateChangeArg[key] = newStateToSet[key];
            }
            if (key === "type") {
              return;
            }
            newStateToSet[key];
            if (!isControlledProp(_this.props, key)) {
              nextState[key] = newStateToSet[key];
            }
          });
          if (isStateToSetFunction && newStateToSet.hasOwnProperty("inputValue")) {
            _this.props.onInputValueChange(newStateToSet.inputValue, _extends2({}, _this.getStateAndHelpers(), newStateToSet));
          }
          return nextState;
        }, function() {
          cbToCb(cb)();
          var hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;
          if (hasMoreStateThanType) {
            _this.props.onStateChange(onStateChangeArg, _this.getStateAndHelpers());
          }
          if (isItemSelected) {
            _this.props.onSelect(stateToSet.selectedItem, _this.getStateAndHelpers());
          }
          if (onChangeArg !== void 0) {
            _this.props.onChange(onChangeArg, _this.getStateAndHelpers());
          }
          _this.props.onUserAction(onStateChangeArg, _this.getStateAndHelpers());
        });
      };
      _this.rootRef = function(node) {
        return _this._rootNode = node;
      };
      _this.getRootProps = function(_temp, _temp2) {
        var _extends22;
        var _ref = _temp === void 0 ? {} : _temp, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref = _ref.ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded$3);
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
        _this.getRootProps.called = true;
        _this.getRootProps.refKey = refKey;
        _this.getRootProps.suppressRefError = suppressRefError;
        var _this$getState = _this.getState(), isOpen = _this$getState.isOpen;
        return _extends2((_extends22 = {}, _extends22[refKey] = handleRefs(ref, _this.rootRef), _extends22.role = "combobox", _extends22["aria-expanded"] = isOpen, _extends22["aria-haspopup"] = "listbox", _extends22["aria-owns"] = isOpen ? _this.menuId : void 0, _extends22["aria-labelledby"] = _this.labelId, _extends22), rest);
      };
      _this.keyDownHandlers = {
        ArrowDown: function ArrowDown2(event) {
          var _this2 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowDown
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowDown
            }, function() {
              var itemCount = _this2.getItemCount();
              if (itemCount > 0) {
                var _this2$getState = _this2.getState(), highlightedIndex = _this2$getState.highlightedIndex;
                var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, 1, {
                  length: itemCount
                }, _this2.isItemDisabled, true);
                _this2.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowDown
                });
              }
            });
          }
        },
        ArrowUp: function ArrowUp3(event) {
          var _this3 = this;
          event.preventDefault();
          if (this.getState().isOpen) {
            var amount = event.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowUp
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowUp
            }, function() {
              var itemCount = _this3.getItemCount();
              if (itemCount > 0) {
                var _this3$getState = _this3.getState(), highlightedIndex = _this3$getState.highlightedIndex;
                var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, -1, {
                  length: itemCount
                }, _this3.isItemDisabled, true);
                _this3.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowUp
                });
              }
            });
          }
        },
        Enter: function Enter2(event) {
          if (event.which === 229) {
            return;
          }
          var _this$getState2 = this.getState(), isOpen = _this$getState2.isOpen, highlightedIndex = _this$getState2.highlightedIndex;
          if (isOpen && highlightedIndex != null) {
            event.preventDefault();
            var item = this.items[highlightedIndex];
            var itemNode = this.getItemNodeFromIndex(highlightedIndex);
            if (item == null || itemNode && itemNode.hasAttribute("disabled")) {
              return;
            }
            this.selectHighlightedItem({
              type: keyDownEnter
            });
          }
        },
        Escape: function Escape2(event) {
          event.preventDefault();
          this.reset(_extends2({
            type: keyDownEscape
          }, !this.state.isOpen && {
            selectedItem: null,
            inputValue: ""
          }));
        }
      };
      _this.buttonKeyDownHandlers = _extends2({}, _this.keyDownHandlers, {
        " ": function _(event) {
          event.preventDefault();
          this.toggleMenu({
            type: keyDownSpaceButton
          });
        }
      });
      _this.inputKeyDownHandlers = _extends2({}, _this.keyDownHandlers, {
        Home: function Home2(event) {
          var _this$getState3 = this.getState(), isOpen = _this$getState3.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNonDisabledIndex(0, false, {
            length: itemCount
          }, this.isItemDisabled);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownHome
          });
        },
        End: function End2(event) {
          var _this$getState4 = this.getState(), isOpen = _this$getState4.isOpen;
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          var itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          var newHighlightedIndex = getNonDisabledIndex(itemCount - 1, true, {
            length: itemCount
          }, this.isItemDisabled);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownEnd
          });
        }
      });
      _this.getToggleButtonProps = function(_temp3) {
        var _ref3 = _temp3 === void 0 ? {} : _temp3, onClick = _ref3.onClick;
        _ref3.onPress;
        var onKeyDown = _ref3.onKeyDown, onKeyUp = _ref3.onKeyUp, onBlur = _ref3.onBlur, rest = _objectWithoutPropertiesLoose(_ref3, _excluded2$3);
        var _this$getState5 = _this.getState(), isOpen = _this$getState5.isOpen;
        var enabledEventHandlers = {
          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
        };
        var eventHandlers = rest.disabled ? {} : enabledEventHandlers;
        return _extends2({
          type: "button",
          role: "button",
          "aria-label": isOpen ? "close menu" : "open menu",
          "aria-haspopup": true,
          "data-toggle": true
        }, eventHandlers, rest);
      };
      _this.buttonHandleKeyUp = function(event) {
        event.preventDefault();
      };
      _this.buttonHandleKeyDown = function(event) {
        var key = normalizeArrowKey(event);
        if (_this.buttonKeyDownHandlers[key]) {
          _this.buttonKeyDownHandlers[key].call(_this, event);
        }
      };
      _this.buttonHandleClick = function(event) {
        event.preventDefault();
        if (_this.props.environment) {
          var _this$props$environme = _this.props.environment.document, body = _this$props$environme.body, activeElement2 = _this$props$environme.activeElement;
          if (body && body === activeElement2) {
            event.target.focus();
          }
        }
        if (false) {
          _this.toggleMenu({
            type: clickButton
          });
        } else {
          _this.internalSetTimeout(function() {
            return _this.toggleMenu({
              type: clickButton
            });
          });
        }
      };
      _this.buttonHandleBlur = function(event) {
        var blurTarget = event.target;
        _this.internalSetTimeout(function() {
          if (_this.isMouseDown || !_this.props.environment) {
            return;
          }
          var activeElement2 = _this.props.environment.document.activeElement;
          if ((activeElement2 == null || activeElement2.id !== _this.inputId) && activeElement2 !== blurTarget) {
            _this.reset({
              type: blurButton
            });
          }
        });
      };
      _this.getLabelProps = function(props) {
        return _extends2({
          htmlFor: _this.inputId,
          id: _this.labelId
        }, props);
      };
      _this.getInputProps = function(_temp4) {
        var _ref4 = _temp4 === void 0 ? {} : _temp4, onKeyDown = _ref4.onKeyDown, onBlur = _ref4.onBlur, onChange = _ref4.onChange, onInput = _ref4.onInput;
        _ref4.onChangeText;
        var rest = _objectWithoutPropertiesLoose(_ref4, _excluded3$2);
        var onChangeKey;
        var eventHandlers = {};
        {
          onChangeKey = "onChange";
        }
        var _this$getState6 = _this.getState(), inputValue = _this$getState6.inputValue, isOpen = _this$getState6.isOpen, highlightedIndex = _this$getState6.highlightedIndex;
        if (!rest.disabled) {
          var _eventHandlers;
          eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, _this.inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, _this.inputHandleBlur), _eventHandlers);
        }
        return _extends2({
          "aria-autocomplete": "list",
          "aria-activedescendant": isOpen && typeof highlightedIndex === "number" && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : void 0,
          "aria-controls": isOpen ? _this.menuId : void 0,
          "aria-labelledby": rest && rest["aria-label"] ? void 0 : _this.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: "off",
          value: inputValue,
          id: _this.inputId
        }, eventHandlers, rest);
      };
      _this.inputHandleKeyDown = function(event) {
        var key = normalizeArrowKey(event);
        if (key && _this.inputKeyDownHandlers[key]) {
          _this.inputKeyDownHandlers[key].call(_this, event);
        }
      };
      _this.inputHandleChange = function(event) {
        _this.internalSetState({
          type: changeInput,
          isOpen: true,
          inputValue: event.target.value,
          highlightedIndex: _this.props.defaultHighlightedIndex
        });
      };
      _this.inputHandleBlur = function() {
        _this.internalSetTimeout(function() {
          var _activeElement$datase;
          if (_this.isMouseDown || !_this.props.environment) {
            return;
          }
          var activeElement2 = _this.props.environment.document.activeElement;
          var downshiftButtonIsActive = (activeElement2 == null || (_activeElement$datase = activeElement2.dataset) == null ? void 0 : _activeElement$datase.toggle) && _this._rootNode && _this._rootNode.contains(activeElement2);
          if (!downshiftButtonIsActive) {
            _this.reset({
              type: blurInput
            });
          }
        });
      };
      _this.menuRef = function(node) {
        _this._menuNode = node;
      };
      _this.getMenuProps = function(_temp5, _temp6) {
        var _extends3;
        var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref = _ref5.ref, props = _objectWithoutPropertiesLoose(_ref5, _excluded4$2);
        var _ref6 = _temp6 === void 0 ? {} : _temp6, _ref6$suppressRefErro = _ref6.suppressRefError, suppressRefError = _ref6$suppressRefErro === void 0 ? false : _ref6$suppressRefErro;
        _this.getMenuProps.called = true;
        _this.getMenuProps.refKey = refKey;
        _this.getMenuProps.suppressRefError = suppressRefError;
        return _extends2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, _this.menuRef), _extends3.role = "listbox", _extends3["aria-labelledby"] = props && props["aria-label"] ? void 0 : _this.labelId, _extends3.id = _this.menuId, _extends3), props);
      };
      _this.getItemProps = function(_temp7) {
        var _enabledEventHandlers;
        var _ref7 = _temp7 === void 0 ? {} : _temp7, onMouseMove = _ref7.onMouseMove, onMouseDown = _ref7.onMouseDown, onClick = _ref7.onClick;
        _ref7.onPress;
        var index3 = _ref7.index, _ref7$item = _ref7.item, item = _ref7$item === void 0 ? false ? (
          /* istanbul ignore next */
          void 0
        ) : requiredProp("getItemProps", "item") : _ref7$item, rest = _objectWithoutPropertiesLoose(_ref7, _excluded5);
        if (index3 === void 0) {
          _this.items.push(item);
          index3 = _this.items.indexOf(item);
        } else {
          _this.items[index3] = item;
        }
        var onSelectKey = "onClick";
        var customClickHandler = onClick;
        var enabledEventHandlers = (_enabledEventHandlers = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: callAllEventHandlers(onMouseMove, function() {
            if (index3 === _this.getState().highlightedIndex) {
              return;
            }
            _this.setHighlightedIndex(index3, {
              type: itemMouseEnter
            });
            _this.avoidScrolling = true;
            _this.internalSetTimeout(function() {
              return _this.avoidScrolling = false;
            }, 250);
          }),
          onMouseDown: callAllEventHandlers(onMouseDown, function(event) {
            event.preventDefault();
          })
        }, _enabledEventHandlers[onSelectKey] = callAllEventHandlers(customClickHandler, function() {
          _this.selectItemAtIndex(index3, {
            type: clickItem
          });
        }), _enabledEventHandlers);
        var eventHandlers = rest.disabled ? {
          onMouseDown: enabledEventHandlers.onMouseDown
        } : enabledEventHandlers;
        return _extends2({
          id: _this.getItemId(index3),
          role: "option",
          "aria-selected": _this.getState().highlightedIndex === index3
        }, eventHandlers, rest);
      };
      _this.clearItems = function() {
        _this.items = [];
      };
      _this.reset = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref8) {
          var selectedItem = _ref8.selectedItem;
          return _extends2({
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            inputValue: _this.props.itemToString(selectedItem)
          }, otherStateToSet);
        }, cb);
      };
      _this.toggleMenu = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState(function(_ref9) {
          var isOpen = _ref9.isOpen;
          return _extends2({
            isOpen: !isOpen
          }, isOpen && {
            highlightedIndex: _this.props.defaultHighlightedIndex
          }, otherStateToSet);
        }, function() {
          var _this$getState7 = _this.getState(), isOpen = _this$getState7.isOpen, highlightedIndex = _this$getState7.highlightedIndex;
          if (isOpen) {
            if (_this.getItemCount() > 0 && typeof highlightedIndex === "number") {
              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
            }
          }
          cbToCb(cb)();
        });
      };
      _this.openMenu = function(cb) {
        _this.internalSetState({
          isOpen: true
        }, cb);
      };
      _this.closeMenu = function(cb) {
        _this.internalSetState({
          isOpen: false
        }, cb);
      };
      _this.updateStatus = debounce3(function() {
        var _this$props;
        if (!((_this$props = _this.props) != null && (_this$props = _this$props.environment) != null && _this$props.document)) {
          return;
        }
        var state = _this.getState();
        var item = _this.items[state.highlightedIndex];
        var resultCount = _this.getItemCount();
        var status = _this.props.getA11yStatusMessage(_extends2({
          itemToString: _this.props.itemToString,
          previousResultCount: _this.previousResultCount,
          resultCount,
          highlightedItem: item
        }, state));
        _this.previousResultCount = resultCount;
        setStatus(status, _this.props.environment.document);
      }, 200);
      var _this$props2 = _this.props, defaultHighlightedIndex = _this$props2.defaultHighlightedIndex, _this$props2$initialH = _this$props2.initialHighlightedIndex, _highlightedIndex = _this$props2$initialH === void 0 ? defaultHighlightedIndex : _this$props2$initialH, defaultIsOpen = _this$props2.defaultIsOpen, _this$props2$initialI = _this$props2.initialIsOpen, _isOpen = _this$props2$initialI === void 0 ? defaultIsOpen : _this$props2$initialI, _this$props2$initialI2 = _this$props2.initialInputValue, _inputValue = _this$props2$initialI2 === void 0 ? "" : _this$props2$initialI2, _this$props2$initialS = _this$props2.initialSelectedItem, _selectedItem = _this$props2$initialS === void 0 ? null : _this$props2$initialS;
      var _state = _this.getState({
        highlightedIndex: _highlightedIndex,
        isOpen: _isOpen,
        inputValue: _inputValue,
        selectedItem: _selectedItem
      });
      if (_state.selectedItem != null && _this.props.initialInputValue === void 0) {
        _state.inputValue = _this.props.itemToString(_state.selectedItem);
      }
      _this.state = _state;
      return _this;
    }
    _inheritsLoose(Downshift3, _Component);
    var _proto = Downshift3.prototype;
    _proto.internalClearTimeouts = function internalClearTimeouts() {
      this.timeoutIds.forEach(function(id) {
        clearTimeout(id);
      });
      this.timeoutIds = [];
    };
    _proto.getState = function getState$1(stateToMerge) {
      if (stateToMerge === void 0) {
        stateToMerge = this.state;
      }
      return getState(stateToMerge, this.props);
    };
    _proto.getItemCount = function getItemCount() {
      var itemCount = this.items.length;
      if (this.itemCount != null) {
        itemCount = this.itemCount;
      } else if (this.props.itemCount !== void 0) {
        itemCount = this.props.itemCount;
      }
      return itemCount;
    };
    _proto.getItemNodeFromIndex = function getItemNodeFromIndex(index3) {
      return this.props.environment ? this.props.environment.document.getElementById(this.getItemId(index3)) : null;
    };
    _proto.scrollHighlightedItemIntoView = function scrollHighlightedItemIntoView() {
      {
        var node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(node, this._menuNode);
      }
    };
    _proto.moveHighlightedIndex = function moveHighlightedIndex(amount, otherStateToSet) {
      var itemCount = this.getItemCount();
      var _this$getState8 = this.getState(), highlightedIndex = _this$getState8.highlightedIndex;
      if (itemCount > 0) {
        var nextHighlightedIndex = getHighlightedIndex(highlightedIndex, amount, {
          length: itemCount
        }, this.isItemDisabled, true);
        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
      }
    };
    _proto.getStateAndHelpers = function getStateAndHelpers() {
      var _this$getState9 = this.getState(), highlightedIndex = _this$getState9.highlightedIndex, inputValue = _this$getState9.inputValue, selectedItem = _this$getState9.selectedItem, isOpen = _this$getState9.isOpen;
      var itemToString3 = this.props.itemToString;
      var id = this.id;
      var getRootProps = this.getRootProps, getToggleButtonProps = this.getToggleButtonProps, getLabelProps = this.getLabelProps, getMenuProps = this.getMenuProps, getInputProps = this.getInputProps, getItemProps = this.getItemProps, openMenu = this.openMenu, closeMenu = this.closeMenu, toggleMenu = this.toggleMenu, selectItem = this.selectItem, selectItemAtIndex = this.selectItemAtIndex, selectHighlightedItem = this.selectHighlightedItem, setHighlightedIndex = this.setHighlightedIndex, clearSelection = this.clearSelection, clearItems = this.clearItems, reset = this.reset, setItemCount = this.setItemCount, unsetItemCount = this.unsetItemCount, setState = this.internalSetState;
      return {
        // prop getters
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        // actions
        reset,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        setItemCount,
        unsetItemCount,
        setState,
        // props
        itemToString: itemToString3,
        // derived
        id,
        // state
        highlightedIndex,
        inputValue,
        isOpen,
        selectedItem
      };
    };
    _proto.componentDidMount = function componentDidMount() {
      var _this4 = this;
      if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
      }
      if (!this.props.environment) {
        this.cleanup = function() {
          _this4.internalClearTimeouts();
        };
      } else {
        var onMouseDown = function onMouseDown2() {
          _this4.isMouseDown = true;
        };
        var onMouseUp = function onMouseUp2(event) {
          _this4.isMouseDown = false;
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this4._rootNode, _this4._menuNode], _this4.props.environment);
          if (!contextWithinDownshift && _this4.getState().isOpen) {
            _this4.reset({
              type: mouseUp
            }, function() {
              return _this4.props.onOuterClick(_this4.getStateAndHelpers());
            });
          }
        };
        var onTouchStart = function onTouchStart2() {
          _this4.isTouchMove = false;
        };
        var onTouchMove = function onTouchMove2() {
          _this4.isTouchMove = true;
        };
        var onTouchEnd = function onTouchEnd2(event) {
          var contextWithinDownshift = targetWithinDownshift(event.target, [_this4._rootNode, _this4._menuNode], _this4.props.environment, false);
          if (!_this4.isTouchMove && !contextWithinDownshift && _this4.getState().isOpen) {
            _this4.reset({
              type: touchEnd
            }, function() {
              return _this4.props.onOuterClick(_this4.getStateAndHelpers());
            });
          }
        };
        var environment = this.props.environment;
        environment.addEventListener("mousedown", onMouseDown);
        environment.addEventListener("mouseup", onMouseUp);
        environment.addEventListener("touchstart", onTouchStart);
        environment.addEventListener("touchmove", onTouchMove);
        environment.addEventListener("touchend", onTouchEnd);
        this.cleanup = function() {
          _this4.internalClearTimeouts();
          _this4.updateStatus.cancel();
          environment.removeEventListener("mousedown", onMouseDown);
          environment.removeEventListener("mouseup", onMouseUp);
          environment.removeEventListener("touchstart", onTouchStart);
          environment.removeEventListener("touchmove", onTouchMove);
          environment.removeEventListener("touchend", onTouchEnd);
        };
      }
    };
    _proto.shouldScroll = function shouldScroll(prevState, prevProps) {
      var _ref0 = this.props.highlightedIndex === void 0 ? this.getState() : this.props, currentHighlightedIndex = _ref0.highlightedIndex;
      var _ref1 = prevProps.highlightedIndex === void 0 ? prevState : prevProps, prevHighlightedIndex = _ref1.highlightedIndex;
      var scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
      var scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;
      return scrollWhenOpen || scrollWhenNavigating;
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
      if (true) {
        validateControlledUnchanged(this.state, prevProps, this.props);
        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
      }
      if (isControlledProp(this.props, "selectedItem") && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
        this.internalSetState({
          type: controlledPropUpdatedSelectedItem,
          inputValue: this.props.itemToString(this.props.selectedItem)
        });
      }
      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
        this.scrollHighlightedItemIntoView();
      }
      {
        this.updateStatus();
      }
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cleanup();
    };
    _proto.render = function render() {
      var children = unwrapArray(this.props.children, noop5);
      this.clearItems();
      this.getRootProps.called = false;
      this.getRootProps.refKey = void 0;
      this.getRootProps.suppressRefError = void 0;
      this.getMenuProps.called = false;
      this.getMenuProps.refKey = void 0;
      this.getMenuProps.suppressRefError = void 0;
      this.getLabelProps.called = false;
      this.getInputProps.called = false;
      var element = unwrapArray(children(this.getStateAndHelpers()));
      if (!element) {
        return null;
      }
      if (this.getRootProps.called || this.props.suppressRefError) {
        if (!this.getRootProps.suppressRefError && !this.props.suppressRefError) {
          validateGetRootPropsCalledCorrectly(element, this.getRootProps);
        }
        return element;
      } else if (isDOMElement(element)) {
        return (0, import_react50.cloneElement)(element, this.getRootProps(getElementProps(element)));
      }
      if (true) {
        throw new Error("downshift: If you return a non-DOM element, you must apply the getRootProps function");
      }
      return void 0;
    };
    return Downshift3;
  }(import_react50.Component);
  Downshift2.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: false,
    getA11yStatusMessage,
    itemToString: function itemToString3(i) {
      if (i == null) {
        return "";
      }
      if (isPlainObject(i) && !i.hasOwnProperty("toString")) {
        console.warn("downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.", "The object that was passed:", i);
      }
      return String(i);
    },
    onStateChange: noop5,
    onInputValueChange: noop5,
    onUserAction: noop5,
    onChange: noop5,
    onSelect: noop5,
    onOuterClick: noop5,
    selectedItemChanged: function selectedItemChanged(prevItem, item) {
      return prevItem !== item;
    },
    environment: (
      /* istanbul ignore next (ssr) */
      typeof window === "undefined" || false ? void 0 : window
    ),
    stateReducer: function stateReducer3(state, stateToSet) {
      return stateToSet;
    },
    suppressRefError: false,
    scrollIntoView
  };
  Downshift2.stateChangeTypes = stateChangeTypes$3;
  return Downshift2;
}();
true ? Downshift.propTypes = {
  children: import_prop_types32.default.func,
  defaultHighlightedIndex: import_prop_types32.default.number,
  defaultIsOpen: import_prop_types32.default.bool,
  initialHighlightedIndex: import_prop_types32.default.number,
  initialSelectedItem: import_prop_types32.default.any,
  initialInputValue: import_prop_types32.default.string,
  initialIsOpen: import_prop_types32.default.bool,
  getA11yStatusMessage: import_prop_types32.default.func,
  itemToString: import_prop_types32.default.func,
  onChange: import_prop_types32.default.func,
  onSelect: import_prop_types32.default.func,
  onStateChange: import_prop_types32.default.func,
  onInputValueChange: import_prop_types32.default.func,
  onUserAction: import_prop_types32.default.func,
  onOuterClick: import_prop_types32.default.func,
  selectedItemChanged: import_prop_types32.default.func,
  stateReducer: import_prop_types32.default.func,
  itemCount: import_prop_types32.default.number,
  id: import_prop_types32.default.string,
  environment: import_prop_types32.default.shape({
    addEventListener: import_prop_types32.default.func.isRequired,
    removeEventListener: import_prop_types32.default.func.isRequired,
    document: import_prop_types32.default.shape({
      createElement: import_prop_types32.default.func.isRequired,
      getElementById: import_prop_types32.default.func.isRequired,
      activeElement: import_prop_types32.default.any.isRequired,
      body: import_prop_types32.default.any.isRequired
    }).isRequired,
    Node: import_prop_types32.default.func.isRequired
  }),
  suppressRefError: import_prop_types32.default.bool,
  scrollIntoView: import_prop_types32.default.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components
  /* eslint-disable react/no-unused-prop-types */
  selectedItem: import_prop_types32.default.any,
  isOpen: import_prop_types32.default.bool,
  inputValue: import_prop_types32.default.string,
  highlightedIndex: import_prop_types32.default.number,
  labelId: import_prop_types32.default.string,
  inputId: import_prop_types32.default.string,
  menuId: import_prop_types32.default.string,
  getItemId: import_prop_types32.default.func
  /* eslint-enable react/no-unused-prop-types */
} : void 0;
function validateGetMenuPropsCalledCorrectly(node, _ref10) {
  var refKey = _ref10.refKey;
  if (!node) {
    console.error('downshift: The ref prop "' + refKey + '" from getMenuProps was not applied correctly on your menu element.');
  }
}
function validateGetRootPropsCalledCorrectly(element, _ref11) {
  var refKey = _ref11.refKey;
  var refKeySpecified = refKey !== "ref";
  var isComposite = !isDOMElement(element);
  if (isComposite && !refKeySpecified && !(0, import_react_is.isForwardRef)(element)) {
    console.error("downshift: You returned a non-DOM element. You must specify a refKey in getRootProps");
  } else if (!isComposite && refKeySpecified) {
    console.error('downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified "' + refKey + '"');
  }
  if (!(0, import_react_is.isForwardRef)(element) && !getElementProps(element)[refKey]) {
    console.error('downshift: You must apply the ref prop "' + refKey + '" from getRootProps onto your root element.');
  }
}
var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ""
};
function callOnChangeProps(action, state, newState) {
  var props = action.props, type = action.type;
  var changes = {};
  Object.keys(state).forEach(function(key) {
    invokeOnChangeHandler(key, action, state, newState);
    if (newState[key] !== state[key]) {
      changes[key] = newState[key];
    }
  });
  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange(_extends2({
      type
    }, changes));
  }
}
function invokeOnChangeHandler(key, action, state, newState) {
  var props = action.props, type = action.type;
  var handler = "on" + capitalizeString(key) + "Change";
  if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
    props[handler](_extends2({
      type
    }, newState));
  }
}
function stateReducer(s, a) {
  return a.changes;
}
var updateA11yStatus = debounce3(function(status, document2) {
  setStatus(status, document2);
}, 200);
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react50.useLayoutEffect : import_react50.useEffect;
var useElementIds = "useId" in import_react50.default ? function useElementIds2(_ref) {
  var id = _ref.id, labelId = _ref.labelId, menuId = _ref.menuId, getItemId = _ref.getItemId, toggleButtonId = _ref.toggleButtonId, inputId = _ref.inputId;
  var reactId = "downshift-" + import_react50.default.useId();
  if (!id) {
    id = reactId;
  }
  var elementIdsRef = (0, import_react50.useRef)({
    labelId: labelId || id + "-label",
    menuId: menuId || id + "-menu",
    getItemId: getItemId || function(index3) {
      return id + "-item-" + index3;
    },
    toggleButtonId: toggleButtonId || id + "-toggle-button",
    inputId: inputId || id + "-input"
  });
  return elementIdsRef.current;
} : function useElementIds3(_ref2) {
  var _ref2$id = _ref2.id, id = _ref2$id === void 0 ? "downshift-" + generateId() : _ref2$id, labelId = _ref2.labelId, menuId = _ref2.menuId, getItemId = _ref2.getItemId, toggleButtonId = _ref2.toggleButtonId, inputId = _ref2.inputId;
  var elementIdsRef = (0, import_react50.useRef)({
    labelId: labelId || id + "-label",
    menuId: menuId || id + "-menu",
    getItemId: getItemId || function(index3) {
      return id + "-item-" + index3;
    },
    toggleButtonId: toggleButtonId || id + "-toggle-button",
    inputId: inputId || id + "-input"
  });
  return elementIdsRef.current;
};
function getItemAndIndex(itemProp, indexProp, items, errorMessage) {
  var item, index3;
  if (itemProp === void 0) {
    if (indexProp === void 0) {
      throw new Error(errorMessage);
    }
    item = items[indexProp];
    index3 = indexProp;
  } else {
    index3 = indexProp === void 0 ? items.indexOf(itemProp) : indexProp;
    item = itemProp;
  }
  return [item, index3];
}
function isAcceptedCharacterKey(key) {
  return /^\S{1}$/.test(key);
}
function capitalizeString(string) {
  return "" + string.slice(0, 1).toUpperCase() + string.slice(1);
}
function useLatestRef3(val) {
  var ref = (0, import_react50.useRef)(val);
  ref.current = val;
  return ref;
}
function useEnhancedReducer(reducer, props, createInitialState, isStateEqual2) {
  var prevStateRef = (0, import_react50.useRef)();
  var actionRef = (0, import_react50.useRef)();
  var enhancedReducer = (0, import_react50.useCallback)(function(state2, action2) {
    actionRef.current = action2;
    state2 = getState(state2, action2.props);
    var changes = reducer(state2, action2);
    var newState = action2.props.stateReducer(state2, _extends2({}, action2, {
      changes
    }));
    return newState;
  }, [reducer]);
  var _useReducer = (0, import_react50.useReducer)(enhancedReducer, props, createInitialState), state = _useReducer[0], dispatch = _useReducer[1];
  var propsRef = useLatestRef3(props);
  var dispatchWithProps = (0, import_react50.useCallback)(function(action2) {
    return dispatch(_extends2({
      props: propsRef.current
    }, action2));
  }, [propsRef]);
  var action = actionRef.current;
  (0, import_react50.useEffect)(function() {
    var prevState = getState(prevStateRef.current, action == null ? void 0 : action.props);
    var shouldCallOnChangeProps = action && prevStateRef.current && !isStateEqual2(prevState, state);
    if (shouldCallOnChangeProps) {
      callOnChangeProps(action, prevState, state);
    }
    prevStateRef.current = state;
  }, [state, action, isStateEqual2]);
  return [state, dispatchWithProps];
}
function useControlledReducer$1(reducer, props, createInitialState, isStateEqual2) {
  var _useEnhancedReducer = useEnhancedReducer(reducer, props, createInitialState, isStateEqual2), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  return [getState(state, props), dispatch];
}
var defaultProps$3 = {
  itemToString: function itemToString(item) {
    return item ? String(item) : "";
  },
  itemToKey: function itemToKey(item) {
    return item;
  },
  stateReducer,
  scrollIntoView,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window === "undefined" || false ? void 0 : window
  )
};
function getDefaultValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  var defaultValue = props["default" + capitalizeString(propKey)];
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  return defaultStateValues2[propKey];
}
function getInitialValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  var value = props[propKey];
  if (value !== void 0) {
    return value;
  }
  var initialValue = props["initial" + capitalizeString(propKey)];
  if (initialValue !== void 0) {
    return initialValue;
  }
  return getDefaultValue$1(props, propKey, defaultStateValues2);
}
function getInitialState$2(props) {
  var selectedItem = getInitialValue$1(props, "selectedItem");
  var isOpen = getInitialValue$1(props, "isOpen");
  var highlightedIndex = getInitialHighlightedIndex(props);
  var inputValue = getInitialValue$1(props, "inputValue");
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.findIndex(function(item) {
      return props.itemToKey(item) === props.itemToKey(selectedItem);
    }) : highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getHighlightedIndexOnOpen(props, state, offset4) {
  var items = props.items, initialHighlightedIndex = props.initialHighlightedIndex, defaultHighlightedIndex = props.defaultHighlightedIndex, isItemDisabled2 = props.isItemDisabled, itemToKey2 = props.itemToKey;
  var selectedItem = state.selectedItem, highlightedIndex = state.highlightedIndex;
  if (items.length === 0) {
    return -1;
  }
  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex && !isItemDisabled2(items[initialHighlightedIndex], initialHighlightedIndex)) {
    return initialHighlightedIndex;
  }
  if (defaultHighlightedIndex !== void 0 && !isItemDisabled2(items[defaultHighlightedIndex], defaultHighlightedIndex)) {
    return defaultHighlightedIndex;
  }
  if (selectedItem) {
    return items.findIndex(function(item) {
      return itemToKey2(selectedItem) === itemToKey2(item);
    });
  }
  if (offset4 < 0 && !isItemDisabled2(items[items.length - 1], items.length - 1)) {
    return items.length - 1;
  }
  if (offset4 > 0 && !isItemDisabled2(items[0], 0)) {
    return 0;
  }
  return -1;
}
function useMouseAndTouchTracker(environment, handleBlur, downshiftElementsRefs) {
  var mouseAndTouchTrackersRef = (0, import_react50.useRef)({
    isMouseDown: false,
    isTouchMove: false,
    isTouchEnd: false
  });
  (0, import_react50.useEffect)(function() {
    if (!environment) {
      return noop5;
    }
    var downshiftElements = downshiftElementsRefs.map(function(ref) {
      return ref.current;
    });
    function onMouseDown() {
      mouseAndTouchTrackersRef.current.isTouchEnd = false;
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    }
    function onMouseUp(event) {
      mouseAndTouchTrackersRef.current.isMouseDown = false;
      if (!targetWithinDownshift(event.target, downshiftElements, environment)) {
        handleBlur();
      }
    }
    function onTouchStart() {
      mouseAndTouchTrackersRef.current.isTouchEnd = false;
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    }
    function onTouchMove() {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    }
    function onTouchEnd(event) {
      mouseAndTouchTrackersRef.current.isTouchEnd = true;
      if (!mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElements, environment, false)) {
        handleBlur();
      }
    }
    environment.addEventListener("mousedown", onMouseDown);
    environment.addEventListener("mouseup", onMouseUp);
    environment.addEventListener("touchstart", onTouchStart);
    environment.addEventListener("touchmove", onTouchMove);
    environment.addEventListener("touchend", onTouchEnd);
    return function cleanup2() {
      environment.removeEventListener("mousedown", onMouseDown);
      environment.removeEventListener("mouseup", onMouseUp);
      environment.removeEventListener("touchstart", onTouchStart);
      environment.removeEventListener("touchmove", onTouchMove);
      environment.removeEventListener("touchend", onTouchEnd);
    };
  }, [downshiftElementsRefs, environment, handleBlur]);
  return mouseAndTouchTrackersRef.current;
}
var useGetterPropsCalledChecker = function useGetterPropsCalledChecker2() {
  return noop5;
};
if (true) {
  useGetterPropsCalledChecker = function useGetterPropsCalledChecker3() {
    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {
      propKeys[_key] = arguments[_key];
    }
    var getterPropsCalledRef = (0, import_react50.useRef)(propKeys.reduce(function(acc, propKey) {
      acc[propKey] = {};
      return acc;
    }, {}));
    (0, import_react50.useEffect)(function() {
      Object.keys(getterPropsCalledRef.current).forEach(function(propKey) {
        var propCallInfo = getterPropsCalledRef.current[propKey];
        if (!Object.keys(propCallInfo).length) {
          console.error("downshift: You forgot to call the " + propKey + " getter function on your component / element.");
          return;
        }
        var suppressRefError = propCallInfo.suppressRefError, refKey = propCallInfo.refKey, elementRef = propCallInfo.elementRef;
        if (suppressRefError) {
          return;
        }
        if (!(elementRef != null && elementRef.current)) {
          console.error('downshift: The ref prop "' + refKey + '" from ' + propKey + " was not applied correctly on your element.");
        }
      });
    }, []);
    var setGetterPropCallInfo = (0, import_react50.useCallback)(function(propKey, suppressRefError, refKey, elementRef) {
      getterPropsCalledRef.current[propKey] = {
        suppressRefError,
        refKey,
        elementRef
      };
    }, []);
    return setGetterPropCallInfo;
  };
}
function useA11yMessageStatus(getA11yStatusMessage2, options, dependencyArray, environment) {
  if (environment === void 0) {
    environment = {};
  }
  var document2 = environment.document;
  var isInitialMount = useIsInitialMount();
  (0, import_react50.useEffect)(function() {
    if (!getA11yStatusMessage2 || isInitialMount || false || !document2) {
      return;
    }
    var status = getA11yStatusMessage2(options);
    updateA11yStatus(status, document2);
  }, dependencyArray);
  (0, import_react50.useEffect)(function() {
    return function() {
      updateA11yStatus.cancel();
      cleanupStatusDiv(document2);
    };
  }, [document2]);
}
function useScrollIntoView(_ref3) {
  var highlightedIndex = _ref3.highlightedIndex, isOpen = _ref3.isOpen, itemRefs = _ref3.itemRefs, getItemNodeFromIndex = _ref3.getItemNodeFromIndex, menuElement = _ref3.menuElement, scrollIntoViewProp = _ref3.scrollIntoView;
  var shouldScrollRef = (0, import_react50.useRef)(true);
  useIsomorphicLayoutEffect2(function() {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }
    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    }
  }, [highlightedIndex]);
  return shouldScrollRef;
}
var useControlPropsValidator = noop5;
if (true) {
  useControlPropsValidator = function useControlPropsValidator2(_ref4) {
    var props = _ref4.props, state = _ref4.state;
    var prevPropsRef = (0, import_react50.useRef)(props);
    var isInitialMount = useIsInitialMount();
    (0, import_react50.useEffect)(function() {
      if (isInitialMount) {
        return;
      }
      validateControlledUnchanged(state, prevPropsRef.current, props);
      prevPropsRef.current = props;
    }, [state, props, isInitialMount]);
  };
}
function getChangesOnSelection(props, highlightedIndex, inputValue) {
  var _props$items;
  if (inputValue === void 0) {
    inputValue = true;
  }
  var shouldSelect = ((_props$items = props.items) == null ? void 0 : _props$items.length) && highlightedIndex >= 0;
  return _extends2({
    isOpen: false,
    highlightedIndex: -1
  }, shouldSelect && _extends2({
    selectedItem: props.items[highlightedIndex],
    isOpen: getDefaultValue$1(props, "isOpen"),
    highlightedIndex: getDefaultValue$1(props, "highlightedIndex")
  }, inputValue && {
    inputValue: props.itemToString(props.items[highlightedIndex])
  }));
}
function isDropdownsStateEqual(prevState, newState) {
  return prevState.isOpen === newState.isOpen && prevState.inputValue === newState.inputValue && prevState.highlightedIndex === newState.highlightedIndex && prevState.selectedItem === newState.selectedItem;
}
function useIsInitialMount() {
  var isInitialMountRef = import_react50.default.useRef(true);
  import_react50.default.useEffect(function() {
    isInitialMountRef.current = false;
    return function() {
      isInitialMountRef.current = true;
    };
  }, []);
  return isInitialMountRef.current;
}
function getDefaultHighlightedIndex(props) {
  var highlightedIndex = getDefaultValue$1(props, "highlightedIndex");
  if (highlightedIndex > -1 && props.isItemDisabled(props.items[highlightedIndex], highlightedIndex)) {
    return -1;
  }
  return highlightedIndex;
}
function getInitialHighlightedIndex(props) {
  var highlightedIndex = getInitialValue$1(props, "highlightedIndex");
  if (highlightedIndex > -1 && props.isItemDisabled(props.items[highlightedIndex], highlightedIndex)) {
    return -1;
  }
  return highlightedIndex;
}
var commonPropTypes = {
  environment: import_prop_types32.default.shape({
    addEventListener: import_prop_types32.default.func.isRequired,
    removeEventListener: import_prop_types32.default.func.isRequired,
    document: import_prop_types32.default.shape({
      createElement: import_prop_types32.default.func.isRequired,
      getElementById: import_prop_types32.default.func.isRequired,
      activeElement: import_prop_types32.default.any.isRequired,
      body: import_prop_types32.default.any.isRequired
    }).isRequired,
    Node: import_prop_types32.default.func.isRequired
  }),
  itemToString: import_prop_types32.default.func,
  itemToKey: import_prop_types32.default.func,
  stateReducer: import_prop_types32.default.func
};
var commonDropdownPropTypes = _extends2({}, commonPropTypes, {
  getA11yStatusMessage: import_prop_types32.default.func,
  highlightedIndex: import_prop_types32.default.number,
  defaultHighlightedIndex: import_prop_types32.default.number,
  initialHighlightedIndex: import_prop_types32.default.number,
  isOpen: import_prop_types32.default.bool,
  defaultIsOpen: import_prop_types32.default.bool,
  initialIsOpen: import_prop_types32.default.bool,
  selectedItem: import_prop_types32.default.any,
  initialSelectedItem: import_prop_types32.default.any,
  defaultSelectedItem: import_prop_types32.default.any,
  id: import_prop_types32.default.string,
  labelId: import_prop_types32.default.string,
  menuId: import_prop_types32.default.string,
  getItemId: import_prop_types32.default.func,
  toggleButtonId: import_prop_types32.default.string,
  onSelectedItemChange: import_prop_types32.default.func,
  onHighlightedIndexChange: import_prop_types32.default.func,
  onStateChange: import_prop_types32.default.func,
  onIsOpenChange: import_prop_types32.default.func,
  scrollIntoView: import_prop_types32.default.func
});
function downshiftCommonReducer(state, action, stateChangeTypes2) {
  var type = action.type, props = action.props;
  var changes;
  switch (type) {
    case stateChangeTypes2.ItemMouseMove:
      changes = {
        highlightedIndex: action.disabled ? -1 : action.index
      };
      break;
    case stateChangeTypes2.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;
    case stateChangeTypes2.ToggleButtonClick:
    case stateChangeTypes2.FunctionToggleMenu:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;
    case stateChangeTypes2.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: props.isItemDisabled(props.items[action.highlightedIndex], action.highlightedIndex) ? -1 : action.highlightedIndex
      };
      break;
    case stateChangeTypes2.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;
    case stateChangeTypes2.FunctionReset:
      changes = {
        highlightedIndex: getDefaultHighlightedIndex(props),
        isOpen: getDefaultValue$1(props, "isOpen"),
        selectedItem: getDefaultValue$1(props, "selectedItem"),
        inputValue: getDefaultValue$1(props, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends2({}, state, changes);
}
function getItemIndexByCharacterKey(_a) {
  var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString3 = _a.itemToString, isItemDisabled2 = _a.isItemDisabled;
  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
  for (var index3 = 0; index3 < items.length; index3++) {
    var offsetIndex = (index3 + highlightedIndex + (keysSoFar.length < 2 ? 1 : 0)) % items.length;
    var item = items[offsetIndex];
    if (item !== void 0 && itemToString3(item).toLowerCase().startsWith(lowerCasedKeysSoFar) && !isItemDisabled2(item, offsetIndex)) {
      return offsetIndex;
    }
  }
  return highlightedIndex;
}
var propTypes$2 = __assign(__assign({}, commonDropdownPropTypes), { items: import_prop_types32.default.array.isRequired, isItemDisabled: import_prop_types32.default.func });
var defaultProps$2 = __assign(__assign({}, defaultProps$3), { isItemDisabled: function() {
  return false;
} });
var validatePropTypes$2 = noop5;
if (true) {
  validatePropTypes$2 = function(options, caller) {
    import_prop_types32.default.checkPropTypes(propTypes$2, options, "prop", caller.name);
  };
}
var ToggleButtonClick$1 = true ? "__togglebutton_click__" : 0;
var ToggleButtonKeyDownArrowDown = true ? "__togglebutton_keydown_arrow_down__" : 1;
var ToggleButtonKeyDownArrowUp = true ? "__togglebutton_keydown_arrow_up__" : 2;
var ToggleButtonKeyDownCharacter = true ? "__togglebutton_keydown_character__" : 3;
var ToggleButtonKeyDownEscape = true ? "__togglebutton_keydown_escape__" : 4;
var ToggleButtonKeyDownHome = true ? "__togglebutton_keydown_home__" : 5;
var ToggleButtonKeyDownEnd = true ? "__togglebutton_keydown_end__" : 6;
var ToggleButtonKeyDownEnter = true ? "__togglebutton_keydown_enter__" : 7;
var ToggleButtonKeyDownSpaceButton = true ? "__togglebutton_keydown_space_button__" : 8;
var ToggleButtonKeyDownPageUp = true ? "__togglebutton_keydown_page_up__" : 9;
var ToggleButtonKeyDownPageDown = true ? "__togglebutton_keydown_page_down__" : 10;
var ToggleButtonBlur = true ? "__togglebutton_blur__" : 11;
var MenuMouseLeave$1 = true ? "__menu_mouse_leave__" : 12;
var ItemMouseMove$1 = true ? "__item_mouse_move__" : 13;
var ItemClick$1 = true ? "__item_click__" : 14;
var FunctionToggleMenu$1 = true ? "__function_toggle_menu__" : 15;
var FunctionOpenMenu$1 = true ? "__function_open_menu__" : 16;
var FunctionCloseMenu$1 = true ? "__function_close_menu__" : 17;
var FunctionSetHighlightedIndex$1 = true ? "__function_set_highlighted_index__" : 18;
var FunctionSelectItem$1 = true ? "__function_select_item__" : 19;
var FunctionSetInputValue$1 = true ? "__function_set_input_value__" : 20;
var FunctionReset$2 = true ? "__function_reset__" : 21;
var stateChangeTypes$2 = Object.freeze({
  __proto__: null,
  FunctionCloseMenu: FunctionCloseMenu$1,
  FunctionOpenMenu: FunctionOpenMenu$1,
  FunctionReset: FunctionReset$2,
  FunctionSelectItem: FunctionSelectItem$1,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
  FunctionSetInputValue: FunctionSetInputValue$1,
  FunctionToggleMenu: FunctionToggleMenu$1,
  ItemClick: ItemClick$1,
  ItemMouseMove: ItemMouseMove$1,
  MenuMouseLeave: MenuMouseLeave$1,
  ToggleButtonBlur,
  ToggleButtonClick: ToggleButtonClick$1,
  ToggleButtonKeyDownArrowDown,
  ToggleButtonKeyDownArrowUp,
  ToggleButtonKeyDownCharacter,
  ToggleButtonKeyDownEnd,
  ToggleButtonKeyDownEnter,
  ToggleButtonKeyDownEscape,
  ToggleButtonKeyDownHome,
  ToggleButtonKeyDownPageDown,
  ToggleButtonKeyDownPageUp,
  ToggleButtonKeyDownSpaceButton
});
function downshiftSelectReducer(state, action) {
  var _props$items;
  var type = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type) {
    case ItemClick$1:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultHighlightedIndex(props),
        selectedItem: props.items[action.index]
      };
      break;
    case ToggleButtonKeyDownCharacter:
      {
        var lowercasedKey = action.key;
        var inputValue = "" + state.inputValue + lowercasedKey;
        var prevHighlightedIndex = !state.isOpen && state.selectedItem ? props.items.findIndex(function(item) {
          return props.itemToKey(item) === props.itemToKey(state.selectedItem);
        }) : state.highlightedIndex;
        var highlightedIndex = getItemIndexByCharacterKey({
          keysSoFar: inputValue,
          highlightedIndex: prevHighlightedIndex,
          items: props.items,
          itemToString: props.itemToString,
          isItemDisabled: props.isItemDisabled
        });
        changes = {
          inputValue,
          highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowDown:
      {
        var _highlightedIndex = state.isOpen ? getHighlightedIndex(state.highlightedIndex, 1, props.items, props.isItemDisabled) : altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1);
        changes = {
          highlightedIndex: _highlightedIndex,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownArrowUp:
      if (state.isOpen && altKey) {
        changes = getChangesOnSelection(props, state.highlightedIndex, false);
      } else {
        var _highlightedIndex2 = state.isOpen ? getHighlightedIndex(state.highlightedIndex, -1, props.items, props.isItemDisabled) : getHighlightedIndexOnOpen(props, state, -1);
        changes = {
          highlightedIndex: _highlightedIndex2,
          isOpen: true
        };
      }
      break;
    case ToggleButtonKeyDownEnter:
    case ToggleButtonKeyDownSpaceButton:
      changes = getChangesOnSelection(props, state.highlightedIndex, false);
      break;
    case ToggleButtonKeyDownHome:
      changes = {
        highlightedIndex: getNonDisabledIndex(0, false, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownEnd:
      changes = {
        highlightedIndex: getNonDisabledIndex(props.items.length - 1, true, props.items, props.isItemDisabled),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownPageUp:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, -10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownPageDown:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, 10, props.items, props.isItemDisabled)
      };
      break;
    case ToggleButtonKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;
    case ToggleButtonBlur:
      changes = _extends2({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && {
        selectedItem: props.items[state.highlightedIndex]
      });
      break;
    case FunctionSelectItem$1:
      changes = {
        selectedItem: action.selectedItem
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$2);
  }
  return _extends2({}, state, changes);
}
var _excluded$2 = ["onClick"];
var _excluded2$2 = ["onMouseLeave", "refKey", "ref"];
var _excluded3$1 = ["onBlur", "onClick", "onPress", "onKeyDown", "refKey", "ref"];
var _excluded4$1 = ["item", "index", "onMouseMove", "onClick", "onMouseDown", "onPress", "refKey", "disabled", "ref"];
useSelect.stateChangeTypes = stateChangeTypes$2;
function useSelect(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$2(userProps, useSelect);
  var props = _extends2({}, defaultProps$2, userProps);
  var scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage;
  var _useControlledReducer = useControlledReducer$1(downshiftSelectReducer, props, getInitialState$2, isDropdownsStateEqual), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var toggleButtonRef = (0, import_react50.useRef)(null);
  var menuRef = (0, import_react50.useRef)(null);
  var itemRefs = (0, import_react50.useRef)({});
  var clearTimeoutRef = (0, import_react50.useRef)(null);
  var elementIds = useElementIds(props);
  var latest = useLatestRef3({
    state,
    props
  });
  var getItemNodeFromIndex = (0, import_react50.useCallback)(function(index3) {
    return itemRefs.current[elementIds.getItemId(index3)];
  }, [elementIds]);
  useA11yMessageStatus(getA11yStatusMessage2, state, [isOpen, highlightedIndex, selectedItem, inputValue], environment);
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  (0, import_react50.useEffect)(function() {
    clearTimeoutRef.current = debounce3(function(outerDispatch) {
      outerDispatch({
        type: FunctionSetInputValue$1,
        inputValue: ""
      });
    }, 500);
    return function() {
      clearTimeoutRef.current.cancel();
    };
  }, []);
  (0, import_react50.useEffect)(function() {
    if (!inputValue) {
      return;
    }
    clearTimeoutRef.current(dispatch);
  }, [dispatch, inputValue]);
  useControlPropsValidator({
    props,
    state
  });
  (0, import_react50.useEffect)(function() {
    var focusOnOpen = getInitialValue$1(props, "isOpen");
    if (focusOnOpen && toggleButtonRef.current) {
      toggleButtonRef.current.focus();
    }
  }, []);
  var mouseAndTouchTrackers = useMouseAndTouchTracker(environment, (0, import_react50.useCallback)(function handleBlur() {
    if (latest.current.state.isOpen) {
      dispatch({
        type: ToggleButtonBlur
      });
    }
  }, [dispatch, latest]), (0, import_react50.useMemo)(function() {
    return [menuRef, toggleButtonRef];
  }, [menuRef.current, toggleButtonRef.current]));
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getMenuProps", "getToggleButtonProps");
  (0, import_react50.useEffect)(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  var toggleButtonKeyDownHandlers = (0, import_react50.useMemo)(function() {
    return {
      ArrowDown: function ArrowDown2(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowDown,
          altKey: event.altKey
        });
      },
      ArrowUp: function ArrowUp3(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownArrowUp,
          altKey: event.altKey
        });
      },
      Home: function Home2(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownHome
        });
      },
      End: function End2(event) {
        event.preventDefault();
        dispatch({
          type: ToggleButtonKeyDownEnd
        });
      },
      Escape: function Escape2() {
        if (latest.current.state.isOpen) {
          dispatch({
            type: ToggleButtonKeyDownEscape
          });
        }
      },
      Enter: function Enter2(event) {
        event.preventDefault();
        dispatch({
          type: latest.current.state.isOpen ? ToggleButtonKeyDownEnter : ToggleButtonClick$1
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageUp
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: ToggleButtonKeyDownPageDown
          });
        }
      },
      " ": function _(event) {
        event.preventDefault();
        var currentState = latest.current.state;
        if (!currentState.isOpen) {
          dispatch({
            type: ToggleButtonClick$1
          });
          return;
        }
        if (currentState.inputValue) {
          dispatch({
            type: ToggleButtonKeyDownCharacter,
            key: " "
          });
        } else {
          dispatch({
            type: ToggleButtonKeyDownSpaceButton
          });
        }
      }
    };
  }, [dispatch, latest]);
  var toggleMenu = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionToggleMenu$1
    });
  }, [dispatch]);
  var closeMenu = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionCloseMenu$1
    });
  }, [dispatch]);
  var openMenu = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionOpenMenu$1
    });
  }, [dispatch]);
  var setHighlightedIndex = (0, import_react50.useCallback)(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex$1,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = (0, import_react50.useCallback)(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem$1,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var reset = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionReset$2
    });
  }, [dispatch]);
  var setInputValue = (0, import_react50.useCallback)(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue$1,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var getLabelProps = (0, import_react50.useCallback)(function(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, onClick = _ref.onClick, labelProps = _objectWithoutPropertiesLoose(_ref, _excluded$2);
    var labelHandleClick = function labelHandleClick2() {
      var _toggleButtonRef$curr;
      (_toggleButtonRef$curr = toggleButtonRef.current) == null || _toggleButtonRef$curr.focus();
    };
    return _extends2({
      id: elementIds.labelId,
      htmlFor: elementIds.toggleButtonId,
      onClick: callAllEventHandlers(onClick, labelHandleClick)
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = (0, import_react50.useCallback)(function(_temp2, _temp3) {
    var _extends22;
    var _ref2 = _temp2 === void 0 ? {} : _temp2, onMouseLeave = _ref2.onMouseLeave, _ref2$refKey = _ref2.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, ref = _ref2.ref, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2$2);
    var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$suppressRefErro = _ref3.suppressRefError, suppressRefError = _ref3$suppressRefErro === void 0 ? false : _ref3$suppressRefErro;
    var menuHandleMouseLeave = function menuHandleMouseLeave2() {
      dispatch({
        type: MenuMouseLeave$1
      });
    };
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return _extends2((_extends22 = {}, _extends22[refKey] = handleRefs(ref, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends22.id = elementIds.menuId, _extends22.role = "listbox", _extends22["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends22.onMouseLeave = callAllEventHandlers(onMouseLeave, menuHandleMouseLeave), _extends22), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getToggleButtonProps = (0, import_react50.useCallback)(function(_temp4, _temp5) {
    var _extends3;
    var _ref4 = _temp4 === void 0 ? {} : _temp4, onBlur = _ref4.onBlur, onClick = _ref4.onClick;
    _ref4.onPress;
    var onKeyDown = _ref4.onKeyDown, _ref4$refKey = _ref4.refKey, refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey, ref = _ref4.ref, rest = _objectWithoutPropertiesLoose(_ref4, _excluded3$1);
    var _ref5 = _temp5 === void 0 ? {} : _temp5, _ref5$suppressRefErro = _ref5.suppressRefError, suppressRefError = _ref5$suppressRefErro === void 0 ? false : _ref5$suppressRefErro;
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick$1
      });
    };
    var toggleButtonHandleBlur = function toggleButtonHandleBlur2() {
      if (latestState.isOpen && !mouseAndTouchTrackers.isMouseDown) {
        dispatch({
          type: ToggleButtonBlur
        });
      }
    };
    var toggleButtonHandleKeyDown = function toggleButtonHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key
        });
      }
    };
    var toggleProps = _extends2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends3["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends3["aria-controls"] = elementIds.menuId, _extends3["aria-expanded"] = latest.current.state.isOpen, _extends3["aria-haspopup"] = "listbox", _extends3["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends3.id = elementIds.toggleButtonId, _extends3.role = "combobox", _extends3.tabIndex = 0, _extends3.onBlur = callAllEventHandlers(onBlur, toggleButtonHandleBlur), _extends3), rest);
    if (!rest.disabled) {
      {
        toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
        toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
      }
    }
    setGetterPropCallInfo("getToggleButtonProps", suppressRefError, refKey, toggleButtonRef);
    return toggleProps;
  }, [dispatch, elementIds, latest, mouseAndTouchTrackers, setGetterPropCallInfo, toggleButtonKeyDownHandlers]);
  var getItemProps = (0, import_react50.useCallback)(function(_temp6) {
    var _extends4;
    var _ref6 = _temp6 === void 0 ? {} : _temp6, itemProp = _ref6.item, indexProp = _ref6.index, onMouseMove = _ref6.onMouseMove, onClick = _ref6.onClick, onMouseDown = _ref6.onMouseDown;
    _ref6.onPress;
    var _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, disabledProp = _ref6.disabled, ref = _ref6.ref, rest = _objectWithoutPropertiesLoose(_ref6, _excluded4$1);
    if (disabledProp !== void 0) {
      console.warn('Passing "disabled" as an argument to getItemProps is not supported anymore. Please use the isItemDisabled prop from useSelect.');
    }
    var _latest$current = latest.current, latestState = _latest$current.state, latestProps = _latest$current.props;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), item = _getItemAndIndex[0], index3 = _getItemAndIndex[1];
    var disabled = latestProps.isItemDisabled(item, index3);
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (mouseAndTouchTrackers.isTouchEnd || index3 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove$1,
        index: index3,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick$1,
        index: index3
      });
    };
    var itemHandleMouseDown = function itemHandleMouseDown2(e2) {
      return e2.preventDefault();
    };
    var itemProps = _extends2((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index3)] = itemNode;
      }
    }), _extends4["aria-disabled"] = disabled, _extends4["aria-selected"] = item === latestState.selectedItem, _extends4.id = elementIds.getItemId(index3), _extends4.role = "option", _extends4), rest);
    if (!disabled) {
      {
        itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
      }
    }
    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
    itemProps.onMouseDown = callAllEventHandlers(onMouseDown, itemHandleMouseDown);
    return itemProps;
  }, [latest, elementIds, mouseAndTouchTrackers, shouldScrollRef, dispatch]);
  return {
    // prop getters.
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    selectItem,
    reset,
    setInputValue,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var InputKeyDownArrowDown = true ? "__input_keydown_arrow_down__" : 0;
var InputKeyDownArrowUp = true ? "__input_keydown_arrow_up__" : 1;
var InputKeyDownEscape = true ? "__input_keydown_escape__" : 2;
var InputKeyDownHome = true ? "__input_keydown_home__" : 3;
var InputKeyDownEnd = true ? "__input_keydown_end__" : 4;
var InputKeyDownPageUp = true ? "__input_keydown_page_up__" : 5;
var InputKeyDownPageDown = true ? "__input_keydown_page_down__" : 6;
var InputKeyDownEnter = true ? "__input_keydown_enter__" : 7;
var InputChange = true ? "__input_change__" : 8;
var InputBlur = true ? "__input_blur__" : 9;
var InputClick = true ? "__input_click__" : 10;
var MenuMouseLeave = true ? "__menu_mouse_leave__" : 11;
var ItemMouseMove = true ? "__item_mouse_move__" : 12;
var ItemClick = true ? "__item_click__" : 13;
var ToggleButtonClick = true ? "__togglebutton_click__" : 14;
var FunctionToggleMenu = true ? "__function_toggle_menu__" : 15;
var FunctionOpenMenu = true ? "__function_open_menu__" : 16;
var FunctionCloseMenu = true ? "__function_close_menu__" : 17;
var FunctionSetHighlightedIndex = true ? "__function_set_highlighted_index__" : 18;
var FunctionSelectItem = true ? "__function_select_item__" : 19;
var FunctionSetInputValue = true ? "__function_set_input_value__" : 20;
var FunctionReset$1 = true ? "__function_reset__" : 21;
var ControlledPropUpdatedSelectedItem = true ? "__controlled_prop_updated_selected_item__" : 22;
var stateChangeTypes$1 = Object.freeze({
  __proto__: null,
  ControlledPropUpdatedSelectedItem,
  FunctionCloseMenu,
  FunctionOpenMenu,
  FunctionReset: FunctionReset$1,
  FunctionSelectItem,
  FunctionSetHighlightedIndex,
  FunctionSetInputValue,
  FunctionToggleMenu,
  InputBlur,
  InputChange,
  InputClick,
  InputKeyDownArrowDown,
  InputKeyDownArrowUp,
  InputKeyDownEnd,
  InputKeyDownEnter,
  InputKeyDownEscape,
  InputKeyDownHome,
  InputKeyDownPageDown,
  InputKeyDownPageUp,
  ItemClick,
  ItemMouseMove,
  MenuMouseLeave,
  ToggleButtonClick
});
function getInitialState$1(props) {
  var initialState = getInitialState$2(props);
  var selectedItem = initialState.selectedItem;
  var inputValue = initialState.inputValue;
  if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
    inputValue = props.itemToString(selectedItem);
  }
  return _extends2({}, initialState, {
    inputValue
  });
}
var propTypes$1 = _extends2({}, commonDropdownPropTypes, {
  items: import_prop_types32.default.array.isRequired,
  isItemDisabled: import_prop_types32.default.func,
  inputValue: import_prop_types32.default.string,
  defaultInputValue: import_prop_types32.default.string,
  initialInputValue: import_prop_types32.default.string,
  inputId: import_prop_types32.default.string,
  onInputValueChange: import_prop_types32.default.func
});
function useControlledReducer(reducer, props, createInitialState, isStateEqual2) {
  var previousSelectedItemRef = (0, import_react50.useRef)();
  var _useEnhancedReducer = useEnhancedReducer(reducer, props, createInitialState, isStateEqual2), state = _useEnhancedReducer[0], dispatch = _useEnhancedReducer[1];
  var isInitialMount = useIsInitialMount();
  (0, import_react50.useEffect)(function() {
    if (!isControlledProp(props, "selectedItem")) {
      return;
    }
    if (!isInitialMount) {
      var shouldCallDispatch = props.itemToKey(props.selectedItem) !== props.itemToKey(previousSelectedItemRef.current);
      if (shouldCallDispatch) {
        dispatch({
          type: ControlledPropUpdatedSelectedItem,
          inputValue: props.itemToString(props.selectedItem)
        });
      }
    }
    previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
  }, [state.selectedItem, props.selectedItem]);
  return [getState(state, props), dispatch];
}
var validatePropTypes$1 = noop5;
if (true) {
  validatePropTypes$1 = function validatePropTypes2(options, caller) {
    import_prop_types32.default.checkPropTypes(propTypes$1, options, "prop", caller.name);
  };
}
var defaultProps$1 = _extends2({}, defaultProps$3, {
  isItemDisabled: function isItemDisabled() {
    return false;
  }
});
function downshiftUseComboboxReducer(state, action) {
  var _props$items;
  var type = action.type, props = action.props, altKey = action.altKey;
  var changes;
  switch (type) {
    case ItemClick:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultHighlightedIndex(props),
        selectedItem: props.items[action.index],
        inputValue: props.itemToString(props.items[action.index])
      };
      break;
    case InputKeyDownArrowDown:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getHighlightedIndex(state.highlightedIndex, 1, props.items, props.isItemDisabled, true)
        };
      } else {
        changes = {
          highlightedIndex: altKey && state.selectedItem == null ? -1 : getHighlightedIndexOnOpen(props, state, 1),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownArrowUp:
      if (state.isOpen) {
        if (altKey) {
          changes = getChangesOnSelection(props, state.highlightedIndex);
        } else {
          changes = {
            highlightedIndex: getHighlightedIndex(state.highlightedIndex, -1, props.items, props.isItemDisabled, true)
          };
        }
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownEnter:
      changes = getChangesOnSelection(props, state.highlightedIndex);
      break;
    case InputKeyDownEscape:
      changes = _extends2({
        isOpen: false,
        highlightedIndex: -1
      }, !state.isOpen && {
        selectedItem: null,
        inputValue: ""
      });
      break;
    case InputKeyDownPageUp:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, -10, props.items, props.isItemDisabled, true)
      };
      break;
    case InputKeyDownPageDown:
      changes = {
        highlightedIndex: getHighlightedIndex(state.highlightedIndex, 10, props.items, props.isItemDisabled, true)
      };
      break;
    case InputKeyDownHome:
      changes = {
        highlightedIndex: getNonDisabledIndex(0, false, props.items, props.isItemDisabled)
      };
      break;
    case InputKeyDownEnd:
      changes = {
        highlightedIndex: getNonDisabledIndex(props.items.length - 1, true, props.items, props.isItemDisabled)
      };
      break;
    case InputBlur:
      changes = _extends2({
        isOpen: false,
        highlightedIndex: -1
      }, state.highlightedIndex >= 0 && ((_props$items = props.items) == null ? void 0 : _props$items.length) && action.selectItem && {
        selectedItem: props.items[state.highlightedIndex],
        inputValue: props.itemToString(props.items[state.highlightedIndex])
      });
      break;
    case InputChange:
      changes = {
        isOpen: true,
        highlightedIndex: getDefaultHighlightedIndex(props),
        inputValue: action.inputValue
      };
      break;
    case InputClick:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case FunctionSelectItem:
      changes = {
        selectedItem: action.selectedItem,
        inputValue: props.itemToString(action.selectedItem)
      };
      break;
    case ControlledPropUpdatedSelectedItem:
      changes = {
        inputValue: action.inputValue
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$1);
  }
  return _extends2({}, state, changes);
}
var _excluded$1 = ["onMouseLeave", "refKey", "ref"];
var _excluded2$1 = ["item", "index", "refKey", "ref", "onMouseMove", "onMouseDown", "onClick", "onPress", "disabled"];
var _excluded3 = ["onClick", "onPress", "refKey", "ref"];
var _excluded4 = ["onKeyDown", "onChange", "onInput", "onBlur", "onChangeText", "onClick", "refKey", "ref"];
useCombobox.stateChangeTypes = stateChangeTypes$1;
function useCombobox(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$1(userProps, useCombobox);
  var props = _extends2({}, defaultProps$1, userProps);
  var items = props.items, scrollIntoView2 = props.scrollIntoView, environment = props.environment, getA11yStatusMessage2 = props.getA11yStatusMessage;
  var _useControlledReducer = useControlledReducer(downshiftUseComboboxReducer, props, getInitialState$1, isDropdownsStateEqual), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var isOpen = state.isOpen, highlightedIndex = state.highlightedIndex, selectedItem = state.selectedItem, inputValue = state.inputValue;
  var menuRef = (0, import_react50.useRef)(null);
  var itemRefs = (0, import_react50.useRef)({});
  var inputRef = (0, import_react50.useRef)(null);
  var toggleButtonRef = (0, import_react50.useRef)(null);
  var isInitialMount = useIsInitialMount();
  var elementIds = useElementIds(props);
  var previousResultCountRef = (0, import_react50.useRef)();
  var latest = useLatestRef3({
    state,
    props
  });
  var getItemNodeFromIndex = (0, import_react50.useCallback)(function(index3) {
    return itemRefs.current[elementIds.getItemId(index3)];
  }, [elementIds]);
  useA11yMessageStatus(getA11yStatusMessage2, state, [isOpen, highlightedIndex, selectedItem, inputValue], environment);
  var shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView2,
    getItemNodeFromIndex
  });
  useControlPropsValidator({
    props,
    state
  });
  (0, import_react50.useEffect)(function() {
    var focusOnOpen = getInitialValue$1(props, "isOpen");
    if (focusOnOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  (0, import_react50.useEffect)(function() {
    if (!isInitialMount) {
      previousResultCountRef.current = items.length;
    }
  });
  var mouseAndTouchTrackers = useMouseAndTouchTracker(environment, (0, import_react50.useCallback)(function handleBlur() {
    if (latest.current.state.isOpen) {
      dispatch({
        type: InputBlur,
        selectItem: false
      });
    }
  }, [dispatch, latest]), (0, import_react50.useMemo)(function() {
    return [menuRef, toggleButtonRef, inputRef];
  }, [menuRef.current, toggleButtonRef.current, inputRef.current]));
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getInputProps", "getMenuProps");
  (0, import_react50.useEffect)(function() {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  (0, import_react50.useEffect)(function() {
    var _inputRef$current;
    if (!isOpen || !(environment != null && environment.document) || !(inputRef != null && (_inputRef$current = inputRef.current) != null && _inputRef$current.focus)) {
      return;
    }
    if (environment.document.activeElement !== inputRef.current) {
      inputRef.current.focus();
    }
  }, [isOpen, environment]);
  var inputKeyDownHandlers = (0, import_react50.useMemo)(function() {
    return {
      ArrowDown: function ArrowDown2(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowDown,
          altKey: event.altKey
        });
      },
      ArrowUp: function ArrowUp3(event) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownArrowUp,
          altKey: event.altKey
        });
      },
      Home: function Home2(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownHome
        });
      },
      End: function End2(event) {
        if (!latest.current.state.isOpen) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnd
        });
      },
      Escape: function Escape2(event) {
        var latestState = latest.current.state;
        if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownEscape
          });
        }
      },
      Enter: function Enter2(event) {
        var latestState = latest.current.state;
        if (!latestState.isOpen || event.which === 229) {
          return;
        }
        event.preventDefault();
        dispatch({
          type: InputKeyDownEnter
        });
      },
      PageUp: function PageUp(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownPageUp
          });
        }
      },
      PageDown: function PageDown(event) {
        if (latest.current.state.isOpen) {
          event.preventDefault();
          dispatch({
            type: InputKeyDownPageDown
          });
        }
      }
    };
  }, [dispatch, latest]);
  var getLabelProps = (0, import_react50.useCallback)(function(labelProps) {
    return _extends2({
      id: elementIds.labelId,
      htmlFor: elementIds.inputId
    }, labelProps);
  }, [elementIds]);
  var getMenuProps = (0, import_react50.useCallback)(function(_temp, _temp2) {
    var _extends22;
    var _ref = _temp === void 0 ? {} : _temp, onMouseLeave = _ref.onMouseLeave, _ref$refKey = _ref.refKey, refKey = _ref$refKey === void 0 ? "ref" : _ref$refKey, ref = _ref.ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded$1);
    var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$suppressRefErro = _ref2.suppressRefError, suppressRefError = _ref2$suppressRefErro === void 0 ? false : _ref2$suppressRefErro;
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return _extends2((_extends22 = {}, _extends22[refKey] = handleRefs(ref, function(menuNode) {
      menuRef.current = menuNode;
    }), _extends22.id = elementIds.menuId, _extends22.role = "listbox", _extends22["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : "" + elementIds.labelId, _extends22.onMouseLeave = callAllEventHandlers(onMouseLeave, function() {
      dispatch({
        type: MenuMouseLeave
      });
    }), _extends22), rest);
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  var getItemProps = (0, import_react50.useCallback)(function(_temp3) {
    var _extends3, _ref4;
    var _ref3 = _temp3 === void 0 ? {} : _temp3, itemProp = _ref3.item, indexProp = _ref3.index, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref = _ref3.ref, onMouseMove = _ref3.onMouseMove, onMouseDown = _ref3.onMouseDown, onClick = _ref3.onClick;
    _ref3.onPress;
    var disabledProp = _ref3.disabled, rest = _objectWithoutPropertiesLoose(_ref3, _excluded2$1);
    if (disabledProp !== void 0) {
      console.warn('Passing "disabled" as an argument to getItemProps is not supported anymore. Please use the isItemDisabled prop from useCombobox.');
    }
    var _latest$current = latest.current, latestProps = _latest$current.props, latestState = _latest$current.state;
    var _getItemAndIndex = getItemAndIndex(itemProp, indexProp, latestProps.items, "Pass either item or index to getItemProps!"), item = _getItemAndIndex[0], index3 = _getItemAndIndex[1];
    var disabled = latestProps.isItemDisabled(item, index3);
    var onSelectKey = "onClick";
    var customClickHandler = onClick;
    var itemHandleMouseMove = function itemHandleMouseMove2() {
      if (mouseAndTouchTrackers.isTouchEnd || index3 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index3,
        disabled
      });
    };
    var itemHandleClick = function itemHandleClick2() {
      dispatch({
        type: ItemClick,
        index: index3
      });
    };
    var itemHandleMouseDown = function itemHandleMouseDown2(e2) {
      return e2.preventDefault();
    };
    return _extends2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(itemNode) {
      if (itemNode) {
        itemRefs.current[elementIds.getItemId(index3)] = itemNode;
      }
    }), _extends3["aria-disabled"] = disabled, _extends3["aria-selected"] = index3 === latestState.highlightedIndex, _extends3.id = elementIds.getItemId(index3), _extends3.role = "option", _extends3), !disabled && (_ref4 = {}, _ref4[onSelectKey] = callAllEventHandlers(customClickHandler, itemHandleClick), _ref4), {
      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),
      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown)
    }, rest);
  }, [dispatch, elementIds, latest, mouseAndTouchTrackers, shouldScrollRef]);
  var getToggleButtonProps = (0, import_react50.useCallback)(function(_temp4) {
    var _extends4;
    var _ref5 = _temp4 === void 0 ? {} : _temp4, onClick = _ref5.onClick;
    _ref5.onPress;
    var _ref5$refKey = _ref5.refKey, refKey = _ref5$refKey === void 0 ? "ref" : _ref5$refKey, ref = _ref5.ref, rest = _objectWithoutPropertiesLoose(_ref5, _excluded3);
    var latestState = latest.current.state;
    var toggleButtonHandleClick = function toggleButtonHandleClick2() {
      dispatch({
        type: ToggleButtonClick
      });
    };
    return _extends2((_extends4 = {}, _extends4[refKey] = handleRefs(ref, function(toggleButtonNode) {
      toggleButtonRef.current = toggleButtonNode;
    }), _extends4["aria-controls"] = elementIds.menuId, _extends4["aria-expanded"] = latestState.isOpen, _extends4.id = elementIds.toggleButtonId, _extends4.tabIndex = -1, _extends4), !rest.disabled && _extends2({}, {
      onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
    }), rest);
  }, [dispatch, latest, elementIds]);
  var getInputProps = (0, import_react50.useCallback)(function(_temp5, _temp6) {
    var _extends5;
    var _ref6 = _temp5 === void 0 ? {} : _temp5, onKeyDown = _ref6.onKeyDown, onChange = _ref6.onChange, onInput = _ref6.onInput, onBlur = _ref6.onBlur;
    _ref6.onChangeText;
    var onClick = _ref6.onClick, _ref6$refKey = _ref6.refKey, refKey = _ref6$refKey === void 0 ? "ref" : _ref6$refKey, ref = _ref6.ref, rest = _objectWithoutPropertiesLoose(_ref6, _excluded4);
    var _ref7 = _temp6 === void 0 ? {} : _temp6, _ref7$suppressRefErro = _ref7.suppressRefError, suppressRefError = _ref7$suppressRefErro === void 0 ? false : _ref7$suppressRefErro;
    setGetterPropCallInfo("getInputProps", suppressRefError, refKey, inputRef);
    var latestState = latest.current.state;
    var inputHandleKeyDown = function inputHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && inputKeyDownHandlers[key]) {
        inputKeyDownHandlers[key](event);
      }
    };
    var inputHandleChange = function inputHandleChange2(event) {
      dispatch({
        type: InputChange,
        inputValue: event.target.value
      });
    };
    var inputHandleBlur = function inputHandleBlur2(event) {
      if (environment != null && environment.document && latestState.isOpen && !mouseAndTouchTrackers.isMouseDown) {
        var isBlurByTabChange = event.relatedTarget === null && environment.document.activeElement !== environment.document.body;
        dispatch({
          type: InputBlur,
          selectItem: !isBlurByTabChange
        });
      }
    };
    var inputHandleClick = function inputHandleClick2() {
      dispatch({
        type: InputClick
      });
    };
    var onChangeKey = "onChange";
    var eventHandlers = {};
    if (!rest.disabled) {
      var _eventHandlers;
      eventHandlers = (_eventHandlers = {}, _eventHandlers[onChangeKey] = callAllEventHandlers(onChange, onInput, inputHandleChange), _eventHandlers.onKeyDown = callAllEventHandlers(onKeyDown, inputHandleKeyDown), _eventHandlers.onBlur = callAllEventHandlers(onBlur, inputHandleBlur), _eventHandlers.onClick = callAllEventHandlers(onClick, inputHandleClick), _eventHandlers);
    }
    return _extends2((_extends5 = {}, _extends5[refKey] = handleRefs(ref, function(inputNode) {
      inputRef.current = inputNode;
    }), _extends5["aria-activedescendant"] = latestState.isOpen && latestState.highlightedIndex > -1 ? elementIds.getItemId(latestState.highlightedIndex) : "", _extends5["aria-autocomplete"] = "list", _extends5["aria-controls"] = elementIds.menuId, _extends5["aria-expanded"] = latestState.isOpen, _extends5["aria-labelledby"] = rest && rest["aria-label"] ? void 0 : elementIds.labelId, _extends5.autoComplete = "off", _extends5.id = elementIds.inputId, _extends5.role = "combobox", _extends5.value = latestState.inputValue, _extends5), eventHandlers, rest);
  }, [dispatch, elementIds, environment, inputKeyDownHandlers, latest, mouseAndTouchTrackers, setGetterPropCallInfo]);
  var toggleMenu = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionToggleMenu
    });
  }, [dispatch]);
  var closeMenu = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionCloseMenu
    });
  }, [dispatch]);
  var openMenu = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionOpenMenu
    });
  }, [dispatch]);
  var setHighlightedIndex = (0, import_react50.useCallback)(function(newHighlightedIndex) {
    dispatch({
      type: FunctionSetHighlightedIndex,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  var selectItem = (0, import_react50.useCallback)(function(newSelectedItem) {
    dispatch({
      type: FunctionSelectItem,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  var setInputValue = (0, import_react50.useCallback)(function(newInputValue) {
    dispatch({
      type: FunctionSetInputValue,
      inputValue: newInputValue
    });
  }, [dispatch]);
  var reset = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionReset$1
    });
  }, [dispatch]);
  return {
    // prop getters.
    getItemProps,
    getLabelProps,
    getMenuProps,
    getInputProps,
    getToggleButtonProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    setInputValue,
    selectItem,
    reset,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var defaultStateValues = {
  activeIndex: -1,
  selectedItems: []
};
function getInitialValue(props, propKey) {
  return getInitialValue$1(props, propKey, defaultStateValues);
}
function getDefaultValue(props, propKey) {
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
function getInitialState(props) {
  var activeIndex = getInitialValue(props, "activeIndex");
  var selectedItems = getInitialValue(props, "selectedItems");
  return {
    activeIndex,
    selectedItems
  };
}
function isKeyDownOperationPermitted(event) {
  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
    return false;
  }
  var element = event.target;
  if (element instanceof HTMLInputElement && // if element is a text input
  element.value !== "" && // and we have text in it
  // and cursor is either not at the start or is currently highlighting text.
  (element.selectionStart !== 0 || element.selectionEnd !== 0)) {
    return false;
  }
  return true;
}
function isStateEqual(prevState, newState) {
  return prevState.selectedItems === newState.selectedItems && prevState.activeIndex === newState.activeIndex;
}
var propTypes = {
  stateReducer: commonPropTypes.stateReducer,
  itemToKey: commonPropTypes.itemToKey,
  environment: commonPropTypes.environment,
  selectedItems: import_prop_types32.default.array,
  initialSelectedItems: import_prop_types32.default.array,
  defaultSelectedItems: import_prop_types32.default.array,
  getA11yStatusMessage: import_prop_types32.default.func,
  activeIndex: import_prop_types32.default.number,
  initialActiveIndex: import_prop_types32.default.number,
  defaultActiveIndex: import_prop_types32.default.number,
  onActiveIndexChange: import_prop_types32.default.func,
  onSelectedItemsChange: import_prop_types32.default.func,
  keyNavigationNext: import_prop_types32.default.string,
  keyNavigationPrevious: import_prop_types32.default.string
};
var defaultProps = {
  itemToKey: defaultProps$3.itemToKey,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  keyNavigationNext: "ArrowRight",
  keyNavigationPrevious: "ArrowLeft"
};
var validatePropTypes = noop5;
if (true) {
  validatePropTypes = function validatePropTypes2(options, caller) {
    import_prop_types32.default.checkPropTypes(propTypes, options, "prop", caller.name);
  };
}
var SelectedItemClick = true ? "__selected_item_click__" : 0;
var SelectedItemKeyDownDelete = true ? "__selected_item_keydown_delete__" : 1;
var SelectedItemKeyDownBackspace = true ? "__selected_item_keydown_backspace__" : 2;
var SelectedItemKeyDownNavigationNext = true ? "__selected_item_keydown_navigation_next__" : 3;
var SelectedItemKeyDownNavigationPrevious = true ? "__selected_item_keydown_navigation_previous__" : 4;
var DropdownKeyDownNavigationPrevious = true ? "__dropdown_keydown_navigation_previous__" : 5;
var DropdownKeyDownBackspace = true ? "__dropdown_keydown_backspace__" : 6;
var DropdownClick = true ? "__dropdown_click__" : 7;
var FunctionAddSelectedItem = true ? "__function_add_selected_item__" : 8;
var FunctionRemoveSelectedItem = true ? "__function_remove_selected_item__" : 9;
var FunctionSetSelectedItems = true ? "__function_set_selected_items__" : 10;
var FunctionSetActiveIndex = true ? "__function_set_active_index__" : 11;
var FunctionReset = true ? "__function_reset__" : 12;
var stateChangeTypes = Object.freeze({
  __proto__: null,
  DropdownClick,
  DropdownKeyDownBackspace,
  DropdownKeyDownNavigationPrevious,
  FunctionAddSelectedItem,
  FunctionRemoveSelectedItem,
  FunctionReset,
  FunctionSetActiveIndex,
  FunctionSetSelectedItems,
  SelectedItemClick,
  SelectedItemKeyDownBackspace,
  SelectedItemKeyDownDelete,
  SelectedItemKeyDownNavigationNext,
  SelectedItemKeyDownNavigationPrevious
});
function downshiftMultipleSelectionReducer(state, action) {
  var type = action.type, index3 = action.index, props = action.props, selectedItem = action.selectedItem;
  var activeIndex = state.activeIndex, selectedItems = state.selectedItems;
  var changes;
  switch (type) {
    case SelectedItemClick:
      changes = {
        activeIndex: index3
      };
      break;
    case SelectedItemKeyDownNavigationPrevious:
      changes = {
        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1
      };
      break;
    case SelectedItemKeyDownNavigationNext:
      changes = {
        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1
      };
      break;
    case SelectedItemKeyDownBackspace:
    case SelectedItemKeyDownDelete: {
      if (activeIndex < 0) {
        break;
      }
      var newActiveIndex = activeIndex;
      if (selectedItems.length === 1) {
        newActiveIndex = -1;
      } else if (activeIndex === selectedItems.length - 1) {
        newActiveIndex = selectedItems.length - 2;
      }
      changes = _extends2({
        selectedItems: [].concat(selectedItems.slice(0, activeIndex), selectedItems.slice(activeIndex + 1))
      }, {
        activeIndex: newActiveIndex
      });
      break;
    }
    case DropdownKeyDownNavigationPrevious:
      changes = {
        activeIndex: selectedItems.length - 1
      };
      break;
    case DropdownKeyDownBackspace:
      changes = {
        selectedItems: selectedItems.slice(0, selectedItems.length - 1)
      };
      break;
    case FunctionAddSelectedItem:
      changes = {
        selectedItems: [].concat(selectedItems, [selectedItem])
      };
      break;
    case DropdownClick:
      changes = {
        activeIndex: -1
      };
      break;
    case FunctionRemoveSelectedItem: {
      var _newActiveIndex = activeIndex;
      var selectedItemIndex = selectedItems.findIndex(function(item) {
        return props.itemToKey(item) === props.itemToKey(selectedItem);
      });
      if (selectedItemIndex < 0) {
        break;
      }
      if (selectedItems.length === 1) {
        _newActiveIndex = -1;
      } else if (selectedItemIndex === selectedItems.length - 1) {
        _newActiveIndex = selectedItems.length - 2;
      }
      changes = {
        selectedItems: [].concat(selectedItems.slice(0, selectedItemIndex), selectedItems.slice(selectedItemIndex + 1)),
        activeIndex: _newActiveIndex
      };
      break;
    }
    case FunctionSetSelectedItems: {
      var newSelectedItems = action.selectedItems;
      changes = {
        selectedItems: newSelectedItems
      };
      break;
    }
    case FunctionSetActiveIndex: {
      var _newActiveIndex2 = action.activeIndex;
      changes = {
        activeIndex: _newActiveIndex2
      };
      break;
    }
    case FunctionReset:
      changes = {
        activeIndex: getDefaultValue(props, "activeIndex"),
        selectedItems: getDefaultValue(props, "selectedItems")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return _extends2({}, state, changes);
}
var _excluded = ["refKey", "ref", "onClick", "onKeyDown", "selectedItem", "index"];
var _excluded2 = ["refKey", "ref", "onKeyDown", "onClick", "preventKeyAction"];
useMultipleSelection.stateChangeTypes = stateChangeTypes;
function useMultipleSelection(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes(userProps, useMultipleSelection);
  var props = _extends2({}, defaultProps, userProps);
  var getA11yStatusMessage2 = props.getA11yStatusMessage, environment = props.environment, keyNavigationNext = props.keyNavigationNext, keyNavigationPrevious = props.keyNavigationPrevious;
  var _useControlledReducer = useControlledReducer$1(downshiftMultipleSelectionReducer, props, getInitialState, isStateEqual), state = _useControlledReducer[0], dispatch = _useControlledReducer[1];
  var activeIndex = state.activeIndex, selectedItems = state.selectedItems;
  var isInitialMount = useIsInitialMount();
  var dropdownRef = (0, import_react50.useRef)(null);
  var selectedItemRefs = (0, import_react50.useRef)();
  selectedItemRefs.current = [];
  var latest = useLatestRef3({
    state,
    props
  });
  useA11yMessageStatus(getA11yStatusMessage2, state, [activeIndex, selectedItems], environment);
  (0, import_react50.useEffect)(function() {
    if (isInitialMount) {
      return;
    }
    if (activeIndex === -1 && dropdownRef.current) {
      dropdownRef.current.focus();
    } else if (selectedItemRefs.current[activeIndex]) {
      selectedItemRefs.current[activeIndex].focus();
    }
  }, [activeIndex]);
  useControlPropsValidator({
    props,
    state
  });
  var setGetterPropCallInfo = useGetterPropsCalledChecker("getDropdownProps");
  var selectedItemKeyDownHandlers = (0, import_react50.useMemo)(function() {
    var _ref;
    return _ref = {}, _ref[keyNavigationPrevious] = function() {
      dispatch({
        type: SelectedItemKeyDownNavigationPrevious
      });
    }, _ref[keyNavigationNext] = function() {
      dispatch({
        type: SelectedItemKeyDownNavigationNext
      });
    }, _ref.Delete = function Delete2() {
      dispatch({
        type: SelectedItemKeyDownDelete
      });
    }, _ref.Backspace = function Backspace() {
      dispatch({
        type: SelectedItemKeyDownBackspace
      });
    }, _ref;
  }, [dispatch, keyNavigationNext, keyNavigationPrevious]);
  var dropdownKeyDownHandlers = (0, import_react50.useMemo)(function() {
    var _ref2;
    return _ref2 = {}, _ref2[keyNavigationPrevious] = function(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownNavigationPrevious
        });
      }
    }, _ref2.Backspace = function Backspace(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownBackspace
        });
      }
    }, _ref2;
  }, [dispatch, keyNavigationPrevious]);
  var getSelectedItemProps = (0, import_react50.useCallback)(function(_temp) {
    var _extends22;
    var _ref3 = _temp === void 0 ? {} : _temp, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, ref = _ref3.ref, onClick = _ref3.onClick, onKeyDown = _ref3.onKeyDown, selectedItemProp = _ref3.selectedItem, indexProp = _ref3.index, rest = _objectWithoutPropertiesLoose(_ref3, _excluded);
    var latestState = latest.current.state;
    var _getItemAndIndex = getItemAndIndex(selectedItemProp, indexProp, latestState.selectedItems, "Pass either item or index to getSelectedItemProps!"), index3 = _getItemAndIndex[1];
    var isFocusable2 = index3 > -1 && index3 === latestState.activeIndex;
    var selectedItemHandleClick = function selectedItemHandleClick2() {
      dispatch({
        type: SelectedItemClick,
        index: index3
      });
    };
    var selectedItemHandleKeyDown = function selectedItemHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && selectedItemKeyDownHandlers[key]) {
        selectedItemKeyDownHandlers[key](event);
      }
    };
    return _extends2((_extends22 = {}, _extends22[refKey] = handleRefs(ref, function(selectedItemNode) {
      if (selectedItemNode) {
        selectedItemRefs.current.push(selectedItemNode);
      }
    }), _extends22.tabIndex = isFocusable2 ? 0 : -1, _extends22.onClick = callAllEventHandlers(onClick, selectedItemHandleClick), _extends22.onKeyDown = callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown), _extends22), rest);
  }, [dispatch, latest, selectedItemKeyDownHandlers]);
  var getDropdownProps = (0, import_react50.useCallback)(function(_temp2, _temp3) {
    var _extends3;
    var _ref4 = _temp2 === void 0 ? {} : _temp2, _ref4$refKey = _ref4.refKey, refKey = _ref4$refKey === void 0 ? "ref" : _ref4$refKey, ref = _ref4.ref, onKeyDown = _ref4.onKeyDown, onClick = _ref4.onClick, _ref4$preventKeyActio = _ref4.preventKeyAction, preventKeyAction = _ref4$preventKeyActio === void 0 ? false : _ref4$preventKeyActio, rest = _objectWithoutPropertiesLoose(_ref4, _excluded2);
    var _ref5 = _temp3 === void 0 ? {} : _temp3, _ref5$suppressRefErro = _ref5.suppressRefError, suppressRefError = _ref5$suppressRefErro === void 0 ? false : _ref5$suppressRefErro;
    setGetterPropCallInfo("getDropdownProps", suppressRefError, refKey, dropdownRef);
    var dropdownHandleKeyDown = function dropdownHandleKeyDown2(event) {
      var key = normalizeArrowKey(event);
      if (key && dropdownKeyDownHandlers[key]) {
        dropdownKeyDownHandlers[key](event);
      }
    };
    var dropdownHandleClick = function dropdownHandleClick2() {
      dispatch({
        type: DropdownClick
      });
    };
    return _extends2((_extends3 = {}, _extends3[refKey] = handleRefs(ref, function(dropdownNode) {
      if (dropdownNode) {
        dropdownRef.current = dropdownNode;
      }
    }), _extends3), !preventKeyAction && {
      onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),
      onClick: callAllEventHandlers(onClick, dropdownHandleClick)
    }, rest);
  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]);
  var addSelectedItem = (0, import_react50.useCallback)(function(selectedItem) {
    dispatch({
      type: FunctionAddSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  var removeSelectedItem = (0, import_react50.useCallback)(function(selectedItem) {
    dispatch({
      type: FunctionRemoveSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  var setSelectedItems = (0, import_react50.useCallback)(function(newSelectedItems) {
    dispatch({
      type: FunctionSetSelectedItems,
      selectedItems: newSelectedItems
    });
  }, [dispatch]);
  var setActiveIndex = (0, import_react50.useCallback)(function(newActiveIndex) {
    dispatch({
      type: FunctionSetActiveIndex,
      activeIndex: newActiveIndex
    });
  }, [dispatch]);
  var reset = (0, import_react50.useCallback)(function() {
    dispatch({
      type: FunctionReset
    });
  }, [dispatch]);
  return {
    getSelectedItemProps,
    getDropdownProps,
    addSelectedItem,
    removeSelectedItem,
    setSelectedItems,
    setActiveIndex,
    reset,
    selectedItems,
    activeIndex
  };
}

// node_modules/@carbon/react/es/components/ComboBox/ComboBox.js
var import_prop_types44 = __toESM(require_prop_types());
var import_react62 = __toESM(require_react());
var import_react_fast_compare = __toESM(require_react_fast_compare());

// node_modules/@carbon/react/es/components/ListBox/ListBoxPropTypes.js
var import_prop_types33 = __toESM(require_prop_types());
var listBoxTypes = ["default", "inline"];
var listBoxSizes = ["sm", "md", "lg"];
var ListBoxTypePropType = import_prop_types33.default.oneOf(listBoxTypes);
var ListBoxSizePropType = import_prop_types33.default.oneOf(listBoxSizes);

// node_modules/@carbon/react/es/components/ListBox/ListBox.js
var import_classnames30 = __toESM(require_classnames());
var import_react54 = __toESM(require_react());
var import_prop_types36 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/components/FluidForm/FluidForm.js
var import_prop_types35 = __toESM(require_prop_types());
var import_react53 = __toESM(require_react());
var import_classnames29 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Form/Form.js
var import_prop_types34 = __toESM(require_prop_types());
var import_react51 = __toESM(require_react());
var import_classnames28 = __toESM(require_classnames());
function Form({
  className,
  children,
  ...other
}) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames28.default)(`${prefix}--form`, className);
  return import_react51.default.createElement("form", _extends({
    className: classNames
  }, other), children);
}
Form.propTypes = {
  /**
   * Provide children to be rendered inside of the <form> element
   */
  children: import_prop_types34.default.node,
  /**
   * Provide a custom className to be applied on the containing <form> node
   */
  className: import_prop_types34.default.string
};

// node_modules/@carbon/react/es/components/FluidForm/FormContext.js
var import_react52 = __toESM(require_react());
var FormContext = (0, import_react52.createContext)({
  isFluid: false
});

// node_modules/@carbon/react/es/components/FluidForm/FluidForm.js
var FluidForm = ({
  className,
  children,
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames29.default)(`${prefix}--form--fluid`, className);
  return import_react53.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react53.default.createElement(Form, _extends({
    className: classNames
  }, other), children));
};
FluidForm.propTypes = {
  /**
   * Provide children to be rendered inside of the <form> element
   */
  children: import_prop_types35.default.node,
  /**
   * Provide a custom className to be applied on the containing <form> node
   */
  className: import_prop_types35.default.string
};

// node_modules/@carbon/react/es/components/ListBox/ListBox.js
var handleOnKeyDown = (event) => {
  if (event.keyCode === 27) {
    event.stopPropagation();
  }
};
var handleClick = (event) => {
  event.preventDefault();
  event.stopPropagation();
};
var ListBox = (0, import_react54.forwardRef)((props, ref) => {
  const {
    children,
    className: containerClassName,
    disabled = false,
    type = "default",
    size: size4,
    invalid,
    invalidText,
    invalidTextId,
    warn: warn2,
    warnText,
    warnTextId,
    light,
    isOpen,
    ...rest
  } = props;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react54.useContext)(FormContext);
  const showWarning = !invalid && warn2;
  const className = (0, import_classnames30.default)({
    ...containerClassName && {
      [containerClassName]: true
    },
    [`${prefix}--list-box`]: true,
    [`${prefix}--list-box--${size4}`]: size4,
    [`${prefix}--list-box--inline`]: type === "inline",
    [`${prefix}--list-box--disabled`]: disabled,
    [`${prefix}--list-box--light`]: light,
    [`${prefix}--list-box--expanded`]: isOpen,
    [`${prefix}--list-box--invalid`]: invalid,
    [`${prefix}--list-box--warning`]: showWarning
  });
  return import_react54.default.createElement(import_react54.default.Fragment, null, import_react54.default.createElement("div", _extends({}, rest, {
    className,
    ref,
    onKeyDown: handleOnKeyDown,
    onClick: handleClick,
    "data-invalid": invalid || void 0
  }), children), isFluid && import_react54.default.createElement("hr", {
    className: `${prefix}--list-box__divider`
  }), invalid ? import_react54.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    id: invalidTextId
  }, invalidText) : null, showWarning ? import_react54.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    id: warnTextId
  }, warnText) : null);
});
ListBox.displayName = "ListBox";
ListBox.propTypes = {
  /**
   * Provide the contents of your ListBox
   */
  children: import_prop_types36.default.node,
  /**
   * Specify a class name to be applied on the containing list box node
   */
  className: import_prop_types36.default.string,
  /**
   * Specify whether the ListBox is currently disabled
   */
  disabled: import_prop_types36.default.bool,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types36.default.bool,
  /**
   * Specify the text to be displayed when the control is invalid
   */
  invalidText: import_prop_types36.default.node,
  /**
   * Specify the id to be applied to the element containing the invalid text
   */
  invalidTextId: import_prop_types36.default.string,
  /**
   * Specify if the control should render open
   */
  isOpen: import_prop_types36.default.bool,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types36.default.bool, "The `light` prop for `ListBox` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSizePropType,
  /**
   * Specify the "type" of the ListBox. Currently supports either `default` or
   * `inline` as an option.
   */
  type: ListBoxTypePropType,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types36.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types36.default.string,
  /**
   * Specify the id to be applied to the element containing the warn text
   */
  warnTextId: import_prop_types36.default.string
};

// node_modules/@carbon/react/es/components/ListBox/ListBoxField.js
var import_react55 = __toESM(require_react());
var import_prop_types37 = __toESM(require_prop_types());
function ListBoxField({
  children,
  disabled,
  tabIndex,
  ...rest
}) {
  const prefix = usePrefix();
  return import_react55.default.createElement("div", _extends({
    className: `${prefix}--list-box__field`,
    tabIndex: !disabled && tabIndex || -1
  }, rest), children);
}
ListBoxField.propTypes = {
  /**
   * Typically set by `getToggleButtonProps`, this should specify whether the
   * field has a popup.
   */
  "aria-haspopup": import_prop_types37.default.oneOfType([import_prop_types37.default.string, import_prop_types37.default.bool]),
  /**
   * Provide the contents of your ListBoxField
   */
  children: import_prop_types37.default.node,
  /**
   * Specify if the parent <ListBox> is disabled
   */
  disabled: import_prop_types37.default.bool,
  /**
   * The role for the component, should be set by `getToggleButtonProps` coming
   * from Downshift
   */
  role: import_prop_types37.default.string,
  /**
   * Optional prop to specify the tabIndex of the <ListBox> trigger button
   */
  tabIndex: import_prop_types37.default.oneOfType([import_prop_types37.default.number, import_prop_types37.default.string])
};

// node_modules/@carbon/react/es/components/ListBox/ListBoxMenu.js
var import_react57 = __toESM(require_react());
var import_prop_types39 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/components/ListBox/ListBoxMenuItem.js
var import_classnames31 = __toESM(require_classnames());
var import_react56 = __toESM(require_react());
var import_prop_types38 = __toESM(require_prop_types());
var useIsTruncated = (forwardedRef, deps = []) => {
  const localRef = (0, import_react56.useRef)(null);
  const mergedRef = useMergedRefs([...forwardedRef ? [forwardedRef] : [], localRef]);
  const [isTruncated, setIsTruncated] = (0, import_react56.useState)(false);
  (0, import_react56.useEffect)(() => {
    const element = localRef.current;
    if (element) {
      const {
        offsetWidth,
        scrollWidth
      } = element;
      setIsTruncated(offsetWidth < scrollWidth);
    }
  }, [localRef, ...deps]);
  return {
    isTruncated,
    ref: mergedRef
  };
};
var ListBoxMenuItem = (0, import_react56.forwardRef)(({
  children,
  isActive = false,
  isHighlighted = false,
  title,
  ...rest
}, forwardedRef) => {
  const prefix = usePrefix();
  const menuItemOptionRefProp = forwardedRef && typeof forwardedRef !== "function" ? forwardedRef.menuItemOptionRef : void 0;
  const {
    isTruncated,
    ref: menuItemOptionRef
  } = useIsTruncated(menuItemOptionRefProp, [children]);
  const className = (0, import_classnames31.default)(`${prefix}--list-box__menu-item`, {
    [`${prefix}--list-box__menu-item--active`]: isActive,
    [`${prefix}--list-box__menu-item--highlighted`]: isHighlighted
  });
  return import_react56.default.createElement("li", _extends({}, rest, {
    className,
    title: isTruncated ? title : void 0
  }), import_react56.default.createElement("div", {
    className: `${prefix}--list-box__menu-item__option`,
    ref: menuItemOptionRef
  }, children));
});
ListBoxMenuItem.displayName = "ListBoxMenuItem";
ListBoxMenuItem.propTypes = {
  /**
   * Specify any children nodes that should be rendered inside of the ListBox
   * Menu Item
   */
  children: import_prop_types38.default.node,
  /**
   * Specify if the item should be disabled
   */
  disabled: import_prop_types38.default.bool,
  /**
   * Specify whether the current menu item is "active".
   */
  isActive: import_prop_types38.default.bool,
  /**
   * Specify whether the current menu item is "highlighted".
   */
  isHighlighted: import_prop_types38.default.bool,
  /**
   * Provide an optional tooltip for the ListBoxMenuItem
   */
  title: import_prop_types38.default.string
};

// node_modules/@carbon/react/es/components/ListBox/ListBoxMenu.js
var frFn2 = import_react57.forwardRef;
var ListBoxMenu = frFn2(({
  children,
  id,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  return import_react57.default.createElement("ul", _extends({
    ref,
    id,
    className: `${prefix}--list-box__menu`,
    role: "listbox"
  }, rest), children);
});
ListBoxMenu.displayName = "ListBoxMenu";
ListBoxMenu.propTypes = {
  /**
   * Provide the contents of your ListBoxMenu
   */
  children: import_prop_types39.default.oneOfType([
    import_prop_types39.default.node,
    import_prop_types39.default.arrayOf(import_prop_types39.default.oneOf([ListBoxMenuItem])),
    /**
     * allow single item using the workaround for functional components
     * https://github.com/facebook/react/issues/2979#issuecomment-222379916
     */
    import_prop_types39.default.shape({
      type: import_prop_types39.default.oneOf([ListBoxMenuItem])
    }),
    import_prop_types39.default.bool
    // used in Dropdown for closed state
  ]),
  /**
   * Specify a custom `id`
   */
  id: import_prop_types39.default.string.isRequired
};

// node_modules/@carbon/react/es/components/ListBox/ListBoxMenuIcon.js
var import_classnames32 = __toESM(require_classnames());
var import_react58 = __toESM(require_react());
var import_prop_types40 = __toESM(require_prop_types());
var defaultTranslations = {
  "close.menu": "Close menu",
  "open.menu": "Open menu"
};
var defaultTranslateWithId = (id) => defaultTranslations[id];
var ListBoxMenuIcon = ({
  isOpen,
  translateWithId: t3 = defaultTranslateWithId
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames32.default)(`${prefix}--list-box__menu-icon`, {
    [`${prefix}--list-box__menu-icon--open`]: isOpen
  });
  const description = isOpen ? t3("close.menu") : t3("open.menu");
  return import_react58.default.createElement("div", {
    className
  }, import_react58.default.createElement(ChevronDown, {
    name: "chevron--down",
    "aria-label": description
  }, import_react58.default.createElement("title", null, description)));
};
ListBoxMenuIcon.propTypes = {
  /**
   * Specify whether the menu is currently open, which will influence the
   * direction of the menu icon
   */
  isOpen: import_prop_types40.default.bool.isRequired,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes a ListBoxMenuIconTranslationKey and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types40.default.func
};

// node_modules/@carbon/react/es/components/ListBox/ListBoxSelection.js
var import_classnames33 = __toESM(require_classnames());
var import_react59 = __toESM(require_react());
var import_prop_types41 = __toESM(require_prop_types());
var _Close;
var _Close2;
var translationIds = {
  "clear.all": "clear.all",
  "clear.selection": "clear.selection"
};
var defaultTranslations2 = {
  [translationIds["clear.all"]]: "Clear all selected items",
  [translationIds["clear.selection"]]: "Clear selected item"
};
var defaultTranslateWithId2 = (id) => defaultTranslations2[id];
var ListBoxSelection = ({
  clearSelection,
  selectionCount,
  translateWithId: t3 = defaultTranslateWithId2,
  disabled,
  onClearSelection,
  readOnly
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames33.default)(`${prefix}--list-box__selection`, {
    [`${prefix}--tag--filter`]: selectionCount,
    [`${prefix}--list-box__selection--multi`]: selectionCount
  });
  const handleOnClick = (event) => {
    event.stopPropagation();
    if (disabled || readOnly) {
      return;
    }
    clearSelection(event);
    if (onClearSelection) {
      onClearSelection(event);
    }
  };
  const description = selectionCount ? t3("clear.all") : t3("clear.selection");
  const tagClasses = (0, import_classnames33.default)(`${prefix}--tag`, `${prefix}--tag--filter`, `${prefix}--tag--high-contrast`, {
    [`${prefix}--tag--disabled`]: disabled
  });
  return selectionCount ? import_react59.default.createElement("div", {
    className: tagClasses
  }, import_react59.default.createElement("span", {
    className: `${prefix}--tag__label`,
    title: `${selectionCount}`
  }, selectionCount), import_react59.default.createElement("div", {
    role: "button",
    tabIndex: -1,
    className: `${prefix}--tag__close-icon`,
    onClick: handleOnClick,
    "aria-label": t3("clear.all"),
    title: description,
    "aria-disabled": readOnly ? true : void 0
  }, _Close || (_Close = import_react59.default.createElement(Close, null)))) : import_react59.default.createElement("div", {
    role: "button",
    className,
    tabIndex: -1,
    onClick: handleOnClick,
    "aria-label": description,
    title: description
  }, selectionCount, _Close2 || (_Close2 = import_react59.default.createElement(Close, null)));
};
ListBoxSelection.propTypes = {
  /**
   * Specify a function to be invoked when a user interacts with the clear
   * selection element.
   */
  clearSelection: import_prop_types41.default.func.isRequired,
  /**
   * Specify whether or not the clear selection element should be disabled
   */
  disabled: import_prop_types41.default.bool,
  /**
   * Specify an optional `onClearSelection` handler that is called when the underlying
   * element is cleared
   */
  onClearSelection: import_prop_types41.default.func,
  /**
   * Whether or not the Dropdown is readonly
   */
  readOnly: import_prop_types41.default.bool,
  /**
   * Specify an optional `selectionCount` value that will be used to determine
   * whether the selection should display a badge or a single clear icon.
   */
  selectionCount: import_prop_types41.default.number,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes in an id defined in `translationIds` and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types41.default.func
};

// node_modules/@carbon/react/es/components/ListBox/index.js
var ListBox2 = Object.assign(ListBox, {
  Field: ListBoxField,
  Menu: ListBoxMenu,
  MenuIcon: ListBoxMenuIcon,
  MenuItem: ListBoxMenuItem,
  Selection: ListBoxSelection
});

// node_modules/@carbon/react/es/components/ListBox/next/ListBoxSelection.js
var import_classnames34 = __toESM(require_classnames());
var import_react60 = __toESM(require_react());
var import_prop_types42 = __toESM(require_prop_types());
var _Close3;
var _Close22;
var defaultTranslations3 = {
  "clear.all": "Clear all selected items",
  "clear.selection": "Clear selected item"
};
function defaultTranslateWithId3(id) {
  return defaultTranslations3[id];
}
function ListBoxSelection2({
  clearSelection,
  selectionCount,
  translateWithId: t3 = defaultTranslateWithId3,
  disabled,
  readOnly,
  onClearSelection,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames34.default)(`${prefix}--list-box__selection`, {
    [`${prefix}--tag--filter`]: selectionCount,
    [`${prefix}--list-box__selection--multi`]: selectionCount
  });
  const description = selectionCount ? t3("clear.all") : t3("clear.selection");
  const tagClasses = (0, import_classnames34.default)(`${prefix}--tag`, `${prefix}--tag--filter`, `${prefix}--tag--high-contrast`, {
    [`${prefix}--tag--disabled`]: disabled
  });
  function onClick(event) {
    event.stopPropagation();
    if (disabled || readOnly) {
      return;
    }
    clearSelection(event);
    if (onClearSelection) {
      onClearSelection(event);
    }
  }
  if (selectionCount) {
    return import_react60.default.createElement("div", {
      className: tagClasses
    }, import_react60.default.createElement("span", {
      className: `${prefix}--tag__label`,
      title: selectionCount == null ? void 0 : selectionCount.toString()
    }, selectionCount), import_react60.default.createElement("button", {
      "aria-label": description,
      className: `${prefix}--tag__close-icon`,
      disabled: disabled || readOnly,
      onClick,
      tabIndex: -1,
      title: description,
      type: "button",
      "aria-disabled": readOnly ? true : void 0
    }, _Close3 || (_Close3 = import_react60.default.createElement(Close, null))));
  }
  return import_react60.default.createElement("button", _extends({}, rest, {
    "aria-label": description,
    className,
    disabled: disabled || readOnly,
    onClick,
    tabIndex: -1,
    title: description,
    type: "button",
    "aria-disabled": readOnly ? true : void 0
  }), _Close22 || (_Close22 = import_react60.default.createElement(Close, null)));
}
ListBoxSelection2.propTypes = {
  /**
   * Specify a function to be invoked when a user interacts with the clear
   * selection element.
   */
  clearSelection: import_prop_types42.default.func.isRequired,
  /**
   * Specify whether or not the clear selection element should be disabled
   */
  disabled: import_prop_types42.default.bool,
  /**
   * Whether or not the listbox is readonly
   */
  readOnly: import_prop_types42.default.bool,
  /**
   * Specify an optional `onClearSelection` handler that is called when the underlying
   * element is cleared
   */
  onClearSelection: import_prop_types42.default.func,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * clear selection element is clicked
   */
  onClick: import_prop_types42.default.func,
  /**
   * Specify an optional `onClick` handler that is called when the underlying
   * clear selection element is clicked
   */
  onMouseUp: import_prop_types42.default.func,
  /**
   * Specify an optional `onKeyDown` handler that is called when the underlying
   * clear selection element fires a keydown event
   */
  onKeyDown: import_prop_types42.default.func,
  /**
   * Specify an optional `selectionCount` value that will be used to determine
   * whether the selection should display a badge or a single clear icon.
   */
  selectionCount: import_prop_types42.default.number,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes in an id defined in `translationIds` and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types42.default.func
};

// node_modules/@carbon/react/es/components/ListBox/next/ListBoxTrigger.js
var import_classnames35 = __toESM(require_classnames());
var import_react61 = __toESM(require_react());
var import_prop_types43 = __toESM(require_prop_types());
var _ChevronDown;
var translationIds2 = {
  "close.menu": "close.menu",
  "open.menu": "open.menu"
};
var defaultTranslations4 = {
  [translationIds2["close.menu"]]: "Close",
  [translationIds2["open.menu"]]: "Open"
};
var defaultTranslateWithId4 = (id) => defaultTranslations4[id];
var ListBoxTrigger = import_react61.default.forwardRef(function ListBoxTrigger2({
  isOpen,
  translateWithId: t3 = defaultTranslateWithId4,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const className = (0, import_classnames35.default)({
    [`${prefix}--list-box__menu-icon`]: true,
    [`${prefix}--list-box__menu-icon--open`]: isOpen
  });
  const description = isOpen ? t3("close.menu") : t3("open.menu");
  return import_react61.default.createElement("button", _extends({}, rest, {
    "aria-label": description,
    title: description,
    className,
    type: "button",
    tabIndex: -1,
    ref
  }), _ChevronDown || (_ChevronDown = import_react61.default.createElement(ChevronDown, null)));
});
ListBoxTrigger.propTypes = {
  /**
   * Specify whether the menu is currently open, which will influence the
   * direction of the menu icon
   */
  isOpen: import_prop_types43.default.bool.isRequired,
  /**
   * i18n hook used to provide the appropriate description for the given menu
   * icon. This function takes in an id defined in `translationIds` and should
   * return a string message for that given message id.
   */
  translateWithId: import_prop_types43.default.func
};

// node_modules/@carbon/react/es/tools/mergeRefs.js
var mergeRefs = (...refs) => (el) => {
  refs.forEach((ref) => {
    if (typeof ref === "function") {
      ref(el);
    } else if (Object(ref) === ref) {
      ref.current = el;
    }
  });
};

// node_modules/@carbon/react/es/components/ComboBox/ComboBox.js
var {
  InputBlur: InputBlur2,
  InputKeyDownEnter: InputKeyDownEnter2,
  FunctionToggleMenu: FunctionToggleMenu2,
  ToggleButtonClick: ToggleButtonClick2,
  ItemMouseMove: ItemMouseMove2,
  InputKeyDownArrowUp: InputKeyDownArrowUp2,
  InputKeyDownArrowDown: InputKeyDownArrowDown2,
  MenuMouseLeave: MenuMouseLeave2,
  ItemClick: ItemClick2,
  FunctionSelectItem: FunctionSelectItem2
} = useCombobox.stateChangeTypes;
var defaultItemToString = (item) => {
  if (typeof item === "string") {
    return item;
  }
  if (typeof item === "number") {
    return `${item}`;
  }
  if (item !== null && typeof item === "object" && "label" in item && typeof item["label"] === "string") {
    return item["label"];
  }
  return "";
};
var defaultShouldFilterItem = () => true;
var autocompleteCustomFilter = ({
  item,
  inputValue
}) => {
  if (inputValue === null || inputValue === "") {
    return true;
  }
  const lowercaseItem = item.toLowerCase();
  const lowercaseInput = inputValue.toLowerCase();
  return lowercaseItem.startsWith(lowercaseInput);
};
var getInputValue = ({
  initialSelectedItem,
  itemToString: itemToString3,
  selectedItem,
  prevSelectedItem
}) => {
  if (selectedItem !== null && typeof selectedItem !== "undefined") {
    return itemToString3(selectedItem);
  }
  if (typeof prevSelectedItem === "undefined" && initialSelectedItem !== null && typeof initialSelectedItem !== "undefined") {
    return itemToString3(initialSelectedItem);
  }
  return "";
};
var findHighlightedIndex = ({
  items,
  itemToString: itemToString3 = defaultItemToString
}, inputValue) => {
  if (!inputValue) {
    return -1;
  }
  const searchValue = inputValue.toLowerCase();
  for (let i = 0; i < items.length; i++) {
    const item = itemToString3(items[i]).toLowerCase();
    if (!items[i]["disabled"] && item.indexOf(searchValue) !== -1) {
      return i;
    }
  }
  return -1;
};
var ComboBox = (0, import_react62.forwardRef)((props, ref) => {
  var _a, _b, _c;
  const prevInputLengthRef = (0, import_react62.useRef)(0);
  const inputRef = (0, import_react62.useRef)(null);
  const {
    ["aria-label"]: ariaLabel = "Choose an item",
    ariaLabel: deprecatedAriaLabel,
    autoAlign = false,
    className: containerClassName,
    decorator,
    direction = "bottom",
    disabled = false,
    downshiftActions,
    downshiftProps,
    helperText,
    id,
    initialSelectedItem,
    invalid,
    invalidText,
    items,
    itemToElement = null,
    itemToString: itemToString3 = defaultItemToString,
    light,
    onChange,
    onInputChange,
    onToggleClick,
    placeholder,
    readOnly,
    selectedItem: selectedItemProp,
    shouldFilterItem = defaultShouldFilterItem,
    size: size4,
    titleText,
    translateWithId: translateWithId8,
    typeahead = false,
    warn: warn2,
    warnText,
    allowCustomValue = false,
    slug,
    inputProps,
    ...rest
  } = props;
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(enableFloatingStyles ? {
    placement: direction,
    strategy: "fixed",
    middleware: autoAlign ? [flip3(), hide3()] : void 0,
    whileElementsMounted: autoUpdate
  } : {});
  const parentWidth = (_b = (_a = refs == null ? void 0 : refs.reference) == null ? void 0 : _a.current) == null ? void 0 : _b.clientWidth;
  (0, import_react62.useEffect)(() => {
    var _a2;
    if (enableFloatingStyles) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a2 = middlewareData.hide) == null ? void 0 : _a2.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
      if (parentWidth && refs.floating.current) {
        refs.floating.current.style.width = parentWidth + "px";
      }
    }
  }, [enableFloatingStyles, floatingStyles, refs.floating, parentWidth]);
  const [inputValue, setInputValue] = (0, import_react62.useState)(getInputValue({
    initialSelectedItem,
    itemToString: itemToString3,
    selectedItem: selectedItemProp
  }));
  const [typeaheadText, setTypeaheadText] = (0, import_react62.useState)("");
  (0, import_react62.useEffect)(() => {
    if (typeahead) {
      if (inputValue.length >= prevInputLengthRef.current) {
        if (inputValue) {
          const filteredItems2 = items.filter((item) => autocompleteCustomFilter({
            item: itemToString3(item),
            inputValue
          }));
          if (filteredItems2.length > 0) {
            const suggestion = itemToString3(filteredItems2[0]);
            setTypeaheadText(suggestion.slice(inputValue.length));
          } else {
            setTypeaheadText("");
          }
        } else {
          setTypeaheadText("");
        }
      } else {
        setTypeaheadText("");
      }
      prevInputLengthRef.current = inputValue.length;
    }
  }, [typeahead, inputValue, items, itemToString3, autocompleteCustomFilter]);
  const isManualClearingRef = (0, import_react62.useRef)(false);
  const [isClearing, setIsClearing] = (0, import_react62.useState)(false);
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react62.useContext)(FormContext);
  const textInput = (0, import_react62.useRef)(null);
  const comboBoxInstanceId = useId();
  const [isFocused, setIsFocused] = (0, import_react62.useState)(false);
  const prevInputValue = (0, import_react62.useRef)(inputValue);
  const prevSelectedItemProp = (0, import_react62.useRef)(selectedItemProp);
  (0, import_react62.useEffect)(() => {
    isManualClearingRef.current = isClearing;
    if (isClearing) {
      setIsClearing(false);
    }
  }, [isClearing]);
  (0, import_react62.useEffect)(() => {
    if (prevSelectedItemProp.current !== selectedItemProp) {
      const currentInputValue = getInputValue({
        initialSelectedItem,
        itemToString: itemToString3,
        selectedItem: selectedItemProp,
        prevSelectedItem: prevSelectedItemProp.current
      });
      if (inputValue !== currentInputValue) {
        setInputValue(currentInputValue);
        onChange({
          selectedItem: selectedItemProp,
          inputValue: currentInputValue
        });
      }
      prevSelectedItemProp.current = selectedItemProp;
    }
  }, [selectedItemProp]);
  const filterItems = (items2, itemToString4, inputValue2) => items2.filter((item) => typeahead ? autocompleteCustomFilter({
    item: itemToString4(item),
    inputValue: inputValue2
  }) : shouldFilterItem ? shouldFilterItem({
    item,
    itemToString: itemToString4,
    inputValue: inputValue2
  }) : defaultShouldFilterItem());
  (0, import_react62.useEffect)(() => {
    if (prevInputValue.current !== inputValue) {
      prevInputValue.current = inputValue;
      onInputChange && onInputChange(inputValue);
    }
  }, [inputValue]);
  const handleSelectionClear = () => {
    if (textInput == null ? void 0 : textInput.current) {
      textInput.current.focus();
    }
  };
  const filteredItems = (inputValue2) => filterItems(items, itemToString3, inputValue2 || null);
  const indexToHighlight = (inputValue2) => findHighlightedIndex({
    ...props,
    items: filteredItems(inputValue2)
  }, inputValue2);
  const stateReducer3 = (0, import_react62.useCallback)(
    (state, actionAndChanges) => {
      const {
        type,
        changes
      } = actionAndChanges;
      const {
        highlightedIndex: highlightedIndex2
      } = changes;
      switch (type) {
        case InputBlur2: {
          if (allowCustomValue && highlightedIndex2 == "-1") {
            const customValue = inputValue;
            changes.selectedItem = customValue;
            if (onChange) {
              onChange({
                selectedItem: inputValue,
                inputValue
              });
            }
            return changes;
          }
          if (state.inputValue && highlightedIndex2 == "-1" && changes.selectedItem) {
            return {
              ...changes,
              inputValue: itemToString3(changes.selectedItem)
            };
          }
          if (state.inputValue && highlightedIndex2 == "-1" && !allowCustomValue && !changes.selectedItem) {
            return {
              ...changes,
              inputValue: ""
            };
          }
          return changes;
        }
        case InputKeyDownEnter2:
          if (!allowCustomValue) {
            if (state.highlightedIndex !== -1) {
              const filteredList = filterItems(items, itemToString3, inputValue);
              const highlightedItem = filteredList[state.highlightedIndex];
              if (highlightedItem && !highlightedItem.disabled) {
                return {
                  ...changes,
                  selectedItem: highlightedItem,
                  inputValue: itemToString3(highlightedItem)
                };
              }
            } else {
              const autoIndex = indexToHighlight(inputValue);
              if (autoIndex !== -1) {
                const matchingItem = items[autoIndex];
                if (matchingItem && !matchingItem.disabled) {
                  return {
                    ...changes,
                    selectedItem: matchingItem,
                    inputValue: itemToString3(matchingItem)
                  };
                }
              }
              if (state.selectedItem !== null) {
                return {
                  ...changes,
                  selectedItem: null,
                  inputValue
                };
              }
            }
          }
          return {
            ...changes,
            isOpen: true
          };
        case FunctionToggleMenu2:
        case ToggleButtonClick2:
          if (!changes.isOpen && state.inputValue && highlightedIndex2 === -1 && !allowCustomValue) {
            return {
              ...changes,
              inputValue: ""
              // Clear the input
            };
          }
          if (changes.isOpen && !changes.selectedItem) {
            return {
              ...changes
            };
          }
          return changes;
        case MenuMouseLeave2:
          return {
            ...changes,
            highlightedIndex: state.highlightedIndex
          };
        case InputKeyDownArrowUp2:
        case InputKeyDownArrowDown2:
          if (highlightedIndex2 === -1) {
            return {
              ...changes,
              highlightedIndex: 0
            };
          }
          return changes;
        case ItemMouseMove2:
          return {
            ...changes,
            highlightedIndex: state.highlightedIndex
          };
        default:
          return changes;
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [allowCustomValue, inputValue, onChange]
  );
  const handleToggleClick = (isOpen2) => (event) => {
    var _a2, _b2;
    if (onToggleClick) {
      onToggleClick(event);
    }
    if (readOnly) {
      event.preventDownshiftDefault = true;
      (_a2 = event == null ? void 0 : event.persist) == null ? void 0 : _a2.call(event);
      return;
    }
    if (event.target === textInput.current && isOpen2) {
      event.preventDownshiftDefault = true;
      (_b2 = event == null ? void 0 : event.persist) == null ? void 0 : _b2.call(event);
    }
  };
  const showWarning = !invalid && warn2;
  const className = (0, import_classnames36.default)(`${prefix}--combo-box`, {
    [`${prefix}--combo-box--invalid--focused`]: invalid && isFocused,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--combo-box--warning`]: showWarning,
    [`${prefix}--combo-box--readonly`]: readOnly,
    [`${prefix}--autoalign`]: enableFloatingStyles
  });
  const titleClasses = (0, import_classnames36.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled
  });
  const helperTextId = `combobox-helper-text-${comboBoxInstanceId}`;
  const warnTextId = `combobox-warn-text-${comboBoxInstanceId}`;
  const invalidTextId = `combobox-invalid-text-${comboBoxInstanceId}`;
  const helperClasses = (0, import_classnames36.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const wrapperClasses = (0, import_classnames36.default)(`${prefix}--list-box__wrapper`, [containerClassName, {
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator
  }]);
  const inputClasses = (0, import_classnames36.default)(`${prefix}--text-input`, {
    [`${prefix}--text-input--empty`]: !inputValue,
    [`${prefix}--combo-box--input--focus`]: isFocused
  });
  const ItemToElement = itemToElement;
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react62.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  const {
    // Prop getters
    getInputProps,
    getItemProps,
    getLabelProps,
    getMenuProps,
    getToggleButtonProps,
    // State
    isOpen,
    highlightedIndex,
    selectedItem,
    // Actions
    closeMenu,
    openMenu,
    reset,
    selectItem,
    setHighlightedIndex,
    setInputValue: downshiftSetInputValue,
    toggleMenu
  } = useCombobox({
    items: filterItems(items, itemToString3, inputValue),
    inputValue,
    itemToString: (item) => {
      return itemToString3(item);
    },
    onInputValueChange({
      inputValue: inputValue2
    }) {
      const normalizedInput = inputValue2 || "";
      setInputValue(normalizedInput);
      setHighlightedIndex(indexToHighlight(normalizedInput));
    },
    onHighlightedIndexChange: ({
      highlightedIndex: highlightedIndex2
    }) => {
      if (highlightedIndex2 > -1 && typeof window !== void 0) {
        const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
        const highlightedItem = itemArray[highlightedIndex2];
        if (highlightedItem) {
          highlightedItem.scrollIntoView({
            behavior: "smooth",
            block: "nearest"
          });
        }
      }
    },
    initialSelectedItem,
    inputId: id,
    stateReducer: stateReducer3,
    isItemDisabled(item, _index) {
      return item == null ? void 0 : item.disabled;
    },
    ...downshiftProps,
    onStateChange: ({
      type,
      selectedItem: newSelectedItem
    }) => {
      var _a2;
      (_a2 = downshiftProps == null ? void 0 : downshiftProps.onStateChange) == null ? void 0 : _a2.call(downshiftProps, {
        type,
        selectedItem: newSelectedItem
      });
      if (isManualClearingRef.current) {
        return;
      }
      if ((type === ItemClick2 || type === FunctionSelectItem2 || type === InputKeyDownEnter2) && typeof newSelectedItem !== "undefined" && !(0, import_react_fast_compare.default)(selectedItemProp, newSelectedItem)) {
        onChange({
          selectedItem: newSelectedItem
        });
      }
    }
  });
  (0, import_react62.useEffect)(() => {
    if (downshiftActions) {
      downshiftActions.current = {
        closeMenu,
        openMenu,
        reset,
        selectItem,
        setHighlightedIndex,
        setInputValue: downshiftSetInputValue,
        toggleMenu
      };
    }
  }, [closeMenu, openMenu, reset, selectItem, setHighlightedIndex, downshiftSetInputValue, toggleMenu]);
  const buttonProps = getToggleButtonProps({
    disabled: disabled || readOnly,
    onClick: handleToggleClick(isOpen),
    // When we moved the "root node" of Downshift to the <input> for
    // ARIA 1.2 compliance, we unfortunately hit this branch for the
    // "mouseup" event that downshift listens to:
    // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
    //
    // As a result, it will reset the state of the component and so we
    // stop the event from propagating to prevent this if the menu is already open.
    // This allows the toggleMenu behavior for the toggleButton to correctly open and
    // close the menu.
    onMouseUp(event) {
      if (isOpen) {
        event.stopPropagation();
      }
    }
  });
  const handleFocus = (evt) => {
    var _a2;
    setIsFocused(evt.type === "focus");
    if (!((_a2 = inputRef.current) == null ? void 0 : _a2.value) && evt.type === "blur") {
      selectItem(null);
    }
  };
  const readOnlyEventHandlers = readOnly ? {
    onKeyDown: (evt) => {
      if (evt.key !== "Tab") {
        evt.preventDefault();
      }
    },
    onClick: (evt) => {
      evt.preventDefault();
      evt.currentTarget.focus();
    }
  } : {};
  const ariaDescribedBy = invalid && invalidText && invalidTextId || warn2 && warnText && warnTextId || helperText && !isFluid && helperTextId || void 0;
  const menuProps = (0, import_react62.useMemo)(() => getMenuProps({
    ref: enableFloatingStyles ? refs.setFloating : null
  }), [enableFloatingStyles, deprecatedAriaLabel, ariaLabel, getMenuProps, refs.setFloating]);
  (0, import_react62.useEffect)(() => {
    if (textInput.current) {
      if (inputRef.current && typeaheadText) {
        const selectionStart = inputValue.length;
        const selectionEnd = selectionStart + typeaheadText.length;
        inputRef.current.value = inputValue + typeaheadText;
        inputRef.current.setSelectionRange(selectionStart, selectionEnd);
      }
    }
  }, [inputValue, typeaheadText]);
  return import_react62.default.createElement("div", {
    className: wrapperClasses
  }, titleText && import_react62.default.createElement(Text, _extends({
    as: "label",
    className: titleClasses
  }, getLabelProps()), titleText), import_react62.default.createElement(ListBox2, {
    onFocus: handleFocus,
    onBlur: handleFocus,
    className,
    disabled,
    invalid,
    invalidText,
    invalidTextId,
    isOpen,
    light,
    size: size4,
    warn: warn2,
    ref: enableFloatingStyles ? refs.setReference : null,
    warnText,
    warnTextId
  }, import_react62.default.createElement("div", {
    className: `${prefix}--list-box__field`
  }, import_react62.default.createElement("input", _extends({
    disabled,
    className: inputClasses,
    type: "text",
    tabIndex: 0,
    "aria-haspopup": "listbox",
    title: (_c = textInput == null ? void 0 : textInput.current) == null ? void 0 : _c.value
  }, getInputProps({
    "aria-label": titleText ? void 0 : deprecatedAriaLabel || ariaLabel,
    "aria-controls": isOpen ? void 0 : menuProps.id,
    placeholder,
    value: inputValue,
    ...inputProps,
    onChange: (e2) => {
      const newValue = e2.target.value;
      setInputValue(newValue);
      downshiftSetInputValue(newValue);
    },
    ref: mergeRefs(textInput, ref, inputRef),
    onKeyDown: (event) => {
      var _a2, _b2;
      if (match(event, Space)) {
        event.stopPropagation();
      }
      if (match(event, Enter) && (!inputValue || allowCustomValue)) {
        toggleMenu();
        if (highlightedIndex !== -1) {
          selectItem(filterItems(items, itemToString3, inputValue)[highlightedIndex]);
        }
        if (allowCustomValue && isOpen && inputValue && highlightedIndex === -1) {
          onChange({
            selectedItem: null,
            inputValue
          });
        }
        event.preventDownshiftDefault = true;
        (_a2 = event == null ? void 0 : event.persist) == null ? void 0 : _a2.call(event);
      }
      if (match(event, Escape) && inputValue) {
        if (event.target === textInput.current && isOpen) {
          toggleMenu();
          event.preventDownshiftDefault = true;
          (_b2 = event == null ? void 0 : event.persist) == null ? void 0 : _b2.call(event);
        }
      }
      if (match(event, Home) && event.code !== "Numpad7") {
        event.target.setSelectionRange(0, 0);
      }
      if (match(event, End) && event.code !== "Numpad1") {
        event.target.setSelectionRange(event.target.value.length, event.target.value.length);
      }
      if (event.altKey && event.key == "ArrowDown") {
        event.preventDownshiftDefault = true;
        if (!isOpen) {
          toggleMenu();
        }
      }
      if (event.altKey && event.key == "ArrowUp") {
        event.preventDownshiftDefault = true;
        if (isOpen) {
          toggleMenu();
        }
      }
      if (!inputValue && highlightedIndex == -1 && event.key == "Enter") {
        if (!isOpen) toggleMenu();
        selectItem(null);
        event.preventDownshiftDefault = true;
        if (event.currentTarget.ariaExpanded === "false") openMenu();
      }
      if (typeahead && event.key === "Tab") {
        const matchingItem = items.find((item) => itemToString3(item).toLowerCase().startsWith(inputValue.toLowerCase()));
        if (matchingItem) {
          const newValue = itemToString3(matchingItem);
          downshiftSetInputValue(newValue);
          selectItem(matchingItem);
        }
      }
    }
  }), rest, readOnlyEventHandlers, {
    readOnly,
    "aria-describedby": ariaDescribedBy
  })), invalid && import_react62.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react62.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), inputValue && import_react62.default.createElement(ListBoxSelection2, {
    clearSelection: () => {
      setIsClearing(true);
      setInputValue("");
      onChange({
        selectedItem: null
      });
      selectItem(null);
      handleSelectionClear();
    },
    translateWithId: translateWithId8,
    disabled: disabled || readOnly,
    onClearSelection: handleSelectionClear,
    selectionCount: 0
  }), import_react62.default.createElement(ListBoxTrigger, _extends({}, buttonProps, {
    isOpen,
    translateWithId: translateWithId8
  }))), slug ? normalizedDecorator : decorator ? import_react62.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react62.default.createElement(ListBox2.Menu, menuProps, isOpen ? filterItems(items, itemToString3, inputValue).map((item, index3) => {
    var _a2;
    const isObject = item !== null && typeof item === "object";
    const title = isObject && "text" in item && itemToElement ? (_a2 = item.text) == null ? void 0 : _a2.toString() : itemToString3(item);
    const itemProps = getItemProps({
      item,
      index: index3
    });
    const disabled2 = itemProps["aria-disabled"];
    const {
      "aria-disabled": unusedAriaDisabled,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      ...modifiedItemProps
    } = itemProps;
    return import_react62.default.createElement(ListBox2.MenuItem, _extends({
      key: itemProps.id,
      isActive: selectedItem === item,
      isHighlighted: highlightedIndex === index3,
      title,
      disabled: disabled2
    }, modifiedItemProps), ItemToElement ? import_react62.default.createElement(ItemToElement, _extends({
      key: itemProps.id
    }, item)) : itemToString3(item), selectedItem === item && import_react62.default.createElement(Checkmark, {
      className: `${prefix}--list-box__menu-item__selected-icon`
    }));
  }) : null)), helperText && !invalid && !warn2 && !isFluid && import_react62.default.createElement(Text, {
    as: "div",
    id: helperTextId,
    className: helperClasses
  }, helperText));
});
ComboBox.displayName = "ComboBox";
ComboBox.propTypes = {
  /**
   * Specify whether or not the ComboBox should allow a value that is
   * not in the list to be entered in the input
   */
  allowCustomValue: import_prop_types44.default.bool,
  /**
   * 'aria-label' of the ListBox component.
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types44.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   * 'aria-label' of the ListBox component.
   */
  ariaLabel: deprecate(import_prop_types44.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * **Experimental**: Will attempt to automatically align the floating
   * element to avoid collisions with the viewport and being clipped by
   * ancestor elements. Requires React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types44.default.bool,
  /**
   * An optional className to add to the container node
   */
  className: import_prop_types44.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `ComboBox` component
   */
  decorator: import_prop_types44.default.node,
  /**
   * Specify the direction of the combobox dropdown. Can be either top or bottom.
   */
  direction: import_prop_types44.default.oneOf(["top", "bottom"]),
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: import_prop_types44.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types44.default.object,
  /**
   * Provide a ref that will be mutated to contain an object of downshift
   * action functions. These can be called to change the internal state of the
   * downshift useCombobox hook.
   *
   * **Use with caution:** calling these actions modifies the internal state of
   * downshift. It may conflict with or override the state management used within
   * Combobox. Downshift APIs and internals are subject to change, and in some
   * cases they can not be shimmed by Carbon to shield you from potentially breaking
   * changes.
   */
  downshiftActions: import_prop_types44.default.exact({
    current: import_prop_types44.default.any
  }),
  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: import_prop_types44.default.node,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types44.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types44.default.oneOfType([import_prop_types44.default.object, import_prop_types44.default.string, import_prop_types44.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types44.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types44.default.node,
  /**
   * Optional function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types44.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list
   */
  itemToString: import_prop_types44.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types44.default.array.isRequired,
  /**
   * should use "light theme" (white background)?
   */
  light: deprecate(import_prop_types44.default.bool, "The `light` prop for `Combobox` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component when a specific dropdown item is selected.
   * `({ selectedItem }) => void`
   * @param {{ selectedItem }}
   */
  onChange: import_prop_types44.default.func.isRequired,
  /**
   * Callback function to notify consumer when the text input changes.
   * This provides support to change available items based on the text.
   * `(inputText) => void`
   * @param {string} inputText
   */
  onInputChange: import_prop_types44.default.func,
  /**
   * Callback function that fires when the combobox menu toggle is clicked
   * `(evt) => void`
   * @param {MouseEvent} event
   */
  onToggleClick: import_prop_types44.default.func,
  /**
   * Used to provide a placeholder text node before a user enters any input.
   * This is only present if the control has no items selected
   */
  placeholder: import_prop_types44.default.string,
  /**
   * Is the ComboBox readonly?
   */
  readOnly: import_prop_types44.default.bool,
  /**
   * For full control of the selection
   */
  selectedItem: import_prop_types44.default.oneOfType([import_prop_types44.default.object, import_prop_types44.default.string, import_prop_types44.default.number]),
  /**
   * Specify your own filtering logic by passing in a `shouldFilterItem`
   * function that takes in the current input and an item and passes back
   * whether or not the item should be filtered.
   * this prop will be ignored if `typeahead` prop is enabled
   */
  shouldFilterItem: import_prop_types44.default.func,
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSizePropType,
  slug: deprecate(import_prop_types44.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * combobox via ARIA attributes.
   */
  titleText: import_prop_types44.default.node,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types44.default.func,
  /**
   * **Experimental**: will enable autocomplete and typeahead for the input field
   */
  typeahead: import_prop_types44.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types44.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types44.default.node,
  /**
   * Specify native input attributes to place on the `<input>`, like maxLength.
   * These are passed to downshift's getInputProps() and will override the
   * internal input props.
   * https://github.com/downshift-js/downshift?tab=readme-ov-file#getinputprops
   */
  inputProps: import_prop_types44.default.object
};

// node_modules/@carbon/react/es/components/ComboButton/index.js
var import_react73 = __toESM(require_react());
var import_prop_types48 = __toESM(require_prop_types());
var import_classnames39 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Menu/Menu.js
var import_classnames37 = __toESM(require_classnames());
var import_prop_types46 = __toESM(require_prop_types());
var import_react68 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/@carbon/react/es/components/Menu/MenuContext.js
var import_react64 = __toESM(require_react());
var menuDefaultState = {
  isRoot: true,
  hasIcons: false,
  hasSelectableItems: false,
  size: null,
  items: [],
  requestCloseRoot: () => {
  }
};
function menuReducer(state, action) {
  var _a;
  switch (action.type) {
    case "enableIcons":
      return {
        ...state,
        hasIcons: true
      };
    case "enableSelectableItems":
      return {
        ...state,
        hasSelectableItems: true
      };
    case "registerItem": {
      const newItem = action.payload;
      const items = state.items.filter((item) => item.ref.current);
      const next = (_a = newItem.ref.current) == null ? void 0 : _a.nextElementSibling;
      const idx = items.findIndex((item) => item.ref.current === next);
      items.splice(idx < 0 ? items.length : idx, 0, newItem);
      return {
        ...state,
        items
      };
    }
  }
}
var MenuContext = (0, import_react64.createContext)({
  state: menuDefaultState,
  // 'dispatch' is populated by the root menu
  dispatch: (_) => {
  }
});

// node_modules/@carbon/react/es/components/LayoutDirection/LayoutDirection.js
var import_prop_types45 = __toESM(require_prop_types());
var import_react66 = __toESM(require_react());

// node_modules/@carbon/react/es/components/LayoutDirection/LayoutDirectionContext.js
var import_react65 = __toESM(require_react());
var LayoutDirectionContext = import_react65.default.createContext({
  direction: "ltr"
});

// node_modules/@carbon/react/es/components/LayoutDirection/LayoutDirection.js
function LayoutDirection({
  as: BaseComponent = "div",
  children,
  dir,
  ...rest
}) {
  const value = import_react66.default.useMemo(() => {
    return {
      direction: dir
    };
  }, [dir]);
  return import_react66.default.createElement(LayoutDirectionContext.Provider, {
    value
  }, import_react66.default.createElement(BaseComponent, _extends({
    dir
  }, rest), children));
}
LayoutDirection.propTypes = {
  /**
   * Customize the element type used to render the outermost node
   */
  as: import_prop_types45.default.oneOfType([import_prop_types45.default.func, import_prop_types45.default.string, import_prop_types45.default.elementType]),
  /**
   * Provide child elements or components to be rendered inside of this
   * component
   */
  children: import_prop_types45.default.node,
  /**
   * Specify the layout direction of this part of the page
   */
  dir: import_prop_types45.default.oneOf(["ltr", "rtl"]).isRequired
};

// node_modules/@carbon/react/es/components/LayoutDirection/useLayoutDirection.js
var import_react67 = __toESM(require_react());
function useLayoutDirection() {
  return (0, import_react67.useContext)(LayoutDirectionContext);
}

// node_modules/@carbon/react/es/components/Menu/Menu.js
var spacing = 8;
var Menu2 = (0, import_react68.forwardRef)(function Menu3({
  children,
  className,
  containerRef,
  label,
  menuAlignment,
  mode,
  onClose,
  onOpen,
  open: open2,
  size: size4 = "sm",
  legacyAutoalign = "true",
  target = canUseDOM && document.body,
  x = 0,
  y = 0,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const focusReturn = (0, import_react68.useRef)(null);
  const context = (0, import_react68.useContext)(MenuContext);
  const isRoot = context.state.isRoot;
  const menuSize = isRoot ? size4 : context.state.size;
  const [childState, childDispatch] = (0, import_react68.useReducer)(menuReducer, {
    ...context.state,
    isRoot: false,
    size: size4,
    requestCloseRoot: isRoot ? handleClose : context.state.requestCloseRoot
  });
  const childContext = (0, import_react68.useMemo)(() => {
    return {
      state: childState,
      dispatch: childDispatch
    };
  }, [childState, childDispatch]);
  const menu = (0, import_react68.useRef)(null);
  const ref = useMergedRefs([forwardRef36, menu]);
  const [position, setPosition] = (0, import_react68.useState)([-1, -1]);
  const focusableItems = childContext.state.items.filter((item) => !item.disabled && item.ref.current);
  let actionButtonWidth;
  if (containerRef == null ? void 0 : containerRef.current) {
    const {
      width: w2
    } = containerRef.current.getBoundingClientRect();
    actionButtonWidth = w2;
  }
  const {
    direction
  } = useLayoutDirection();
  function returnFocus() {
    if (focusReturn.current) {
      focusReturn.current.focus();
    }
  }
  function handleOpen() {
    var _a;
    if (menu.current) {
      focusReturn.current = document.activeElement;
      if (legacyAutoalign) {
        const pos = calculatePosition();
        if (((document == null ? void 0 : document.dir) === "rtl" || direction === "rtl") && !((_a = rest == null ? void 0 : rest.id) == null ? void 0 : _a.includes("MenuButton"))) {
          menu.current.style.insetInlineStart = `initial`;
          menu.current.style.insetInlineEnd = `${pos[0]}px`;
        } else {
          menu.current.style.insetInlineStart = `${pos[0]}px`;
          menu.current.style.insetInlineEnd = `initial`;
        }
        menu.current.style.insetBlockStart = `${pos[1]}px`;
        setPosition(pos);
      }
      menu.current.focus();
      if (onOpen) {
        onOpen();
      }
    }
  }
  function handleClose() {
    returnFocus();
    if (onClose) {
      onClose();
    }
  }
  function handleKeyDown(e2) {
    e2.stopPropagation();
    if ((match(e2, Escape) || !isRoot && match(e2, ArrowLeft)) && onClose) {
      handleClose();
    } else {
      focusItem(e2);
    }
  }
  function focusItem(e2) {
    var _a, _b;
    const currentItem = focusableItems.findIndex((item) => {
      var _a2, _b2;
      return (_b2 = (_a2 = item.ref) == null ? void 0 : _a2.current) == null ? void 0 : _b2.contains(document.activeElement);
    });
    let indexToFocus = currentItem;
    if (currentItem === -1) {
      indexToFocus = 0;
    } else if (e2) {
      if (match(e2, ArrowUp2)) {
        indexToFocus = indexToFocus - 1;
      }
      if (match(e2, ArrowDown)) {
        indexToFocus = indexToFocus + 1;
      }
    }
    if (indexToFocus < 0) {
      indexToFocus = focusableItems.length - 1;
    }
    if (indexToFocus >= focusableItems.length) {
      indexToFocus = 0;
    }
    if (indexToFocus !== currentItem) {
      const nodeToFocus = focusableItems[indexToFocus];
      (_b = (_a = nodeToFocus.ref) == null ? void 0 : _a.current) == null ? void 0 : _b.focus();
      e2 == null ? void 0 : e2.preventDefault();
    }
  }
  function handleBlur(e2) {
    var _a;
    if (open2 && onClose && isRoot && !((_a = menu.current) == null ? void 0 : _a.contains(e2.relatedTarget))) {
      handleClose();
    }
  }
  function fitValue(range, axis) {
    if (!menu.current) {
      return;
    }
    const {
      width,
      height
    } = menu.current.getBoundingClientRect();
    const alignment = isRoot ? "vertical" : "horizontal";
    const axes = {
      x: {
        max: window.innerWidth,
        size: width,
        anchor: alignment === "horizontal" ? range[1] : range[0],
        reversedAnchor: alignment === "horizontal" ? range[0] : range[1],
        offset: 0
      },
      y: {
        max: window.innerHeight,
        size: height,
        anchor: alignment === "horizontal" ? range[0] : range[1],
        reversedAnchor: alignment === "horizontal" ? range[1] : range[0],
        offset: isRoot ? 0 : 4
        // top padding in menu, used to align the menu items
      }
    };
    if (actionButtonWidth && actionButtonWidth < axes.x.size && (menuAlignment === "bottom" || menuAlignment === "top")) {
      axes.x.size = actionButtonWidth;
    }
    if (actionButtonWidth && (menuAlignment === "bottom-end" || menuAlignment === "top-end") && axes.x.anchor >= 87 && actionButtonWidth < axes.x.size) {
      const diff = axes.x.anchor + axes.x.reversedAnchor;
      axes.x.anchor = axes.x.anchor + diff;
    }
    const {
      max: max2,
      size: size5,
      anchor,
      reversedAnchor,
      offset: offset4
    } = axes[axis];
    const options = [
      // towards max (preferred)
      max2 - spacing - size5 - anchor >= 0 ? anchor - offset4 : false,
      // towards min / reversed (first fallback)
      reversedAnchor - size5 >= 0 ? reversedAnchor - size5 + offset4 : false,
      // align at max (second fallback)
      max2 - spacing - size5
    ];
    const topAlignment = menuAlignment === "top" || menuAlignment === "top-end" || menuAlignment === "top-start";
    if (typeof options[0] === "number" && topAlignment && options[0] >= 0 && !options[1] && axis === "y") {
      menu.current.style.transform = "translate(0)";
    } else if (topAlignment && !options[0] && axis === "y") {
      options[0] = anchor - offset4;
    }
    const bestOption = options.find((option) => option !== false);
    return bestOption >= spacing ? bestOption : spacing;
  }
  function notEmpty(value) {
    return value !== null && value !== void 0;
  }
  function getPosition(x2) {
    if (Array.isArray(x2)) {
      const filtered = x2.filter(notEmpty);
      if (filtered.length === 2) {
        return filtered;
      } else {
        return;
      }
    } else {
      return [x2, x2];
    }
  }
  function calculatePosition() {
    const ranges = {
      x: getPosition(x),
      y: getPosition(y)
    };
    if (!ranges.x || !ranges.y) {
      return [-1, -1];
    }
    return [fitValue(ranges.x, "x") ?? -1, fitValue(ranges.y, "y") ?? -1];
  }
  (0, import_react68.useEffect)(() => {
    if (open2) {
      const raf = requestAnimationFrame(() => {
        if (focusableItems.length > 0) {
          focusItem();
        }
      });
      return () => cancelAnimationFrame(raf);
    }
  }, [open2, focusableItems]);
  (0, import_react68.useEffect)(() => {
    if (open2) {
      handleOpen();
    } else {
      setPosition([-1, -1]);
    }
  }, [open2]);
  const classNames = (0, import_classnames37.default)(className, `${prefix}--menu`, `${prefix}--menu--${menuSize}`, {
    // --open sets visibility and --shown sets opacity.
    // visibility is needed for focusing elements.
    // opacity is only set once the position has been set correctly
    // to avoid a flicker effect when opening.
    [`${prefix}--menu--box-shadow-top`]: menuAlignment && menuAlignment.slice(0, 3) === "top",
    [`${prefix}--menu--open`]: open2,
    [`${prefix}--menu--shown`]: open2 && !legacyAutoalign || position[0] >= 0 && position[1] >= 0,
    [`${prefix}--menu--with-icons`]: childContext.state.hasIcons,
    [`${prefix}--menu--with-selectable-items`]: childContext.state.hasSelectableItems,
    [`${prefix}--autoalign`]: !legacyAutoalign
  });
  const rendered = import_react68.default.createElement(MenuContext.Provider, {
    value: childContext
  }, import_react68.default.createElement("ul", _extends({}, rest, {
    className: classNames,
    role: "menu",
    ref,
    "aria-label": label,
    tabIndex: -1,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur
  }), children));
  if (!target) {
    return rendered;
  }
  return isRoot ? open2 && (0, import_react_dom3.createPortal)(rendered, target) || null : rendered;
});
Menu2.propTypes = {
  /**
   * A collection of MenuItems to be rendered within this Menu.
   */
  children: import_prop_types46.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types46.default.string,
  /**
   * A label describing the Menu.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  label: import_prop_types46.default.string,
  /**
   * Specify how the menu should align with the button element
   */
  menuAlignment: import_prop_types46.default.string,
  /**
   * **Deprecated**: Menus now always support both icons as well as selectable items and nesting.
   * The mode of this menu. Defaults to full.
   * `full` supports nesting and selectable menu items, but no icons.
   * `basic` supports icons but no nesting or selectable menu items.
   *
   * **This prop is not intended for use and will be set by the respective implementation (like useContextMenu, MenuButton, and ComboButton).**
   */
  mode: deprecate(import_prop_types46.default.oneOf(["full", "basic"]), "Menus now always support both icons as well as selectable items and nesting."),
  /**
   * Provide an optional function to be called when the Menu should be closed,
   * including if the Menu is blurred, the user presses escape, or the Menu is
   * a submenu and the user presses ArrowLeft.
   */
  onClose: import_prop_types46.default.func,
  /**
   * Provide an optional function to be called when the Menu is opened.
   */
  onOpen: import_prop_types46.default.func,
  /**
   * Whether the Menu is open or not.
   */
  open: import_prop_types46.default.bool,
  /**
   * Specify the size of the Menu.
   */
  size: import_prop_types46.default.oneOf(["xs", "sm", "md", "lg"]),
  /**
   * Specify a DOM node where the Menu should be rendered in. Defaults to document.body.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  target: import_prop_types46.default.object,
  /**
   * Specify the x position of the Menu. Either pass a single number or an array with two numbers describing your activator's boundaries ([x1, x2])
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  x: import_prop_types46.default.oneOfType([import_prop_types46.default.number, import_prop_types46.default.arrayOf(import_prop_types46.default.number)]),
  /**
   * Specify the y position of the Menu. Either pass a single number or an array with two numbers describing your activator's boundaries ([y1, y2])
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  y: import_prop_types46.default.oneOfType([import_prop_types46.default.number, import_prop_types46.default.arrayOf(import_prop_types46.default.number)])
};

// node_modules/@carbon/react/es/components/Menu/MenuItem.js
var import_classnames38 = __toESM(require_classnames());
var import_prop_types47 = __toESM(require_prop_types());
var import_react70 = __toESM(require_react());

// node_modules/@carbon/react/es/internal/useControllableState.js
var import_react69 = __toESM(require_react());
var useControllableState = ({
  defaultValue,
  name = "custom",
  onChange,
  value
}) => {
  const [state, internalSetState] = (0, import_react69.useState)(typeof value !== "undefined" ? value : defaultValue);
  const controlled = (0, import_react69.useRef)(null);
  if (controlled.current === null) {
    controlled.current = typeof value !== "undefined";
  }
  const setState = (stateOrUpdater) => {
    const newValue = typeof stateOrUpdater === "function" ? stateOrUpdater(state) : stateOrUpdater;
    if (controlled.current === false) {
      internalSetState(newValue);
    }
    if (onChange) {
      onChange(newValue);
    }
  };
  (0, import_react69.useEffect)(() => {
    const controlledValue = typeof value !== "undefined";
    if (controlled.current === false && controlledValue) {
      true ? warning(false, `A component is changing an uncontrolled ${name} component to be controlled. This is likely caused by the value changing to a defined value from undefined. Decide between using a controlled or uncontrolled value for the lifetime of the component. More info: https://reactjs.org/link/controlled-components`) : void 0;
    }
    if (controlled.current === true && !controlledValue) {
      true ? warning(false, `A component is changing a controlled ${name} component to be uncontrolled. This is likely caused by the value changing to an undefined value from a defined one. Decide between using a controlled or uncontrolled value for the lifetime of the component. More info: https://reactjs.org/link/controlled-components`) : void 0;
    }
  }, [name, value]);
  if (controlled.current === true) {
    return [value, setState, controlled.current];
  }
  return [state, setState, controlled.current];
};

// node_modules/@carbon/react/es/components/Menu/MenuItem.js
var _Checkmark;
var _CaretLeft;
var _CaretRight;
var MenuItem = (0, import_react70.forwardRef)(function MenuItem2({
  children,
  className,
  disabled,
  kind = "default",
  label,
  onClick,
  renderIcon: IconElement,
  shortcut,
  ...rest
}, forwardRef36) {
  const [submenuOpen, setSubmenuOpen] = (0, import_react70.useState)(false);
  const [rtl, setRtl] = (0, import_react70.useState)(false);
  const {
    refs,
    floatingStyles,
    context: floatingContext
  } = useFloating2({
    open: submenuOpen,
    onOpenChange: setSubmenuOpen,
    placement: rtl ? "left-start" : "right-start",
    whileElementsMounted: autoUpdate,
    middleware: [offset3({
      mainAxis: -6,
      crossAxis: -6
    })],
    strategy: "fixed"
  });
  const {
    getReferenceProps,
    getFloatingProps
  } = useInteractions([useHover(floatingContext, {
    delay: 100,
    enabled: true,
    handleClose: safePolygon({
      requireIntent: false
    })
  })]);
  const prefix = usePrefix();
  const context = (0, import_react70.useContext)(MenuContext);
  const menuItem = (0, import_react70.useRef)(null);
  const ref = useMergedRefs([forwardRef36, menuItem, refs.setReference]);
  const hasChildren = Boolean(children);
  const isDisabled = disabled && !hasChildren;
  const isDanger = kind === "danger" && !hasChildren;
  function registerItem() {
    context.dispatch({
      type: "registerItem",
      payload: {
        ref: menuItem,
        disabled: Boolean(disabled)
      }
    });
  }
  function openSubmenu() {
    if (!menuItem.current) {
      return;
    }
    setSubmenuOpen(true);
  }
  function closeSubmenu() {
    setSubmenuOpen(false);
  }
  function handleClick2(e2) {
    if (!isDisabled) {
      if (hasChildren) {
        openSubmenu();
      } else {
        context.state.requestCloseRoot(e2);
        if (onClick) {
          onClick(e2);
        }
      }
    }
  }
  const pendingKeyboardClick = (0, import_react70.useRef)(false);
  const keyboardClickEvent = (e2) => match(e2, Enter) || match(e2, Space);
  function handleKeyDown(e2) {
    if (hasChildren && match(e2, ArrowRight2)) {
      openSubmenu();
      requestAnimationFrame(() => {
        var _a;
        (_a = refs.floating.current) == null ? void 0 : _a.focus();
      });
      e2.stopPropagation();
      e2.preventDefault();
    }
    pendingKeyboardClick.current = keyboardClickEvent(e2);
    if (rest.onKeyDown) {
      rest.onKeyDown(e2);
    }
  }
  function handleKeyUp(e2) {
    if (pendingKeyboardClick.current && keyboardClickEvent(e2)) {
      handleClick2(e2);
    }
    pendingKeyboardClick.current = false;
  }
  const classNames = (0, import_classnames38.default)(className, `${prefix}--menu-item`, {
    [`${prefix}--menu-item--disabled`]: isDisabled,
    [`${prefix}--menu-item--danger`]: isDanger
  });
  (0, import_react70.useEffect)(() => {
    registerItem();
  }, []);
  const {
    direction
  } = useLayoutDirection();
  (0, import_react70.useEffect)(() => {
    if ((document == null ? void 0 : document.dir) === "rtl" || direction === "rtl") {
      setRtl(true);
    } else {
      setRtl(false);
    }
  }, [direction]);
  (0, import_react70.useEffect)(() => {
    if (IconElement && !context.state.hasIcons) {
      context.dispatch({
        type: "enableIcons"
      });
    }
  }, [IconElement, context.state.hasIcons, context]);
  (0, import_react70.useEffect)(() => {
    Object.keys(floatingStyles).forEach((style) => {
      if (refs.floating.current && style !== "position") {
        refs.floating.current.style[style] = floatingStyles[style];
      }
    });
  }, [floatingStyles, refs.floating]);
  return import_react70.default.createElement(FloatingFocusManager, {
    context: floatingContext,
    order: ["reference", "floating"],
    modal: false
  }, import_react70.default.createElement("li", _extends({
    role: "menuitem"
  }, rest, {
    ref,
    className: classNames,
    tabIndex: !disabled ? 0 : -1,
    "aria-disabled": isDisabled ?? void 0,
    "aria-haspopup": hasChildren ?? void 0,
    "aria-expanded": hasChildren ? submenuOpen : void 0,
    onClick: handleClick2,
    onKeyDown: handleKeyDown,
    onKeyUp: handleKeyUp
  }, getReferenceProps()), import_react70.default.createElement("div", {
    className: `${prefix}--menu-item__selection-icon`
  }, rest["aria-checked"] && (_Checkmark || (_Checkmark = import_react70.default.createElement(Checkmark, null)))), import_react70.default.createElement("div", {
    className: `${prefix}--menu-item__icon`
  }, IconElement && import_react70.default.createElement(IconElement, null)), import_react70.default.createElement(Text, {
    as: "div",
    className: `${prefix}--menu-item__label`,
    title: label
  }, label), shortcut && !hasChildren && import_react70.default.createElement("div", {
    className: `${prefix}--menu-item__shortcut`
  }, shortcut), hasChildren && import_react70.default.createElement(import_react70.default.Fragment, null, import_react70.default.createElement("div", {
    className: `${prefix}--menu-item__shortcut`
  }, rtl ? _CaretLeft || (_CaretLeft = import_react70.default.createElement(CaretLeft, null)) : _CaretRight || (_CaretRight = import_react70.default.createElement(CaretRight, null))), import_react70.default.createElement(Menu2, _extends({
    label,
    open: submenuOpen,
    onClose: () => {
      var _a;
      closeSubmenu();
      (_a = menuItem.current) == null ? void 0 : _a.focus();
    },
    ref: refs.setFloating
  }, getFloatingProps()), children))));
});
MenuItem.propTypes = {
  /**
   * Optionally provide another Menu to create a submenu. props.children can't be used to specify the content of the MenuItem itself. Use props.label instead.
   */
  children: import_prop_types47.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types47.default.string,
  /**
   * Specify whether the MenuItem is disabled or not.
   */
  disabled: import_prop_types47.default.bool,
  /**
   * Specify the kind of the MenuItem.
   */
  kind: import_prop_types47.default.oneOf(["default", "danger"]),
  /**
   * A required label titling the MenuItem. Will be rendered as its text content.
   */
  label: import_prop_types47.default.string.isRequired,
  /**
   * Provide an optional function to be called when the MenuItem is clicked.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onClick: import_prop_types47.default.func,
  /**
   * A component used to render an icon.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  renderIcon: import_prop_types47.default.oneOfType([import_prop_types47.default.func, import_prop_types47.default.object]),
  /**
   * Provide a shortcut for the action of this MenuItem. Note that the component will only render it as a hint but not actually register the shortcut.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  shortcut: import_prop_types47.default.string
};
var MenuItemSelectable = (0, import_react70.forwardRef)(function MenuItemSelectable2({
  className,
  defaultSelected,
  label,
  onChange,
  selected,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const context = (0, import_react70.useContext)(MenuContext);
  const [checked, setChecked] = useControllableState({
    value: selected,
    onChange,
    defaultValue: defaultSelected ?? false
  });
  function handleClick2(e2) {
    setChecked(!checked);
  }
  (0, import_react70.useEffect)(() => {
    if (!context.state.hasSelectableItems) {
      context.dispatch({
        type: "enableSelectableItems"
      });
    }
  }, [context.state.hasSelectableItems, context]);
  const classNames = (0, import_classnames38.default)(className, `${prefix}--menu-item-selectable--selected`);
  return import_react70.default.createElement(MenuItem, _extends({}, rest, {
    ref: forwardRef36,
    label,
    className: classNames,
    role: "menuitemcheckbox",
    "aria-checked": checked,
    onClick: handleClick2
  }));
});
MenuItemSelectable.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types47.default.string,
  /**
   * Specify whether the option should be selected by default.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  defaultSelected: import_prop_types47.default.bool,
  /**
   * A required label titling this option.
   */
  label: import_prop_types47.default.string.isRequired,
  /**
   * Provide an optional function to be called when the selection state changes.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onChange: import_prop_types47.default.func,
  /**
   * Pass a bool to props.selected to control the state of this option.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  selected: import_prop_types47.default.bool
};
var MenuItemGroup = (0, import_react70.forwardRef)(function MenuItemGroup2({
  children,
  className,
  label,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames38.default)(className, `${prefix}--menu-item-group`);
  return import_react70.default.createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef36
  }, import_react70.default.createElement("ul", _extends({}, rest, {
    role: "group",
    "aria-label": label
  }), children));
});
MenuItemGroup.propTypes = {
  /**
   * A collection of MenuItems to be rendered within this group.
   */
  children: import_prop_types47.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types47.default.string,
  /**
   * A required label titling this group.
   */
  label: import_prop_types47.default.string.isRequired
};
var defaultItemToString2 = (item) => item.toString();
var MenuItemRadioGroup = (0, import_react70.forwardRef)(function MenuItemRadioGroup2({
  className,
  defaultSelectedItem,
  items,
  itemToString: itemToString3 = defaultItemToString2,
  label,
  onChange,
  selectedItem,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const context = (0, import_react70.useContext)(MenuContext);
  const [selection, setSelection] = useControllableState({
    value: selectedItem,
    onChange,
    defaultValue: defaultSelectedItem ?? {}
  });
  function handleClick2(item, e2) {
    setSelection(item);
  }
  (0, import_react70.useEffect)(() => {
    if (!context.state.hasSelectableItems) {
      context.dispatch({
        type: "enableSelectableItems"
      });
    }
  }, [context.state.hasSelectableItems, context]);
  const classNames = (0, import_classnames38.default)(className, `${prefix}--menu-item-radio-group`);
  return import_react70.default.createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef36
  }, import_react70.default.createElement("ul", _extends({}, rest, {
    role: "group",
    "aria-label": label
  }), items.map((item, i) => import_react70.default.createElement(MenuItem, {
    key: i,
    label: itemToString3(item),
    role: "menuitemradio",
    "aria-checked": item === selection,
    onClick: (e2) => {
      handleClick2(item);
    }
  }))));
});
MenuItemRadioGroup.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types47.default.string,
  /**
   * Specify the default selected item. Must match the type of props.items.
   */
  defaultSelectedItem: import_prop_types47.default.any,
  /**
   * Provide a function to convert an item to the string that will be rendered. Defaults to item.toString().
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  itemToString: import_prop_types47.default.func,
  /**
   * Provide the options for this radio group. Can be of any type, as long as you provide an appropriate props.itemToString function.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  items: import_prop_types47.default.array,
  /**
   * A required label titling this radio group.
   */
  label: import_prop_types47.default.string.isRequired,
  /**
   * Provide an optional function to be called when the selection changes.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  onChange: import_prop_types47.default.func,
  /**
   * Provide props.selectedItem to control the state of this radio group. Must match the type of props.items.
   */
  selectedItem: import_prop_types47.default.any
};
var MenuItemDivider = (0, import_react70.forwardRef)(function MenuItemDivider2({
  className,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames38.default)(className, `${prefix}--menu-item-divider`);
  return import_react70.default.createElement("li", _extends({}, rest, {
    className: classNames,
    role: "separator",
    ref: forwardRef36
  }));
});
MenuItemDivider.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types47.default.string
};

// node_modules/@carbon/react/es/internal/useAttachedMenu.js
var import_react72 = __toESM(require_react());
function useAttachedMenu(anchor) {
  const [open2, setOpen] = (0, import_react72.useState)(false);
  const [position, setPosition] = (0, import_react72.useState)([[-1, -1], [-1, -1]]);
  function openMenu() {
    const anchorEl = (anchor == null ? void 0 : anchor.current) || anchor;
    if (anchorEl) {
      const {
        left,
        top,
        right,
        bottom
      } = anchorEl.getBoundingClientRect();
      setPosition([[left, right], [top, bottom]]);
    }
    setOpen(true);
  }
  function closeMenu() {
    setOpen(false);
  }
  function handleClick2() {
    if (open2) {
      closeMenu();
    } else {
      openMenu();
    }
  }
  function handleMousedown(e2) {
    e2.preventDefault();
  }
  return {
    open: open2,
    x: position[0],
    y: position[1],
    handleClick: handleClick2,
    handleMousedown,
    handleClose: closeMenu
  };
}

// node_modules/@carbon/react/es/components/ComboButton/index.js
var _ChevronDown2;
var defaultTranslations5 = {
  "carbon.combo-button.additional-actions": "Additional actions"
};
function defaultTranslateWithId5(messageId) {
  return defaultTranslations5[messageId];
}
var ComboButton = import_react73.default.forwardRef(function ComboButton2({
  children,
  className,
  disabled,
  label,
  onClick,
  size: size$1 = "lg",
  menuAlignment = "bottom",
  tooltipAlignment,
  translateWithId: t3 = defaultTranslateWithId5,
  ...rest
}, forwardRef36) {
  const enableOnlyFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles");
  const id = useId("combobutton");
  const prefix = usePrefix();
  const containerRef = (0, import_react73.useRef)(null);
  let middlewares = [];
  if (!enableOnlyFloatingStyles) {
    middlewares = [flip3({
      crossAxis: false
    }), hide3()];
  }
  if (menuAlignment === "bottom" || menuAlignment === "top") {
    middlewares.push(size3({
      apply({
        rects,
        elements
      }) {
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }));
  }
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2({
    placement: menuAlignment,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Middleware order matters, arrow should be last
    middleware: middlewares,
    whileElementsMounted: autoUpdate
  });
  const ref = mergeRefs(forwardRef36, containerRef, refs.setReference);
  const {
    open: open2,
    handleClick: hookOnClick,
    handleMousedown: handleTriggerMousedown,
    handleClose
  } = useAttachedMenu(containerRef);
  (0, import_react73.useLayoutEffect)(() => {
    var _a;
    const updatedFloatingStyles = {
      ...floatingStyles,
      visibility: ((_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden) ? "hidden" : "visible"
    };
    Object.keys(updatedFloatingStyles).forEach((style) => {
      if (refs.floating.current) {
        refs.floating.current.style[style] = updatedFloatingStyles[style];
      }
    });
  }, [floatingStyles, refs.floating, middlewareData, placement, open2]);
  function handleTriggerClick() {
    if (containerRef.current) {
      hookOnClick();
    }
  }
  function handlePrimaryActionClick(e2) {
    if (onClick) {
      onClick(e2);
    }
  }
  const containerClasses = (0, import_classnames39.default)(`${prefix}--combo-button__container`, `${prefix}--combo-button__container--${size$1}`, {
    [`${prefix}--combo-button__container--open`]: open2
  }, className);
  const menuClasses = (0, import_classnames39.default)(`${prefix}--combo-button__${menuAlignment}`);
  const primaryActionClasses = (0, import_classnames39.default)(`${prefix}--combo-button__primary-action`);
  const triggerClasses = (0, import_classnames39.default)(`${prefix}--combo-button__trigger`);
  return import_react73.default.createElement("div", _extends({}, rest, {
    className: containerClasses,
    ref,
    "aria-owns": open2 ? id : void 0
  }), import_react73.default.createElement("div", {
    className: primaryActionClasses
  }, import_react73.default.createElement(Button, {
    title: label,
    size: size$1,
    disabled,
    onClick: handlePrimaryActionClick
  }, label)), import_react73.default.createElement(IconButton, {
    ref: refs.setReference,
    className: triggerClasses,
    label: t3("carbon.combo-button.additional-actions"),
    size: size$1,
    disabled,
    align: tooltipAlignment,
    "aria-haspopup": true,
    "aria-expanded": open2,
    onClick: handleTriggerClick,
    onMouseDown: handleTriggerMousedown,
    "aria-controls": open2 ? id : void 0
  }, _ChevronDown2 || (_ChevronDown2 = import_react73.default.createElement(ChevronDown, null))), import_react73.default.createElement(Menu2, {
    containerRef,
    menuAlignment,
    className: menuClasses,
    ref: refs.setFloating,
    id,
    label: t3("carbon.combo-button.additional-actions"),
    size: size$1,
    open: open2,
    onClose: handleClose
  }, children));
});
ComboButton.propTypes = {
  /**
   * A collection of MenuItems to be rendered as additional actions for this ComboButton.
   */
  children: import_prop_types48.default.node.isRequired,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types48.default.string,
  /**
   * Specify whether the ComboButton should be disabled, or not.
   */
  disabled: import_prop_types48.default.bool,
  /**
   * Provide the label to be rendered on the primary action button.
   */
  label: import_prop_types48.default.string.isRequired,
  /**
   * Experimental property. Specify how the menu should align with the button element
   */
  menuAlignment: import_prop_types48.default.oneOf(["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"]),
  /**
   * Provide an optional function to be called when the primary action element is clicked.
   */
  onClick: import_prop_types48.default.func,
  /**
   * Specify the size of the buttons and menu.
   */
  size: import_prop_types48.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify how the trigger tooltip should be aligned.
   */
  tooltipAlignment: deprecateValuesWithin(import_prop_types48.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * Optional method that takes in a message id and returns an
   * internationalized string.
   */
  translateWithId: import_prop_types48.default.func
};

// node_modules/@carbon/react/es/components/ComposedModal/ComposedModal.js
var import_react82 = __toESM(require_react());
var import_react_is2 = __toESM(require_react_is2());
var import_prop_types55 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/components/Layer/index.js
var import_react76 = __toESM(require_react());
var import_prop_types49 = __toESM(require_prop_types());
var import_classnames40 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Layer/LayerContext.js
var import_react75 = __toESM(require_react());
var LayerContext = import_react75.default.createContext(1);

// node_modules/@carbon/react/es/components/Layer/LayerLevel.js
var levels = ["one", "two", "three"];
var LayerLevels = [0, 1, 2];
var MIN_LEVEL = LayerLevels[0];
var MAX_LEVEL = LayerLevels[LayerLevels.length - 1];

// node_modules/@carbon/react/es/internal/clamp.js
var clamp2 = (num, min2, max2) => Math.min(max2, Math.max(min2, num));

// node_modules/@carbon/react/es/components/Layer/index.js
function useLayer() {
  const level = import_react76.default.useContext(LayerContext);
  return {
    level
  };
}
var Layer = import_react76.default.forwardRef((props, ref) => {
  const {
    as,
    className: customClassName,
    children,
    level: overrideLevel,
    withBackground = false,
    ...rest
  } = props;
  const contextLevel = import_react76.default.useContext(LayerContext);
  const level = overrideLevel ?? contextLevel;
  const prefix = usePrefix();
  const className = (0, import_classnames40.default)(`${prefix}--layer-${levels[level]}`, {
    [`${prefix}--layer__with-background`]: withBackground
  }, customClassName);
  const value = clamp2(level + 1, MIN_LEVEL, MAX_LEVEL);
  const BaseComponent = as || "div";
  return import_react76.default.createElement(LayerContext.Provider, {
    value
  }, import_react76.default.createElement(BaseComponent, _extends({
    ref
  }, rest, {
    className
  }), children));
});
Layer.displayName = "Layer";
Layer.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types49.default.oneOfType([import_prop_types49.default.func, import_prop_types49.default.string, import_prop_types49.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `Theme`
   */
  children: import_prop_types49.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types49.default.string,
  /**
   * Specify the layer level and override any existing levels based on hierarchy
   */
  level: import_prop_types49.default.oneOf([0, 1, 2]),
  /**
   * Applies a css background-color set to $layer-background
   */
  withBackground: import_prop_types49.default.bool
};

// node_modules/@carbon/react/es/components/ComposedModal/ModalHeader.js
var import_react77 = __toESM(require_react());
var import_prop_types50 = __toESM(require_prop_types());
var import_classnames41 = __toESM(require_classnames());
var ModalHeader = import_react77.default.forwardRef(function ModalHeader2({
  buttonOnClick,
  children,
  className: customClassName,
  closeClassName,
  closeIconClassName,
  closeModal,
  iconDescription = "Close",
  label,
  labelClassName,
  title,
  titleClassName,
  ...rest
}, ref) {
  const prefix = usePrefix();
  function handleCloseButtonClick(evt) {
    closeModal == null ? void 0 : closeModal(evt);
    buttonOnClick == null ? void 0 : buttonOnClick(evt);
  }
  const headerClass = (0, import_classnames41.default)(`${prefix}--modal-header`, customClassName);
  const labelClass = (0, import_classnames41.default)(`${prefix}--modal-header__label ${prefix}--type-delta`, labelClassName);
  const titleClass = (0, import_classnames41.default)(`${prefix}--modal-header__heading ${prefix}--type-beta`, titleClassName);
  const closeClass = (0, import_classnames41.default)(`${prefix}--modal-close`, closeClassName);
  const closeIconClass = (0, import_classnames41.default)(`${prefix}--modal-close__icon`, closeIconClassName);
  return import_react77.default.createElement("div", _extends({
    className: headerClass
  }, rest, {
    ref
  }), label && import_react77.default.createElement("h2", {
    className: labelClass
  }, label), title && import_react77.default.createElement("h2", {
    className: titleClass
  }, title), children, import_react77.default.createElement("div", {
    className: `${prefix}--modal-close-button`
  }, import_react77.default.createElement(IconButton, {
    className: closeClass,
    label: iconDescription,
    onClick: handleCloseButtonClick,
    "aria-label": iconDescription,
    align: "left"
  }, import_react77.default.createElement(Close, {
    size: 20,
    "aria-hidden": "true",
    tabIndex: "-1",
    className: closeIconClass
  }))));
});
ModalHeader.propTypes = {
  /**
   * Provide an optional function to be called when the close button is
   * clicked
   */
  buttonOnClick: import_prop_types50.default.func,
  /**
   * Specify the content to be placed in the ModalHeader
   */
  children: import_prop_types50.default.node,
  /**
   * Specify an optional className to be applied to the modal header
   */
  className: import_prop_types50.default.string,
  /**
   * Specify an optional className to be applied to the modal close node
   */
  closeClassName: import_prop_types50.default.string,
  /**
   * Specify an optional className to be applied to the modal close icon node
   */
  closeIconClassName: import_prop_types50.default.string,
  /**
   * Provide an optional function to be called when the modal is closed
   */
  closeModal: import_prop_types50.default.func,
  /**
   * Specify a description for the close icon that can be read by screen
   * readers
   */
  iconDescription: import_prop_types50.default.string,
  /**
   * Specify an optional label to be displayed
   */
  label: import_prop_types50.default.node,
  /**
   * Specify an optional className to be applied to the modal header label
   */
  labelClassName: import_prop_types50.default.string,
  /**
   * Specify an optional title to be displayed
   */
  title: import_prop_types50.default.node,
  /**
   * Specify an optional className to be applied to the modal heading
   */
  titleClassName: import_prop_types50.default.string
};

// node_modules/@carbon/react/es/components/ComposedModal/ModalFooter.js
var import_react80 = __toESM(require_react());
var import_prop_types53 = __toESM(require_prop_types());
var import_classnames44 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/InlineLoading/InlineLoading.js
var import_react79 = __toESM(require_react());
var import_prop_types52 = __toESM(require_prop_types());
var import_classnames43 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Loading/Loading.js
var import_classnames42 = __toESM(require_classnames());
var import_prop_types51 = __toESM(require_prop_types());
var import_react78 = __toESM(require_react());
function Loading({
  active = true,
  className: customClassName,
  withOverlay = true,
  small = false,
  description = "loading",
  ...rest
}) {
  const prefix = usePrefix();
  const loadingClassName = (0, import_classnames42.default)(customClassName, {
    [`${prefix}--loading`]: true,
    [`${prefix}--loading--small`]: small,
    [`${prefix}--loading--stop`]: !active
  });
  const overlayClassName = (0, import_classnames42.default)({
    [`${prefix}--loading-overlay`]: true,
    [`${prefix}--loading-overlay--stop`]: !active
  });
  const loading = import_react78.default.createElement("div", _extends({}, rest, {
    "aria-atomic": "true",
    "aria-live": active ? "assertive" : "off",
    className: loadingClassName
  }), import_react78.default.createElement("svg", {
    className: `${prefix}--loading__svg`,
    viewBox: "0 0 100 100"
  }, import_react78.default.createElement("title", null, description), small ? import_react78.default.createElement("circle", {
    className: `${prefix}--loading__background`,
    cx: "50%",
    cy: "50%",
    r: "42"
  }) : null, import_react78.default.createElement("circle", {
    className: `${prefix}--loading__stroke`,
    cx: "50%",
    cy: "50%",
    r: small ? "42" : "44"
  })));
  return withOverlay ? import_react78.default.createElement("div", {
    className: overlayClassName
  }, loading) : loading;
}
Loading.propTypes = {
  /**
   * Specify whether you want the loading indicator to be spinning or not
   */
  active: import_prop_types51.default.bool,
  /**
   * Provide an optional className to be applied to the containing node
   */
  className: import_prop_types51.default.string,
  /**
   * Specify a description that would be used to best describe the loading state
   */
  description: import_prop_types51.default.string,
  /**
   * Provide an `id` to uniquely identify the label
   */
  id: deprecate(import_prop_types51.default.string, `
The prop \`id\` is no longer needed.`),
  /**
   * Specify whether you would like the small variant of <Loading>
   */
  small: import_prop_types51.default.bool,
  /**
   * Specify whether you want the loader to be applied with an overlay
   */
  withOverlay: import_prop_types51.default.bool
};

// node_modules/@carbon/react/es/components/InlineLoading/InlineLoading.js
var InlineLoading = ({
  className,
  status = "active",
  iconDescription,
  description,
  onSuccess,
  successDelay = 1500,
  ...rest
}) => {
  const prefix = usePrefix();
  const loadingClasses = (0, import_classnames43.default)(`${prefix}--inline-loading`, className);
  const timerRef = (0, import_react79.useRef)(null);
  (0, import_react79.useEffect)(() => {
    if (status === "finished") {
      timerRef.current = setTimeout(() => {
        if (onSuccess) {
          onSuccess();
        }
      }, successDelay);
    }
    return () => {
      if (timerRef.current) {
        clearTimeout(timerRef.current);
        timerRef.current = null;
      }
    };
  }, [status, onSuccess, successDelay]);
  const getLoading = () => {
    let iconLabel = iconDescription ? iconDescription : status;
    if (status === "error") {
      return import_react79.default.createElement(ErrorFilled, {
        className: `${prefix}--inline-loading--error`
      }, import_react79.default.createElement("title", null, iconLabel));
    }
    if (status === "finished") {
      return import_react79.default.createElement(CheckmarkFilled, {
        className: `${prefix}--inline-loading__checkmark-container`
      }, import_react79.default.createElement("title", null, iconLabel));
    }
    if (status === "active") {
      if (!iconDescription) {
        iconLabel = "loading";
      }
      return import_react79.default.createElement(Loading, {
        small: true,
        description: iconLabel,
        withOverlay: false,
        active: status === "active"
      });
    }
    if (status === "inactive") {
      if (!iconDescription) {
        iconLabel = "not loading";
      }
      return import_react79.default.createElement("title", {
        className: `${prefix}--inline-loading__inactive-status`
      }, iconLabel);
    }
    return void 0;
  };
  const loadingText = description && import_react79.default.createElement("div", {
    className: `${prefix}--inline-loading__text`
  }, description);
  const loading = getLoading();
  const loadingAnimation = loading && import_react79.default.createElement("div", {
    className: `${prefix}--inline-loading__animation`
  }, loading);
  return import_react79.default.createElement("div", _extends({
    className: loadingClasses
  }, rest, {
    "aria-live": rest["aria-live"] ?? "assertive"
  }), loadingAnimation, loadingText);
};
InlineLoading.propTypes = {
  /**
   * Specify a custom className to be applied to the container node
   */
  className: import_prop_types52.default.string,
  /**
   * Specify the description for the inline loading text
   */
  description: import_prop_types52.default.node,
  /**
   * Specify the description for the inline loading text
   */
  iconDescription: import_prop_types52.default.string,
  /**
   * Provide an optional handler to be invoked when <InlineLoading> is
   * successful
   */
  onSuccess: import_prop_types52.default.func,
  /**
   * Specify the loading status
   */
  status: import_prop_types52.default.oneOf(["inactive", "active", "finished", "error"]),
  /**
   * Provide a delay for the `setTimeout` for success
   */
  successDelay: import_prop_types52.default.number
};

// node_modules/@carbon/react/es/components/ComposedModal/ModalFooter.js
function SecondaryButtonSet({
  secondaryButtons,
  secondaryButtonText,
  secondaryClassName,
  closeModal,
  onRequestClose,
  disabled
}) {
  function handleRequestClose(evt) {
    closeModal(evt);
    onRequestClose(evt);
  }
  if (Array.isArray(secondaryButtons) && secondaryButtons.length <= 2) {
    return import_react80.default.createElement(import_react80.default.Fragment, null, secondaryButtons.map(({
      buttonText,
      onClick: onButtonClick
    }, i) => import_react80.default.createElement(Button, {
      key: `${buttonText}-${i}`,
      className: secondaryClassName,
      kind: "secondary",
      onClick: onButtonClick || handleRequestClose
    }, buttonText)));
  }
  if (secondaryButtonText) {
    return import_react80.default.createElement(Button, {
      disabled,
      className: secondaryClassName,
      onClick: handleRequestClose,
      kind: "secondary"
    }, secondaryButtonText);
  }
  return null;
}
SecondaryButtonSet.propTypes = {
  closeModal: import_prop_types53.default.func,
  disabled: import_prop_types53.default.bool,
  onRequestClose: import_prop_types53.default.func,
  secondaryButtonText: import_prop_types53.default.string,
  secondaryButtons: (props, propName, componentName) => {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error(`${propName} needs to be an array of two button config objects`);
      }
      const shape = {
        buttonText: import_prop_types53.default.node,
        onClick: import_prop_types53.default.func
      };
      props[propName].forEach((secondaryButton) => {
        import_prop_types53.default.checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }
    return null;
  },
  secondaryClassName: import_prop_types53.default.string
};
var ModalFooter = import_react80.default.forwardRef(function ModalFooter2({
  children,
  className: customClassName,
  closeModal = noopFn,
  danger,
  inputref,
  onRequestClose = noopFn,
  onRequestSubmit = noopFn,
  primaryButtonDisabled,
  primaryButtonText,
  primaryClassName,
  secondaryButtonText,
  secondaryButtons,
  secondaryClassName,
  loadingStatus = "inactive",
  loadingDescription,
  loadingIconDescription,
  onLoadingSuccess = noopFn,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const footerClass = (0, import_classnames44.default)(`${prefix}--modal-footer`, customClassName, Array.isArray(secondaryButtons) && secondaryButtons.length === 2 ? `${prefix}--modal-footer--three-button` : null);
  const primaryButtonClass = (0, import_classnames44.default)(primaryClassName, loadingStatus !== "inactive" ? `${prefix}--btn--loading` : null);
  const loadingActive = loadingStatus !== "inactive";
  const secondaryButtonProps = {
    closeModal,
    secondaryButtons,
    secondaryButtonText,
    secondaryClassName,
    onRequestClose,
    disabled: loadingActive
  };
  return import_react80.default.createElement(ButtonSet, _extends({
    className: footerClass
  }, rest, {
    // @ts-expect-error: Invalid derived types, will be fine once explicit types are added
    ref,
    "aria-busy": loadingActive
  }), import_react80.default.createElement(SecondaryButtonSet, secondaryButtonProps), primaryButtonText && import_react80.default.createElement(Button, {
    onClick: onRequestSubmit,
    className: primaryButtonClass,
    disabled: loadingActive || primaryButtonDisabled,
    kind: danger ? "danger" : "primary",
    ref: inputref
  }, loadingStatus === "inactive" ? primaryButtonText : import_react80.default.createElement(InlineLoading, {
    status: loadingStatus,
    description: loadingDescription,
    iconDescription: loadingIconDescription,
    className: `${prefix}--inline-loading--btn`,
    onSuccess: onLoadingSuccess
  })), children);
});
ModalFooter.propTypes = {
  /**
   * Pass in content that will be rendered in the Modal Footer
   */
  children: import_prop_types53.default.node,
  /**
   * Specify a custom className to be applied to the Modal Footer container
   */
  className: import_prop_types53.default.string,
  /**
   * Specify an optional function that is called whenever the modal is closed
   */
  closeModal: import_prop_types53.default.func,
  /**
   * Specify whether the primary button should be replaced with danger button.
   * Note that this prop is not applied if you render primary/danger button by yourself
   */
  danger: import_prop_types53.default.bool,
  /**
   * The `ref` callback for the primary button.
   */
  inputref: import_prop_types53.default.oneOfType([import_prop_types53.default.func, import_prop_types53.default.shape({
    current: import_prop_types53.default.any
  })]),
  /**
   * Specify the description for the loading text
   */
  loadingDescription: import_prop_types53.default.string,
  /**
   * Specify the description for the loading text
   */
  loadingIconDescription: import_prop_types53.default.string,
  /**
   * loading status
   */
  loadingStatus: import_prop_types53.default.oneOf(["inactive", "active", "finished", "error"]),
  /**
   * Provide an optional handler to be invoked when loading is
   * successful
   */
  onLoadingSuccess: import_prop_types53.default.func,
  /**
   * Specify an optional function for when the modal is requesting to be
   * closed
   */
  onRequestClose: import_prop_types53.default.func,
  /**
   * Specify an optional function for when the modal is requesting to be
   * submitted
   */
  onRequestSubmit: import_prop_types53.default.func,
  /**
   * Specify whether the primary button should be disabled
   */
  primaryButtonDisabled: import_prop_types53.default.bool,
  /**
   * Specify the text for the primary button
   */
  primaryButtonText: import_prop_types53.default.string,
  /**
   * Specify a custom className to be applied to the primary button
   */
  primaryClassName: import_prop_types53.default.string,
  /**
   * Specify the text for the secondary button
   */
  secondaryButtonText: import_prop_types53.default.string,
  /**
   * Specify an array of config objects for secondary buttons
   * (`Array<{
   *   buttonText: string,
   *   onClick: function,
   * }>`).
   */
  secondaryButtons: (props, propName, componentName) => {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error(`${propName} needs to be an array of two button config objects`);
      }
      const shape = {
        buttonText: import_prop_types53.default.node,
        onClick: import_prop_types53.default.func
      };
      props[propName].forEach((secondaryButton) => {
        import_prop_types53.default.checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }
    return null;
  },
  /**
   * Specify a custom className to be applied to the secondary button
   */
  secondaryClassName: import_prop_types53.default.string
};

// node_modules/@carbon/react/es/components/ComposedModal/ComposedModal.js
var import_classnames46 = __toESM(require_classnames());

// node_modules/@carbon/react/es/tools/toggleClass.js
var toggleClass = (element, className, add) => {
  element.classList.toggle(className, add);
};

// node_modules/@carbon/react/es/prop-types/requiredIfGivenPropIsTruthy.js
function requiredIfGivenPropIsTruthy(name, propType) {
  return function check(props, propName, componentName, ...rest) {
    if (props[name] == true && props[propName] == null) {
      return new Error(`You must provide a value for \`${propName}\` in \`${componentName}\` if \`${name}\` exists.`);
    }
    return propType(props, propName, componentName, ...rest);
  };
}

// node_modules/@carbon/react/es/internal/keyboard/navigation.js
var getNextIndex = (key, index3, arrayLength) => {
  if (match(key, ArrowRight2)) {
    return (index3 + 1) % arrayLength;
  }
  if (match(key, ArrowLeft)) {
    return (index3 + arrayLength - 1) % arrayLength;
  }
  return;
};
var selectorTabbable = `
  a[href], area[href], input:not([disabled]):not([tabindex='-1']),
  button:not([disabled]):not([tabindex='-1']),select:not([disabled]):not([tabindex='-1']),
  textarea:not([disabled]):not([tabindex='-1']),
  iframe, object, embed, *[tabindex]:not([tabindex='-1']):not([disabled]), *[contenteditable=true]
`;
var selectorFocusable = `
  a[href], area[href], input:not([disabled]),
  button:not([disabled]),select:not([disabled]),
  textarea:not([disabled]),
  iframe, object, embed, *[tabindex]:not([disabled]), *[contenteditable=true]
`;

// node_modules/@carbon/react/es/internal/wrapFocus.js
var DOCUMENT_POSITION_BROAD_PRECEDING = typeof Node !== "undefined" ? Node.DOCUMENT_POSITION_PRECEDING | Node.DOCUMENT_POSITION_CONTAINS : 0;
var DOCUMENT_POSITION_BROAD_FOLLOWING = typeof Node !== "undefined" ? Node.DOCUMENT_POSITION_FOLLOWING | Node.DOCUMENT_POSITION_CONTAINED_BY : 0;
var elementOrParentIsFloatingMenu = (node, selectorsFloatingMenus = []) => {
  if (node instanceof Element && typeof node.closest === "function") {
    const allSelectorsFloatingMenus = [".cds--overflow-menu-options", ".cds--tooltip", ".flatpickr-calendar", ...selectorsFloatingMenus];
    return allSelectorsFloatingMenus.some((selector) => !!node.closest(selector));
  }
  return false;
};
var wrapFocus = ({
  bodyNode,
  startTrapNode,
  endTrapNode,
  currentActiveNode,
  oldActiveNode,
  selectorsFloatingMenus
}) => {
  if (bodyNode && currentActiveNode && oldActiveNode && !bodyNode.contains(currentActiveNode) && !elementOrParentIsFloatingMenu(currentActiveNode, selectorsFloatingMenus)) {
    const comparisonResult = oldActiveNode.compareDocumentPosition(currentActiveNode);
    if (currentActiveNode === startTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_PRECEDING) {
      const tabbableElement = Array.from(bodyNode.querySelectorAll(selectorTabbable)).reverse().find(({
        offsetParent
      }) => Boolean(offsetParent));
      if (tabbableElement) {
        tabbableElement.focus();
      } else if (bodyNode !== oldActiveNode) {
        bodyNode.focus();
      }
    } else if (currentActiveNode === endTrapNode || comparisonResult & DOCUMENT_POSITION_BROAD_FOLLOWING) {
      const tabbableElement = Array.from(bodyNode.querySelectorAll(selectorTabbable)).find(({
        offsetParent
      }) => Boolean(offsetParent));
      if (tabbableElement) {
        tabbableElement.focus();
      } else if (bodyNode !== oldActiveNode) {
        bodyNode.focus();
      }
    }
  }
};
var wrapFocusWithoutSentinels = ({
  containerNode,
  currentActiveNode,
  event
}) => {
  if (!containerNode) return;
  if (["blur", "focusout", "focusin", "focus"].includes(event.type) && true) {
    throw new Error(`Error: wrapFocusWithoutSentinels(...) called in unsupported ${event.type} event.

Call wrapFocusWithoutSentinels(...) from onKeyDown instead.`);
  }
  const tabbables = tabbable(containerNode);
  const firstTabbable = tabbables[0];
  const lastTabbable = tabbables[tabbables.length - 1];
  if (currentActiveNode === lastTabbable && !event.shiftKey) {
    event.preventDefault();
    firstTabbable.focus();
  }
  if (currentActiveNode === firstTabbable && event.shiftKey) {
    event.preventDefault();
    lastTabbable.focus();
  }
};

// node_modules/@carbon/react/es/components/Dialog/Dialog.js
var import_prop_types54 = __toESM(require_prop_types());
var import_react81 = __toESM(require_react());
var import_classnames45 = __toESM(require_classnames());
var DialogContext = (0, import_react81.createContext)({});
var Dialog = import_react81.default.forwardRef(({
  children,
  className,
  focusAfterCloseRef,
  modal,
  onCancel = noopFn,
  onClick = noopFn,
  onClose = noopFn,
  onRequestClose = noopFn,
  open: open2 = false,
  role,
  ariaLabel,
  ariaLabelledBy,
  ariaDescribedBy,
  ...rest
}, forwardRef36) => {
  const prefix = usePrefix();
  const dialogId = useId();
  const titleId = `${prefix}--dialog-header__heading--${dialogId}`;
  const subtitleId = `${prefix}--dialog-header__label--${dialogId}`;
  const backupRef = (0, import_react81.useRef)(null);
  const ref = forwardRef36 ?? backupRef;
  function handleModalBackdropClick(e2) {
    if (open2 && modal && e2.target === ref.current) {
      onRequestClose(e2);
    }
  }
  function handleClick2(e2) {
    handleModalBackdropClick(e2);
    onClick(e2);
  }
  (0, import_react81.useEffect)(() => {
    if (ref.current) {
      if (open2) {
        if (modal) {
          ref.current.showModal();
        } else {
          ref.current.show();
        }
      } else {
        ref.current.close();
      }
    }
  }, [modal, open2]);
  (0, import_react81.useEffect)(() => {
    if (!open2 && focusAfterCloseRef) {
      const moveFocus = setTimeout(() => {
        var _a;
        (_a = focusAfterCloseRef.current) == null ? void 0 : _a.focus();
      });
      return () => {
        clearTimeout(moveFocus);
      };
    }
  }, [open2, focusAfterCloseRef]);
  const containerClasses = (0, import_classnames45.default)(`${prefix}--dialog-container`);
  const contextValue = {
    dialogId,
    titleId,
    subtitleId,
    isOpen: open2
  };
  (0, import_react81.useEffect)(() => {
    if (ref.current && open2 && !ariaLabel && !ariaLabelledBy) {
      const title = ref.current.querySelector(`.${prefix}--dialog-header__heading`);
      if (title && title.id) {
        ref.current.setAttribute("aria-labelledby", title.id);
      }
    }
  }, [open2, ariaLabel, ariaLabelledBy, prefix]);
  return import_react81.default.createElement(DialogContext.Provider, {
    value: contextValue
  }, import_react81.default.createElement("dialog", _extends({}, rest, {
    className: (0, import_classnames45.default)(`${prefix}--dialog`, {
      [`${prefix}--dialog--modal`]: modal
    }, className),
    ref,
    onCancel,
    onClick: handleClick2,
    onClose,
    role,
    "aria-label": ariaLabel,
    "aria-labelledby": !ariaLabel ? ariaLabelledBy || titleId : void 0,
    "aria-describedby": ariaDescribedBy
  }), import_react81.default.createElement("div", {
    className: containerClasses
  }, children)));
});
Dialog.displayName = "Dialog";
Dialog.propTypes = {
  /**
   * Provide children to be rendered inside of the Dialog
   */
  children: import_prop_types54.default.node,
  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: import_prop_types54.default.string,
  /**
   * Provide a ref to return focus to once the dialog is closed.
   */
  focusAfterCloseRef: import_prop_types54.default.oneOfType([import_prop_types54.default.func, import_prop_types54.default.shape({
    current: import_prop_types54.default.any
  })]),
  /**
   * Modal specifies whether the Dialog is modal or non-modal. This cannot be
   * changed while open=true
   */
  modal: import_prop_types54.default.bool,
  /**
   * Specify a handler for closing Dialog.
   * The handler should care of closing Dialog, e.g. changing `open` prop.
   */
  onRequestClose: import_prop_types54.default.func,
  /**
   * open initial state
   */
  open: import_prop_types54.default.bool,
  /**
   * Specify the role of the dialog for accessibility
   */
  role: import_prop_types54.default.oneOf(["dialog", "alertdialog"]),
  /**
   * Specify a label for screen readers
   */
  "aria-label": import_prop_types54.default.string,
  /**
   * Specify the ID of an element that labels this dialog
   */
  "aria-labelledby": import_prop_types54.default.string,
  /**
   * Specify the ID of an element that describes this dialog
   */
  ariaDescribedBy: import_prop_types54.default.string
};
var DialogHeader = import_react81.default.forwardRef(({
  children,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  return import_react81.default.createElement("div", _extends({
    className: `${prefix}--dialog__header`,
    ref
  }, rest), children);
});
DialogHeader.displayName = "DialogHeader";
DialogHeader.propTypes = {
  /**
   * Provide the contents to be rendered inside of this component
   */
  children: import_prop_types54.default.node
};
var DialogControls = import_react81.default.forwardRef(({
  children,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  return (
    // @ts-ignore
    import_react81.default.createElement("div", _extends({
      className: `${prefix}--dialog__header-controls`,
      ref
    }, rest), children)
  );
});
DialogControls.displayName = "DialogControls";
DialogControls.propTypes = {
  /**
   * Provide children to be rendered inside of this component
   */
  children: import_prop_types54.default.node
};
var DialogCloseButton = import_react81.default.forwardRef(({
  onClick,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  return (
    // @ts-ignore
    import_react81.default.createElement(IconButton, _extends({
      kind: "ghost",
      className: `${prefix}--dialog__close`,
      label: "Close",
      title: "Close",
      "aria-label": "Close",
      align: "left",
      onClick,
      ref
    }, rest), import_react81.default.createElement(Close, {
      size: 20,
      "aria-hidden": "true",
      tabIndex: -1,
      className: `${prefix}--icon__close`
    }))
  );
});
DialogCloseButton.displayName = "DialogCloseButton";
DialogCloseButton.propTypes = {
  /**
   * Specify a click handler applied to the IconButton
   */
  onClick: import_prop_types54.default.func
};
var DialogTitle = import_react81.default.forwardRef(({
  children,
  className,
  id,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const {
    titleId
  } = (0, import_react81.useContext)(DialogContext);
  const headingId = id || titleId;
  return import_react81.default.createElement(Text, _extends({
    as: "h2",
    id: headingId,
    className: (0, import_classnames45.default)(`${prefix}--dialog-header__heading`, className),
    ref
  }, rest), children);
});
DialogTitle.displayName = "DialogTitle";
DialogTitle.propTypes = {
  /**
   * Provide the contents to be rendered inside of this component
   */
  children: import_prop_types54.default.node,
  /**
   * Specify an optional className to be applied to the title node
   */
  className: import_prop_types54.default.string,
  /**
   * Specify an optional id for the title element
   */
  id: import_prop_types54.default.string
};
var DialogSubtitle = import_react81.default.forwardRef(({
  children,
  className,
  id,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const {
    subtitleId
  } = (0, import_react81.useContext)(DialogContext);
  const labelId = id || subtitleId;
  return import_react81.default.createElement(Text, _extends({
    as: "h2",
    id: labelId,
    className: (0, import_classnames45.default)(`${prefix}--dialog-header__label`, className),
    ref
  }, rest), children);
});
DialogSubtitle.displayName = "DialogSubtitle";
DialogSubtitle.propTypes = {
  /**
   * Provide the contents to be rendered inside of this component
   */
  children: import_prop_types54.default.node,
  /**
   * Specify an optional className to be applied to the subtitle node
   */
  className: import_prop_types54.default.string,
  /**
   * Specify an optional id for the subtitle element
   */
  id: import_prop_types54.default.string
};
var DialogBody = import_react81.default.forwardRef(({
  children,
  className,
  hasScrollingContent,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const contentRef = (0, import_react81.useRef)(null);
  const [isScrollable, setIsScrollable] = (0, import_react81.useState)(false);
  const dialogId = useId();
  const dialogBodyId = `${prefix}--dialog-body--${dialogId}`;
  useIsomorphicEffect(() => {
    if (contentRef.current) {
      setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
    }
    function handler() {
      if (contentRef.current) {
        setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
      }
    }
    const debouncedHandler = debounce2(handler, 200);
    window.addEventListener("resize", debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener("resize", debouncedHandler);
    };
  }, []);
  const contentClasses = (0, import_classnames45.default)(`${prefix}--dialog-content`, {
    [`${prefix}--dialog-scroll-content`]: hasScrollingContent || isScrollable
  }, className);
  const hasScrollingContentProps = hasScrollingContent || isScrollable ? {
    tabIndex: 0,
    role: "region"
  } : {};
  const combinedRef = (el) => {
    if (typeof ref === "function") {
      ref(el);
    } else if (ref) {
      ref.current = el;
    }
    contentRef.current = el;
  };
  return import_react81.default.createElement(Layer, _extends({
    ref: combinedRef,
    id: dialogBodyId,
    className: contentClasses
  }, hasScrollingContentProps, rest), children);
});
DialogBody.displayName = "DialogBody";
DialogBody.propTypes = {
  /**
   * Provide the contents to be rendered inside of this component
   */
  children: import_prop_types54.default.node,
  /**
   * Specify an optional className to be applied to the body node
   */
  className: import_prop_types54.default.string,
  /**
   * Specify whether the content has overflow that should be scrollable
   */
  hasScrollingContent: import_prop_types54.default.bool
};
var DialogFooter = import_react81.default.forwardRef(({
  children,
  className,
  onRequestClose = noopFn,
  onSecondarySubmit,
  onRequestSubmit = noopFn,
  primaryButtonText = "Save",
  primaryButtonDisabled = false,
  secondaryButtonText = "Cancel",
  secondaryButtons,
  loadingStatus = "inactive",
  loadingDescription,
  loadingIconDescription,
  onLoadingSuccess = noopFn,
  danger = false,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const button = (0, import_react81.useRef)(null);
  const {
    isOpen
  } = (0, import_react81.useContext)(DialogContext);
  const [secondaryButtonRef, setSecondaryButtonRef] = (0, import_react81.useState)(null);
  (0, import_react81.useEffect)(() => {
    if (danger && secondaryButtonRef) {
      const focusFrame = requestAnimationFrame(() => {
        secondaryButtonRef.focus();
      });
      return () => cancelAnimationFrame(focusFrame);
    }
  }, [danger, secondaryButtonRef, isOpen]);
  const classes = (0, import_classnames45.default)(`${prefix}--dialog-footer`, className, {
    [`${prefix}--dialog-footer--three-button`]: Array.isArray(secondaryButtons) && secondaryButtons.length === 2
  });
  const loadingActive = loadingStatus !== "inactive";
  const primaryButtonClass = (0, import_classnames45.default)({
    [`${prefix}--btn--loading`]: loadingStatus !== "inactive"
  });
  const onSecondaryButtonClick = onSecondarySubmit ? onSecondarySubmit : onRequestClose;
  if (children) {
    return import_react81.default.createElement(ButtonSet, _extends({
      className: classes,
      ref
    }, rest), children);
  }
  return import_react81.default.createElement(ButtonSet, _extends({
    className: classes,
    "aria-busy": loadingActive,
    ref
  }, rest), Array.isArray(secondaryButtons) && secondaryButtons.length <= 2 ? secondaryButtons.map(({
    buttonText,
    onClick: onButtonClick
  }, i) => import_react81.default.createElement(Button, {
    key: `${buttonText}-${i}`,
    autoFocus: danger,
    kind: "secondary",
    ref: i === 0 && danger ? setSecondaryButtonRef : void 0,
    onClick: onButtonClick
  }, buttonText)) : secondaryButtonText && import_react81.default.createElement(Button, {
    ref: danger ? setSecondaryButtonRef : void 0,
    disabled: loadingActive,
    kind: "secondary",
    autoFocus: danger,
    onClick: onSecondaryButtonClick
  }, secondaryButtonText), import_react81.default.createElement(Button, {
    className: primaryButtonClass,
    kind: danger ? "danger" : "primary",
    disabled: loadingActive || primaryButtonDisabled,
    onClick: onRequestSubmit,
    ref: button
  }, loadingStatus === "inactive" ? primaryButtonText : import_react81.default.createElement(InlineLoading, {
    status: loadingStatus,
    description: loadingDescription,
    iconDescription: loadingIconDescription,
    className: `${prefix}--inline-loading--btn`,
    onSuccess: onLoadingSuccess
  })));
});
DialogFooter.displayName = "DialogFooter";
DialogFooter.propTypes = {
  /**
   * Provide the contents to be rendered inside of this component
   */
  children: import_prop_types54.default.node,
  /**
   * Specify an optional className to be applied to the footer node
   */
  className: import_prop_types54.default.string,
  /**
   * Specify a handler for closing dialog.
   */
  onRequestClose: import_prop_types54.default.func,
  /**
   * Specify a handler for the secondary button.
   */
  onSecondarySubmit: import_prop_types54.default.func,
  /**
   * Specify a handler for submitting dialog.
   */
  onRequestSubmit: import_prop_types54.default.func,
  /**
   * Specify the text for the primary button
   */
  primaryButtonText: import_prop_types54.default.node,
  /**
   * Specify whether the Button should be disabled, or not
   */
  primaryButtonDisabled: import_prop_types54.default.bool,
  /**
   * Specify the text for the secondary button
   */
  secondaryButtonText: import_prop_types54.default.node,
  /**
   * Specify an array of config objects for secondary buttons
   */
  secondaryButtons: (props, propName, componentName) => {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error(`${propName} needs to be an array of two button config objects`);
      }
      const shape = {
        buttonText: import_prop_types54.default.node,
        onClick: import_prop_types54.default.func
      };
      props[propName].forEach((secondaryButton) => {
        import_prop_types54.default.checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }
    return null;
  },
  /**
   * Specify whether the Dialog is for dangerous actions
   */
  danger: import_prop_types54.default.bool,
  /**
   * Specify loading status
   */
  loadingStatus: import_prop_types54.default.oneOf(["inactive", "active", "finished", "error"]),
  /**
   * Specify the description for the loading text
   */
  loadingDescription: import_prop_types54.default.string,
  /**
   * Specify the description for the loading icon
   */
  loadingIconDescription: import_prop_types54.default.string,
  /**
   * Provide an optional handler to be invoked when loading is
   * successful
   */
  onLoadingSuccess: import_prop_types54.default.func
};

// node_modules/@carbon/react/es/components/ComposedModal/ComposedModal.js
var ModalBody = import_react82.default.forwardRef(function ModalBody2({
  className: customClassName,
  children,
  hasForm,
  hasScrollingContent,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const contentRef = (0, import_react82.useRef)(null);
  const [isScrollable, setIsScrollable] = (0, import_react82.useState)(false);
  const contentClass = (0, import_classnames46.default)({
    [`${prefix}--modal-content`]: true,
    [`${prefix}--modal-content--with-form`]: hasForm,
    [`${prefix}--modal-scroll-content`]: hasScrollingContent || isScrollable
  }, customClassName);
  useIsomorphicEffect(() => {
    if (contentRef.current) {
      setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
    }
    function handler() {
      if (contentRef.current) {
        setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
      }
    }
    const debouncedHandler = debounce2(handler, 200);
    window.addEventListener("resize", debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener("resize", debouncedHandler);
    };
  }, []);
  const hasScrollingContentProps = hasScrollingContent || isScrollable ? {
    tabIndex: 0,
    role: "region"
  } : {};
  return import_react82.default.createElement(Layer, _extends({
    className: contentClass
  }, hasScrollingContentProps, rest, {
    ref: mergeRefs(contentRef, ref)
  }), children);
});
ModalBody.propTypes = {
  /**
   * Required props for the accessibility label of the header
   */
  ["aria-label"]: requiredIfGivenPropIsTruthy("hasScrollingContent", import_prop_types55.default.string),
  /**
   * Specify the content to be placed in the ModalBody
   */
  children: import_prop_types55.default.node,
  /**
   * Specify an optional className to be added to the Modal Body node
   */
  className: import_prop_types55.default.string,
  /**
   * Provide whether the modal content has a form element.
   * If `true` is used here, non-form child content should have `cds--modal-content__regular-content` class.
   */
  hasForm: import_prop_types55.default.bool,
  /**
   * Specify whether the modal contains scrolling content
   */
  hasScrollingContent: import_prop_types55.default.bool
};
var ComposedModal = import_react82.default.forwardRef(function ComposedModal2({
  ["aria-labelledby"]: ariaLabelledBy,
  ["aria-label"]: ariaLabel,
  children,
  className: customClassName,
  containerClassName,
  danger,
  decorator,
  isFullWidth,
  onClose,
  onKeyDown,
  open: open2,
  preventCloseOnClickOutside,
  selectorPrimaryFocus = "[data-modal-primary-focus]",
  selectorsFloatingMenus,
  size: size4,
  launcherButtonRef,
  slug,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const [isOpen, setIsOpen] = (0, import_react82.useState)(!!open2);
  const [wasOpen, setWasOpen] = (0, import_react82.useState)(!!open2);
  const innerModal = (0, import_react82.useRef)(null);
  const button = (0, import_react82.useRef)(null);
  const startSentinel = (0, import_react82.useRef)(null);
  const endSentinel = (0, import_react82.useRef)(null);
  const onMouseDownTarget = (0, import_react82.useRef)(null);
  const enableDialogElement = useFeatureFlag("enable-dialog-element");
  const focusTrapWithoutSentinels = useFeatureFlag("enable-experimental-focus-wrap-without-sentinels");
  true ? warning(!(focusTrapWithoutSentinels && enableDialogElement), "`<Modal>` detected both `focusTrapWithoutSentinels` and `enableDialogElement` feature flags are enabled. The native dialog element handles focus, so `enableDialogElement` must be off for `focusTrapWithoutSentinels` to have any effect.") : void 0;
  (0, import_react82.useEffect)(() => {
    if (!enableDialogElement && open2 !== wasOpen) {
      setIsOpen(!!open2);
      setWasOpen(!!open2);
      toggleClass(document.body, `${prefix}--body--with-modal-open`, !!open2);
    }
  }, [open2, wasOpen, prefix]);
  (0, import_react82.useEffect)(() => {
    if (!enableDialogElement) {
      return () => {
        toggleClass(document.body, `${prefix}--body--with-modal-open`, false);
      };
    }
  }, []);
  function handleKeyDown(event) {
    if (!enableDialogElement) {
      if (focusTrapWithoutSentinels && open2 && match(event, Tab) && innerModal.current) {
        wrapFocusWithoutSentinels({
          containerNode: innerModal.current,
          currentActiveNode: event.target,
          event
        });
      }
    }
    onKeyDown == null ? void 0 : onKeyDown(event);
  }
  function handleOnMouseDown(evt) {
    const target = evt.target;
    onMouseDownTarget.current = target;
  }
  function handleOnClick(evt) {
    const {
      target
    } = evt;
    const mouseDownTarget = onMouseDownTarget.current;
    evt.stopPropagation();
    const containsModalFooter = import_react82.Children.toArray(childrenWithProps).some((child) => isComponentElement(child, ModalFooter));
    const isPassive = !containsModalFooter;
    const shouldCloseOnOutsideClick = isPassive ? preventCloseOnClickOutside !== false : preventCloseOnClickOutside === true;
    if (shouldCloseOnOutsideClick && target instanceof Node && !elementOrParentIsFloatingMenu(target, selectorsFloatingMenus) && innerModal.current && !innerModal.current.contains(target) && !innerModal.current.contains(mouseDownTarget)) {
      closeModal(evt);
    }
  }
  function handleBlur({
    target: oldActiveNode,
    relatedTarget: currentActiveNode
  }) {
    if (!enableDialogElement && !focusTrapWithoutSentinels && open2 && currentActiveNode && oldActiveNode && innerModal.current) {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startSentinelNode
      } = startSentinel;
      const {
        current: endSentinelNode
      } = endSentinel;
      wrapFocus({
        bodyNode,
        startTrapNode: startSentinelNode,
        endTrapNode: endSentinelNode,
        currentActiveNode,
        oldActiveNode,
        selectorsFloatingMenus: selectorsFloatingMenus == null ? void 0 : selectorsFloatingMenus.filter(Boolean)
      });
    }
    const modalContent = document.querySelector(`.${prefix}--modal-content`);
    if (!modalContent || !modalContent.classList.contains(`${prefix}--modal-scroll-content`) || !currentActiveNode || !modalContent.contains(currentActiveNode)) {
      return;
    }
    const lastContent = modalContent.children[modalContent.children.length - 1];
    const gradientSpacing = modalContent.scrollHeight - lastContent.offsetTop - lastContent.clientHeight;
    for (let elem of modalContent.children) {
      if (elem.contains(currentActiveNode)) {
        const spaceBelow = modalContent.clientHeight - elem.offsetTop + modalContent.scrollTop - elem.clientHeight;
        if (spaceBelow < gradientSpacing) {
          modalContent.scrollTop = modalContent.scrollTop + (gradientSpacing - spaceBelow);
        }
        break;
      }
    }
  }
  function closeModal(evt) {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  }
  const modalClass = (0, import_classnames46.default)(`${prefix}--modal`, {
    "is-visible": isOpen,
    [`${prefix}--modal--danger`]: danger,
    [`${prefix}--modal--slug`]: slug,
    [`${prefix}--modal--decorator`]: decorator
  }, customClassName);
  const containerClass = (0, import_classnames46.default)(`${prefix}--modal-container`, size4 && `${prefix}--modal-container--${size4}`, isFullWidth && `${prefix}--modal-container--full-width`, containerClassName);
  let generatedAriaLabel;
  const childrenWithProps = import_react82.default.Children.toArray(children).map((child) => {
    switch (true) {
      case ((0, import_react_is2.isElement)(child) && child.type === import_react82.default.createElement(ModalHeader).type): {
        const el = child;
        generatedAriaLabel = el.props.label;
        return import_react82.default.cloneElement(el, {
          closeModal
        });
      }
      case ((0, import_react_is2.isElement)(child) && child.type === import_react82.default.createElement(ModalFooter).type): {
        const el = child;
        return import_react82.default.cloneElement(el, {
          closeModal,
          inputref: button,
          danger
        });
      }
      default:
        return child;
    }
  });
  (0, import_react82.useEffect)(() => {
    if (!open2) return;
    const handleEscapeKey = (event) => {
      if (match(event, Escape)) {
        event.preventDefault();
        event.stopPropagation();
        closeModal(event);
      }
    };
    document.addEventListener("keydown", handleEscapeKey, true);
    return () => {
      document.removeEventListener("keydown", handleEscapeKey, true);
    };
  }, [open2]);
  (0, import_react82.useEffect)(() => {
    if (!enableDialogElement && !open2 && launcherButtonRef) {
      setTimeout(() => {
        var _a;
        (_a = launcherButtonRef.current) == null ? void 0 : _a.focus();
      });
    }
  }, [enableDialogElement, open2, launcherButtonRef]);
  (0, import_react82.useEffect)(() => {
    if (!enableDialogElement) {
      const initialFocus = (focusContainerElement) => {
        const containerElement = focusContainerElement || innerModal.current;
        const primaryFocusElement = containerElement ? containerElement.querySelector(danger ? `.${prefix}--btn--secondary` : selectorPrimaryFocus) : null;
        if (primaryFocusElement) {
          return primaryFocusElement;
        }
        return button && button.current;
      };
      const focusButton = (focusContainerElement) => {
        const target = initialFocus(focusContainerElement);
        const closeButton = focusContainerElement.querySelector(`.${prefix}--modal-close`);
        if (target) {
          target.focus();
        } else if (!target && closeButton) {
          closeButton == null ? void 0 : closeButton.focus();
        }
      };
      if (open2 && isOpen) {
        focusButton(innerModal.current);
      }
    }
  }, [open2, selectorPrimaryFocus, isOpen]);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react82.cloneElement)(candidate, {
    size: "sm"
  }) : null;
  const modalBody = enableDialogElement ? import_react82.default.createElement(Dialog, {
    open: open2,
    focusAfterCloseRef: launcherButtonRef,
    modal: true,
    className: containerClass,
    "aria-label": ariaLabel ? ariaLabel : generatedAriaLabel,
    "aria-labelledby": ariaLabelledBy
  }, import_react82.default.createElement("div", {
    ref: innerModal,
    className: `${prefix}--modal-container-body`
  }, slug ? normalizedDecorator : decorator ? import_react82.default.createElement("div", {
    className: `${prefix}--modal--inner__decorator`
  }, normalizedDecorator) : "", childrenWithProps)) : import_react82.default.createElement("div", {
    className: containerClass,
    role: "dialog",
    "aria-modal": "true",
    "aria-label": ariaLabel ? ariaLabel : generatedAriaLabel,
    "aria-labelledby": ariaLabelledBy
  }, !focusTrapWithoutSentinels && import_react82.default.createElement("button", {
    type: "button",
    ref: startSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), import_react82.default.createElement("div", {
    ref: innerModal,
    className: `${prefix}--modal-container-body`
  }, slug ? normalizedDecorator : decorator ? import_react82.default.createElement("div", {
    className: `${prefix}--modal--inner__decorator`
  }, normalizedDecorator) : "", childrenWithProps), !focusTrapWithoutSentinels && import_react82.default.createElement("button", {
    type: "button",
    ref: endSentinel,
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"));
  return import_react82.default.createElement(Layer, _extends({}, rest, {
    level: 0,
    role: "presentation",
    ref,
    "aria-hidden": !open2,
    onBlur: handleBlur,
    onClick: composeEventHandlers([rest == null ? void 0 : rest.onClick, handleOnClick]),
    onMouseDown: composeEventHandlers([rest == null ? void 0 : rest.onMouseDown, handleOnMouseDown]),
    onKeyDown: handleKeyDown,
    className: modalClass
  }), modalBody);
});
ComposedModal.propTypes = {
  /**
   * Specify the aria-label for cds--modal-container
   */
  ["aria-label"]: import_prop_types55.default.string,
  /**
   * Specify the aria-labelledby for cds--modal-container
   */
  ["aria-labelledby"]: import_prop_types55.default.string,
  /**
   * Specify the content to be placed in the ComposedModal
   */
  children: import_prop_types55.default.node,
  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: import_prop_types55.default.string,
  /**
   * Specify an optional className to be applied to the modal node
   */
  containerClassName: import_prop_types55.default.string,
  /**
   * Specify whether the primary button should be replaced with danger button.
   * Note that this prop is not applied if you render primary/danger button by yourself
   */
  danger: import_prop_types55.default.bool,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `ComposedModal` component
   */
  decorator: import_prop_types55.default.node,
  /**
   * Specify whether the Modal content should have any inner padding.
   */
  isFullWidth: import_prop_types55.default.bool,
  /**
   * Provide a ref to return focus to once the modal is closed.
   */
  launcherButtonRef: import_prop_types55.default.oneOfType([import_prop_types55.default.func, import_prop_types55.default.shape({
    current: import_prop_types55.default.any
  })]),
  /**
   * Specify an optional handler for closing modal.
   * Returning `false` here prevents closing modal.
   */
  onClose: import_prop_types55.default.func,
  /**
   * Specify an optional handler for the `onKeyDown` event. Called for all
   * `onKeyDown` events that do not close the modal
   */
  onKeyDown: import_prop_types55.default.func,
  /**
   * Specify whether the Modal is currently open
   */
  open: import_prop_types55.default.bool,
  preventCloseOnClickOutside: import_prop_types55.default.bool,
  /**
   * Specify a CSS selector that matches the DOM element that should be
   * focused when the Modal opens
   */
  selectorPrimaryFocus: import_prop_types55.default.string,
  /**
   * Specify the CSS selectors that match the floating menus
   */
  selectorsFloatingMenus: import_prop_types55.default.arrayOf(import_prop_types55.default.string.isRequired),
  /**
   * Specify the size variant.
   */
  size: import_prop_types55.default.oneOf(["xs", "sm", "md", "lg"]),
  slug: deprecate(import_prop_types55.default.node, "The `slug` prop for `ComposedModal` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release.")
};

// node_modules/@carbon/react/es/internal/deprecateFieldOnObject.js
var deprecateFieldOnObject = (object, field, Component2, message) => {
  const didWarnAboutDeprecation6 = {};
  Object.defineProperty(object, field, {
    enumerable: true,
    get: () => {
      if (!didWarnAboutDeprecation6[field]) {
        true ? warning(false, `The ${field} field has been deprecated on the ${object.displayName} object. Please import and use ${Component2.displayName || Component2.name || "the field"} directly.`) : void 0;
        didWarnAboutDeprecation6[field] = true;
      }
      return Component2;
    }
  });
};

// node_modules/@carbon/react/es/components/ContainedList/ContainedList.js
var import_react86 = __toESM(require_react());
var import_prop_types59 = __toESM(require_prop_types());
var import_classnames50 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/ContainedList/ContainedListItem/ContainedListItem.js
var import_react83 = __toESM(require_react());
var import_prop_types56 = __toESM(require_prop_types());
var import_classnames47 = __toESM(require_classnames());
var ContainedListItem = ({
  action,
  children,
  className,
  disabled = false,
  onClick,
  renderIcon: IconElement,
  ...rest
}) => {
  const prefix = usePrefix();
  const isClickable = onClick !== void 0;
  const classes = (0, import_classnames47.default)(`${prefix}--contained-list-item`, className, {
    [`${prefix}--contained-list-item--clickable`]: isClickable,
    [`${prefix}--contained-list-item--with-icon`]: IconElement,
    [`${prefix}--contained-list-item--with-action`]: action
  });
  const content = import_react83.default.createElement(import_react83.default.Fragment, null, IconElement && import_react83.default.createElement("div", {
    className: `${prefix}--contained-list-item__icon`
  }, import_react83.default.createElement(IconElement, null)), import_react83.default.createElement("div", null, children));
  return import_react83.default.createElement("li", _extends({
    className: classes
  }, rest), isClickable ? import_react83.default.createElement("button", {
    className: `${prefix}--contained-list-item__content`,
    type: "button",
    disabled,
    onClick
  }, content) : import_react83.default.createElement("div", {
    className: `${prefix}--contained-list-item__content`
  }, content), action && import_react83.default.createElement(LayoutConstraint, {
    size: {
      min: "sm",
      max: "lg"
    },
    className: `${prefix}--contained-list-item__action`
  }, action));
};
ContainedListItem.propTypes = {
  /**
   * A slot for a possible interactive element to render within the item.
   */
  action: import_prop_types56.default.node,
  /**
   * The content of this item. Must not contain any interactive elements. Use props.action to include those.
   */
  children: import_prop_types56.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types56.default.string,
  /**
   * Whether this item is disabled.
   */
  disabled: import_prop_types56.default.bool,
  /**
   * Provide an optional function to be called when the item is clicked.
   */
  onClick: import_prop_types56.default.func,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types56.default.oneOfType([import_prop_types56.default.func, import_prop_types56.default.object])
};

// node_modules/@carbon/react/es/components/Search/Search.js
var import_classnames48 = __toESM(require_classnames());
var import_prop_types57 = __toESM(require_prop_types());
var import_react84 = __toESM(require_react());
var _Close4;
var Search2 = import_react84.default.forwardRef(function Search3({
  autoComplete = "off",
  className,
  closeButtonLabelText = "Clear search input",
  defaultValue,
  disabled,
  isExpanded = true,
  id,
  labelText,
  // @ts-expect-error: deprecated prop
  light,
  onChange = () => {
  },
  onClear = () => {
  },
  onKeyDown,
  onExpand,
  placeholder = "Search",
  renderIcon,
  role = "searchbox",
  size: size4 = "md",
  type = "text",
  value,
  ...rest
}, forwardRef36) {
  const hasPropValue = value || defaultValue ? true : false;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react84.useContext)(FormContext);
  const inputRef = (0, import_react84.useRef)(null);
  const ref = useMergedRefs([forwardRef36, inputRef]);
  const expandButtonRef = (0, import_react84.useRef)(null);
  const inputId = useId("search-input");
  const uniqueId = id || inputId;
  const searchId = `${uniqueId}-search`;
  const [hasContent, setHasContent] = (0, import_react84.useState)(hasPropValue || false);
  const [prevValue, setPrevValue] = (0, import_react84.useState)(value);
  const searchClasses = (0, import_classnames48.default)({
    [`${prefix}--search`]: true,
    [`${prefix}--search--sm`]: size4 === "sm",
    [`${prefix}--search--md`]: size4 === "md",
    [`${prefix}--search--lg`]: size4 === "lg",
    [`${prefix}--search--light`]: light,
    [`${prefix}--search--disabled`]: disabled,
    [`${prefix}--search--fluid`]: isFluid
  }, className);
  const clearClasses = (0, import_classnames48.default)({
    [`${prefix}--search-close`]: true,
    [`${prefix}--search-close--hidden`]: !hasContent || !isExpanded
  });
  if (value !== prevValue) {
    setHasContent(!!value);
    setPrevValue(value);
  }
  function clearInput() {
    var _a;
    if (!value && inputRef.current) {
      inputRef.current.value = "";
    }
    if (inputRef.current) {
      const inputTarget = Object.assign({}, inputRef.current, {
        value: ""
      });
      const syntheticEvent = {
        bubbles: false,
        cancelable: false,
        currentTarget: inputRef.current,
        defaultPrevented: false,
        eventPhase: 0,
        isDefaultPrevented: () => false,
        isPropagationStopped: () => false,
        isTrusted: false,
        nativeEvent: new Event("change"),
        persist: noopFn,
        preventDefault: noopFn,
        stopPropagation: noopFn,
        target: inputTarget,
        timeStamp: 0,
        type: "change"
      };
      onChange(syntheticEvent);
    }
    onClear();
    setHasContent(false);
    (_a = inputRef.current) == null ? void 0 : _a.focus();
  }
  function handleChange(event) {
    setHasContent(event.target.value !== "");
  }
  function handleKeyDown(event) {
    var _a, _b;
    if (match(event, Escape)) {
      event.stopPropagation();
      if ((_a = inputRef.current) == null ? void 0 : _a.value) {
        clearInput();
      } else if (onExpand && isExpanded) {
        (_b = expandButtonRef.current) == null ? void 0 : _b.focus();
      }
    }
  }
  function handleExpandButtonKeyDown(event) {
    if (match(event, Enter) || match(event, Space)) {
      event.stopPropagation();
      if (onExpand) {
        onExpand(event);
      }
    }
  }
  return import_react84.default.createElement("div", {
    role: "search",
    "aria-label": placeholder,
    className: searchClasses
  }, import_react84.default.createElement("div", {
    "aria-labelledby": onExpand ? searchId : void 0,
    role: onExpand ? "button" : void 0,
    className: `${prefix}--search-magnifier`,
    onClick: onExpand,
    onKeyDown: handleExpandButtonKeyDown,
    tabIndex: onExpand && !isExpanded ? 0 : -1,
    ref: expandButtonRef,
    "aria-expanded": onExpand && isExpanded ? true : onExpand && !isExpanded ? false : void 0,
    "aria-controls": onExpand ? uniqueId : void 0
  }, import_react84.default.createElement(CustomSearchIcon, {
    icon: renderIcon
  })), import_react84.default.createElement("label", {
    id: searchId,
    htmlFor: uniqueId,
    className: `${prefix}--label`
  }, labelText), import_react84.default.createElement("input", _extends({
    autoComplete,
    className: `${prefix}--search-input`,
    defaultValue,
    disabled,
    role,
    ref,
    id: uniqueId,
    onChange: composeEventHandlers([onChange, handleChange]),
    onKeyDown: composeEventHandlers([onKeyDown, handleKeyDown]),
    placeholder,
    type,
    value,
    tabIndex: onExpand && !isExpanded ? -1 : void 0
  }, rest)), import_react84.default.createElement("button", {
    "aria-label": closeButtonLabelText,
    className: clearClasses,
    disabled,
    onClick: clearInput,
    title: closeButtonLabelText,
    type: "button"
  }, _Close4 || (_Close4 = import_react84.default.createElement(Close, null))));
});
Search2.displayName = "Search";
Search2.propTypes = {
  /**
   * Specify an optional value for the `autocomplete` property on the underlying
   * `<input>`, defaults to "off"
   */
  autoComplete: import_prop_types57.default.string,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types57.default.string,
  /**
   * Specify a label to be read by screen readers on the "close" button
   */
  closeButtonLabelText: import_prop_types57.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types57.default.oneOfType([import_prop_types57.default.string, import_prop_types57.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types57.default.bool,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types57.default.string,
  /**
   * Specify whether or not ExpandableSearch should render expanded or not
   */
  isExpanded: import_prop_types57.default.bool,
  /**
   * Provide the label text for the Search icon
   */
  labelText: import_prop_types57.default.node.isRequired,
  /**
   * Specify light version or default version of this control
   */
  light: deprecate(import_prop_types57.default.bool, "The `light` prop for `Search` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * Optional callback called when the search value changes.
   */
  onChange: import_prop_types57.default.func,
  /**
   * Optional callback called when the search value is cleared.
   */
  onClear: import_prop_types57.default.func,
  /**
   * Optional callback called when the magnifier icon is clicked in ExpandableSearch.
   */
  onExpand: import_prop_types57.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the input
   */
  onKeyDown: import_prop_types57.default.func,
  /**
   * Provide an optional placeholder text for the Search.
   * Note: if the label and placeholder differ,
   * VoiceOver on Mac will read both
   */
  placeholder: import_prop_types57.default.string,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types57.default.oneOfType([import_prop_types57.default.func, import_prop_types57.default.object]),
  /**
   * Specify the role for the underlying `<input>`, defaults to `searchbox`
   */
  role: import_prop_types57.default.string,
  /**
   * Specify the size of the Search
   */
  size: import_prop_types57.default.oneOf(["sm", "md", "lg"]),
  /**
   * Optional prop to specify the type of the `<input>`
   */
  type: import_prop_types57.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types57.default.oneOfType([import_prop_types57.default.string, import_prop_types57.default.number])
};
function CustomSearchIcon({
  icon: Icon
}) {
  const prefix = usePrefix();
  if (Icon) {
    return import_react84.default.createElement(Icon, {
      className: `${prefix}--search-magnifier-icon`
    });
  }
  return import_react84.default.createElement(Search, {
    className: `${prefix}--search-magnifier-icon`
  });
}
CustomSearchIcon.propTypes = {
  /**
   * Rendered icon for the Search. Can be a React component class
   */
  icon: import_prop_types57.default.oneOfType([import_prop_types57.default.func, import_prop_types57.default.object])
};

// node_modules/@carbon/react/es/components/Search/Search.Skeleton.js
var import_prop_types58 = __toESM(require_prop_types());
var import_react85 = __toESM(require_react());
var import_classnames49 = __toESM(require_classnames());
var SearchSkeleton = ({
  small = false,
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const searchClasses = (0, import_classnames49.default)(className, {
    [`${prefix}--skeleton`]: true,
    [`${prefix}--search--xl`]: !small,
    [`${prefix}--search--sm`]: small
  });
  return import_react85.default.createElement("div", _extends({
    className: searchClasses
  }, rest), import_react85.default.createElement("span", {
    className: `${prefix}--label`
  }), import_react85.default.createElement("div", {
    className: `${prefix}--search-input`
  }));
};
SearchSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types58.default.string,
  /**
   * Specify whether the Search should be a small variant
   */
  small: import_prop_types58.default.bool
};

// node_modules/@carbon/react/es/components/ContainedList/ContainedList.js
var variants = ["on-page", "disclosed"];
function filterChildren(children) {
  var _a;
  if (Array.isArray(children)) {
    return children == null ? void 0 : children.filter((child) => {
      var _a2;
      return !["Search", "ExpandableSearch"].includes((_a2 = child == null ? void 0 : child.type) == null ? void 0 : _a2.displayName);
    });
  }
  if (children && !["Search", "ExpandableSearch"].includes((_a = children == null ? void 0 : children.type) == null ? void 0 : _a.displayName)) {
    return children;
  }
  return null;
}
function renderChildren(children) {
  if (Array.isArray(children)) {
    children.map((child, index3) => {
      if (index3 === 0 && child.type === Search2) {
        return child;
      }
      return child;
    });
  }
  if (children && children.type === Search2) {
    return children;
  }
  return children;
}
var ContainedList = ({
  action,
  children,
  className,
  isInset,
  kind = variants[0],
  label,
  size: size4,
  ...rest
}) => {
  const labelId = `${useId("contained-list")}-header`;
  const prefix = usePrefix();
  const classes = (0, import_classnames50.default)(`${prefix}--contained-list`, {
    [`${prefix}--contained-list--inset-rulers`]: isInset,
    [`${prefix}--contained-list--${size4}`]: size4,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4
  }, `${prefix}--contained-list--${kind}`, className);
  const filteredChildren = filterChildren(children);
  function isSearchAction(action2) {
    if (!import_react86.default.isValidElement(action2)) {
      return false;
    }
    const actionTypes = ["Search", "ExpandableSearch"];
    let actionType = "";
    if (typeof action2.type === "string") {
      actionType = action2.type;
    } else {
      actionType = action2.type.displayName || "";
    }
    return actionTypes.includes(actionType);
  }
  const isActionSearch = isSearchAction(action);
  const renderedChildren = renderChildren(children);
  return import_react86.default.createElement("div", _extends({
    className: classes
  }, rest), label && import_react86.default.createElement("div", {
    className: `${prefix}--contained-list__header`
  }, import_react86.default.createElement("div", {
    id: labelId,
    className: `${prefix}--contained-list__label`
  }, label), import_react86.default.createElement(LayoutConstraint, {
    size: {
      min: "sm",
      max: "xl"
    },
    className: `${prefix}--contained-list__action`
  }, action)), children && /**
   * Webkit removes implicit "list" semantics when "list-style-type: none" is set.
   * Explicitly setting the "list" role ensures assistive technology in webkit
   * browsers correctly announce the semantics.
   *
   * Ref https://bugs.webkit.org/show_bug.cgi?id=170179#c1
   */
  // eslint-disable-next-line jsx-a11y/no-redundant-roles
  import_react86.default.createElement("ul", {
    role: "list",
    "aria-labelledby": label ? labelId : void 0
  }, isActionSearch ? filteredChildren : renderedChildren));
};
ContainedList.propTypes = {
  /**
   * A slot for a possible interactive element to render.
   */
  action: import_prop_types59.default.node,
  /**
   * A collection of ContainedListItems to be rendered in the ContainedList
   */
  children: import_prop_types59.default.node,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types59.default.string,
  /**
   * Specify whether the dividing lines in between list items should be inset.
   */
  isInset: import_prop_types59.default.bool,
  /**
   * The kind of ContainedList you want to display
   */
  kind: import_prop_types59.default.oneOf(variants),
  /**
   * A label describing the contained list.
   */
  label: import_prop_types59.default.oneOfType([import_prop_types59.default.string, import_prop_types59.default.node]),
  /**
   * Specify the size of the contained list.
   */
  size: import_prop_types59.default.oneOf(["sm", "md", "lg", "xl"])
};
ContainedList.ContainedListItem = ContainedListItem;

// node_modules/@carbon/react/es/components/ContainedList/index.js
ContainedList.ContainedListItem = ContainedListItem;
if (true) {
  deprecateFieldOnObject(ContainedList, "ContainedListItem", ContainedListItem);
}

// node_modules/@carbon/react/es/components/ContentSwitcher/ContentSwitcher.js
var import_prop_types62 = __toESM(require_prop_types());
var import_react89 = __toESM(require_react());
var import_classnames53 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Switch/Switch.js
var import_prop_types60 = __toESM(require_prop_types());
var import_react87 = __toESM(require_react());
var import_classnames51 = __toESM(require_classnames());
var Switch = import_react87.default.forwardRef(function Switch2(props, tabRef) {
  const {
    children,
    className,
    disabled,
    index: index3,
    name,
    onClick = noopFn,
    onKeyDown = noopFn,
    selected = false,
    text,
    ...other
  } = props;
  const prefix = usePrefix();
  const handleClick2 = (e2) => {
    e2.preventDefault();
    onClick == null ? void 0 : onClick({
      index: index3,
      name,
      text
    });
  };
  const handleKeyDown = (event) => {
    const key = event.key || event.which;
    onKeyDown == null ? void 0 : onKeyDown({
      index: index3,
      name,
      text,
      key
    });
  };
  const classes = (0, import_classnames51.default)(className, `${prefix}--content-switcher-btn`, {
    [`${prefix}--content-switcher--selected`]: selected
  });
  const commonProps = {
    onClick: handleClick2,
    onKeyDown: handleKeyDown,
    className: classes,
    disabled
  };
  return import_react87.default.createElement("button", _extends({
    type: "button",
    ref: tabRef,
    role: "tab",
    tabIndex: selected ? 0 : -1,
    "aria-selected": selected
  }, other, commonProps), import_react87.default.createElement("span", {
    className: `${prefix}--content-switcher__label`,
    title: text
  }, text !== void 0 ? text : children));
});
Switch.displayName = "Switch";
Switch.propTypes = {
  /**
   * Provide child elements to be rendered inside of the Switch
   */
  children: import_prop_types60.default.node,
  /**
   * Specify an optional className to be added to your Switch
   */
  className: import_prop_types60.default.string,
  /**
   * Specify whether or not the Switch should be disabled
   */
  disabled: import_prop_types60.default.bool,
  /**
   * The index of your Switch in your ContentSwitcher that is used for event handlers.
   * Reserved for usage in ContentSwitcher
   */
  index: import_prop_types60.default.number,
  /**
   * Provide the name of your Switch that is used for event handlers
   */
  name: import_prop_types60.default.oneOfType([import_prop_types60.default.string, import_prop_types60.default.number]),
  /**
   * A handler that is invoked when a user clicks on the control.
   * Reserved for usage in ContentSwitcher
   */
  onClick: import_prop_types60.default.func,
  /**
   * A handler that is invoked on the key down event for the control.
   * Reserved for usage in ContentSwitcher
   */
  onKeyDown: import_prop_types60.default.func,
  /**
   * Whether your Switch is selected. Reserved for usage in ContentSwitcher
   */
  selected: import_prop_types60.default.bool,
  /**
   * Provide the contents of your Switch
   */
  text: import_prop_types60.default.string
};

// node_modules/@carbon/react/es/components/Switch/IconSwitch.js
var import_prop_types61 = __toESM(require_prop_types());
var import_react88 = __toESM(require_react());
var import_classnames52 = __toESM(require_classnames());
var frFn3 = import_react88.forwardRef;
var IconSwitch = frFn3((props, ref) => {
  const {
    align,
    children,
    className,
    disabled,
    enterDelayMs,
    index: index3,
    leaveDelayMs = 0,
    name,
    onClick = noopFn,
    onKeyDown = noopFn,
    selected = false,
    size: size4,
    text,
    ...other
  } = props;
  const prefix = usePrefix();
  const [isHovered, setIsHovered] = (0, import_react88.useState)(false);
  const handleClick2 = (event) => {
    event.preventDefault();
    onClick({
      index: index3,
      name,
      text
    });
  };
  const handleKeyDown = (event) => {
    const key = event.key || event.which;
    onKeyDown({
      index: index3,
      name,
      text,
      key
    });
  };
  const handleMouseEnter = () => {
    setIsHovered(true);
  };
  const handleMouseLeave = () => {
    setIsHovered(false);
  };
  const classes = (0, import_classnames52.default)(className, `${prefix}--content-switcher-btn`, {
    [`${prefix}--content-switcher--selected`]: selected
  });
  const iconButtonClasses = (0, import_classnames52.default)(`${prefix}--content-switcher-popover__wrapper`, {
    [`${prefix}--content-switcher-popover--selected`]: selected,
    [`${prefix}--content-switcher-popover--disabled`]: disabled
  });
  return import_react88.default.createElement(IconButton, _extends({
    label: text,
    type: "button",
    ref,
    role: "tab",
    tabIndex: selected || isHovered ? 0 : -1,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onFocus: handleMouseEnter,
    onBlur: handleMouseLeave,
    "aria-selected": selected,
    "aria-label": text,
    wrapperClasses: iconButtonClasses
  }, other, {
    align,
    className: classes,
    disabled,
    enterDelayMs,
    leaveDelayMs,
    onClick: handleClick2,
    onKeyDown: handleKeyDown,
    size: size4
  }), children);
});
IconSwitch.displayName = "IconSwitch";
IconSwitch.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: import_prop_types61.default.oneOf(["top", "top-left", "top-right", "bottom", "bottom-left", "bottom-right", "left", "right"]),
  /**
   * Children to be rendered inside of the `IconSwitch`.
   */
  children: import_prop_types61.default.node,
  /**
   * Specify an optional className to be added to your `IconSwitch`.
   */
  className: import_prop_types61.default.string,
  /**
   * Whether the `IconSwitch` should be disabled.
   */
  disabled: import_prop_types61.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip
   */
  enterDelayMs: import_prop_types61.default.number,
  /**
   * The index of the `IconSwitch`.
   *
   * Reserved for usage in `ContentSwitcher`.
   */
  index: import_prop_types61.default.number,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types61.default.number,
  /**
   * The name of the `IconSwitch`.
   */
  name: import_prop_types61.default.oneOfType([import_prop_types61.default.string, import_prop_types61.default.number]),
  /**
   * A handler that is invoked when a user clicks on the control.
   *
   * Reserved for usage in `ContentSwitcher`.
   */
  onClick: import_prop_types61.default.func,
  /**
   * A handler that is invoked on the key down event for the control.
   *
   * Reserved for usage in `ContentSwitcher`.
   */
  onKeyDown: import_prop_types61.default.func,
  /**
   * Whether the `IconSwitch` is selected.
   *
   * Reserved for usage in `ContentSwitcher`.
   */
  selected: import_prop_types61.default.bool,
  // TODO: Icon only variant of what? Isn't the `IconSwitch` always icon only?
  /**
   * Passed in from `ContentSwitcher` to render icon-only variant
   */
  size: import_prop_types61.default.oneOf(["sm", "md", "lg"]),
  /**
   * `Tooltip` text.
   */
  text: import_prop_types61.default.string
};

// node_modules/@carbon/react/es/components/ContentSwitcher/ContentSwitcher.js
var ContentSwitcher = ({
  children,
  className,
  light,
  lowContrast,
  selectedIndex: selectedIndexProp = 0,
  selectionMode = "automatic",
  size: size4,
  onChange = noopFn,
  ...other
}) => {
  var _a;
  const prefix = (0, import_react89.useContext)(PrefixContext);
  const [selectedIndex, setSelectedIndex] = (0, import_react89.useState)(selectedIndexProp);
  const prevSelectedIndexRef = (0, import_react89.useRef)(selectedIndexProp);
  const switchRefs = (0, import_react89.useRef)([]);
  const childrenArray = import_react89.Children.toArray(children);
  (0, import_react89.useEffect)(() => {
    if (prevSelectedIndexRef.current !== selectedIndexProp) {
      setSelectedIndex(selectedIndexProp);
      prevSelectedIndexRef.current = selectedIndexProp;
    }
  }, [selectedIndexProp]);
  const handleItemRef = (index3) => (ref) => {
    if (ref) {
      switchRefs.current[index3] = ref;
    }
  };
  const focusSwitch = (index3) => {
    const ref = switchRefs.current[index3];
    if (ref) {
      ref.focus();
    }
  };
  const isKeyboardEvent = (event) => event && typeof event === "object" && "key" in event;
  const handleChildChange = (event) => {
    if (typeof event.index === "undefined") return;
    const {
      index: index3
    } = event;
    if (isKeyboardEvent(event) && matches(event, [ArrowRight2, ArrowLeft])) {
      const nextIndex = getNextIndex(event.key, index3, childrenArray.length);
      if (typeof nextIndex !== "number") return;
      focusSwitch(nextIndex);
      if (selectionMode !== "manual") {
        const child = childrenArray[nextIndex];
        setSelectedIndex(nextIndex);
        if ((0, import_react89.isValidElement)(child)) {
          onChange({
            ...event,
            index: nextIndex,
            name: child.props.name,
            text: child.props.text
          });
        }
      }
    } else if (selectedIndex !== index3) {
      setSelectedIndex(index3);
      focusSwitch(index3);
      onChange(event);
    }
  };
  const isIconOnly = (_a = import_react89.Children.map(children, (child) => {
    return (0, import_react89.isValidElement)(child) ? child.type === IconSwitch : null;
  })) == null ? void 0 : _a.every((val) => val === true);
  const classes = (0, import_classnames53.default)(`${prefix}--content-switcher`, className, {
    [`${prefix}--content-switcher--light`]: light,
    [`${prefix}--content-switcher--${size4}`]: size4,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4,
    [`${prefix}--content-switcher--icon-only`]: isIconOnly,
    [`${prefix}--content-switcher--low-contrast`]: lowContrast
  });
  return import_react89.default.createElement(LayoutConstraint, _extends({
    size: {
      default: "md",
      min: "sm",
      max: "lg"
    }
  }, other, {
    className: classes,
    role: "tablist",
    onChange: void 0
  }), children && import_react89.Children.map(children, (child, index3) => (0, import_react89.cloneElement)(child, {
    index: index3,
    onClick: composeEventHandlers([handleChildChange, child.props.onClick]),
    onKeyDown: composeEventHandlers([handleChildChange, child.props.onKeyDown]),
    selected: index3 === selectedIndex,
    ref: handleItemRef(index3),
    size: size4
  })));
};
ContentSwitcher.displayName = "ContentSwitcher";
ContentSwitcher.propTypes = {
  /**
   * Pass in Switch components to be rendered in the ContentSwitcher
   */
  children: import_prop_types62.default.node,
  /**
   * Specify an optional className to be added to the container node
   */
  className: import_prop_types62.default.string,
  /**
   * `true` to use the light variant.
   */
  light: deprecate(import_prop_types62.default.bool, "The `light` prop for `ContentSwitcher` is no longer needed and has been deprecated. It will be removed in the next major release."),
  /**
   * `true` to use the low contrast version.
   */
  lowContrast: import_prop_types62.default.bool,
  /**
   * Specify an `onChange` handler that is called whenever the ContentSwitcher
   * changes which item is selected
   */
  onChange: import_prop_types62.default.func.isRequired,
  /**
   * Specify a selected index for the initially selected content
   */
  selectedIndex: import_prop_types62.default.number,
  /**
   * Choose whether or not to automatically change selection on focus when left/right arrow pressed. Defaults to 'automatic'
   */
  selectionMode: import_prop_types62.default.oneOf(["automatic", "manual"]),
  /**
   * Specify the size of the Content Switcher. Currently supports either `sm`, `md` (default) or `lg` as an option.
   */
  size: import_prop_types62.default.oneOf(["sm", "md", "lg"])
};

// node_modules/@carbon/react/es/components/ContextMenu/useContextMenu.js
var import_react90 = __toESM(require_react());
function useContextMenu(trigger = document) {
  const [open2, setOpen] = (0, import_react90.useState)(false);
  const [position, setPosition] = (0, import_react90.useState)([0, 0]);
  function openContextMenu(e2) {
    e2.preventDefault();
    const {
      clientX: x,
      clientY: y
    } = e2;
    setPosition([x, y]);
    setOpen(true);
  }
  function onClose() {
    setOpen(false);
  }
  (0, import_react90.useEffect)(() => {
    const el = trigger instanceof Element || trigger instanceof Document || trigger instanceof Window ? trigger : trigger.current;
    if (el) {
      const eventListener = (e2) => openContextMenu(e2);
      el.addEventListener("contextmenu", eventListener);
      return () => {
        el.removeEventListener("contextmenu", eventListener);
      };
    }
  }, [trigger]);
  return {
    open: open2,
    x: position[0],
    y: position[1],
    onClose
  };
}

// node_modules/@carbon/react/es/components/DangerButton/DangerButton.js
var import_react91 = __toESM(require_react());
var DangerButton = (props) => import_react91.default.createElement(Button, _extends({}, props, {
  kind: "danger"
}));

// node_modules/@carbon/react/es/components/DataTable/DataTable.js
var import_prop_types89 = __toESM(require_prop_types());
var import_react123 = __toESM(require_react());
var import_react_fast_compare2 = __toESM(require_react_fast_compare());

// node_modules/@carbon/react/es/components/DataTable/state/sortStates.js
var sortStates = {
  NONE: "NONE",
  DESC: "DESC",
  ASC: "ASC"
};

// node_modules/@carbon/react/es/components/DataTable/tools/cells.js
var getCellId = (rowId, header) => `${rowId}:${header}`;

// node_modules/@carbon/react/es/components/DataTable/tools/sorting.js
var compare = (a, b2, locale = "en") => {
  var _a, _b;
  if (a === null) a = "";
  if (b2 === null) b2 = "";
  if (typeof a === "number" && typeof b2 === "number") {
    return a - b2;
  }
  if (typeof a === "string" && typeof b2 === "string") {
    return compareStrings(a, b2, locale);
  }
  const aChild = (_a = a == null ? void 0 : a.props) == null ? void 0 : _a.children;
  const bChild = (_b = b2 == null ? void 0 : b2.props) == null ? void 0 : _b.children;
  if (typeof aChild === "string" && typeof bChild === "string") {
    return compareStrings(aChild, bChild, locale);
  }
  return compareStrings(String(a), String(b2), locale);
};
var compareStrings = (a, b2, locale = "en") => {
  const isNumeric = !isNaN(parseFloat(a)) && !isNaN(parseFloat(b2));
  return a.localeCompare(b2, locale, {
    numeric: isNumeric
  });
};
var sortRows = ({
  rowIds,
  cellsById,
  sortDirection,
  key,
  locale = "en",
  sortRow = defaultSortRow
}) => rowIds.slice().sort((a, b2) => {
  const cellA = cellsById[getCellId(a, key)];
  const cellB = cellsById[getCellId(b2, key)];
  return sortRow(cellA == null ? void 0 : cellA.value, cellB == null ? void 0 : cellB.value, {
    key,
    sortDirection,
    sortStates,
    locale,
    compare,
    rowIds: [a, b2]
  });
});
var defaultSortRow = (cellA, cellB, {
  sortDirection,
  sortStates: sortStates2,
  locale
}) => {
  if (sortDirection === sortStates2.ASC) {
    return compare(cellA, cellB, locale);
  }
  return compare(cellB, cellA, locale);
};

// node_modules/@carbon/react/es/components/DataTable/state/sorting.js
var initialSortState = sortStates.NONE;
var getNextSortDirection = (prevHeader, header, prevState) => {
  if (prevHeader === header) {
    if (prevState === "NONE") {
      return sortStates.ASC;
    }
    if (prevState === "ASC") {
      return sortStates.DESC;
    }
    return sortStates.NONE;
  }
  return sortStates.ASC;
};
var getNextSortState = (props, state, {
  key
}) => {
  const {
    sortDirection,
    sortHeaderKey
  } = state;
  const nextSortDirection = getNextSortDirection(key, sortHeaderKey, sortDirection);
  return getSortedState(props, state, key, nextSortDirection);
};
var getSortedState = (props, state, key, sortDirection) => {
  const {
    rowIds,
    cellsById,
    initialRowOrder
  } = state;
  const {
    locale,
    sortRow
  } = props;
  const nextRowIds = sortDirection !== sortStates.NONE ? sortRows({
    rowIds,
    cellsById,
    sortDirection,
    key,
    locale,
    sortRow
  }) : initialRowOrder;
  return {
    sortHeaderKey: key,
    sortDirection,
    rowIds: nextRowIds
  };
};

// node_modules/@carbon/react/es/components/DataTable/tools/normalize.js
var normalize = (rows, headers, prevState = {}) => {
  const {
    rowsById: prevRowsByIds
  } = prevState;
  const rowIds = new Array(rows.length);
  const rowsById = {};
  const cellsById = {};
  rows.forEach((row, i) => {
    rowIds[i] = row.id;
    const {
      id,
      isSelected = false,
      isExpanded = false,
      disabled = false
    } = row;
    rowsById[id] = {
      id,
      isSelected,
      isExpanded,
      disabled,
      cells: new Array(headers.length)
    };
    if (prevRowsByIds && prevRowsByIds[row.id] !== void 0) {
      rowsById[row.id].isSelected = prevRowsByIds[row.id].isSelected;
      rowsById[row.id].isExpanded = prevRowsByIds[row.id].isExpanded;
    }
    headers.forEach(({
      key,
      slug,
      decorator
    }, i2) => {
      const id2 = getCellId(row.id, key);
      cellsById[id2] = {
        id: id2,
        value: row[key],
        isEditable: false,
        isEditing: false,
        isValid: true,
        errors: null,
        hasAILabelHeader: !!(slug || (decorator == null ? void 0 : decorator.type) === AILabel),
        info: {
          header: key
        }
      };
      rowsById[row.id].cells[i2] = id2;
    });
  });
  return {
    rowIds,
    rowsById,
    cellsById
  };
};

// node_modules/@carbon/react/es/components/DataTable/state/getDerivedStateFromProps.js
var getDerivedStateFromProps = (props, prevState) => {
  const {
    rowIds,
    rowsById,
    cellsById
  } = normalize(props.rows, props.headers, prevState);
  const state = {
    rowIds,
    rowsById,
    cellsById,
    sortDirection: prevState.sortDirection || initialSortState,
    sortHeaderKey: prevState.sortHeaderKey || null,
    // Copy over rowIds so the reference doesn't mutate the stored
    // `initialRowOrder`
    initialRowOrder: rowIds.slice(),
    filterInputValue: prevState.filterInputValue || null,
    // Optional state field to indicate whether a consumer should show a
    // batch actions menu
    shouldShowBatchActions: prevState.shouldShowBatchActions || false,
    // TODO: Investigate deleting this property when this util is ported to
    // TypeScript. The only reason it was added was to address a type error in
    // packages/react/src/components/DataTable/DataTable.tsx
    isExpandedAll: false
  };
  if (prevState.sortDirection && prevState.sortHeaderKey) {
    const {
      rowIds: rowIds2
    } = getSortedState(props, state, prevState.sortHeaderKey, prevState.sortDirection);
    state.rowIds = rowIds2;
  }
  state.isExpandedAll = state.rowIds.every((id) => {
    return state.rowsById[id].isExpanded === true;
  });
  return state;
};

// node_modules/@carbon/react/es/components/DataTable/tools/denormalize.js
var denormalize = (rowIds, rowsById, cellsById) => {
  return rowIds.map((id) => ({
    ...rowsById[id],
    cells: rowsById[id].cells.map((cellId) => cellsById[cellId])
  }));
};

// node_modules/@carbon/react/es/components/DataTable/tools/filter.js
var defaultFilterRows = ({
  rowIds,
  headers,
  cellsById,
  inputValue,
  getCellId: getCellId2
}) => {
  const normalizedInput = inputValue.trim().toLowerCase();
  if (!normalizedInput) return rowIds;
  return rowIds.filter((rowId) => headers.some(({
    key
  }) => {
    const cellId = getCellId2(rowId, key);
    const cell = cellsById[cellId];
    if (typeof cell.value === "boolean") return false;
    return String(cell.value).toLowerCase().includes(normalizedInput);
  }));
};

// node_modules/@carbon/react/es/components/DataTable/Table.js
var import_react93 = __toESM(require_react());
var import_prop_types63 = __toESM(require_prop_types());
var import_classnames54 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/DataTable/TableContext.js
var import_react92 = __toESM(require_react());
var TableContext = (0, import_react92.createContext)({
  titleId: void 0,
  descriptionId: void 0
});

// node_modules/@carbon/react/es/components/DataTable/Table.js
var isElementWrappingContent = (element, context) => {
  var _a, _b, _c, _d;
  if (element.children.length > 0) {
    return false;
  }
  const computedStyles = window.getComputedStyle(element);
  context.font = computedStyles.font ? computedStyles.font : `${computedStyles.fontSize}" "${computedStyles.fontFamily}`;
  const measuredText = context == null ? void 0 : context.measureText(element.textContent ?? "");
  let textWidth = measuredText.width ?? 0;
  const letterSpacing = (_a = computedStyles.letterSpacing) == null ? void 0 : _a.split("px");
  if (letterSpacing && letterSpacing.length && !isNaN(Number(letterSpacing[0]))) {
    textWidth += Number(letterSpacing[0]) * (((_b = element.textContent) == null ? void 0 : _b.length) ?? 0);
  }
  const paddingLeft = (_c = computedStyles.paddingLeft) == null ? void 0 : _c.split("px");
  if (paddingLeft && paddingLeft.length && !isNaN(Number(paddingLeft[0]))) {
    textWidth += Number(paddingLeft[0]);
  }
  const paddingRight = (_d = computedStyles.paddingLeft) == null ? void 0 : _d.split("px");
  if (paddingRight && paddingRight.length && !isNaN(Number(paddingRight[0]))) {
    textWidth += Number(paddingRight[0]);
  }
  if (textWidth > element.getBoundingClientRect().width) {
    return true;
  }
  return false;
};
var Table = ({
  className,
  children,
  useZebraStyles,
  size: size4 = "lg",
  isSortable = false,
  useStaticWidth,
  stickyHeader,
  overflowMenuOnHover = true,
  experimentalAutoAlign = false,
  tabIndex,
  ...other
}) => {
  var _a;
  const {
    titleId,
    descriptionId
  } = (0, import_react93.useContext)(TableContext);
  const prefix = usePrefix();
  const [isScrollable, setIsScrollable] = (0, import_react93.useState)(false);
  const tableRef = (0, import_react93.useRef)(null);
  const componentClass = (0, import_classnames54.default)(`${prefix}--data-table`, className, {
    [`${prefix}--data-table--${size4}`]: size4,
    [`${prefix}--data-table--sort`]: isSortable,
    [`${prefix}--data-table--zebra`]: useZebraStyles,
    [`${prefix}--data-table--static`]: useStaticWidth,
    [`${prefix}--data-table--sticky-header`]: stickyHeader,
    [`${prefix}--data-table--visible-overflow-menu`]: !overflowMenuOnHover
  });
  const toggleTableBodyAlignmentClass = (0, import_react93.useCallback)((alignTop = false) => {
    var _a2, _b;
    alignTop ? (_a2 = tableRef.current) == null ? void 0 : _a2.classList.add(`${prefix}--data-table--top-aligned-body`) : (_b = tableRef.current) == null ? void 0 : _b.classList.remove(`${prefix}--data-table--top-aligned-body`);
  }, [prefix]);
  const toggleTableHeaderAlignmentClass = (0, import_react93.useCallback)((alignTop = false) => {
    var _a2, _b;
    alignTop ? (_a2 = tableRef.current) == null ? void 0 : _a2.classList.add(`${prefix}--data-table--top-aligned-header`) : (_b = tableRef.current) == null ? void 0 : _b.classList.remove(`${prefix}--data-table--top-aligned-header`);
  }, [prefix]);
  const setTableAlignment = (0, import_react93.useCallback)(() => {
    if (experimentalAutoAlign) {
      const canvas = document.createElement("canvas");
      const context = canvas.getContext("2d");
      if (tableRef.current && context) {
        const isBodyMultiline = Array.from(tableRef.current.querySelectorAll("td")).some((td) => isElementWrappingContent(td, context));
        const isHeaderMultiline = Array.from(tableRef.current.querySelectorAll("th")).some((th) => {
          const label = th.querySelector(`.${prefix}--table-header-label`);
          return label && isElementWrappingContent(label, context);
        });
        toggleTableBodyAlignmentClass(isBodyMultiline);
        toggleTableHeaderAlignmentClass(isHeaderMultiline);
      }
    } else {
      toggleTableBodyAlignmentClass(false);
      toggleTableHeaderAlignmentClass(false);
    }
  }, [experimentalAutoAlign, toggleTableBodyAlignmentClass, toggleTableHeaderAlignmentClass, prefix]);
  const debouncedSetTableAlignment = debounce2(setTableAlignment, 100);
  useWindowEvent("resize", debouncedSetTableAlignment);
  const setTabIndex = (0, import_react93.useCallback)(() => {
    var _a2, _b;
    const tableContainer = (_a2 = tableRef == null ? void 0 : tableRef.current) == null ? void 0 : _a2.parentNode;
    const tableHeader = (_b = tableRef == null ? void 0 : tableRef.current) == null ? void 0 : _b.firstChild;
    if ((tableHeader == null ? void 0 : tableHeader.scrollWidth) > (tableContainer == null ? void 0 : tableContainer.clientWidth)) {
      setIsScrollable(true);
    } else {
      setIsScrollable(false);
    }
  }, []);
  const debouncedSetTabIndex = debounce2(setTabIndex, 100);
  useWindowEvent("resize", debouncedSetTabIndex);
  useIsomorphicEffect(() => {
    setTabIndex();
  }, [setTabIndex]);
  if (typeof document !== "undefined" && ((_a = document == null ? void 0 : document.fonts) == null ? void 0 : _a.status) && document.fonts.status !== "loaded") {
    document.fonts.ready.then(() => {
      setTableAlignment();
    });
  }
  useIsomorphicEffect(() => {
    setTableAlignment();
  }, [setTableAlignment, size4]);
  const table = import_react93.default.createElement("div", {
    className: `${prefix}--data-table-content`,
    tabIndex: tabIndex ?? (isScrollable ? 0 : void 0)
  }, import_react93.default.createElement("table", _extends({
    "aria-labelledby": titleId,
    "aria-describedby": descriptionId
  }, other, {
    className: componentClass,
    ref: tableRef
  }), children));
  return stickyHeader ? import_react93.default.createElement("section", {
    className: `${prefix}--data-table_inner-container`
  }, table) : table;
};
Table.propTypes = {
  /**
   * Pass in the children that will be rendered within the Table
   */
  children: import_prop_types63.default.node,
  className: import_prop_types63.default.string,
  /**
   * Experimental property. Allows table to align cell contents to the top if there is text wrapping in the content. Might have performance issues, intended for smaller tables
   */
  experimentalAutoAlign: import_prop_types63.default.bool,
  /**
   * `false` If true, will apply sorting styles
   */
  isSortable: import_prop_types63.default.bool,
  /**
   * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
   */
  overflowMenuOnHover: import_prop_types63.default.bool,
  /**
   *  Change the row height of table. Currently supports `xs`, `sm`, `md`, `lg`, and `xl`.
   */
  size: import_prop_types63.default.oneOf(["xs", "sm", "md", "lg", "xl"]),
  /**
   * `false` If true, will keep the header sticky (only data rows will scroll)
   */
  stickyHeader: import_prop_types63.default.bool,
  /**
   * `false` If true, will use a width of 'auto' instead of 100%
   */
  useStaticWidth: import_prop_types63.default.bool,
  /**
   * `true` to add useZebraStyles striping.
   */
  useZebraStyles: import_prop_types63.default.bool,
  /**
   * Specify the table tabIndex
   */
  tabIndex: import_prop_types63.default.number
};

// node_modules/@carbon/react/es/tools/wrapComponent.js
var import_classnames55 = __toESM(require_classnames());
var import_prop_types64 = __toESM(require_prop_types());
var import_react94 = __toESM(require_react());
var wrapComponent = ({
  name,
  className: getClassName,
  type
}) => {
  function Component2({
    className: baseClassName,
    ...other
  }) {
    const prefix = usePrefix();
    const componentClass = (0, import_classnames55.default)(typeof getClassName === "function" ? getClassName(prefix) : getClassName, baseClassName);
    return import_react94.default.createElement(type, {
      ...other,
      // Prevent Weird quirk where `cx` will evaluate to an empty string, '',
      // and so we have empty `class` attributes in the resulting markup
      // eslint-disable-next-line no-extra-boolean-cast
      className: !!componentClass ? componentClass : void 0
    });
  }
  Component2.displayName = name;
  Component2.propTypes = {
    className: import_prop_types64.default.string
  };
  return Component2;
};

// node_modules/@carbon/react/es/components/DataTable/TableActionList.js
var TableActionList = wrapComponent({
  name: "TableActionList",
  type: "div",
  className: (prefix) => `${prefix}--action-list`
});

// node_modules/@carbon/react/es/components/DataTable/TableBatchAction.js
var import_prop_types65 = __toESM(require_prop_types());
var import_react95 = __toESM(require_react());
var TableBatchAction = ({
  renderIcon = AddFilled,
  iconDescription = "Add",
  ...props
}) => import_react95.default.createElement(Button, _extends({
  renderIcon,
  iconDescription
}, props));
TableBatchAction.propTypes = {
  /**
   * Specify if the button is an icon-only button
   */
  hasIconOnly: import_prop_types65.default.bool,
  /**
   * If specifying the `renderIcon` prop, provide a description for that icon that can
   * be read by screen readers
   */
  iconDescription: (props) => {
    if (props.renderIcon && !props.children && !props.iconDescription) {
      return new Error("renderIcon property specified without also providing an iconDescription property.");
    }
    return void 0;
  },
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types65.default.oneOfType([import_prop_types65.default.func, import_prop_types65.default.object])
};

// node_modules/@carbon/react/es/components/DataTable/TableBatchActions.js
var import_classnames56 = __toESM(require_classnames());
var import_prop_types66 = __toESM(require_prop_types());
var import_react96 = __toESM(require_react());
var TableBatchActionsTranslationKeys = ["carbon.table.batch.cancel", "carbon.table.batch.items.selected", "carbon.table.batch.item.selected", "carbon.table.batch.selectAll"];
var translationKeys = {
  "carbon.table.batch.cancel": "Cancel",
  "carbon.table.batch.items.selected": "items selected",
  "carbon.table.batch.item.selected": "item selected",
  "carbon.table.batch.selectAll": "Select all"
};
var translateWithId = (id, {
  totalSelected,
  totalCount
} = {
  totalSelected: 0,
  totalCount: 0
}) => {
  if (id === "carbon.table.batch.cancel") {
    return translationKeys[id];
  }
  if (id === "carbon.table.batch.selectAll") {
    return `${translationKeys[id]} (${totalCount})`;
  }
  return `${totalSelected} ${translationKeys[id]}`;
};
var TableBatchActions = ({
  className,
  children,
  shouldShowBatchActions,
  totalSelected,
  totalCount,
  onCancel,
  onSelectAll,
  translateWithId: t3 = translateWithId,
  ...rest
}) => {
  const [isScrolling, setIsScrolling] = import_react96.default.useState(false);
  const prefix = usePrefix();
  const batchActionsClasses = (0, import_classnames56.default)({
    [`${prefix}--batch-actions`]: true,
    [`${prefix}--batch-actions--active`]: shouldShowBatchActions
  }, className);
  const batchSummaryClasses = (0, import_classnames56.default)(`${prefix}--batch-summary`, {
    [`${prefix}--batch-summary__scroll`]: isScrolling
  });
  return import_react96.default.createElement("div", _extends({
    onScroll: () => {
      setIsScrolling(!isScrolling);
    },
    "aria-hidden": !shouldShowBatchActions,
    className: batchActionsClasses
  }, rest), import_react96.default.createElement("div", {
    className: batchSummaryClasses
  }, import_react96.default.createElement("p", {
    className: `${prefix}--batch-summary__para`
  }, import_react96.default.createElement(Text, null, totalSelected > 1 || totalSelected === 0 ? t3("carbon.table.batch.items.selected", {
    totalSelected
  }) : t3("carbon.table.batch.item.selected", {
    totalSelected
  }))), onSelectAll && import_react96.default.createElement(import_react96.default.Fragment, null, import_react96.default.createElement("span", {
    className: `${prefix}--batch-summary__divider`
  }, "|"), import_react96.default.createElement(Button, {
    onClick: onSelectAll,
    tabIndex: shouldShowBatchActions ? 0 : -1
  }, t3("carbon.table.batch.selectAll", {
    totalCount
  })))), import_react96.default.createElement(TableActionList, null, children, import_react96.default.createElement(Button, {
    className: `${prefix}--batch-summary__cancel`,
    tabIndex: shouldShowBatchActions ? 0 : -1,
    onClick: onCancel
  }, t3("carbon.table.batch.cancel"))));
};
TableBatchActions.translationKeys = TableBatchActionsTranslationKeys;
TableBatchActions.propTypes = {
  children: import_prop_types66.default.node,
  className: import_prop_types66.default.string,
  /**
   * Hook required to listen for when the user initiates a cancel request
   * through this component
   */
  onCancel: import_prop_types66.default.func.isRequired,
  /**
   * Hook to listen for when the user initiates a select all
   * request through this component. This _only_ controls the rendering
   * of the `Select All` button and does not include built in functionality
   */
  onSelectAll: import_prop_types66.default.func,
  /**
   * Boolean specifier for whether or not the batch action bar should be
   * displayed
   */
  shouldShowBatchActions: import_prop_types66.default.bool,
  /**
   * Numeric representation of the total number of items in a table.
   * This number is used in the select all button text
   */
  totalCount: import_prop_types66.default.number,
  /**
   * Numeric representation of the total number of items selected in a table.
   * This number is used to derive the selection message
   */
  totalSelected: import_prop_types66.default.number.isRequired,
  /**
   * Supply a method to translate internal strings with your i18n tool of
   * choice. Translation keys are available on the `translationKeys` field for
   * this component.
   */
  translateWithId: import_prop_types66.default.func
};

// node_modules/@carbon/react/es/components/DataTable/TableBody.js
var import_prop_types67 = __toESM(require_prop_types());
var import_react97 = __toESM(require_react());
var TableBody = ({
  children,
  className,
  ...rest
}) => import_react97.default.createElement("tbody", _extends({
  "aria-live": rest["aria-live"] ?? "polite",
  className
}, rest), children);
TableBody.propTypes = {
  /**
   * `polite` Adjust the notification behavior of screen readers
   */
  "aria-live": import_prop_types67.default.oneOf(["polite", "assertive", "off"]),
  children: import_prop_types67.default.node,
  className: import_prop_types67.default.string
};

// node_modules/@carbon/react/es/components/DataTable/TableCell.js
var import_react98 = __toESM(require_react());
var import_classnames57 = __toESM(require_classnames());
var import_prop_types68 = __toESM(require_prop_types());
var frFn4 = import_react98.forwardRef;
var TableCell = frFn4((props, ref) => {
  const {
    children,
    className,
    hasAILabelHeader,
    colSpan,
    ...rest
  } = props;
  const prefix = usePrefix();
  const tableCellClassNames = (0, import_classnames57.default)(className, {
    [`${prefix}--table-cell--column-slug`]: hasAILabelHeader
  });
  return import_react98.default.createElement("td", _extends({
    className: tableCellClassNames ? tableCellClassNames : void 0,
    ref,
    colSpan
  }, rest), children);
});
TableCell.displayName = "TableCell";
TableCell.propTypes = {
  /**
   * Pass in children that will be embedded in the table header label
   */
  children: import_prop_types68.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types68.default.string,
  /**
   * The width of the expanded row's internal cell
   */
  colSpan: import_prop_types68.default.number,
  /**
   * Specify if the table cell is in an AI column
   */
  hasAILabelHeader: import_prop_types68.default.bool,
  /**
   * The id of the matching th node in the table head. Addresses a11y concerns outlined here: https://www.ibm.com/able/guidelines/ci162/info_and_relationships.html and https://www.w3.org/TR/WCAG20-TECHS/H43
   */
  headers: import_prop_types68.default.string
};

// node_modules/@carbon/react/es/components/DataTable/TableContainer.js
var import_classnames58 = __toESM(require_classnames());
var import_prop_types70 = __toESM(require_prop_types());
var import_react100 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Heading/index.js
var import_prop_types69 = __toESM(require_prop_types());
var import_react99 = __toESM(require_react());
var HeadingContext = import_react99.default.createContext(1);
var Section = import_react99.default.forwardRef(function Section2({
  as: BaseComponent = "section",
  level: levelOverride,
  ...rest
}, ref) {
  const parentLevel = import_react99.default.useContext(HeadingContext);
  const level = levelOverride ?? parentLevel + 1;
  const BaseComponentAsAny = BaseComponent;
  return import_react99.default.createElement(HeadingContext.Provider, {
    value: Math.min(level, 6)
  }, import_react99.default.createElement(BaseComponentAsAny, _extends({
    ref
  }, rest)));
});
Section.propTypes = {
  /**
   * Provide an alternative tag or component to use instead of the default
   * <section> element
   */
  as: import_prop_types69.default.elementType,
  /**
   * Specify the content that will be placed in the component
   */
  children: import_prop_types69.default.node,
  /**
   * Specify a class name for the outermost node of the component
   */
  className: import_prop_types69.default.string,
  /**
   * Overrides the level of the section
   */
  level: import_prop_types69.default.number
};
var Heading = import_react99.default.forwardRef(function Heading2(props, ref) {
  const HeadingIntrinsic = `h${import_react99.default.useContext(HeadingContext)}`;
  return import_react99.default.createElement(HeadingIntrinsic, _extends({
    ref
  }, props));
});
Heading.propTypes = {
  /**
   * Specify the content that will be placed in the component
   */
  children: import_prop_types69.default.node,
  /**
   * Specify a class name for the outermost node of the component
   */
  className: import_prop_types69.default.string
};

// node_modules/@carbon/react/es/components/DataTable/TableContainer.js
var TableContainer = ({
  aiEnabled,
  className,
  children,
  title,
  description,
  stickyHeader,
  useStaticWidth,
  ...rest
}) => {
  const baseId = useId("tc");
  const titleId = `${baseId}-title`;
  const descriptionId = `${baseId}-description`;
  const prefix = usePrefix();
  const tableContainerClasses = (0, import_classnames58.default)(className, `${prefix}--data-table-container`, {
    [`${prefix}--data-table--max-width`]: stickyHeader,
    [`${prefix}--data-table-container--static`]: useStaticWidth,
    [`${prefix}--data-table-container--ai-enabled`]: aiEnabled
  });
  const value = (0, import_react100.useMemo)(() => {
    return {
      titleId: title ? titleId : void 0,
      descriptionId: description ? descriptionId : void 0
    };
  }, [title, description, titleId, descriptionId]);
  return import_react100.default.createElement(TableContext.Provider, {
    value
  }, import_react100.default.createElement(Section, _extends({}, rest, {
    className: tableContainerClasses
  }), (title || description) && import_react100.default.createElement("div", {
    className: `${prefix}--data-table-header`
  }, title && import_react100.default.createElement(Heading, {
    className: `${prefix}--data-table-header__title`,
    id: titleId
  }, title), description && import_react100.default.createElement("p", {
    className: `${prefix}--data-table-header__description`,
    id: descriptionId
  }, description)), children));
};
TableContainer.propTypes = {
  /**
   * Specify if the entire table has AI generated contents
   */
  aiEnabled: import_prop_types70.default.bool,
  children: import_prop_types70.default.node,
  className: import_prop_types70.default.string,
  /**
   * Optional description text for the Table
   */
  description: import_prop_types70.default.node,
  /**
   * Specify whether the table should have a sticky header
   */
  stickyHeader: import_prop_types70.default.bool,
  /**
   * Provide a title for the Table
   */
  title: import_prop_types70.default.node,
  /**
   * If true, will use a width of 'fit-content' to match the inner table width
   */
  useStaticWidth: import_prop_types70.default.bool
};

// node_modules/@carbon/react/es/components/DataTable/TableDecoratorRow.js
var import_classnames59 = __toESM(require_classnames());
var import_prop_types71 = __toESM(require_prop_types());
var import_react101 = __toESM(require_react());
var TableDecoratorRow = ({
  className,
  decorator
}) => {
  const prefix = usePrefix();
  const TableDecoratorRowClasses = (0, import_classnames59.default)({
    ...className && {
      [className]: true
    },
    [`${prefix}--table-column-decorator`]: true,
    [`${prefix}--table-column-decorator--active`]: decorator
  });
  const decoratorIsAILabel = isComponentElement(decorator, AILabel);
  const normalizedDecorator = decoratorIsAILabel ? (0, import_react101.cloneElement)(decorator, {
    size: "mini"
  }) : null;
  return import_react101.default.createElement("td", {
    className: TableDecoratorRowClasses
  }, normalizedDecorator);
};
TableDecoratorRow.displayName = "TableDecoratorRow";
TableDecoratorRow.propTypes = {
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types71.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `TableDecoratorRow` component
   */
  decorator: import_prop_types71.default.node
};

// node_modules/@carbon/react/es/components/DataTable/TableExpandHeader.js
var import_classnames60 = __toESM(require_classnames());
var import_prop_types72 = __toESM(require_prop_types());
var import_react102 = __toESM(require_react());
var TableExpandHeader = ({
  ["aria-controls"]: ariaControls,
  ["aria-label"]: ariaLabel,
  ariaLabel: deprecatedAriaLabel,
  className: headerClassName,
  enableExpando,
  enableToggle,
  id = "expand",
  isExpanded,
  onExpand,
  expandIconDescription,
  children,
  ...rest
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames60.default)(`${prefix}--table-expand`, headerClassName);
  const previousValue = isExpanded ? "collapsed" : void 0;
  return import_react102.default.createElement("th", _extends({
    scope: "col",
    className,
    "data-previous-value": previousValue,
    id
  }, rest), enableExpando || enableToggle ? import_react102.default.createElement("button", {
    type: "button",
    className: `${prefix}--table-expand__button`,
    onClick: onExpand,
    title: expandIconDescription,
    "aria-label": deprecatedAriaLabel || ariaLabel,
    "aria-expanded": isExpanded,
    "aria-controls": ariaControls
  }, import_react102.default.createElement(ChevronRight, {
    className: `${prefix}--table-expand__svg`,
    "aria-label": expandIconDescription
  })) : null, children);
};
TableExpandHeader.propTypes = {
  /**
   * Space separated list of one or more ID values referencing the TableExpandedRow(s) being controlled by the TableExpandHeader
   */
  ["aria-controls"]: import_prop_types72.default.string,
  /**
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  ["aria-label"]: import_prop_types72.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  ariaLabel: import_prop_types72.default.string,
  children: import_prop_types72.default.node,
  className: import_prop_types72.default.string,
  /**
   * The enableExpando prop is being replaced by TableExpandHeader
   */
  enableExpando: deprecate(import_prop_types72.default.bool, "The `enableExpando` prop has been deprecated in favor of `enableToggle`. This prop will be removed in the next major release."),
  /**
   * Specify whether an expand all button should be displayed
   */
  enableToggle: import_prop_types72.default.bool,
  /**
   * The description of the chevron right icon, to be put in its SVG `<title>` element.
   */
  expandIconDescription: import_prop_types72.default.string,
  /**
   * Supply an id to the th element.
   */
  id: import_prop_types72.default.string,
  /**
   * Specify whether this row is expanded or not. This helps coordinate data
   * attributes so that `TableExpandRow` and `TableExpandedRow` work together
   */
  isExpanded: requiredIfGivenPropIsTruthy("enableToggle", import_prop_types72.default.bool),
  /**
   * Hook for when a listener initiates a request to expand the given row
   */
  onExpand: import_prop_types72.default.oneOfType([requiredIfGivenPropIsTruthy("enableExpando", import_prop_types72.default.func), requiredIfGivenPropIsTruthy("enableToggle", import_prop_types72.default.func)])
};

// node_modules/@carbon/react/es/components/DataTable/TableExpandRow.js
var import_classnames62 = __toESM(require_classnames());
var import_prop_types74 = __toESM(require_prop_types());
var import_react104 = __toESM(require_react());

// node_modules/@carbon/react/es/components/DataTable/TableSlugRow.js
var import_prop_types73 = __toESM(require_prop_types());
var import_react103 = __toESM(require_react());
var import_classnames61 = __toESM(require_classnames());

// node_modules/@carbon/react/es/prop-types/deprecateComponent.js
var didWarnAboutDeprecation2 = {};
function deprecateComponent(componentName, message) {
  if (!didWarnAboutDeprecation2[componentName]) {
    didWarnAboutDeprecation2[componentName] = true;
    true ? warning(false, message) : void 0;
  }
  return componentName;
}

// node_modules/@carbon/react/es/components/DataTable/TableSlugRow.js
var TableSlugRow = ({
  className,
  slug
}) => {
  (0, import_react103.useEffect)(() => {
    deprecateComponent("TableSlugRow", "The `TableSlugRow` component has been deprecated and will be removed in the next major version. Use the TableDecoratorRow component instead.");
  }, []);
  const prefix = usePrefix();
  const TableSlugRowClasses = (0, import_classnames61.default)({
    ...className && {
      [className]: true
    },
    [`${prefix}--table-column-slug`]: true,
    [`${prefix}--table-column-slug--active`]: slug
  });
  let normalizedSlug;
  if (slug) {
    normalizedSlug = import_react103.default.cloneElement(slug, {
      size: "mini"
    });
  }
  return import_react103.default.createElement("td", {
    className: TableSlugRowClasses
  }, normalizedSlug);
};
TableSlugRow.displayName = "TableSlugRow";
TableSlugRow.propTypes = {
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types73.default.string,
  /**
   * Provide a `Slug` component to be rendered inside the `TableSlugRow` component
   */
  slug: import_prop_types73.default.node
};

// node_modules/@carbon/react/es/components/DataTable/TableExpandRow.js
var TableExpandRow = import_react104.default.forwardRef(({
  ["aria-controls"]: ariaControls,
  ["aria-label"]: ariaLabel,
  ariaLabel: deprecatedAriaLabel,
  className: rowClassName,
  children,
  isExpanded,
  onExpand,
  expandIconDescription,
  isSelected,
  expandHeader = "expand",
  ...rest
}, ref) => {
  const prefix = usePrefix();
  let rowHasAILabel;
  const decorator = import_react104.Children.toArray(children).map((child) => {
    if (isComponentElement(child, TableSlugRow)) {
      if (child.props.slug) {
        rowHasAILabel = true;
      }
      return child;
    } else if (isComponentElement(child, TableDecoratorRow)) {
      if (isComponentElement(child.props.decorator, AILabel)) {
        rowHasAILabel = true;
      }
      return child;
    }
  });
  const normalizedChildren = import_react104.Children.toArray(children).map((child) => {
    if ((0, import_react104.isValidElement)(child) && child.type !== TableSlugRow && child.type !== TableDecoratorRow) {
      return child;
    }
  });
  const className = (0, import_classnames62.default)({
    [`${prefix}--parent-row`]: true,
    [`${prefix}--expandable-row`]: isExpanded,
    [`${prefix}--data-table--selected`]: isSelected,
    [`${prefix}--data-table--slug-row ${prefix}--data-table--ai-label-row`]: rowHasAILabel
  }, rowClassName);
  const previousValue = isExpanded ? "collapsed" : void 0;
  return import_react104.default.createElement("tr", _extends({}, rest, {
    ref,
    className,
    "data-parent-row": true
  }), decorator, import_react104.default.createElement(TableCell, {
    className: `${prefix}--table-expand`,
    "data-previous-value": previousValue,
    headers: expandHeader
  }, import_react104.default.createElement("button", {
    type: "button",
    className: `${prefix}--table-expand__button`,
    onClick: onExpand,
    title: expandIconDescription,
    "aria-label": deprecatedAriaLabel || ariaLabel,
    "aria-expanded": isExpanded,
    "aria-controls": ariaControls
  }, import_react104.default.createElement(ChevronRight, {
    className: `${prefix}--table-expand__svg`,
    "aria-label": expandIconDescription
  }))), normalizedChildren);
});
TableExpandRow.propTypes = {
  /**
   * Space separated list of one or more ID values referencing the TableExpandedRow(s) being controlled by the TableExpandRow
   * TODO: make this required in v12
   */
  ["aria-controls"]: import_prop_types74.default.string,
  /**
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  /**@ts-ignore*/
  ["aria-label"]: import_prop_types74.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the string read by a voice reader when the expand trigger is
   * focused
   */
  ariaLabel: import_prop_types74.default.string,
  children: import_prop_types74.default.node,
  className: import_prop_types74.default.string,
  /**
   * The id of the matching th node in the table head. Addresses a11y concerns outlined here: https://www.ibm.com/able/guidelines/ci162/info_and_relationships.html and https://www.w3.org/TR/WCAG20-TECHS/H43
   */
  expandHeader: import_prop_types74.default.string,
  /**
   * The description of the chevron right icon, to be put in its SVG `<title>` element.
   */
  expandIconDescription: import_prop_types74.default.string,
  /**
   * Specify whether this row is expanded or not. This helps coordinate data
   * attributes so that `TableExpandRow` and `TableExpandedRow` work together
   */
  isExpanded: import_prop_types74.default.bool,
  /**
   * Specify if the row is selected
   */
  isSelected: import_prop_types74.default.bool,
  /**
   * Hook for when a listener initiates a request to expand the given row
   */
  onExpand: import_prop_types74.default.func.isRequired
};
TableExpandRow.displayName = "TableExpandRow";

// node_modules/@carbon/react/es/components/DataTable/TableExpandedRow.js
var import_classnames63 = __toESM(require_classnames());
var import_prop_types75 = __toESM(require_prop_types());
var import_react105 = __toESM(require_react());
var TableExpandedRow = ({
  className: customClassName,
  children,
  colSpan,
  ...rest
}) => {
  const rowRef = (0, import_react105.useRef)(null);
  const prefix = usePrefix();
  const className = (0, import_classnames63.default)(`${prefix}--expandable-row`, customClassName);
  const toggleParentHoverClass = (eventType) => {
    if (rowRef && rowRef.current && rowRef.current.previousElementSibling) {
      const parentNode = rowRef.current.previousElementSibling;
      if (eventType === "enter") {
        parentNode.classList.add(`${prefix}--expandable-row--hover`);
      } else {
        parentNode.classList.remove(`${prefix}--expandable-row--hover`);
      }
    }
  };
  return import_react105.default.createElement("tr", _extends({
    ref: rowRef,
    onMouseEnter: () => toggleParentHoverClass("enter"),
    onMouseLeave: () => toggleParentHoverClass("leave")
  }, rest, {
    className,
    "data-child-row": true
  }), import_react105.default.createElement(TableCell, {
    colSpan
  }, import_react105.default.createElement("div", {
    className: `${prefix}--child-row-inner-container`
  }, children)));
};
TableExpandedRow.propTypes = {
  /**
   * Pass in the contents for your TableExpandedRow
   */
  children: import_prop_types75.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types75.default.string,
  /**
   * The width of the expanded row's internal cell
   */
  colSpan: import_prop_types75.default.number.isRequired
};

// node_modules/@carbon/react/es/components/DataTable/TableHead.js
var TableHead = wrapComponent({
  name: "TableHead",
  type: "thead"
});

// node_modules/@carbon/react/es/components/DataTable/TableHeader.js
var import_classnames64 = __toESM(require_classnames());
var import_prop_types76 = __toESM(require_prop_types());
var import_react106 = __toESM(require_react());
var defaultScope = "col";
var translationKeys2 = {
  buttonDescription: "carbon.table.header.icon.description"
};
var translateWithId2 = (key, args) => {
  if (args && key === translationKeys2.buttonDescription) {
    if (args.isSortHeader && sortStates) {
      if (args.sortDirection === sortStates.NONE) {
        return `Click to sort rows by ${args.header} header in ascending order`;
      }
      if (args.sortDirection === sortStates.ASC) {
        return `Click to sort rows by ${args.header} header in descending order`;
      }
      return `Click to unsort rows by ${args.header} header`;
    }
    return `Click to sort rows by ${args.header} header in ascending order`;
  }
  return "";
};
var sortDirections = {
  [sortStates.NONE]: "none",
  [sortStates.ASC]: "ascending",
  [sortStates.DESC]: "descending"
};
var TableHeader = import_react106.default.forwardRef(function TableHeader2({
  className: headerClassName,
  children,
  colSpan,
  decorator,
  isSortable = false,
  isSortHeader,
  onClick,
  scope = defaultScope,
  sortDirection,
  translateWithId: t3 = translateWithId2,
  slug,
  id,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const uniqueId = useId("table-sort");
  const AILableRef = (0, import_react106.useRef)(null);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const colHasAILabel = candidateIsAILabel;
  const normalizedDecorator = candidateIsAILabel ? (0, import_react106.cloneElement)(candidate, {
    size: "mini",
    ref: AILableRef
  }) : null;
  const headerLabelClassNames = (0, import_classnames64.default)({
    [`${prefix}--table-header-label`]: true,
    [`${prefix}--table-header-label--slug ${prefix}--table-header-label--ai-label`]: colHasAILabel,
    [`${prefix}--table-header-label--decorator`]: decorator
  });
  if (!isSortable) {
    return import_react106.default.createElement("th", _extends({}, rest, {
      id,
      className: headerClassName,
      scope,
      colSpan,
      ref
    }), children ? import_react106.default.createElement("div", {
      className: headerLabelClassNames
    }, children, import_react106.default.createElement("div", {
      className: `${prefix}--table-header-label--decorator-inner`
    }, normalizedDecorator)) : null);
  }
  const className = (0, import_classnames64.default)(headerClassName, {
    [`${prefix}--table-sort`]: true,
    [`${prefix}--table-sort--active`]: isSortHeader && sortDirection !== sortStates.NONE,
    [`${prefix}--table-sort--descending`]: isSortHeader && sortDirection === sortStates.DESC
  });
  const ariaSort = !isSortHeader || !sortDirection ? "none" : sortDirections[sortDirection];
  const sortDescription = t3 && t3("carbon.table.header.icon.description", {
    header: children,
    sortDirection,
    isSortHeader,
    sortStates
  });
  const headerClasses = (0, import_classnames64.default)(headerClassName, `${prefix}--table-sort__header`, {
    [`${prefix}--table-sort__header--ai-label`]: colHasAILabel,
    [`${prefix}--table-sort__header--decorator`]: decorator
  });
  const handleClick2 = (evt) => {
    if (colHasAILabel && AILableRef.current && AILableRef.current.contains(evt.target)) {
      return;
    } else if (onClick) {
      return onClick(evt);
    }
  };
  return import_react106.default.createElement("th", {
    id,
    "aria-sort": ariaSort,
    className: headerClasses,
    colSpan,
    ref,
    scope
  }, import_react106.default.createElement("div", {
    className: `${prefix}--table-sort__description`,
    id: uniqueId
  }, sortDescription), import_react106.default.createElement("button", _extends({
    type: "button",
    "aria-describedby": uniqueId,
    className,
    onClick: handleClick2
  }, rest), import_react106.default.createElement("span", {
    className: `${prefix}--table-sort__flex`
  }, import_react106.default.createElement("div", {
    className: `${prefix}--table-header-label`
  }, children), import_react106.default.createElement(ArrowUp, {
    size: 20,
    className: `${prefix}--table-sort__icon`
  }), import_react106.default.createElement(ArrowsVertical, {
    size: 20,
    className: `${prefix}--table-sort__icon-unsorted`
  }), import_react106.default.createElement("div", {
    className: `${prefix}--table-header-label--decorator-inner`
  }, normalizedDecorator))));
});
TableHeader.propTypes = {
  /**
   * Pass in children that will be embedded in the table header label
   */
  children: import_prop_types76.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types76.default.string,
  /**
   * Specify `colSpan` as a non-negative integer value to indicate how
   * many columns the TableHeader cell extends in a table
   */
  colSpan: import_prop_types76.default.number,
  /**
   * Supply an id to the th element.
   */
  id: import_prop_types76.default.string,
  /**
   * Specify whether this header is the header by which a table is being sorted
   * by
   */
  isSortHeader: import_prop_types76.default.bool,
  /**
   * Specify whether this header is one through which a user can sort the table
   */
  isSortable: import_prop_types76.default.bool,
  /**
   * Hook that is invoked when the header is clicked
   */
  onClick: import_prop_types76.default.func,
  /**
   * Specify the scope of this table header. You can find more info about this
   * attribute at the following URL:
   * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/th#attr-scope
   */
  scope: import_prop_types76.default.string,
  /**
   * Specify which direction we are currently sorting by, should be one of DESC,
   * NONE, or ASC.
   */
  sortDirection: import_prop_types76.default.oneOf(Object.values(sortStates)),
  /**
   * Supply a method to translate internal strings with your i18n tool of
   * choice. Translation keys are available on the `translationKeys` field for
   * this component.
   */
  translateWithId: import_prop_types76.default.func
};
TableHeader.translationKeys = Object.values(translationKeys2);
TableHeader.displayName = "TableHeader";

// node_modules/@carbon/react/es/components/DataTable/TableRow.js
var import_react107 = __toESM(require_react());
var import_prop_types77 = __toESM(require_prop_types());
var import_classnames65 = __toESM(require_classnames());
var TableRow = import_react107.default.forwardRef((props, ref) => {
  const prefix = usePrefix();
  let rowHasAILabel;
  if (props == null ? void 0 : props.children) {
    import_react107.Children.toArray(props.children).map((child) => {
      if (isComponentElement(child, TableSlugRow)) {
        if (child.props.slug) {
          rowHasAILabel = true;
        }
      } else if (isComponentElement(child, TableDecoratorRow) && isComponentElement(child.props.decorator, AILabel)) {
        rowHasAILabel = true;
      }
    });
  }
  const className = (0, import_classnames65.default)(props.className, {
    [`${prefix}--data-table--selected`]: props.isSelected,
    [`${prefix}--data-table--slug-row ${prefix}--data-table--ai-label-row`]: rowHasAILabel
  });
  const {
    ariaLabel,
    "aria-label": ariaLabelAlt,
    "aria-controls": ariaControls,
    onExpand,
    isExpanded,
    isSelected,
    ...cleanProps
  } = props;
  if (className) {
    cleanProps.className = className;
  }
  return import_react107.default.createElement("tr", _extends({
    ref
  }, cleanProps));
});
TableRow.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types77.default.string,
  /**
   * Specify if the row is selected
   */
  isSelected: import_prop_types77.default.bool
};

// node_modules/@carbon/react/es/components/DataTable/TableSelectAll.js
var import_prop_types79 = __toESM(require_prop_types());
var import_react109 = __toESM(require_react());

// node_modules/@carbon/react/es/components/InlineCheckbox/InlineCheckbox.js
var import_prop_types78 = __toESM(require_prop_types());
var import_react108 = __toESM(require_react());
var InlineCheckbox = import_react108.default.forwardRef(function InlineCheckbox2(props, forwardRef36) {
  const {
    ["aria-label"]: ariaLabel,
    ariaLabel: deprecatedAriaLabel,
    checked = false,
    disabled,
    id,
    indeterminate,
    name,
    onChange = () => {
    },
    onClick,
    onKeyDown,
    title
  } = props;
  const prefix = usePrefix();
  const inputRef = (0, import_react108.useRef)(null);
  const ref = useMergedRefs([inputRef, forwardRef36]);
  const inputProps = {
    checked,
    className: `${prefix}--checkbox`,
    disabled,
    id,
    name,
    onClick: onClick ? onClickCheckBoxInput : onClick,
    onChange: (evt) => {
      onChange(evt.target.checked, id, evt);
    },
    onKeyDown,
    ref,
    type: "checkbox"
  };
  if (indeterminate) {
    inputProps.checked = false;
  }
  (0, import_react108.useEffect)(() => {
    if (inputRef == null ? void 0 : inputRef.current) {
      inputRef.current.indeterminate = indeterminate || false;
    }
  }, [indeterminate]);
  function onClickCheckBoxInput(evt) {
    if (indeterminate) {
      evt.target.checked = false;
    }
    onClick == null ? void 0 : onClick(evt);
  }
  return import_react108.default.createElement(
    "div",
    {
      className: `${prefix}--checkbox--inline`
    },
    import_react108.default.createElement("input", inputProps),
    /* eslint-disable jsx-a11y/label-has-for,jsx-a11y/label-has-associated-control,jsx-a11y/click-events-have-key-events,jsx-a11y/no-noninteractive-element-interactions */
    import_react108.default.createElement("label", {
      htmlFor: id,
      className: `${prefix}--checkbox-label`,
      title,
      onClick: (evt) => {
        evt.stopPropagation();
      }
    }, import_react108.default.createElement("span", {
      className: `${prefix}--visually-hidden`
    }, deprecatedAriaLabel || ariaLabel))
  );
});
InlineCheckbox.propTypes = {
  /**
   * Specify the label for the control
   */
  ["aria-label"]: import_prop_types78.default.string.isRequired,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the label for the control
   */
  ariaLabel: deprecate(import_prop_types78.default.string.isRequired, "The `ariaLabel` prop has been deprecated in favor of `aria-label`. This prop will be removed in the next major release."),
  /**
   * Specify whether the underlying control is checked, or not
   */
  checked: import_prop_types78.default.bool,
  /**
   * Specify whether the underlying input control should be disabled
   */
  disabled: import_prop_types78.default.bool,
  /**
   * Provide an `id` for the underlying input control
   */
  id: import_prop_types78.default.string.isRequired,
  /**
   * Specify whether the control is in an indeterminate state
   */
  indeterminate: import_prop_types78.default.bool,
  /**
   * Provide a `name` for the underlying input control
   */
  name: import_prop_types78.default.string.isRequired,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types78.default.func,
  /**
   * Provide a handler that is invoked when a user clicks on the control
   */
  onClick: import_prop_types78.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the control
   */
  onKeyDown: import_prop_types78.default.func,
  /**
   * Provide an optional tooltip for the InlineCheckbox
   */
  title: import_prop_types78.default.string
};

// node_modules/@carbon/react/es/components/DataTable/TableSelectAll.js
var import_classnames66 = __toESM(require_classnames());
var TableSelectAll = ({
  ariaLabel: deprecatedAriaLabel = "Select all rows in the table",
  ["aria-label"]: ariaLabel,
  checked,
  id,
  indeterminate,
  name,
  onSelect,
  disabled,
  className
}) => {
  const prefix = usePrefix();
  return import_react109.default.createElement("th", {
    "aria-live": "off",
    scope: "col",
    className: (0, import_classnames66.default)(`${prefix}--table-column-checkbox`, className)
  }, import_react109.default.createElement(InlineCheckbox, {
    "aria-label": ariaLabel || deprecatedAriaLabel,
    checked,
    id,
    indeterminate,
    name,
    onClick: onSelect,
    disabled
  }));
};
TableSelectAll.propTypes = {
  /**
   * Specify the aria label for the underlying input control
   */
  ["aria-label"]: import_prop_types79.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the aria label for the underlying input control
   */
  ariaLabel: deprecate(import_prop_types79.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify whether all items are selected, or not
   */
  checked: import_prop_types79.default.bool,
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types79.default.string,
  /**
   * Specify whether the checkbox input should be disabled
   */
  disabled: import_prop_types79.default.bool,
  /**
   * Provide an `id` for the underlying input control
   */
  id: import_prop_types79.default.string.isRequired,
  /**
   * Specify whether the selection only has a subset of all items
   */
  indeterminate: import_prop_types79.default.bool,
  /**
   * Provide a `name` for the underlying input control
   */
  name: import_prop_types79.default.string.isRequired,
  /**
   * Provide a handler to listen to when a user initiates a selection request
   */
  onSelect: import_prop_types79.default.func.isRequired
};

// node_modules/@carbon/react/es/components/DataTable/TableSelectRow.js
var import_prop_types81 = __toESM(require_prop_types());
var import_react111 = __toESM(require_react());
var import_classnames68 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/RadioButton/RadioButton.js
var import_prop_types80 = __toESM(require_prop_types());
var import_react110 = __toESM(require_react());
var import_classnames67 = __toESM(require_classnames());
var RadioButton2 = import_react110.default.forwardRef((props, ref) => {
  var _a;
  const {
    className,
    decorator,
    disabled,
    hideLabel,
    id,
    labelPosition = "right",
    labelText = "",
    name,
    onChange = () => {
    },
    value = "",
    slug,
    required,
    ...rest
  } = props;
  const prefix = usePrefix();
  const uid = useId("radio-button");
  const uniqueId = id || uid;
  function handleOnChange(event) {
    onChange(value, name, event);
  }
  const innerLabelClasses = (0, import_classnames67.default)(`${prefix}--radio-button__label-text`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const wrapperClasses = (0, import_classnames67.default)(className, `${prefix}--radio-button-wrapper`, {
    [`${prefix}--radio-button-wrapper--label-${labelPosition}`]: labelPosition !== "right",
    [`${prefix}--radio-button-wrapper--slug`]: slug,
    [`${prefix}--radio-button-wrapper--decorator`]: decorator
  });
  const inputRef = (0, import_react110.useRef)(null);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react110.cloneElement)(candidate, {
    size: ((_a = candidate.props) == null ? void 0 : _a["kind"]) === "inline" ? "md" : "mini"
  }) : null;
  return import_react110.default.createElement("div", {
    className: wrapperClasses
  }, import_react110.default.createElement("input", _extends({}, rest, {
    type: "radio",
    className: `${prefix}--radio-button`,
    onChange: handleOnChange,
    id: uniqueId,
    ref: mergeRefs(inputRef, ref),
    disabled,
    value,
    name,
    required
  })), import_react110.default.createElement("label", {
    htmlFor: uniqueId,
    className: `${prefix}--radio-button__label`
  }, import_react110.default.createElement("span", {
    className: `${prefix}--radio-button__appearance`
  }), labelText && import_react110.default.createElement(Text, {
    className: innerLabelClasses
  }, labelText, slug ? normalizedDecorator : decorator ? import_react110.default.createElement("div", {
    className: `${prefix}--radio-button-wrapper-inner--decorator`
  }, normalizedDecorator) : "")));
});
RadioButton2.displayName = "RadioButton";
RadioButton2.propTypes = {
  /**
   * Specify whether the `<RadioButton>` is currently checked
   */
  checked: import_prop_types80.default.bool,
  /**
   * Provide an optional className to be applied to the containing node
   */
  className: import_prop_types80.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `RadioButton` component
   */
  decorator: import_prop_types80.default.node,
  /**
   * Specify whether the `<RadioButton>` should be checked by default
   */
  defaultChecked: import_prop_types80.default.bool,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types80.default.bool,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types80.default.bool,
  /**
   * Provide a unique id for the underlying `<input>` node
   */
  id: import_prop_types80.default.string,
  /**
   * Provide where label text should be placed
   * NOTE: `top`/`bottom` are deprecated
   */
  labelPosition: import_prop_types80.default.oneOf(["right", "left"]),
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types80.default.node.isRequired,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types80.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types80.default.func,
  /**
   * Provide a handler that is invoked when a user clicks on the control
   */
  onClick: import_prop_types80.default.func,
  /**
   * `true` to specify if the control is required.
   */
  required: import_prop_types80.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `RadioButton` component
   */
  slug: deprecate(import_prop_types80.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify the value of the `<RadioButton>`
   */
  value: import_prop_types80.default.oneOfType([import_prop_types80.default.string, import_prop_types80.default.number])
};

// node_modules/@carbon/react/es/components/DataTable/TableSelectRow.js
var TableSelectRow = ({
  ariaLabel: deprecatedAriaLabel,
  ["aria-label"]: ariaLabel,
  checked,
  id,
  name,
  onSelect,
  onChange,
  disabled,
  radio,
  className
}) => {
  const prefix = usePrefix();
  const uniqueNameId = useId();
  const handleRadioChange = onChange ? (value, name2, event) => {
    onChange(!!value, name2 || "", event);
  } : void 0;
  const handleCheckboxChange = onChange ? (checked2, name2, event) => {
    onChange(checked2, name2, event);
  } : void 0;
  const selectionInputProps = {
    id,
    name: name ? name : uniqueNameId,
    onClick: onSelect,
    checked,
    disabled
  };
  const labelValue = ariaLabel || deprecatedAriaLabel || "";
  const tableSelectRowClasses = (0, import_classnames68.default)(`${prefix}--table-column-checkbox`, {
    ...className && {
      [className]: true
    },
    [`${prefix}--table-column-radio`]: radio
  });
  return import_react111.default.createElement("td", {
    className: tableSelectRowClasses,
    "aria-live": "off"
  }, radio ? import_react111.default.createElement(RadioButton2, _extends({}, selectionInputProps, {
    labelText: labelValue,
    onChange: handleRadioChange,
    hideLabel: true
  })) : import_react111.default.createElement(InlineCheckbox, _extends({}, selectionInputProps, {
    "aria-label": labelValue,
    onChange: handleCheckboxChange
  })));
};
TableSelectRow.propTypes = {
  /**
   * Specify the aria label for the underlying input control
   */
  ["aria-label"]: import_prop_types81.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify the aria label for the underlying input control
   */
  ariaLabel: deprecate(import_prop_types81.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify whether this row is selected, or not
   */
  checked: import_prop_types81.default.bool,
  /**
   * The CSS class names of the cell that wraps the underlying input control
   */
  className: import_prop_types81.default.string,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types81.default.bool,
  /**
   * Provide an `id` for the underlying input control
   */
  id: import_prop_types81.default.string.isRequired,
  /**
   * Provide a `name` for the underlying input control
   */
  name: import_prop_types81.default.string.isRequired,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types81.default.func,
  /**
   * Provide a handler to listen to when a user initiates a selection request
   */
  onSelect: import_prop_types81.default.func.isRequired,
  /**
   * Specify whether the control should be a radio button or inline checkbox
   */
  radio: import_prop_types81.default.bool
};

// node_modules/@carbon/react/es/components/DataTable/TableToolbar.js
var import_classnames69 = __toESM(require_classnames());
var import_prop_types82 = __toESM(require_prop_types());
var import_react112 = __toESM(require_react());
var TableToolbar = ({
  ["aria-label"]: ariaLabel = "data table toolbar",
  ariaLabel: deprecatedAriaLabel,
  children,
  size: size4,
  ...rest
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames69.default)({
    [`${prefix}--table-toolbar`]: true,
    [`${prefix}--table-toolbar--${size4}`]: size4
  });
  return import_react112.default.createElement("section", _extends({
    "aria-label": deprecatedAriaLabel || ariaLabel
  }, rest, {
    className
  }), children);
};
TableToolbar.propTypes = {
  /**
   * 'aria-label' of the TableToolbar component.
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types82.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container node.
   * 'aria-label' of the TableToolbar component.
   */
  ariaLabel: deprecate(import_prop_types82.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Pass in the children that will be rendered inside the TableToolbar
   */
  children: import_prop_types82.default.node,
  /**
   * `lg` Change the row height of table
   */
  size: import_prop_types82.default.oneOf(["sm", "lg"])
};

// node_modules/@carbon/react/es/components/DataTable/TableToolbarAction.js
var import_prop_types84 = __toESM(require_prop_types());
var import_react114 = __toESM(require_react());

// node_modules/@carbon/react/es/components/OverflowMenuItem/OverflowMenuItem.js
var import_classnames70 = __toESM(require_classnames());
var import_prop_types83 = __toESM(require_prop_types());
var import_react113 = __toESM(require_react());
var frFn5 = import_react113.forwardRef;
var OverflowMenuItem = frFn5((props, ref) => {
  const {
    className,
    closeMenu,
    disabled = false,
    handleOverflowMenuItemFocus,
    hasDivider = false,
    href,
    isDelete = false,
    index: index3,
    itemText = "Provide itemText",
    onClick = () => {
    },
    onKeyDown = () => {
    },
    requireTitle,
    title,
    wrapperClassName,
    ...rest
  } = props;
  const prefix = usePrefix();
  function setTabFocus(evt) {
    if (match(evt, ArrowDown)) {
      handleOverflowMenuItemFocus == null ? void 0 : handleOverflowMenuItemFocus({
        currentIndex: index3,
        direction: 1
      });
    }
    if (match(evt, ArrowUp2)) {
      handleOverflowMenuItemFocus == null ? void 0 : handleOverflowMenuItemFocus({
        currentIndex: index3,
        direction: -1
      });
    }
  }
  function handleClick2(evt) {
    onClick(evt);
    if (closeMenu) {
      closeMenu();
    }
  }
  true ? warning(!!closeMenu, "`<OverflowMenuItem>` detected missing `closeMenu` prop. `closeMenu` is required to let `<OverflowMenu>` close the menu upon actions on `<OverflowMenuItem>`. Please make sure `<OverflowMenuItem>` is a direct child of `<OverflowMenu>.") : void 0;
  const overflowMenuBtnClasses = (0, import_classnames70.default)(`${prefix}--overflow-menu-options__btn`, className);
  const overflowMenuItemClasses = (0, import_classnames70.default)(`${prefix}--overflow-menu-options__option`, {
    [`${prefix}--overflow-menu--divider`]: hasDivider,
    [`${prefix}--overflow-menu-options__option--danger`]: isDelete,
    [`${prefix}--overflow-menu-options__option--disabled`]: disabled
  }, wrapperClassName);
  const TagToUse = href ? "a" : "button";
  const OverflowMenuItemContent = (() => {
    if (typeof itemText !== "string") {
      return itemText;
    }
    return import_react113.default.createElement("div", {
      className: `${prefix}--overflow-menu-options__option-content`
    }, itemText);
  })();
  return import_react113.default.createElement(Text, {
    as: "li",
    className: overflowMenuItemClasses,
    role: "none"
  }, import_react113.default.createElement(TagToUse, _extends({
    className: overflowMenuBtnClasses,
    disabled,
    href,
    onClick: handleClick2,
    onKeyDown: (evt) => {
      setTabFocus(evt);
      onKeyDown(evt);
    },
    role: "menuitem",
    ref,
    tabIndex: -1,
    title: requireTitle ? title || itemText : void 0
  }, rest), OverflowMenuItemContent));
});
OverflowMenuItem.propTypes = {
  /**
   * The CSS class name to be placed on the button element
   */
  className: import_prop_types83.default.string,
  /**
   * A callback to tell the parent menu component that the menu should be closed.
   */
  closeMenu: import_prop_types83.default.func,
  /**
   * `true` to make this menu item disabled.
   */
  disabled: import_prop_types83.default.bool,
  handleOverflowMenuItemFocus: import_prop_types83.default.func,
  /**
   * `true` to make this menu item a divider.
   */
  hasDivider: import_prop_types83.default.bool,
  /**
   * If given, overflow item will render as a link with the given href
   */
  href: import_prop_types83.default.string,
  index: import_prop_types83.default.number,
  /**
   * `true` to make this menu item a "danger button".
   */
  isDelete: import_prop_types83.default.bool,
  /**
   * The text in the menu item.
   */
  itemText: import_prop_types83.default.node.isRequired,
  /**
   * event handlers
   */
  onBlur: import_prop_types83.default.func,
  onClick: import_prop_types83.default.func,
  onFocus: import_prop_types83.default.func,
  onKeyDown: import_prop_types83.default.func,
  onKeyUp: import_prop_types83.default.func,
  onMouseDown: import_prop_types83.default.func,
  onMouseEnter: import_prop_types83.default.func,
  onMouseLeave: import_prop_types83.default.func,
  onMouseUp: import_prop_types83.default.func,
  /**
   * `true` if this menu item has long text and requires a browser tooltip
   */
  requireTitle: import_prop_types83.default.bool,
  /**
   * Specify a title for the OverflowMenuItem
   */
  title: import_prop_types83.default.string,
  /**
   * The CSS class name to be placed on the wrapper list item element
   */
  wrapperClassName: import_prop_types83.default.string
};

// node_modules/@carbon/react/es/components/DataTable/TableToolbarAction.js
var frFn6 = import_react114.forwardRef;
var TableToolbarAction = frFn6((props, ref) => {
  const {
    children,
    ...rest
  } = props;
  return import_react114.default.createElement(OverflowMenuItem, _extends({
    ref,
    itemText: children
  }, rest));
});
TableToolbarAction.displayName = "TableToolbarAction";
TableToolbarAction.propTypes = {
  children: import_prop_types84.default.node,
  className: import_prop_types84.default.string,
  onClick: import_prop_types84.default.func.isRequired
};

// node_modules/@carbon/react/es/components/DataTable/TableToolbarContent.js
var TableToolbarContent = wrapComponent({
  name: "TableToolbarContent",
  type: "div",
  className: (prefix) => `${prefix}--toolbar-content`
});

// node_modules/@carbon/react/es/components/DataTable/TableToolbarSearch.js
var import_classnames71 = __toESM(require_classnames());
var import_prop_types85 = __toESM(require_prop_types());
var import_react115 = __toESM(require_react());
var translationKeys3 = {
  "carbon.table.toolbar.search.label": "Filter table",
  "carbon.table.toolbar.search.placeholder": "Filter table"
};
var translateWithId3 = (id) => {
  return translationKeys3[id];
};
var TableToolbarSearch = ({
  className,
  searchContainerClass,
  onChange: onChangeProp,
  onClear = noopFn,
  translateWithId: t3 = translateWithId3,
  placeholder,
  labelText,
  expanded: expandedProp,
  defaultExpanded,
  defaultValue,
  disabled,
  onExpand,
  persistent = false,
  id,
  onBlur,
  onFocus,
  size: size4 = "lg",
  tabIndex = "0",
  ...rest
}) => {
  const {
    current: controlled
  } = (0, import_react115.useRef)(expandedProp !== void 0);
  const [expandedState, setExpandedState] = (0, import_react115.useState)(Boolean(defaultExpanded || defaultValue));
  const expanded = controlled ? expandedProp : expandedState;
  const [value, setValue] = (0, import_react115.useState)(defaultValue || "");
  const uniqueId = useId("table-toolbar-search");
  const [focusTarget, setFocusTarget] = (0, import_react115.useState)(null);
  const prefix = usePrefix();
  (0, import_react115.useEffect)(() => {
    var _a, _b, _c;
    if (focusTarget) {
      (_c = (_b = (_a = focusTarget.current) == null ? void 0 : _a.querySelector) == null ? void 0 : _b.call(_a, "input")) == null ? void 0 : _c.focus();
      setFocusTarget(null);
    }
  }, [focusTarget]);
  (0, import_react115.useEffect)(
    () => {
      if (defaultValue) {
        onChangeProp == null ? void 0 : onChangeProp("", defaultValue);
      }
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  const searchClasses = (0, import_classnames71.default)(className, {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    [searchContainerClass]: searchContainerClass,
    [`${prefix}--toolbar-search-container-active`]: expanded,
    [`${prefix}--toolbar-search-container-disabled`]: disabled,
    [`${prefix}--toolbar-search-container-expandable`]: !persistent,
    [`${prefix}--toolbar-search-container-persistent`]: persistent
  });
  const handleExpand = (event, value2 = !expanded) => {
    if (!disabled) {
      if (!controlled && !persistent) {
        setExpandedState(value2);
      }
      if (onExpand) {
        onExpand(event, value2);
      }
    }
  };
  const onChange = (e2) => {
    setValue(e2.target.value);
    if (onChangeProp) {
      onChangeProp(e2, e2.target.value);
    }
  };
  const handleOnFocus = (event) => handleExpand(event, true);
  const handleOnBlur = (event) => !value && handleExpand(event, false);
  return import_react115.default.createElement(Search2, _extends({
    disabled,
    className: searchClasses,
    value,
    id: typeof id !== "undefined" ? id : uniqueId,
    labelText: labelText || t3("carbon.table.toolbar.search.label"),
    placeholder: placeholder || t3("carbon.table.toolbar.search.placeholder"),
    onChange,
    onClear,
    onFocus: onFocus ? (event) => onFocus(event, handleExpand) : handleOnFocus,
    onBlur: onBlur ? (event) => onBlur(event, handleExpand) : handleOnBlur,
    size: size4,
    tabIndex
  }, rest));
};
TableToolbarSearch.propTypes = {
  children: import_prop_types85.default.node,
  /**
   * Provide an optional class name for the search container
   */
  className: import_prop_types85.default.string,
  /**
   * Specifies if the search should initially render in an expanded state
   */
  defaultExpanded: import_prop_types85.default.bool,
  /**
   * Provide an optional default value for the Search component
   */
  defaultValue: import_prop_types85.default.string,
  /**
   * Specifies if the search should be disabled
   */
  disabled: import_prop_types85.default.bool,
  /**
   * Specifies if the search should expand
   */
  expanded: import_prop_types85.default.bool,
  /**
   * Provide an optional id for the search container
   */
  id: import_prop_types85.default.string,
  /**
   * Provide an optional label text for the Search component icon
   */
  labelText: import_prop_types85.default.string,
  /**
   * Provide an optional function to be called when the search input loses focus, this will be
   * passed the event as the first parameter and a function to handle the expanding of the search
   * input as the second
   */
  onBlur: import_prop_types85.default.func,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types85.default.func,
  /**
   * Optional callback called when the search value is cleared.
   */
  onClear: import_prop_types85.default.func,
  /**
   * Provide an optional hook that is called each time the input is expanded
   */
  onExpand: import_prop_types85.default.func,
  /**
   * Provide an optional function to be called when the search input gains focus, this will be
   * passed the event as the first parameter and a function to handle the expanding of the search
   * input as the second.
   */
  onFocus: import_prop_types85.default.func,
  /**
   * Whether the search should be allowed to expand
   */
  persistent: import_prop_types85.default.bool,
  /**
   * Provide an optional placeholder text for the Search component
   */
  placeholder: import_prop_types85.default.string,
  /**
   * Provide an optional className for the overall container of the Search
   */
  searchContainerClass: import_prop_types85.default.string,
  /**
   * Specify the size of the Search
   */
  size: import_prop_types85.default.oneOf(["sm", "md", "lg"]),
  /**
   * Optional prop to specify the tabIndex of the <Search> (in expanded state) or the container (in collapsed state)
   */
  tabIndex: import_prop_types85.default.oneOfType([import_prop_types85.default.number, import_prop_types85.default.string]),
  /**
   * Provide custom text for the component for each translation id
   */
  translateWithId: import_prop_types85.default.func
};

// node_modules/@carbon/react/es/components/DataTable/TableToolbarMenu.js
var import_classnames74 = __toESM(require_classnames());
var import_prop_types88 = __toESM(require_prop_types());
var import_react122 = __toESM(require_react());

// node_modules/@carbon/react/es/components/OverflowMenu/index.js
var import_react121 = __toESM(require_react());

// node_modules/@carbon/react/es/components/OverflowMenu/next/index.js
var import_react116 = __toESM(require_react());
var import_prop_types86 = __toESM(require_prop_types());
var import_classnames72 = __toESM(require_classnames());
var defaultSize = "md";
var OverflowMenu = import_react116.default.forwardRef(function OverflowMenu2({
  autoAlign = false,
  children,
  className,
  label = "Options",
  renderIcon: IconElement = OverflowMenuVertical,
  size: size4 = defaultSize,
  menuAlignment = "bottom-start",
  tooltipAlignment,
  menuTarget,
  ...rest
}, forwardRef36) {
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2(
    enableFloatingStyles ? {
      // Computing the position starts with initial positioning
      // via `placement`.
      placement: menuAlignment,
      // The floating element is positioned relative to its nearest
      // containing block (usually the viewport). It will in many cases
      // also “break” the floating element out of a clipping ancestor.
      // https://floating-ui.com/docs/misc#clipping
      strategy: "fixed",
      // Middleware are executed as an in-between “middle” step of the
      // initial `placement` computation and eventual return of data for
      // rendering. Each middleware is executed in order.
      middleware: [autoAlign && flip3({
        // An explicit array of placements to try if the initial
        // `placement` doesn’t fit on the axes in which overflow
        // is checked.
        fallbackPlacements: menuAlignment.includes("bottom") ? ["bottom-start", "bottom-end", "top-start", "top-end"] : ["top-start", "top-end", "bottom-start", "bottom-end"]
      })],
      whileElementsMounted: autoUpdate
    } : {}
    // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not
    // enabled, floating-ui will not be used
  );
  const id = useId("overflowmenu");
  const prefix = usePrefix();
  const triggerRef = (0, import_react116.useRef)(null);
  const {
    open: open2,
    x,
    y,
    handleClick: hookOnClick,
    handleMousedown,
    handleClose
  } = useAttachedMenu(triggerRef);
  (0, import_react116.useEffect)(() => {
    if (enableFloatingStyles) {
      Object.keys(floatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = floatingStyles[style];
        }
      });
    }
  }, [floatingStyles, enableFloatingStyles, refs.floating, open2, placement, middlewareData]);
  function handleTriggerClick() {
    if (triggerRef.current) {
      hookOnClick();
    }
  }
  const containerClasses = (0, import_classnames72.default)(className, `${prefix}--overflow-menu__container`, {
    [`${prefix}--autoalign`]: enableFloatingStyles
  });
  const menuClasses = (0, import_classnames72.default)(`${prefix}--overflow-menu__${menuAlignment}`);
  const triggerClasses = (0, import_classnames72.default)(`${prefix}--overflow-menu`, {
    [`${prefix}--overflow-menu--open`]: open2
  }, size4 !== defaultSize && `${prefix}--overflow-menu--${size4}`);
  const floatingRef = mergeRefs(triggerRef, refs.setReference);
  return import_react116.default.createElement("div", _extends({}, rest, {
    className: containerClasses,
    "aria-owns": open2 ? id : void 0,
    ref: forwardRef36
  }), import_react116.default.createElement(IconButton, {
    "aria-controls": open2 ? id : void 0,
    "aria-haspopup": true,
    "aria-expanded": open2,
    className: triggerClasses,
    onClick: handleTriggerClick,
    onMouseDown: handleMousedown,
    ref: floatingRef,
    label,
    align: tooltipAlignment,
    kind: "ghost"
  }, import_react116.default.createElement(IconElement, {
    className: `${prefix}--overflow-menu__icon`
  })), import_react116.default.createElement(Menu2, {
    containerRef: triggerRef,
    ref: refs.setFloating,
    menuAlignment,
    className: menuClasses,
    id,
    size: size4,
    legacyAutoalign: !enableFloatingStyles,
    open: open2,
    onClose: handleClose,
    x,
    y,
    label,
    target: menuTarget
  }, children));
});
OverflowMenu.propTypes = {
  /**
   * **Experimental**: Will attempt to automatically align the floating element
   * to avoid collisions with the viewport and being clipped by ancestor
   * elements. Requires React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types86.default.bool,
  /**
   * A collection of MenuItems to be rendered within this OverflowMenu.
   */
  children: import_prop_types86.default.node,
  /**
   * Additional CSS class names for the trigger button.
   */
  className: import_prop_types86.default.string,
  /**
   * A label describing the options available. Is used in the trigger tooltip and as the menu's accessible label.
   */
  label: import_prop_types86.default.string,
  /**
   * Experimental property. Specify how the menu should align with the button element
   */
  menuAlignment: import_prop_types86.default.oneOf(["top-start", "top-end", "bottom-start", "bottom-end"]),
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types86.default.oneOfType([import_prop_types86.default.func, import_prop_types86.default.object]),
  /**
   * Specify the size of the menu, from a list of available sizes.
   */
  size: import_prop_types86.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify how the trigger tooltip should be aligned.
   */
  tooltipAlignment: deprecateValuesWithin(import_prop_types86.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * Specify a DOM node where the Menu should be rendered in. Defaults to document.body.
   */
  menuTarget: import_prop_types86.default.instanceOf(typeof Element !== "undefined" ? Element : Object)
};

// node_modules/@carbon/react/es/components/OverflowMenu/OverflowMenu.js
var import_react120 = __toESM(require_react());
var import_classnames73 = __toESM(require_classnames());
var import_invariant = __toESM(require_browser());
var import_prop_types87 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/internal/FloatingMenu.js
var import_react118 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());
var import_window_or_global2 = __toESM(require_lib());

// node_modules/@carbon/react/es/internal/OptimizedResize.js
var import_window_or_global = __toESM(require_lib());
var OptimizedResize = /* @__PURE__ */ (() => {
  const callbacks = [];
  let running = false;
  const runCallbacks = () => {
    callbacks.forEach((callback) => {
      callback();
    });
    running = false;
  };
  const handleResize = () => {
    if (!running) {
      running = true;
      import_window_or_global.default.requestAnimationFrame(runCallbacks);
    }
  };
  const addCallback = (callback) => {
    const index3 = callbacks.indexOf(callback);
    if (index3 < 0) {
      callbacks.push(callback);
    }
  };
  return {
    /** Adds a callback function to be executed on window `resize`. */
    add: (callback) => {
      if (!callbacks.length) {
        import_window_or_global.default.addEventListener("resize", handleResize);
      }
      addCallback(callback);
      return {
        /** Removes the callback. */
        remove: () => {
          const index3 = callbacks.indexOf(callback);
          if (index3 >= 0) {
            callbacks.splice(index3, 1);
          }
        }
      };
    }
  };
})();

// node_modules/@carbon/react/es/internal/FloatingMenu.js
var DIRECTION_LEFT = "left";
var DIRECTION_TOP = "top";
var DIRECTION_RIGHT = "right";
var DIRECTION_BOTTOM = "bottom";
var getFloatingPosition = ({
  menuSize,
  refPosition,
  offset: offset4,
  direction,
  scrollX,
  scrollY,
  container
}) => {
  const {
    left: refLeft = 0,
    top: refTop = 0,
    right: refRight = 0,
    bottom: refBottom = 0
  } = refPosition;
  const effectiveScrollX = container.position !== "static" ? 0 : scrollX;
  const effectiveScrollY = container.position !== "static" ? 0 : scrollY;
  const relativeDiff = {
    top: container.position !== "static" ? container.rect.top : 0,
    left: container.position !== "static" ? container.rect.left : 0
  };
  const {
    width,
    height
  } = menuSize;
  const {
    top = 0,
    left = 0
  } = offset4;
  const refCenterHorizontal = (refLeft + refRight) / 2;
  const refCenterVertical = (refTop + refBottom) / 2;
  const positions = {
    [DIRECTION_LEFT]: () => ({
      left: refLeft - width + effectiveScrollX - left - relativeDiff.left,
      top: refCenterVertical - height / 2 + effectiveScrollY + top - 9 - relativeDiff.top
    }),
    [DIRECTION_TOP]: () => ({
      left: refCenterHorizontal - width / 2 + effectiveScrollX + left - relativeDiff.left,
      top: refTop - height + effectiveScrollY - top - relativeDiff.top
    }),
    [DIRECTION_RIGHT]: () => ({
      left: refRight + effectiveScrollX + left - relativeDiff.left,
      top: refCenterVertical - height / 2 + effectiveScrollY + top + 3 - relativeDiff.top
    }),
    [DIRECTION_BOTTOM]: () => ({
      left: refCenterHorizontal - width / 2 + effectiveScrollX + left - relativeDiff.left,
      top: refBottom + effectiveScrollY + top - relativeDiff.top
    })
  };
  return positions[direction]();
};
var FloatingMenu = ({
  children,
  flipped,
  focusTrap,
  menuDirection = DIRECTION_BOTTOM,
  menuOffset = {
    top: 0,
    left: 0
  },
  menuRef: externalMenuRef,
  onPlace,
  selectorPrimaryFocus,
  styles,
  target = () => document.body,
  triggerRef,
  updateOrientation
}) => {
  const prefix = (0, import_react118.useContext)(PrefixContext);
  const [floatingPosition, setFloatingPosition] = (0, import_react118.useState)(void 0);
  const menuBodyRef = (0, import_react118.useRef)(null);
  const startSentinelRef = (0, import_react118.useRef)(null);
  const endSentinelRef = (0, import_react118.useRef)(null);
  const placeInProgressRef = (0, import_react118.useRef)(false);
  const updateMenuPosition = (0, import_react118.useCallback)((isAdjustment) => {
    const menuBody = menuBodyRef.current;
    if (!menuBody) {
      true ? warning(!!menuBody, "The DOM node for menu body for calculating its position is not available. Skipping...") : void 0;
      return;
    }
    const triggerEl = triggerRef.current;
    const menuSize = menuBody.getBoundingClientRect();
    const refPosition = triggerEl ? triggerEl.getBoundingClientRect() : void 0;
    const offsetValue = typeof menuOffset === "function" ? menuOffset(menuBody, menuDirection, triggerEl, flipped) : menuOffset;
    if (updateOrientation) {
      updateOrientation({
        menuSize,
        refPosition,
        direction: menuDirection,
        offset: offsetValue,
        scrollX: import_window_or_global2.default.pageXOffset,
        scrollY: import_window_or_global2.default.pageYOffset,
        container: {
          rect: target().getBoundingClientRect(),
          position: getComputedStyle(target()).position
        }
      });
    }
    if (menuSize.width > 0 && menuSize.height > 0 || !offsetValue) {
      const newFloatingPosition = getFloatingPosition({
        menuSize,
        refPosition: refPosition ?? {
          left: 0,
          top: 0,
          right: 0,
          bottom: 0
        },
        offset: offsetValue,
        direction: menuDirection,
        scrollX: import_window_or_global2.default.pageXOffset,
        scrollY: import_window_or_global2.default.pageYOffset,
        container: {
          rect: target().getBoundingClientRect(),
          position: getComputedStyle(target()).position
        }
      });
      if (!floatingPosition || floatingPosition.left !== newFloatingPosition.left || floatingPosition.top !== newFloatingPosition.top) {
        setFloatingPosition(newFloatingPosition);
      }
      if (!isAdjustment) {
        const newMenuSize = menuBody.getBoundingClientRect();
        if (newMenuSize.width !== menuSize.width || newMenuSize.height !== menuSize.height) {
          updateMenuPosition(true);
        }
      }
    }
  }, [triggerRef, menuOffset, menuDirection, flipped, target, updateOrientation, floatingPosition]);
  const focusMenuContent = (menuBody) => {
    const primaryFocusNode = selectorPrimaryFocus ? menuBody.querySelector(selectorPrimaryFocus) : null;
    const tabbableNode = menuBody.querySelector(selectorTabbable);
    const focusableNode = menuBody.querySelector(selectorFocusable);
    const focusTarget = primaryFocusNode || // User defined focusable node
    tabbableNode || // First sequentially focusable node
    focusableNode || // First programmatic focusable node
    menuBody;
    focusTarget.focus();
    if (focusTarget === menuBody) {
      true ? warning(focusableNode === null, 'Floating Menus must have at least a programmatically focusable child. This can be accomplished by adding tabIndex="-1" to the content element.') : void 0;
    }
  };
  const handleMenuRef = (node) => {
    menuBodyRef.current = node;
    placeInProgressRef.current = !!node;
    if (externalMenuRef) {
      externalMenuRef(node);
    }
    if (node) {
      updateMenuPosition();
    }
  };
  (0, import_react118.useEffect)(() => {
    if (placeInProgressRef.current && floatingPosition && menuBodyRef.current) {
      if (!menuBodyRef.current.contains(document.activeElement)) {
        focusMenuContent(menuBodyRef.current);
      }
      if (typeof onPlace === "function") {
        onPlace(menuBodyRef.current);
      }
      placeInProgressRef.current = false;
    }
  }, [floatingPosition, onPlace]);
  (0, import_react118.useEffect)(() => {
    const resizeHandler = OptimizedResize.add(() => {
      updateMenuPosition();
    });
    return () => {
      resizeHandler.remove();
    };
  }, [triggerRef, menuOffset, menuDirection, flipped, target, updateOrientation]);
  (0, import_react118.useEffect)(() => {
    updateMenuPosition();
  }, [menuOffset, menuDirection, flipped, triggerRef, target, updateOrientation]);
  const getChildrenWithProps = () => {
    const pos = floatingPosition;
    const positioningStyle = pos ? {
      left: `${pos.left}px`,
      top: `${pos.top}px`,
      right: "auto"
    } : {
      visibility: "hidden",
      top: "0px"
    };
    const child = children;
    return (0, import_react118.cloneElement)(child, {
      ref: handleMenuRef,
      style: {
        ...styles,
        ...positioningStyle,
        position: "absolute",
        opacity: 1
      }
    });
  };
  const handleBlur = (event) => {
    const {
      target: target2,
      relatedTarget
    } = event;
    if (menuBodyRef.current && startSentinelRef.current && endSentinelRef.current && target2 instanceof HTMLElement && relatedTarget instanceof HTMLElement) {
      wrapFocus({
        bodyNode: menuBodyRef.current,
        startTrapNode: startSentinelRef.current,
        endTrapNode: endSentinelRef.current,
        currentActiveNode: relatedTarget,
        oldActiveNode: target2
      });
    }
  };
  const handleKeyDown = (event) => {
    if (match(event, Tab) && menuBodyRef.current && event.target instanceof HTMLElement) {
      wrapFocusWithoutSentinels({
        containerNode: menuBodyRef.current,
        currentActiveNode: event.target,
        event
      });
    }
  };
  const focusTrapWithoutSentinels = enabled("enable-experimental-focus-wrap-without-sentinels");
  if (typeof document !== "undefined") {
    const portalTarget = target ? target() : document.body;
    return import_react_dom4.default.createPortal(import_react118.default.createElement("div", {
      onBlur: focusTrap && !focusTrapWithoutSentinels ? handleBlur : void 0,
      onKeyDown: focusTrapWithoutSentinels ? handleKeyDown : void 0
    }, !focusTrapWithoutSentinels && import_react118.default.createElement("span", {
      ref: startSentinelRef,
      tabIndex: 0,
      role: "link",
      className: `${prefix}--visually-hidden`
    }, "Focus sentinel"), getChildrenWithProps(), !focusTrapWithoutSentinels && import_react118.default.createElement("span", {
      ref: endSentinelRef,
      tabIndex: 0,
      role: "link",
      className: `${prefix}--visually-hidden`
    }, "Focus sentinel")), portalTarget);
  }
  return null;
};

// node_modules/@carbon/react/es/internal/useOutsideClick.js
var import_react119 = __toESM(require_react());
var useOutsideClick = (ref, callback) => {
  const savedCallback = (0, import_react119.useRef)(callback);
  (0, import_react119.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  if (canUseDOM) {
    useWindowEvent("click", (event) => {
      const {
        target
      } = event;
      if (target instanceof Node && ref.current && !ref.current.contains(target)) {
        savedCallback.current(event);
      }
    });
  }
};

// node_modules/@carbon/react/es/components/OverflowMenu/OverflowMenu.js
var getInstanceId = setupGetInstanceId();
var on = (target, ...args) => {
  target.addEventListener(...args);
  return {
    release() {
      target.removeEventListener(...args);
      return null;
    }
  };
};
var triggerButtonPositionProps = {
  [DIRECTION_TOP]: "bottom",
  [DIRECTION_BOTTOM]: "top"
};
var triggerButtonPositionFactors = {
  [DIRECTION_TOP]: -2,
  [DIRECTION_BOTTOM]: -1
};
var getMenuOffset = (menuBody, direction, trigger, flip4) => {
  const triggerButtonPositionProp = triggerButtonPositionProps[direction];
  const triggerButtonPositionFactor = triggerButtonPositionFactors[direction];
  if (true) {
    !(triggerButtonPositionProp && triggerButtonPositionFactor) ? true ? (0, import_invariant.default)(false, "[OverflowMenu] wrong floating menu direction: `%s`", direction) : (0, import_invariant.default)(false) : void 0;
  }
  const {
    offsetWidth: menuWidth,
    offsetHeight: menuHeight
  } = menuBody;
  switch (triggerButtonPositionProp) {
    case "top":
    case "bottom": {
      const triggerWidth = !trigger ? 0 : trigger.offsetWidth;
      return {
        left: (!flip4 ? 1 : -1) * (menuWidth / 2 - triggerWidth / 2),
        top: 0
      };
    }
    default:
      return {
        left: 0,
        top: 0
      };
  }
};
var OverflowMenu3 = (0, import_react120.forwardRef)(({
  align,
  ["aria-label"]: ariaLabel = null,
  ariaLabel: deprecatedAriaLabel,
  children,
  className,
  direction = DIRECTION_BOTTOM,
  flipped = false,
  focusTrap = true,
  iconClass,
  iconDescription = "Options",
  id,
  light,
  menuOffset = getMenuOffset,
  menuOffsetFlip = getMenuOffset,
  menuOptionsClass,
  onClick = noopFn,
  onClose = noopFn,
  onOpen = noopFn,
  open: openProp,
  renderIcon: IconElement = OverflowMenuVertical,
  selectorPrimaryFocus = "[data-floating-menu-primary-focus]",
  size: size4 = "md",
  innerRef,
  ...other
}, ref) => {
  const prefix = (0, import_react120.useContext)(PrefixContext);
  const [open2, setOpen] = (0, import_react120.useState)(openProp ?? false);
  const [click, setClick] = (0, import_react120.useState)(false);
  const [hasMountedTrigger, setHasMountedTrigger] = (0, import_react120.useState)(false);
  const hFocusIn = (0, import_react120.useRef)(null);
  const instanceId2 = (0, import_react120.useRef)(getInstanceId());
  const menuBodyRef = (0, import_react120.useRef)(null);
  const menuItemRefs = (0, import_react120.useRef)({});
  const prevOpenProp = (0, import_react120.useRef)(openProp);
  const prevOpenState = (0, import_react120.useRef)(open2);
  const triggerRef = (0, import_react120.useRef)(null);
  const wrapperRef = (0, import_react120.useRef)(null);
  (0, import_react120.useEffect)(() => {
    if (prevOpenProp.current !== openProp) {
      setOpen(!!openProp);
      prevOpenProp.current = openProp;
    }
  }, [openProp]);
  (0, import_react120.useEffect)(() => {
    if (triggerRef.current) {
      setHasMountedTrigger(true);
    }
  }, []);
  (0, import_react120.useEffect)(() => {
    if (open2 && !prevOpenState.current) {
      onOpen();
    } else if (!open2 && prevOpenState.current) {
      onClose();
    }
    prevOpenState.current = open2;
  }, [open2, onClose, onOpen]);
  useOutsideClick(wrapperRef, ({
    target
  }) => {
    if (open2 && (!menuBodyRef.current || target instanceof Node && !menuBodyRef.current.contains(target))) {
      closeMenu();
    }
  });
  const focusMenuEl = (0, import_react120.useCallback)(() => {
    if (triggerRef.current) {
      triggerRef.current.focus();
    }
  }, []);
  const closeMenu = (0, import_react120.useCallback)((onCloseMenu) => {
    setOpen(false);
    if (onCloseMenu) {
      onCloseMenu();
    }
    onClose();
  }, [onClose]);
  const closeMenuAndFocus = (0, import_react120.useCallback)(() => {
    const wasClicked = click;
    const wasOpen = open2;
    closeMenu(() => {
      if (wasOpen && !wasClicked) {
        focusMenuEl();
      }
    });
  }, [click, open2, closeMenu, focusMenuEl]);
  const closeMenuOnEscape = (0, import_react120.useCallback)(() => {
    const wasOpen = open2;
    closeMenu(() => {
      if (wasOpen) {
        focusMenuEl();
      }
    });
  }, [open2, closeMenu, focusMenuEl]);
  const handleClick2 = (evt) => {
    setClick(true);
    if (!menuBodyRef.current || !menuBodyRef.current.contains(evt.target)) {
      setOpen((prev) => !prev);
      onClick(evt);
    }
  };
  const handleKeyPress = (evt) => {
    if (open2 && matches(evt, [ArrowUp2, ArrowRight2, ArrowDown, ArrowLeft])) {
      evt.preventDefault();
    }
    if (matches(evt, [Escape])) {
      closeMenuOnEscape();
      evt.stopPropagation();
    }
  };
  const handleOverflowMenuItemFocus = ({
    currentIndex = 0,
    direction: direction2
  }) => {
    const enabledIndices = import_react120.Children.toArray(children).reduce((acc, curr, i) => {
      if (import_react120.default.isValidElement(curr) && !curr.props.disabled) {
        acc.push(i);
      }
      return acc;
    }, []);
    const nextValidIndex = (() => {
      const nextIndex = enabledIndices.indexOf(currentIndex) + direction2;
      switch (nextIndex) {
        case -1:
          return enabledIndices.length - 1;
        case enabledIndices.length:
          return 0;
        default:
          return nextIndex;
      }
    })();
    const overflowMenuItem = menuItemRefs.current[enabledIndices[nextValidIndex]];
    overflowMenuItem == null ? void 0 : overflowMenuItem.focus();
  };
  const bindMenuBody = (menuBody2) => {
    if (!menuBody2) {
      menuBodyRef.current = menuBody2;
    }
    if (!menuBody2 && hFocusIn.current) {
      hFocusIn.current = hFocusIn.current.release();
    }
  };
  const handlePlace = (menuBody2) => {
    if (!menuBody2) return;
    menuBodyRef.current = menuBody2;
    const hasFocusin = "onfocusin" in window;
    const focusinEventName = hasFocusin ? "focusin" : "focus";
    hFocusIn.current = on(menuBody2.ownerDocument, focusinEventName, (event) => {
      const target = event.target;
      const triggerEl = triggerRef.current;
      if (typeof target.matches === "function") {
        if (!menuBody2.contains(target) && triggerEl && !target.matches(`.${prefix}--overflow-menu:first-child, .${prefix}--overflow-menu-options:first-child`)) {
          closeMenuAndFocus();
        }
      }
    }, !hasFocusin);
  };
  const getTarget3 = () => {
    const triggerEl = triggerRef.current;
    if (triggerEl instanceof Element) {
      return triggerEl.closest("[data-floating-menu-container]") || document.body;
    }
    return document.body;
  };
  const menuBodyId = `overflow-menu-${instanceId2.current}__menu-body`;
  const overflowMenuClasses = (0, import_classnames73.default)(className, `${prefix}--overflow-menu`, {
    [`${prefix}--overflow-menu--open`]: open2,
    [`${prefix}--overflow-menu--light`]: light,
    [`${prefix}--overflow-menu--${size4}`]: size4
  });
  const overflowMenuOptionsClasses = (0, import_classnames73.default)(menuOptionsClass, `${prefix}--overflow-menu-options`, {
    [`${prefix}--overflow-menu--flip`]: flipped,
    [`${prefix}--overflow-menu-options--open`]: open2,
    [`${prefix}--overflow-menu-options--light`]: light,
    [`${prefix}--overflow-menu-options--${size4}`]: size4
  });
  const overflowMenuIconClasses = (0, import_classnames73.default)(`${prefix}--overflow-menu__icon`, iconClass);
  const childrenWithProps = import_react120.Children.toArray(children).map((child, index3) => {
    if ((0, import_react120.isValidElement)(child)) {
      const childElement = child;
      return (0, import_react120.cloneElement)(childElement, {
        closeMenu: childElement.props.closeMenu || closeMenuAndFocus,
        handleOverflowMenuItemFocus,
        ref: (el) => {
          menuItemRefs.current[index3] = el;
        },
        index: index3
      });
    }
    return null;
  });
  const menuBody = import_react120.default.createElement("ul", {
    className: overflowMenuOptionsClasses,
    tabIndex: -1,
    role: "menu",
    "aria-label": ariaLabel || deprecatedAriaLabel,
    onKeyDown: handleKeyPress,
    id: menuBodyId
  }, childrenWithProps);
  const wrappedMenuBody = import_react120.default.createElement(FloatingMenu, {
    focusTrap,
    triggerRef,
    menuDirection: direction,
    menuOffset: flipped ? menuOffsetFlip : menuOffset,
    menuRef: bindMenuBody,
    flipped,
    target: getTarget3,
    onPlace: handlePlace,
    selectorPrimaryFocus
  }, (0, import_react120.cloneElement)(menuBody, {
    "data-floating-menu-direction": direction
  }));
  const combinedRef = innerRef ? mergeRefs(triggerRef, innerRef, ref) : mergeRefs(triggerRef, ref);
  return import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("span", {
    className: `${prefix}--overflow-menu__wrapper`,
    "aria-owns": open2 ? menuBodyId : void 0,
    ref: wrapperRef
  }, import_react120.default.createElement(IconButton, _extends({}, other, {
    align,
    type: "button",
    "aria-haspopup": true,
    "aria-expanded": open2,
    "aria-controls": open2 ? menuBodyId : void 0,
    className: overflowMenuClasses,
    onClick: handleClick2,
    id,
    ref: combinedRef,
    size: size4,
    label: iconDescription,
    kind: "ghost"
  }), import_react120.default.createElement(IconElement, {
    className: overflowMenuIconClasses,
    "aria-label": iconDescription
  })), open2 && hasMountedTrigger && wrappedMenuBody));
});
OverflowMenu3.propTypes = {
  /**
   * Specify how the trigger should align with the tooltip
   */
  align: deprecateValuesWithin(import_prop_types87.default.oneOf([
    "top",
    "top-left",
    // deprecated use top-start instead
    "top-right",
    // deprecated use top-end instead
    "bottom",
    "bottom-left",
    // deprecated use bottom-start instead
    "bottom-right",
    // deprecated use bottom-end instead
    "left",
    "left-bottom",
    // deprecated use left-end instead
    "left-top",
    // deprecated use left-start instead
    "right",
    "right-bottom",
    // deprecated use right-end instead
    "right-top",
    // deprecated use right-start instead
    // new values to match floating-ui
    "top-start",
    "top-end",
    "bottom-start",
    "bottom-end",
    "left-end",
    "left-start",
    "right-end",
    "right-start"
  ]), ["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end", "left", "left-start", "left-end", "right", "right-start", "right-end"], mapPopoverAlign),
  /**
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types87.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types87.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * The child nodes.
   */
  children: import_prop_types87.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types87.default.string,
  /**
   * The menu direction.
   */
  direction: import_prop_types87.default.oneOf([DIRECTION_TOP, DIRECTION_BOTTOM]),
  /**
   * `true` if the menu alignment should be flipped.
   */
  flipped: import_prop_types87.default.bool,
  /**
   * Enable or disable focus trap behavior
   */
  focusTrap: import_prop_types87.default.bool,
  /**
   * The CSS class for the icon.
   */
  iconClass: import_prop_types87.default.string,
  /**
   * The icon description.
   */
  iconDescription: import_prop_types87.default.string,
  /**
   * The element ID.
   */
  id: import_prop_types87.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make OverflowMenu background color same as container background color.
   */
  light: deprecate(import_prop_types87.default.bool, "The `light` prop for `OverflowMenu` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffset: import_prop_types87.default.oneOfType([import_prop_types87.default.shape({
    top: import_prop_types87.default.number.isRequired,
    left: import_prop_types87.default.number.isRequired
  }), import_prop_types87.default.func]),
  /**
   * The adjustment in position applied to the floating menu.
   */
  menuOffsetFlip: import_prop_types87.default.oneOfType([import_prop_types87.default.shape({
    top: import_prop_types87.default.number.isRequired,
    left: import_prop_types87.default.number.isRequired
  }), import_prop_types87.default.func]),
  /**
   * The class to apply to the menu options
   */
  menuOptionsClass: import_prop_types87.default.string,
  /**
   * The event handler for the `click` event.
   */
  onClick: import_prop_types87.default.func,
  /**
   * Function called when menu is closed
   */
  onClose: import_prop_types87.default.func,
  /**
   * The event handler for the `focus` event.
   */
  onFocus: import_prop_types87.default.func,
  /**
   * The event handler for the `keydown` event.
   */
  onKeyDown: import_prop_types87.default.func,
  /**
   * Function called when menu is opened
   */
  onOpen: import_prop_types87.default.func,
  /**
   * `true` if the menu should be open.
   */
  open: import_prop_types87.default.bool,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types87.default.oneOfType([import_prop_types87.default.func, import_prop_types87.default.object]),
  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the OverflowMenu opens
   */
  selectorPrimaryFocus: import_prop_types87.default.string,
  /**
   * Specify the size of the OverflowMenu. Currently supports either `sm`, `md` (default) or `lg` as an option.
   */
  size: import_prop_types87.default.oneOf(["sm", "md", "lg"])
};

// node_modules/@carbon/react/es/components/OverflowMenu/index.js
var OverflowMenu4 = (0, import_react121.forwardRef)((props, ref) => {
  const enableV12OverflowMenu = useFeatureFlag("enable-v12-overflowmenu");
  return enableV12OverflowMenu ? import_react121.default.createElement(OverflowMenu, _extends({}, props, {
    ref
  })) : import_react121.default.createElement(OverflowMenu3, _extends({}, props, {
    ref
  }));
});
OverflowMenu4.displayName = "OverflowMenu";
OverflowMenu4.propTypes = OverflowMenu3.propTypes;

// node_modules/@carbon/react/es/components/DataTable/TableToolbarMenu.js
var defaultIconDescription = "Settings";
var TableToolbarMenu = ({
  className,
  renderIcon = Settings,
  iconDescription = defaultIconDescription,
  children,
  menuOptionsClass,
  ...rest
}) => {
  const prefix = usePrefix();
  const toolbarActionClasses = (0, import_classnames74.default)(className, `${prefix}--toolbar-action ${prefix}--overflow-menu`);
  const menuOptionsClasses = (0, import_classnames74.default)(menuOptionsClass, `${prefix}--toolbar-action__menu`);
  return import_react122.default.createElement(OverflowMenu4, _extends({
    renderIcon,
    className: toolbarActionClasses,
    title: iconDescription,
    iconDescription,
    menuOptionsClass: menuOptionsClasses,
    flipped: true
  }, rest), children);
};
TableToolbarMenu.propTypes = {
  children: import_prop_types88.default.node.isRequired,
  /**
   * Provide an optional class name for the toolbar menu
   */
  className: import_prop_types88.default.string,
  /**
   * The description of the menu icon.
   */
  iconDescription: import_prop_types88.default.string,
  /**
   * Provide an optional class name for the toolbar menu
   */
  menuOptionsClass: import_prop_types88.default.string,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types88.default.oneOfType([import_prop_types88.default.func, import_prop_types88.default.object])
};

// node_modules/@carbon/react/es/components/DataTable/DataTable.js
var getInstanceId2 = setupGetInstanceId();
var translationKeys4 = {
  expandRow: "carbon.table.row.expand",
  collapseRow: "carbon.table.row.collapse",
  expandAll: "carbon.table.all.expand",
  collapseAll: "carbon.table.all.collapse",
  selectAll: "carbon.table.all.select",
  unselectAll: "carbon.table.all.unselect",
  selectRow: "carbon.table.row.select",
  unselectRow: "carbon.table.row.unselect"
};
var defaultTranslations6 = {
  [translationKeys4.expandAll]: "Expand all rows",
  [translationKeys4.collapseAll]: "Collapse all rows",
  [translationKeys4.expandRow]: "Expand current row",
  [translationKeys4.collapseRow]: "Collapse current row",
  [translationKeys4.selectAll]: "Select all rows",
  [translationKeys4.unselectAll]: "Unselect all rows",
  [translationKeys4.selectRow]: "Select row",
  [translationKeys4.unselectRow]: "Unselect row"
};
var translateWithId4 = (id) => defaultTranslations6[id];
var DataTable = (props) => {
  const {
    children,
    filterRows = defaultFilterRows,
    headers,
    render,
    translateWithId: t3 = translateWithId4,
    size: size4,
    isSortable: isSortableProp,
    useZebraStyles,
    useStaticWidth,
    stickyHeader,
    overflowMenuOnHover,
    experimentalAutoAlign,
    radio,
    rows
  } = props;
  const instanceId2 = (0, import_react123.useMemo)(() => getInstanceId2(), []);
  const [state, setState] = (0, import_react123.useState)(() => ({
    ...getDerivedStateFromProps(props, {}),
    isExpandedAll: false
    // Start with collapsed state, treat `undefined` as neutral state
  }));
  (0, import_react123.useEffect)(() => {
    const nextRowIds = rows.map((row) => row.id);
    const nextHeaders = headers.map((header) => header.key);
    const hasRowIdsChanged = !(0, import_react_fast_compare2.default)(nextRowIds, state.rowIds);
    const currentHeaders = Object.keys(state.cellsById).reduce((acc, cellId) => {
      const headerKey = cellId.split(":")[1];
      if (headerKey && !acc.includes(headerKey)) {
        acc.push(headerKey);
      }
      return acc;
    }, []);
    const hasHeadersChanged = !(0, import_react_fast_compare2.default)(nextHeaders, currentHeaders);
    const currentRows = state.rowIds.map((id) => {
      const row = state.rowsById[id];
      return {
        // TODO: Investigate whether it be okay to just return `row`.
        id: row.id,
        disabled: row.disabled,
        isExpanded: row.isExpanded,
        isSelected: row.isSelected
      };
    });
    const hasRowsChanged = !(0, import_react_fast_compare2.default)(rows, currentRows);
    if (hasRowIdsChanged || hasHeadersChanged || hasRowsChanged) {
      setState((prev) => getDerivedStateFromProps(props, prev));
    }
  }, [headers, rows]);
  const getHeaderProps = ({
    header,
    onClick,
    isSortable = isSortableProp,
    ...rest
  }) => {
    const {
      sortDirection,
      sortHeaderKey
    } = state;
    return {
      ...rest,
      key: header.key,
      sortDirection,
      isSortable,
      isSortHeader: sortHeaderKey === header.key,
      slug: header.slug,
      decorator: header.decorator,
      onClick: (event) => {
        const nextSortState = getNextSortState(props, state, {
          key: header.key
        });
        setState((prev) => ({
          ...prev,
          ...nextSortState
        }));
        onClick && handleOnHeaderClick(onClick, {
          sortHeaderKey: header.key,
          sortDirection: nextSortState.sortDirection
        })(event);
      }
    };
  };
  const getExpandHeaderProps = ({
    onClick,
    onExpand,
    ...rest
  } = {}) => {
    const {
      isExpandedAll,
      rowIds,
      rowsById
    } = state;
    const isExpanded = isExpandedAll || rowIds.every((id) => rowsById[id].isExpanded);
    const translationKey = isExpanded ? translationKeys4.collapseAll : translationKeys4.expandAll;
    return {
      ...rest,
      "aria-label": t3(translationKey),
      // Provide a string of all the expanded row id's, separated by a space.
      "aria-controls": rowIds.map((id) => `expanded-row-${id}`).join(" "),
      isExpanded,
      // Compose the event handlers so we don't overwrite a consumer's `onClick`
      // handler
      onExpand: composeEventHandlers([
        handleOnExpandAll,
        onExpand,
        // TODO: Avoid passing `false` to this function.
        onClick && handleOnExpandHeaderClick(onClick, {
          isExpanded
        })
      ])
    };
  };
  const handleOnHeaderClick = (onClick, sortParams) => {
    return (event) => onClick(event, sortParams);
  };
  const handleOnExpandHeaderClick = (onClick, expandParams) => {
    return (event) => onClick(event, expandParams);
  };
  const getRowProps = ({
    row,
    onClick,
    ...rest
  }) => {
    const translationKey = row.isExpanded ? translationKeys4.collapseRow : translationKeys4.expandRow;
    return {
      ...rest,
      key: row.id,
      onClick,
      // Compose the event handlers so we don't overwrite a consumer's `onClick`
      // handler
      onExpand: composeEventHandlers([handleOnExpandRow(row.id), onClick]),
      isExpanded: row.isExpanded,
      "aria-label": t3(translationKey),
      "aria-controls": `expanded-row-${row.id}`,
      isSelected: row.isSelected,
      disabled: row.disabled
    };
  };
  const getExpandedRowProps = ({
    row,
    ...rest
  }) => {
    return {
      ...rest,
      id: `expanded-row-${row.id}`
    };
  };
  const getSelectionProps = ({
    onClick,
    row,
    ...rest
  } = {}) => {
    if (row) {
      const translationKey2 = row.isSelected ? translationKeys4.unselectRow : translationKeys4.selectRow;
      return {
        ...rest,
        checked: row.isSelected,
        onSelect: composeEventHandlers([handleOnSelectRow(row.id), onClick]),
        id: `${getTablePrefix()}__select-row-${row.id}`,
        name: `select-row-${instanceId2}`,
        "aria-label": t3(translationKey2),
        disabled: row.disabled,
        radio
      };
    }
    const rowCount = state.rowIds.length;
    const selectedRowCount = getSelectedRows().length;
    const checked = rowCount > 0 && selectedRowCount === rowCount;
    const indeterminate = rowCount > 0 && selectedRowCount > 0 && selectedRowCount !== rowCount;
    const translationKey = checked || indeterminate ? translationKeys4.unselectAll : translationKeys4.selectAll;
    return {
      ...rest,
      "aria-label": t3(translationKey),
      checked,
      id: `${getTablePrefix()}__select-all`,
      indeterminate,
      name: `select-all-${instanceId2}`,
      onSelect: composeEventHandlers([handleSelectAll, onClick])
    };
  };
  const getToolbarProps = (props2) => {
    const isSmall = size4 === "xs" || size4 === "sm";
    return {
      ...props2,
      size: isSmall ? "sm" : void 0
    };
  };
  const getBatchActionProps = (props2) => {
    const {
      shouldShowBatchActions
    } = state;
    const totalSelected = getSelectedRows().length;
    return {
      onSelectAll: void 0,
      totalCount: state.rowIds.length || 0,
      ...props2,
      shouldShowBatchActions: shouldShowBatchActions && totalSelected > 0,
      totalSelected,
      onCancel: handleOnCancel
    };
  };
  const getTableProps = () => {
    return {
      useZebraStyles,
      size: size4 ?? "lg",
      isSortable: isSortableProp,
      useStaticWidth,
      stickyHeader,
      overflowMenuOnHover: overflowMenuOnHover ?? false,
      experimentalAutoAlign
    };
  };
  const getTableContainerProps = () => {
    return {
      stickyHeader,
      useStaticWidth
    };
  };
  const getCellProps = ({
    cell: {
      hasAILabelHeader,
      hasDecoratorHeader
    },
    ...rest
  }) => {
    return {
      ...rest,
      hasAILabelHeader,
      hasDecoratorHeader
    };
  };
  const getSelectedRows = () => state.rowIds.filter((id) => {
    const row = state.rowsById[id];
    return row.isSelected && !row.disabled;
  });
  const getFilteredRowIds = () => {
    const filteredRowIds2 = typeof state.filterInputValue === "string" ? filterRows({
      rowIds: state.rowIds,
      headers,
      cellsById: state.cellsById,
      inputValue: state.filterInputValue,
      getCellId
    }) : state.rowIds;
    if (filteredRowIds2.length == 0) {
      return [];
    }
    return filteredRowIds2;
  };
  const getTablePrefix = () => `data-table-${instanceId2}`;
  const setAllSelectedState = (initialState, isSelected, filteredRowIds2) => {
    const {
      rowIds
    } = initialState;
    const isFiltered = rowIds.length != filteredRowIds2.length;
    return {
      // TODO: Should the `reduce` be typed with `<Record<string,
      // DataTableRow<ColTypes>>>`?
      rowsById: rowIds.reduce((acc, id) => {
        const row = {
          ...initialState.rowsById[id]
        };
        if (!row.disabled && (!isFiltered || filteredRowIds2.includes(id))) {
          row.isSelected = isSelected;
        }
        acc[id] = row;
        return acc;
      }, {})
    };
  };
  const handleOnCancel = () => {
    setState((prev) => {
      return {
        ...prev,
        shouldShowBatchActions: false,
        ...setAllSelectedState(prev, false, getFilteredRowIds())
      };
    });
  };
  const handleSelectAll = () => {
    setState((prev) => {
      const filteredRowIds2 = getFilteredRowIds();
      const {
        rowsById
      } = prev;
      const isSelected = !(Object.values(rowsById).filter((row) => row.isSelected && !row.disabled).length > 0);
      return {
        ...prev,
        shouldShowBatchActions: isSelected,
        ...setAllSelectedState(prev, isSelected, filteredRowIds2)
      };
    });
  };
  const handleOnSelectRow = (rowId) => () => {
    setState((prev) => {
      const row = prev.rowsById[rowId];
      if (radio) {
        const rowsById = Object.entries(prev.rowsById).reduce((p, c) => {
          const [key, val] = c;
          val.isSelected = false;
          p[key] = val;
          return p;
        }, {});
        return {
          ...prev,
          shouldShowBatchActions: false,
          rowsById: {
            ...rowsById,
            [rowId]: {
              ...row,
              isSelected: !row.isSelected
            }
          }
        };
      }
      const selectedRows = prev.rowIds.filter((id) => prev.rowsById[id].isSelected).length;
      const selectedRowsCount = !row.isSelected ? selectedRows + 1 : selectedRows - 1;
      return {
        ...prev,
        // Basic assumption here is that we want to show the batch action bar if
        // the row is being selected. If it's being unselected, then see if we
        // have a non-zero number of selected rows that batch actions could
        // still apply to
        shouldShowBatchActions: !row.isSelected || selectedRowsCount > 0,
        rowsById: {
          ...prev.rowsById,
          [rowId]: {
            ...row,
            isSelected: !row.isSelected
          }
        }
      };
    });
  };
  const handleOnExpandRow = (rowId) => () => {
    setState((prev) => {
      const row = prev.rowsById[rowId];
      const {
        isExpandedAll
      } = prev;
      return {
        ...prev,
        isExpandedAll: row.isExpanded ? false : isExpandedAll,
        rowsById: {
          ...prev.rowsById,
          [rowId]: {
            ...row,
            isExpanded: !row.isExpanded
          }
        }
      };
    });
  };
  const handleOnExpandAll = () => {
    setState((prev) => {
      const {
        rowIds,
        isExpandedAll
      } = prev;
      return {
        ...prev,
        isExpandedAll: !isExpandedAll,
        // TODO: Add generic to `reduce`.
        rowsById: rowIds.reduce((acc, id) => ({
          ...acc,
          [id]: {
            ...prev.rowsById[id],
            isExpanded: !isExpandedAll
          }
        }), {})
      };
    });
  };
  const handleSortBy = (headerKey) => () => {
    setState((prev) => {
      const sortState = getNextSortState(props, prev, {
        key: headerKey
      });
      return {
        ...prev,
        // Preserve ALL existing state
        ...sortState
        // Then apply only the sorting changes
      };
    });
  };
  const handleOnInputValueChange = (event, defaultValue) => {
    if (event.target) {
      setState((prev) => ({
        ...prev,
        filterInputValue: event.target.value
      }));
    }
    if (defaultValue) {
      setState((prev) => ({
        ...prev,
        filterInputValue: defaultValue
      }));
    }
  };
  const filteredRowIds = typeof state.filterInputValue === "string" ? filterRows({
    rowIds: state.rowIds,
    headers,
    cellsById: state.cellsById,
    inputValue: state.filterInputValue,
    getCellId
  }) : state.rowIds;
  const renderProps = {
    // Data derived from state
    rows: denormalize(filteredRowIds, state.rowsById, state.cellsById),
    headers,
    selectedRows: denormalize(getSelectedRows(), state.rowsById, state.cellsById),
    // Prop accessors/getters
    getHeaderProps,
    getExpandHeaderProps,
    getRowProps,
    getExpandedRowProps,
    getSelectionProps,
    getToolbarProps,
    getBatchActionProps,
    getTableProps,
    getTableContainerProps,
    getCellProps,
    // Custom event handlers
    onInputChange: handleOnInputValueChange,
    // Expose internal state change actions
    sortBy: (headerKey) => handleSortBy(headerKey)(),
    selectAll: handleSelectAll,
    selectRow: (rowId) => handleOnSelectRow(rowId)(),
    expandRow: (rowId) => handleOnExpandRow(rowId)(),
    expandAll: handleOnExpandAll,
    radio
  };
  if (typeof render !== "undefined") {
    return render(renderProps);
  }
  if (typeof children !== "undefined") {
    return children(renderProps);
  }
  return null;
};
DataTable.translationKeys = Object.values(translationKeys4);
DataTable.Table = Table;
DataTable.TableActionList = TableActionList;
DataTable.TableBatchAction = TableBatchAction;
DataTable.TableBatchActions = TableBatchActions;
DataTable.TableBody = TableBody;
DataTable.TableCell = TableCell;
DataTable.TableContainer = TableContainer;
DataTable.TableDecoratorRow = TableDecoratorRow;
DataTable.TableExpandHeader = TableExpandHeader;
DataTable.TableExpandRow = TableExpandRow;
DataTable.TableExpandedRow = TableExpandedRow;
DataTable.TableHead = TableHead;
DataTable.TableHeader = TableHeader;
DataTable.TableRow = TableRow;
DataTable.TableSelectAll = TableSelectAll;
DataTable.TableSelectRow = TableSelectRow;
DataTable.TableSlugRow = TableSlugRow;
DataTable.TableToolbar = TableToolbar;
DataTable.TableToolbarAction = TableToolbarAction;
DataTable.TableToolbarContent = TableToolbarContent;
DataTable.TableToolbarSearch = TableToolbarSearch;
DataTable.TableToolbarMenu = TableToolbarMenu;
DataTable.propTypes = {
  /**
   * Experimental property. Allows table to align cell contents to the top if there is text wrapping in the content. Might have performance issues, intended for smaller tables
   */
  experimentalAutoAlign: import_prop_types89.default.bool,
  /**
   * Optional hook to manually control filtering of the rows from the
   * TableToolbarSearch component
   */
  filterRows: import_prop_types89.default.func,
  /**
   * The `headers` prop represents the order in which the headers should
   * appear in the table. We expect an array of objects to be passed in, where
   * `key` is the name of the key in a row object, and `header` is the name of
   * the header.
   */
  headers: import_prop_types89.default.arrayOf(import_prop_types89.default.shape({
    key: import_prop_types89.default.string.isRequired,
    header: import_prop_types89.default.node.isRequired
  })).isRequired,
  /**
   * Specify whether the table should be able to be sorted by its headers
   */
  isSortable: import_prop_types89.default.bool,
  /**
   * Provide a string for the current locale
   */
  locale: import_prop_types89.default.string,
  /**
   * Specify whether the overflow menu (if it exists) should be shown always, or only on hover
   */
  overflowMenuOnHover: import_prop_types89.default.bool,
  /**
   * Specify whether the control should be a radio button or inline checkbox
   */
  radio: import_prop_types89.default.bool,
  /**
   * The `rows` prop is where you provide us with a list of all the rows that
   * you want to render in the table. The only hard requirement is that this
   * is an array of objects, and that each object has a unique `id` field
   * available on it.
   */
  rows: import_prop_types89.default.arrayOf(import_prop_types89.default.shape({
    id: import_prop_types89.default.string.isRequired,
    disabled: import_prop_types89.default.bool,
    isSelected: import_prop_types89.default.bool,
    isExpanded: import_prop_types89.default.bool
  })).isRequired,
  /**
   *  Change the row height of table. Currently supports `xs`, `sm`, `md`, `lg`, and `xl`.
   */
  size: import_prop_types89.default.oneOf(["xs", "sm", "md", "lg", "xl"]),
  /**
   * Optional hook to manually control sorting of the rows.
   */
  sortRow: import_prop_types89.default.func,
  /**
   * Specify whether the header should be sticky.
   * Still experimental: may not work with every combination of table props
   */
  stickyHeader: import_prop_types89.default.bool,
  /**
   * Optional method that takes in a message id and returns an
   * internationalized string. See `DataTable.translationKeys` for all
   * available message ids.
   */
  translateWithId: import_prop_types89.default.func,
  /**
   * `false` If true, will use a width of 'auto' instead of 100%
   */
  useStaticWidth: import_prop_types89.default.bool,
  /**
   * `true` to add useZebraStyles striping.
   */
  useZebraStyles: import_prop_types89.default.bool
};

// node_modules/@carbon/react/es/components/DataTableSkeleton/DataTableSkeleton.js
var import_prop_types90 = __toESM(require_prop_types());
var import_react124 = __toESM(require_react());
var import_classnames75 = __toESM(require_classnames());
var _span5;
var _span22;
var DataTableSkeleton = ({
  headers,
  rowCount = 5,
  columnCount = 5,
  zebra = false,
  compact = false,
  className,
  showHeader = true,
  showToolbar = true,
  ...rest
}) => {
  const prefix = usePrefix();
  const dataTableSkeletonClasses = (0, import_classnames75.default)(className, {
    [`${prefix}--skeleton`]: true,
    [`${prefix}--data-table`]: true,
    [`${prefix}--data-table--zebra`]: zebra,
    [`${prefix}--data-table--compact`]: compact
  });
  const rowRepeat = rowCount;
  const rows = Array(rowRepeat);
  const columnsArray = Array.from({
    length: columnCount
  }, (_, index3) => index3);
  for (let i = 0; i < rowRepeat; i++) {
    rows[i] = import_react124.default.createElement("tr", {
      key: i
    }, columnsArray.map((j) => import_react124.default.createElement("td", {
      key: j
    }, _span5 || (_span5 = import_react124.default.createElement("span", null)))));
  }
  return import_react124.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--data-table-container`
  }, showHeader ? import_react124.default.createElement("div", {
    className: `${prefix}--data-table-header`
  }, import_react124.default.createElement("div", {
    className: `${prefix}--data-table-header__title`
  }), import_react124.default.createElement("div", {
    className: `${prefix}--data-table-header__description`
  })) : null, showToolbar ? import_react124.default.createElement("section", {
    "aria-label": "data table toolbar",
    className: `${prefix}--table-toolbar`
  }, import_react124.default.createElement("div", {
    className: `${prefix}--toolbar-content`
  }, import_react124.default.createElement("span", {
    className: `${prefix}--skeleton ${prefix}--btn ${prefix}--btn--sm`
  }))) : null, import_react124.default.createElement("table", _extends({
    className: dataTableSkeletonClasses
  }, rest), import_react124.default.createElement("thead", null, import_react124.default.createElement("tr", null, columnsArray.map((i) => {
    var _a;
    return import_react124.default.createElement("th", {
      key: i
    }, headers ? import_react124.default.createElement("div", {
      className: "cds--table-header-label"
    }, (_a = headers[i]) == null ? void 0 : _a.header) : _span22 || (_span22 = import_react124.default.createElement("span", null)));
  }))), import_react124.default.createElement("tbody", null, rows)));
};
DataTableSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types90.default.string,
  /**
   * Specify the number of columns that you want to render in the skeleton state
   */
  columnCount: import_prop_types90.default.number,
  /**
   * Optionally specify whether you want the Skeleton to be rendered as a
   * compact DataTable
   */
  compact: import_prop_types90.default.bool,
  /**
   * Optionally specify the displayed headers
   */
  headers: import_prop_types90.default.arrayOf(import_prop_types90.default.shape({
    header: import_prop_types90.default.node.isRequired
  }).isRequired),
  /**
   * Specify the number of rows that you want to render in the skeleton state
   */
  rowCount: import_prop_types90.default.number,
  /**
   * Specify if the table header should be rendered as part of the skeleton.
   */
  showHeader: import_prop_types90.default.bool,
  /**
   * Specify if the table toolbar should be rendered as part of the skeleton.
   */
  showToolbar: import_prop_types90.default.bool,
  /**
   * Optionally specify whether you want the DataTable to be zebra striped
   */
  zebra: import_prop_types90.default.bool
};

// node_modules/@carbon/react/es/components/DatePicker/DatePicker.js
var import_prop_types92 = __toESM(require_prop_types());
var import_react127 = __toESM(require_react());
var import_classnames77 = __toESM(require_classnames());

// node_modules/flatpickr/dist/esm/types/options.js
var HOOKS = [
  "onChange",
  "onClose",
  "onDayCreate",
  "onDestroy",
  "onKeyDown",
  "onMonthChange",
  "onOpen",
  "onParseConfig",
  "onReady",
  "onValueUpdate",
  "onYearChange",
  "onPreCalendarPosition"
];
var defaults = {
  _disable: [],
  allowInput: false,
  allowInvalidPreload: false,
  altFormat: "F j, Y",
  altInput: false,
  altInputClass: "form-control input",
  animate: typeof window === "object" && window.navigator.userAgent.indexOf("MSIE") === -1,
  ariaDateFormat: "F j, Y",
  autoFillDefaultTime: true,
  clickOpens: true,
  closeOnSelect: true,
  conjunction: ", ",
  dateFormat: "Y-m-d",
  defaultHour: 12,
  defaultMinute: 0,
  defaultSeconds: 0,
  disable: [],
  disableMobile: false,
  enableSeconds: false,
  enableTime: false,
  errorHandler: function(err) {
    return typeof console !== "undefined" && console.warn(err);
  },
  getWeek: function(givenDate) {
    var date = new Date(givenDate.getTime());
    date.setHours(0, 0, 0, 0);
    date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
    var week1 = new Date(date.getFullYear(), 0, 4);
    return 1 + Math.round(((date.getTime() - week1.getTime()) / 864e5 - 3 + (week1.getDay() + 6) % 7) / 7);
  },
  hourIncrement: 1,
  ignoredFocusElements: [],
  inline: false,
  locale: "default",
  minuteIncrement: 5,
  mode: "single",
  monthSelectorType: "dropdown",
  nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
  noCalendar: false,
  now: /* @__PURE__ */ new Date(),
  onChange: [],
  onClose: [],
  onDayCreate: [],
  onDestroy: [],
  onKeyDown: [],
  onMonthChange: [],
  onOpen: [],
  onParseConfig: [],
  onReady: [],
  onValueUpdate: [],
  onYearChange: [],
  onPreCalendarPosition: [],
  plugins: [],
  position: "auto",
  positionElement: void 0,
  prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
  shorthandCurrentMonth: false,
  showMonths: 1,
  static: false,
  time_24hr: false,
  weekNumbers: false,
  wrap: false
};

// node_modules/flatpickr/dist/esm/l10n/default.js
var english = {
  weekdays: {
    shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    longhand: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  },
  months: {
    shorthand: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    longhand: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  },
  daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
  firstDayOfWeek: 0,
  ordinal: function(nth) {
    var s = nth % 100;
    if (s > 3 && s < 21)
      return "th";
    switch (s % 10) {
      case 1:
        return "st";
      case 2:
        return "nd";
      case 3:
        return "rd";
      default:
        return "th";
    }
  },
  rangeSeparator: " to ",
  weekAbbreviation: "Wk",
  scrollTitle: "Scroll to increment",
  toggleTitle: "Click to toggle",
  amPM: ["AM", "PM"],
  yearAriaLabel: "Year",
  monthAriaLabel: "Month",
  hourAriaLabel: "Hour",
  minuteAriaLabel: "Minute",
  time_24hr: false
};
var default_default = english;

// node_modules/flatpickr/dist/esm/utils/index.js
var pad = function(number, length) {
  if (length === void 0) {
    length = 2;
  }
  return ("000" + number).slice(length * -1);
};
var int = function(bool) {
  return bool === true ? 1 : 0;
};
function debounce4(fn, wait) {
  var t3;
  return function() {
    var _this = this;
    var args = arguments;
    clearTimeout(t3);
    t3 = setTimeout(function() {
      return fn.apply(_this, args);
    }, wait);
  };
}
var arrayify = function(obj) {
  return obj instanceof Array ? obj : [obj];
};

// node_modules/flatpickr/dist/esm/utils/dom.js
function toggleClass2(elem, className, bool) {
  if (bool === true)
    return elem.classList.add(className);
  elem.classList.remove(className);
}
function createElement(tag, className, content) {
  var e2 = window.document.createElement(tag);
  className = className || "";
  content = content || "";
  e2.className = className;
  if (content !== void 0)
    e2.textContent = content;
  return e2;
}
function clearNode(node) {
  while (node.firstChild)
    node.removeChild(node.firstChild);
}
function findParent(node, condition) {
  if (condition(node))
    return node;
  else if (node.parentNode)
    return findParent(node.parentNode, condition);
  return void 0;
}
function createNumberInput(inputClassName, opts) {
  var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
  if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
    numInput.type = "number";
  } else {
    numInput.type = "text";
    numInput.pattern = "\\d*";
  }
  if (opts !== void 0)
    for (var key in opts)
      numInput.setAttribute(key, opts[key]);
  wrapper.appendChild(numInput);
  wrapper.appendChild(arrowUp);
  wrapper.appendChild(arrowDown);
  return wrapper;
}
function getEventTarget(event) {
  try {
    if (typeof event.composedPath === "function") {
      var path = event.composedPath();
      return path[0];
    }
    return event.target;
  } catch (error2) {
    return event.target;
  }
}

// node_modules/flatpickr/dist/esm/utils/formatting.js
var doNothing = function() {
  return void 0;
};
var monthToStr = function(monthNumber, shorthand, locale) {
  return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
};
var revFormat = {
  D: doNothing,
  F: function(dateObj, monthName, locale) {
    dateObj.setMonth(locale.months.longhand.indexOf(monthName));
  },
  G: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  H: function(dateObj, hour) {
    dateObj.setHours(parseFloat(hour));
  },
  J: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  K: function(dateObj, amPM, locale) {
    dateObj.setHours(dateObj.getHours() % 12 + 12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
  },
  M: function(dateObj, shortMonth, locale) {
    dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
  },
  S: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  U: function(_, unixSeconds) {
    return new Date(parseFloat(unixSeconds) * 1e3);
  },
  W: function(dateObj, weekNum, locale) {
    var weekNumber = parseInt(weekNum);
    var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
    date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
    return date;
  },
  Y: function(dateObj, year) {
    dateObj.setFullYear(parseFloat(year));
  },
  Z: function(_, ISODate) {
    return new Date(ISODate);
  },
  d: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  h: function(dateObj, hour) {
    dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
  },
  i: function(dateObj, minutes) {
    dateObj.setMinutes(parseFloat(minutes));
  },
  j: function(dateObj, day) {
    dateObj.setDate(parseFloat(day));
  },
  l: doNothing,
  m: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  n: function(dateObj, month) {
    dateObj.setMonth(parseFloat(month) - 1);
  },
  s: function(dateObj, seconds) {
    dateObj.setSeconds(parseFloat(seconds));
  },
  u: function(_, unixMillSeconds) {
    return new Date(parseFloat(unixMillSeconds));
  },
  w: doNothing,
  y: function(dateObj, year) {
    dateObj.setFullYear(2e3 + parseFloat(year));
  }
};
var tokenRegex = {
  D: "",
  F: "",
  G: "(\\d\\d|\\d)",
  H: "(\\d\\d|\\d)",
  J: "(\\d\\d|\\d)\\w+",
  K: "",
  M: "",
  S: "(\\d\\d|\\d)",
  U: "(.+)",
  W: "(\\d\\d|\\d)",
  Y: "(\\d{4})",
  Z: "(.+)",
  d: "(\\d\\d|\\d)",
  h: "(\\d\\d|\\d)",
  i: "(\\d\\d|\\d)",
  j: "(\\d\\d|\\d)",
  l: "",
  m: "(\\d\\d|\\d)",
  n: "(\\d\\d|\\d)",
  s: "(\\d\\d|\\d)",
  u: "(.+)",
  w: "(\\d\\d|\\d)",
  y: "(\\d{2})"
};
var formats = {
  Z: function(date) {
    return date.toISOString();
  },
  D: function(date, locale, options) {
    return locale.weekdays.shorthand[formats.w(date, locale, options)];
  },
  F: function(date, locale, options) {
    return monthToStr(formats.n(date, locale, options) - 1, false, locale);
  },
  G: function(date, locale, options) {
    return pad(formats.h(date, locale, options));
  },
  H: function(date) {
    return pad(date.getHours());
  },
  J: function(date, locale) {
    return locale.ordinal !== void 0 ? date.getDate() + locale.ordinal(date.getDate()) : date.getDate();
  },
  K: function(date, locale) {
    return locale.amPM[int(date.getHours() > 11)];
  },
  M: function(date, locale) {
    return monthToStr(date.getMonth(), true, locale);
  },
  S: function(date) {
    return pad(date.getSeconds());
  },
  U: function(date) {
    return date.getTime() / 1e3;
  },
  W: function(date, _, options) {
    return options.getWeek(date);
  },
  Y: function(date) {
    return pad(date.getFullYear(), 4);
  },
  d: function(date) {
    return pad(date.getDate());
  },
  h: function(date) {
    return date.getHours() % 12 ? date.getHours() % 12 : 12;
  },
  i: function(date) {
    return pad(date.getMinutes());
  },
  j: function(date) {
    return date.getDate();
  },
  l: function(date, locale) {
    return locale.weekdays.longhand[date.getDay()];
  },
  m: function(date) {
    return pad(date.getMonth() + 1);
  },
  n: function(date) {
    return date.getMonth() + 1;
  },
  s: function(date) {
    return date.getSeconds();
  },
  u: function(date) {
    return date.getTime();
  },
  w: function(date) {
    return date.getDay();
  },
  y: function(date) {
    return String(date.getFullYear()).substring(2);
  }
};

// node_modules/flatpickr/dist/esm/utils/dates.js
var createDateFormatter = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n2 = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
  return function(dateObj, frmt, overrideLocale) {
    var locale = overrideLocale || l10n2;
    if (config.formatDate !== void 0 && !isMobile) {
      return config.formatDate(dateObj, frmt, locale);
    }
    return frmt.split("").map(function(c, i, arr) {
      return formats[c] && arr[i - 1] !== "\\" ? formats[c](dateObj, locale, config) : c !== "\\" ? c : "";
    }).join("");
  };
};
var createDateParser = function(_a) {
  var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n2 = _c === void 0 ? english : _c;
  return function(date, givenFormat, timeless, customLocale) {
    if (date !== 0 && !date)
      return void 0;
    var locale = customLocale || l10n2;
    var parsedDate;
    var dateOrig = date;
    if (date instanceof Date)
      parsedDate = new Date(date.getTime());
    else if (typeof date !== "string" && date.toFixed !== void 0)
      parsedDate = new Date(date);
    else if (typeof date === "string") {
      var format = givenFormat || (config || defaults).dateFormat;
      var datestr = String(date).trim();
      if (datestr === "today") {
        parsedDate = /* @__PURE__ */ new Date();
        timeless = true;
      } else if (config && config.parseDate) {
        parsedDate = config.parseDate(date, format);
      } else if (/Z$/.test(datestr) || /GMT$/.test(datestr)) {
        parsedDate = new Date(date);
      } else {
        var matched = void 0, ops = [];
        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
          var token = format[i];
          var isBackSlash = token === "\\";
          var escaped = format[i - 1] === "\\" || isBackSlash;
          if (tokenRegex[token] && !escaped) {
            regexStr += tokenRegex[token];
            var match2 = new RegExp(regexStr).exec(date);
            if (match2 && (matched = true)) {
              ops[token !== "Y" ? "push" : "unshift"]({
                fn: revFormat[token],
                val: match2[++matchIndex]
              });
            }
          } else if (!isBackSlash)
            regexStr += ".";
        }
        parsedDate = !config || !config.noCalendar ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1, 0, 0, 0, 0) : new Date((/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0));
        ops.forEach(function(_a2) {
          var fn = _a2.fn, val = _a2.val;
          return parsedDate = fn(parsedDate, val, locale) || parsedDate;
        });
        parsedDate = matched ? parsedDate : void 0;
      }
    }
    if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
      config.errorHandler(new Error("Invalid date provided: " + dateOrig));
      return void 0;
    }
    if (timeless === true)
      parsedDate.setHours(0, 0, 0, 0);
    return parsedDate;
  };
};
function compareDates(date1, date2, timeless) {
  if (timeless === void 0) {
    timeless = true;
  }
  if (timeless !== false) {
    return new Date(date1.getTime()).setHours(0, 0, 0, 0) - new Date(date2.getTime()).setHours(0, 0, 0, 0);
  }
  return date1.getTime() - date2.getTime();
}
var isBetween = function(ts, ts1, ts2) {
  return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function(hours, minutes, seconds) {
  return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function(secondsSinceMidnight) {
  var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
  return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
  DAY: 864e5
};
function getDefaultHours(config) {
  var hours = config.defaultHour;
  var minutes = config.defaultMinute;
  var seconds = config.defaultSeconds;
  if (config.minDate !== void 0) {
    var minHour = config.minDate.getHours();
    var minMinutes = config.minDate.getMinutes();
    var minSeconds = config.minDate.getSeconds();
    if (hours < minHour) {
      hours = minHour;
    }
    if (hours === minHour && minutes < minMinutes) {
      minutes = minMinutes;
    }
    if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
      seconds = config.minDate.getSeconds();
  }
  if (config.maxDate !== void 0) {
    var maxHr = config.maxDate.getHours();
    var maxMinutes = config.maxDate.getMinutes();
    hours = Math.min(hours, maxHr);
    if (hours === maxHr)
      minutes = Math.min(maxMinutes, minutes);
    if (hours === maxHr && minutes === maxMinutes)
      seconds = config.maxDate.getSeconds();
  }
  return { hours, minutes, seconds };
}

// node_modules/flatpickr/dist/esm/utils/polyfills.js
if (typeof Object.assign !== "function") {
  Object.assign = function(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (!target) {
      throw TypeError("Cannot convert undefined or null to object");
    }
    var _loop_1 = function(source2) {
      if (source2) {
        Object.keys(source2).forEach(function(key) {
          return target[key] = source2[key];
        });
      }
    };
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var source = args_1[_a];
      _loop_1(source);
    }
    return target;
  };
}

// node_modules/flatpickr/dist/esm/index.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t3) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t3[p] = s[p];
    }
    return t3;
  };
  return __assign2.apply(this, arguments);
};
var __spreadArrays = function() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r2 = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r2[k] = a[j];
  return r2;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
  var self2 = {
    config: __assign2(__assign2({}, defaults), flatpickr.defaultConfig),
    l10n: default_default
  };
  self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  self2._handlers = [];
  self2.pluginElements = [];
  self2.loadedPlugins = [];
  self2._bind = bind;
  self2._setHoursFromDate = setHoursFromDate;
  self2._positionCalendar = positionCalendar;
  self2.changeMonth = changeMonth;
  self2.changeYear = changeYear;
  self2.clear = clear;
  self2.close = close;
  self2.onMouseOver = onMouseOver;
  self2._createElement = createElement;
  self2.createDay = createDay;
  self2.destroy = destroy;
  self2.isEnabled = isEnabled;
  self2.jumpToDate = jumpToDate;
  self2.updateValue = updateValue;
  self2.open = open2;
  self2.redraw = redraw;
  self2.set = set;
  self2.setDate = setDate;
  self2.toggle = toggle;
  function setupHelperFunctions() {
    self2.utils = {
      getDaysInMonth: function(month, yr) {
        if (month === void 0) {
          month = self2.currentMonth;
        }
        if (yr === void 0) {
          yr = self2.currentYear;
        }
        if (month === 1 && (yr % 4 === 0 && yr % 100 !== 0 || yr % 400 === 0))
          return 29;
        return self2.l10n.daysInMonth[month];
      }
    };
  }
  function init() {
    self2.element = self2.input = element;
    self2.isOpen = false;
    parseConfig();
    setupLocale();
    setupInputs();
    setupDates();
    setupHelperFunctions();
    if (!self2.isMobile)
      build();
    bindEvents();
    if (self2.selectedDates.length || self2.config.noCalendar) {
      if (self2.config.enableTime) {
        setHoursFromDate(self2.config.noCalendar ? self2.latestSelectedDateObj : void 0);
      }
      updateValue(false);
    }
    setCalendarWidth();
    var isSafari2 = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    if (!self2.isMobile && isSafari2) {
      positionCalendar();
    }
    triggerEvent("onReady");
  }
  function getClosestActiveElement() {
    var _a;
    return ((_a = self2.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode()).activeElement || document.activeElement;
  }
  function bindToInstance(fn) {
    return fn.bind(self2);
  }
  function setCalendarWidth() {
    var config = self2.config;
    if (config.weekNumbers === false && config.showMonths === 1) {
      return;
    } else if (config.noCalendar !== true) {
      window.requestAnimationFrame(function() {
        if (self2.calendarContainer !== void 0) {
          self2.calendarContainer.style.visibility = "hidden";
          self2.calendarContainer.style.display = "block";
        }
        if (self2.daysContainer !== void 0) {
          var daysWidth = (self2.days.offsetWidth + 1) * config.showMonths;
          self2.daysContainer.style.width = daysWidth + "px";
          self2.calendarContainer.style.width = daysWidth + (self2.weekWrapper !== void 0 ? self2.weekWrapper.offsetWidth : 0) + "px";
          self2.calendarContainer.style.removeProperty("visibility");
          self2.calendarContainer.style.removeProperty("display");
        }
      });
    }
  }
  function updateTime(e2) {
    if (self2.selectedDates.length === 0) {
      var defaultDate = self2.config.minDate === void 0 || compareDates(/* @__PURE__ */ new Date(), self2.config.minDate) >= 0 ? /* @__PURE__ */ new Date() : new Date(self2.config.minDate.getTime());
      var defaults2 = getDefaultHours(self2.config);
      defaultDate.setHours(defaults2.hours, defaults2.minutes, defaults2.seconds, defaultDate.getMilliseconds());
      self2.selectedDates = [defaultDate];
      self2.latestSelectedDateObj = defaultDate;
    }
    if (e2 !== void 0 && e2.type !== "blur") {
      timeWrapper(e2);
    }
    var prevValue = self2._input.value;
    setHoursFromInputs();
    updateValue();
    if (self2._input.value !== prevValue) {
      self2._debouncedChange();
    }
  }
  function ampm2military(hour, amPM) {
    return hour % 12 + 12 * int(amPM === self2.l10n.amPM[1]);
  }
  function military2ampm(hour) {
    switch (hour % 24) {
      case 0:
      case 12:
        return 12;
      default:
        return hour % 12;
    }
  }
  function setHoursFromInputs() {
    if (self2.hourElement === void 0 || self2.minuteElement === void 0)
      return;
    var hours = (parseInt(self2.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self2.minuteElement.value, 10) || 0) % 60, seconds = self2.secondElement !== void 0 ? (parseInt(self2.secondElement.value, 10) || 0) % 60 : 0;
    if (self2.amPM !== void 0) {
      hours = ampm2military(hours, self2.amPM.textContent);
    }
    var limitMinHours = self2.config.minTime !== void 0 || self2.config.minDate && self2.minDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.minDate, true) === 0;
    var limitMaxHours = self2.config.maxTime !== void 0 || self2.config.maxDate && self2.maxDateHasTime && self2.latestSelectedDateObj && compareDates(self2.latestSelectedDateObj, self2.config.maxDate, true) === 0;
    if (self2.config.maxTime !== void 0 && self2.config.minTime !== void 0 && self2.config.minTime > self2.config.maxTime) {
      var minBound = calculateSecondsSinceMidnight(self2.config.minTime.getHours(), self2.config.minTime.getMinutes(), self2.config.minTime.getSeconds());
      var maxBound = calculateSecondsSinceMidnight(self2.config.maxTime.getHours(), self2.config.maxTime.getMinutes(), self2.config.maxTime.getSeconds());
      var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
      if (currentTime > maxBound && currentTime < minBound) {
        var result = parseSeconds(minBound);
        hours = result[0];
        minutes = result[1];
        seconds = result[2];
      }
    } else {
      if (limitMaxHours) {
        var maxTime = self2.config.maxTime !== void 0 ? self2.config.maxTime : self2.config.maxDate;
        hours = Math.min(hours, maxTime.getHours());
        if (hours === maxTime.getHours())
          minutes = Math.min(minutes, maxTime.getMinutes());
        if (minutes === maxTime.getMinutes())
          seconds = Math.min(seconds, maxTime.getSeconds());
      }
      if (limitMinHours) {
        var minTime = self2.config.minTime !== void 0 ? self2.config.minTime : self2.config.minDate;
        hours = Math.max(hours, minTime.getHours());
        if (hours === minTime.getHours() && minutes < minTime.getMinutes())
          minutes = minTime.getMinutes();
        if (minutes === minTime.getMinutes())
          seconds = Math.max(seconds, minTime.getSeconds());
      }
    }
    setHours(hours, minutes, seconds);
  }
  function setHoursFromDate(dateObj) {
    var date = dateObj || self2.latestSelectedDateObj;
    if (date && date instanceof Date) {
      setHours(date.getHours(), date.getMinutes(), date.getSeconds());
    }
  }
  function setHours(hours, minutes, seconds) {
    if (self2.latestSelectedDateObj !== void 0) {
      self2.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
    }
    if (!self2.hourElement || !self2.minuteElement || self2.isMobile)
      return;
    self2.hourElement.value = pad(!self2.config.time_24hr ? (12 + hours) % 12 + 12 * int(hours % 12 === 0) : hours);
    self2.minuteElement.value = pad(minutes);
    if (self2.amPM !== void 0)
      self2.amPM.textContent = self2.l10n.amPM[int(hours >= 12)];
    if (self2.secondElement !== void 0)
      self2.secondElement.value = pad(seconds);
  }
  function onYearInput(event) {
    var eventTarget = getEventTarget(event);
    var year = parseInt(eventTarget.value) + (event.delta || 0);
    if (year / 1e3 > 1 || event.key === "Enter" && !/[^\d]/.test(year.toString())) {
      changeYear(year);
    }
  }
  function bind(element2, event, handler, options) {
    if (event instanceof Array)
      return event.forEach(function(ev) {
        return bind(element2, ev, handler, options);
      });
    if (element2 instanceof Array)
      return element2.forEach(function(el) {
        return bind(el, event, handler, options);
      });
    element2.addEventListener(event, handler, options);
    self2._handlers.push({
      remove: function() {
        return element2.removeEventListener(event, handler, options);
      }
    });
  }
  function triggerChange() {
    triggerEvent("onChange");
  }
  function bindEvents() {
    if (self2.config.wrap) {
      ["open", "close", "toggle", "clear"].forEach(function(evt) {
        Array.prototype.forEach.call(self2.element.querySelectorAll("[data-" + evt + "]"), function(el) {
          return bind(el, "click", self2[evt]);
        });
      });
    }
    if (self2.isMobile) {
      setupMobile();
      return;
    }
    var debouncedResize = debounce4(onResize, 50);
    self2._debouncedChange = debounce4(triggerChange, DEBOUNCED_CHANGE_MS);
    if (self2.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
      bind(self2.daysContainer, "mouseover", function(e2) {
        if (self2.config.mode === "range")
          onMouseOver(getEventTarget(e2));
      });
    bind(self2._input, "keydown", onKeyDown);
    if (self2.calendarContainer !== void 0) {
      bind(self2.calendarContainer, "keydown", onKeyDown);
    }
    if (!self2.config.inline && !self2.config.static)
      bind(window, "resize", debouncedResize);
    if (window.ontouchstart !== void 0)
      bind(window.document, "touchstart", documentClick);
    else
      bind(window.document, "mousedown", documentClick);
    bind(window.document, "focus", documentClick, { capture: true });
    if (self2.config.clickOpens === true) {
      bind(self2._input, "focus", self2.open);
      bind(self2._input, "click", self2.open);
    }
    if (self2.daysContainer !== void 0) {
      bind(self2.monthNav, "click", onMonthNavClick);
      bind(self2.monthNav, ["keyup", "increment"], onYearInput);
      bind(self2.daysContainer, "click", selectDate);
    }
    if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0) {
      var selText = function(e2) {
        return getEventTarget(e2).select();
      };
      bind(self2.timeContainer, ["increment"], updateTime);
      bind(self2.timeContainer, "blur", updateTime, { capture: true });
      bind(self2.timeContainer, "click", timeIncrement);
      bind([self2.hourElement, self2.minuteElement], ["focus", "click"], selText);
      if (self2.secondElement !== void 0)
        bind(self2.secondElement, "focus", function() {
          return self2.secondElement && self2.secondElement.select();
        });
      if (self2.amPM !== void 0) {
        bind(self2.amPM, "click", function(e2) {
          updateTime(e2);
        });
      }
    }
    if (self2.config.allowInput) {
      bind(self2._input, "blur", onBlur);
    }
  }
  function jumpToDate(jumpDate, triggerChange2) {
    var jumpTo = jumpDate !== void 0 ? self2.parseDate(jumpDate) : self2.latestSelectedDateObj || (self2.config.minDate && self2.config.minDate > self2.now ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate < self2.now ? self2.config.maxDate : self2.now);
    var oldYear = self2.currentYear;
    var oldMonth = self2.currentMonth;
    try {
      if (jumpTo !== void 0) {
        self2.currentYear = jumpTo.getFullYear();
        self2.currentMonth = jumpTo.getMonth();
      }
    } catch (e2) {
      e2.message = "Invalid date supplied: " + jumpTo;
      self2.config.errorHandler(e2);
    }
    if (triggerChange2 && self2.currentYear !== oldYear) {
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    if (triggerChange2 && (self2.currentYear !== oldYear || self2.currentMonth !== oldMonth)) {
      triggerEvent("onMonthChange");
    }
    self2.redraw();
  }
  function timeIncrement(e2) {
    var eventTarget = getEventTarget(e2);
    if (~eventTarget.className.indexOf("arrow"))
      incrementNumInput(e2, eventTarget.classList.contains("arrowUp") ? 1 : -1);
  }
  function incrementNumInput(e2, delta, inputElem) {
    var target = e2 && getEventTarget(e2);
    var input = inputElem || target && target.parentNode && target.parentNode.firstChild;
    var event = createEvent("increment");
    event.delta = delta;
    input && input.dispatchEvent(event);
  }
  function build() {
    var fragment = window.document.createDocumentFragment();
    self2.calendarContainer = createElement("div", "flatpickr-calendar");
    self2.calendarContainer.tabIndex = -1;
    if (!self2.config.noCalendar) {
      fragment.appendChild(buildMonthNav());
      self2.innerContainer = createElement("div", "flatpickr-innerContainer");
      if (self2.config.weekNumbers) {
        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
        self2.innerContainer.appendChild(weekWrapper);
        self2.weekNumbers = weekNumbers;
        self2.weekWrapper = weekWrapper;
      }
      self2.rContainer = createElement("div", "flatpickr-rContainer");
      self2.rContainer.appendChild(buildWeekdays());
      if (!self2.daysContainer) {
        self2.daysContainer = createElement("div", "flatpickr-days");
        self2.daysContainer.tabIndex = -1;
      }
      buildDays();
      self2.rContainer.appendChild(self2.daysContainer);
      self2.innerContainer.appendChild(self2.rContainer);
      fragment.appendChild(self2.innerContainer);
    }
    if (self2.config.enableTime) {
      fragment.appendChild(buildTime());
    }
    toggleClass2(self2.calendarContainer, "rangeMode", self2.config.mode === "range");
    toggleClass2(self2.calendarContainer, "animate", self2.config.animate === true);
    toggleClass2(self2.calendarContainer, "multiMonth", self2.config.showMonths > 1);
    self2.calendarContainer.appendChild(fragment);
    var customAppend = self2.config.appendTo !== void 0 && self2.config.appendTo.nodeType !== void 0;
    if (self2.config.inline || self2.config.static) {
      self2.calendarContainer.classList.add(self2.config.inline ? "inline" : "static");
      if (self2.config.inline) {
        if (!customAppend && self2.element.parentNode)
          self2.element.parentNode.insertBefore(self2.calendarContainer, self2._input.nextSibling);
        else if (self2.config.appendTo !== void 0)
          self2.config.appendTo.appendChild(self2.calendarContainer);
      }
      if (self2.config.static) {
        var wrapper = createElement("div", "flatpickr-wrapper");
        if (self2.element.parentNode)
          self2.element.parentNode.insertBefore(wrapper, self2.element);
        wrapper.appendChild(self2.element);
        if (self2.altInput)
          wrapper.appendChild(self2.altInput);
        wrapper.appendChild(self2.calendarContainer);
      }
    }
    if (!self2.config.static && !self2.config.inline)
      (self2.config.appendTo !== void 0 ? self2.config.appendTo : window.document.body).appendChild(self2.calendarContainer);
  }
  function createDay(className, date, _dayNumber, i) {
    var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
    dayElement.dateObj = date;
    dayElement.$i = i;
    dayElement.setAttribute("aria-label", self2.formatDate(date, self2.config.ariaDateFormat));
    if (className.indexOf("hidden") === -1 && compareDates(date, self2.now) === 0) {
      self2.todayDateElem = dayElement;
      dayElement.classList.add("today");
      dayElement.setAttribute("aria-current", "date");
    }
    if (dateIsEnabled) {
      dayElement.tabIndex = -1;
      if (isDateSelected(date)) {
        dayElement.classList.add("selected");
        self2.selectedDateElem = dayElement;
        if (self2.config.mode === "range") {
          toggleClass2(dayElement, "startRange", self2.selectedDates[0] && compareDates(date, self2.selectedDates[0], true) === 0);
          toggleClass2(dayElement, "endRange", self2.selectedDates[1] && compareDates(date, self2.selectedDates[1], true) === 0);
          if (className === "nextMonthDay")
            dayElement.classList.add("inRange");
        }
      }
    } else {
      dayElement.classList.add("flatpickr-disabled");
    }
    if (self2.config.mode === "range") {
      if (isDateInRange(date) && !isDateSelected(date))
        dayElement.classList.add("inRange");
    }
    if (self2.weekNumbers && self2.config.showMonths === 1 && className !== "prevMonthDay" && i % 7 === 6) {
      self2.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self2.config.getWeek(date) + "</span>");
    }
    triggerEvent("onDayCreate", dayElement);
    return dayElement;
  }
  function focusOnDayElem(targetNode) {
    targetNode.focus();
    if (self2.config.mode === "range")
      onMouseOver(targetNode);
  }
  function getFirstAvailableDay(delta) {
    var startMonth = delta > 0 ? 0 : self2.config.showMonths - 1;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    for (var m = startMonth; m != endMonth; m += delta) {
      var month = self2.daysContainer.children[m];
      var startIndex = delta > 0 ? 0 : month.children.length - 1;
      var endIndex = delta > 0 ? month.children.length : -1;
      for (var i = startIndex; i != endIndex; i += delta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
          return c;
      }
    }
    return void 0;
  }
  function getNextAvailableDay(current, delta) {
    var givenMonth = current.className.indexOf("Month") === -1 ? current.dateObj.getMonth() : self2.currentMonth;
    var endMonth = delta > 0 ? self2.config.showMonths : -1;
    var loopDelta = delta > 0 ? 1 : -1;
    for (var m = givenMonth - self2.currentMonth; m != endMonth; m += loopDelta) {
      var month = self2.daysContainer.children[m];
      var startIndex = givenMonth - self2.currentMonth === m ? current.$i + delta : delta < 0 ? month.children.length - 1 : 0;
      var numMonthDays = month.children.length;
      for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
        var c = month.children[i];
        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj) && Math.abs(current.$i - i) >= Math.abs(delta))
          return focusOnDayElem(c);
      }
    }
    self2.changeMonth(loopDelta);
    focusOnDay(getFirstAvailableDay(loopDelta), 0);
    return void 0;
  }
  function focusOnDay(current, offset4) {
    var activeElement2 = getClosestActiveElement();
    var dayFocused = isInView(activeElement2 || document.body);
    var startElem = current !== void 0 ? current : dayFocused ? activeElement2 : self2.selectedDateElem !== void 0 && isInView(self2.selectedDateElem) ? self2.selectedDateElem : self2.todayDateElem !== void 0 && isInView(self2.todayDateElem) ? self2.todayDateElem : getFirstAvailableDay(offset4 > 0 ? 1 : -1);
    if (startElem === void 0) {
      self2._input.focus();
    } else if (!dayFocused) {
      focusOnDayElem(startElem);
    } else {
      getNextAvailableDay(startElem, offset4);
    }
  }
  function buildMonthDays(year, month) {
    var firstOfMonth = (new Date(year, month, 1).getDay() - self2.l10n.firstDayOfWeek + 7) % 7;
    var prevMonthDays = self2.utils.getDaysInMonth((month - 1 + 12) % 12, year);
    var daysInMonth = self2.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self2.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
    var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
    for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
    }
    for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
    }
    for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth && (self2.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
      days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
    }
    var dayContainer = createElement("div", "dayContainer");
    dayContainer.appendChild(days);
    return dayContainer;
  }
  function buildDays() {
    if (self2.daysContainer === void 0) {
      return;
    }
    clearNode(self2.daysContainer);
    if (self2.weekNumbers)
      clearNode(self2.weekNumbers);
    var frag = document.createDocumentFragment();
    for (var i = 0; i < self2.config.showMonths; i++) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
    }
    self2.daysContainer.appendChild(frag);
    self2.days = self2.daysContainer.firstChild;
    if (self2.config.mode === "range" && self2.selectedDates.length === 1) {
      onMouseOver();
    }
  }
  function buildMonthSwitch() {
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType !== "dropdown")
      return;
    var shouldBuildMonth = function(month2) {
      if (self2.config.minDate !== void 0 && self2.currentYear === self2.config.minDate.getFullYear() && month2 < self2.config.minDate.getMonth()) {
        return false;
      }
      return !(self2.config.maxDate !== void 0 && self2.currentYear === self2.config.maxDate.getFullYear() && month2 > self2.config.maxDate.getMonth());
    };
    self2.monthsDropdownContainer.tabIndex = -1;
    self2.monthsDropdownContainer.innerHTML = "";
    for (var i = 0; i < 12; i++) {
      if (!shouldBuildMonth(i))
        continue;
      var month = createElement("option", "flatpickr-monthDropdown-month");
      month.value = new Date(self2.currentYear, i).getMonth().toString();
      month.textContent = monthToStr(i, self2.config.shorthandCurrentMonth, self2.l10n);
      month.tabIndex = -1;
      if (self2.currentMonth === i) {
        month.selected = true;
      }
      self2.monthsDropdownContainer.appendChild(month);
    }
  }
  function buildMonth() {
    var container = createElement("div", "flatpickr-month");
    var monthNavFragment = window.document.createDocumentFragment();
    var monthElement;
    if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
      monthElement = createElement("span", "cur-month");
    } else {
      self2.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
      self2.monthsDropdownContainer.setAttribute("aria-label", self2.l10n.monthAriaLabel);
      bind(self2.monthsDropdownContainer, "change", function(e2) {
        var target = getEventTarget(e2);
        var selectedMonth = parseInt(target.value, 10);
        self2.changeMonth(selectedMonth - self2.currentMonth);
        triggerEvent("onMonthChange");
      });
      buildMonthSwitch();
      monthElement = self2.monthsDropdownContainer;
    }
    var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
    var yearElement = yearInput.getElementsByTagName("input")[0];
    yearElement.setAttribute("aria-label", self2.l10n.yearAriaLabel);
    if (self2.config.minDate) {
      yearElement.setAttribute("min", self2.config.minDate.getFullYear().toString());
    }
    if (self2.config.maxDate) {
      yearElement.setAttribute("max", self2.config.maxDate.getFullYear().toString());
      yearElement.disabled = !!self2.config.minDate && self2.config.minDate.getFullYear() === self2.config.maxDate.getFullYear();
    }
    var currentMonth = createElement("div", "flatpickr-current-month");
    currentMonth.appendChild(monthElement);
    currentMonth.appendChild(yearInput);
    monthNavFragment.appendChild(currentMonth);
    container.appendChild(monthNavFragment);
    return {
      container,
      yearElement,
      monthElement
    };
  }
  function buildMonths() {
    clearNode(self2.monthNav);
    self2.monthNav.appendChild(self2.prevMonthNav);
    if (self2.config.showMonths) {
      self2.yearElements = [];
      self2.monthElements = [];
    }
    for (var m = self2.config.showMonths; m--; ) {
      var month = buildMonth();
      self2.yearElements.push(month.yearElement);
      self2.monthElements.push(month.monthElement);
      self2.monthNav.appendChild(month.container);
    }
    self2.monthNav.appendChild(self2.nextMonthNav);
  }
  function buildMonthNav() {
    self2.monthNav = createElement("div", "flatpickr-months");
    self2.yearElements = [];
    self2.monthElements = [];
    self2.prevMonthNav = createElement("span", "flatpickr-prev-month");
    self2.prevMonthNav.innerHTML = self2.config.prevArrow;
    self2.nextMonthNav = createElement("span", "flatpickr-next-month");
    self2.nextMonthNav.innerHTML = self2.config.nextArrow;
    buildMonths();
    Object.defineProperty(self2, "_hidePrevMonthArrow", {
      get: function() {
        return self2.__hidePrevMonthArrow;
      },
      set: function(bool) {
        if (self2.__hidePrevMonthArrow !== bool) {
          toggleClass2(self2.prevMonthNav, "flatpickr-disabled", bool);
          self2.__hidePrevMonthArrow = bool;
        }
      }
    });
    Object.defineProperty(self2, "_hideNextMonthArrow", {
      get: function() {
        return self2.__hideNextMonthArrow;
      },
      set: function(bool) {
        if (self2.__hideNextMonthArrow !== bool) {
          toggleClass2(self2.nextMonthNav, "flatpickr-disabled", bool);
          self2.__hideNextMonthArrow = bool;
        }
      }
    });
    self2.currentYearElement = self2.yearElements[0];
    updateNavigationCurrentMonth();
    return self2.monthNav;
  }
  function buildTime() {
    self2.calendarContainer.classList.add("hasTime");
    if (self2.config.noCalendar)
      self2.calendarContainer.classList.add("noCalendar");
    var defaults2 = getDefaultHours(self2.config);
    self2.timeContainer = createElement("div", "flatpickr-time");
    self2.timeContainer.tabIndex = -1;
    var separator = createElement("span", "flatpickr-time-separator", ":");
    var hourInput = createNumberInput("flatpickr-hour", {
      "aria-label": self2.l10n.hourAriaLabel
    });
    self2.hourElement = hourInput.getElementsByTagName("input")[0];
    var minuteInput = createNumberInput("flatpickr-minute", {
      "aria-label": self2.l10n.minuteAriaLabel
    });
    self2.minuteElement = minuteInput.getElementsByTagName("input")[0];
    self2.hourElement.tabIndex = self2.minuteElement.tabIndex = -1;
    self2.hourElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getHours() : self2.config.time_24hr ? defaults2.hours : military2ampm(defaults2.hours));
    self2.minuteElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getMinutes() : defaults2.minutes);
    self2.hourElement.setAttribute("step", self2.config.hourIncrement.toString());
    self2.minuteElement.setAttribute("step", self2.config.minuteIncrement.toString());
    self2.hourElement.setAttribute("min", self2.config.time_24hr ? "0" : "1");
    self2.hourElement.setAttribute("max", self2.config.time_24hr ? "23" : "12");
    self2.hourElement.setAttribute("maxlength", "2");
    self2.minuteElement.setAttribute("min", "0");
    self2.minuteElement.setAttribute("max", "59");
    self2.minuteElement.setAttribute("maxlength", "2");
    self2.timeContainer.appendChild(hourInput);
    self2.timeContainer.appendChild(separator);
    self2.timeContainer.appendChild(minuteInput);
    if (self2.config.time_24hr)
      self2.timeContainer.classList.add("time24hr");
    if (self2.config.enableSeconds) {
      self2.timeContainer.classList.add("hasSeconds");
      var secondInput = createNumberInput("flatpickr-second");
      self2.secondElement = secondInput.getElementsByTagName("input")[0];
      self2.secondElement.value = pad(self2.latestSelectedDateObj ? self2.latestSelectedDateObj.getSeconds() : defaults2.seconds);
      self2.secondElement.setAttribute("step", self2.minuteElement.getAttribute("step"));
      self2.secondElement.setAttribute("min", "0");
      self2.secondElement.setAttribute("max", "59");
      self2.secondElement.setAttribute("maxlength", "2");
      self2.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
      self2.timeContainer.appendChild(secondInput);
    }
    if (!self2.config.time_24hr) {
      self2.amPM = createElement("span", "flatpickr-am-pm", self2.l10n.amPM[int((self2.latestSelectedDateObj ? self2.hourElement.value : self2.config.defaultHour) > 11)]);
      self2.amPM.title = self2.l10n.toggleTitle;
      self2.amPM.tabIndex = -1;
      self2.timeContainer.appendChild(self2.amPM);
    }
    return self2.timeContainer;
  }
  function buildWeekdays() {
    if (!self2.weekdayContainer)
      self2.weekdayContainer = createElement("div", "flatpickr-weekdays");
    else
      clearNode(self2.weekdayContainer);
    for (var i = self2.config.showMonths; i--; ) {
      var container = createElement("div", "flatpickr-weekdaycontainer");
      self2.weekdayContainer.appendChild(container);
    }
    updateWeekdays();
    return self2.weekdayContainer;
  }
  function updateWeekdays() {
    if (!self2.weekdayContainer) {
      return;
    }
    var firstDayOfWeek = self2.l10n.firstDayOfWeek;
    var weekdays = __spreadArrays(self2.l10n.weekdays.shorthand);
    if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
      weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
    }
    for (var i = self2.config.showMonths; i--; ) {
      self2.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
    }
  }
  function buildWeeks() {
    self2.calendarContainer.classList.add("hasWeeks");
    var weekWrapper = createElement("div", "flatpickr-weekwrapper");
    weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self2.l10n.weekAbbreviation));
    var weekNumbers = createElement("div", "flatpickr-weeks");
    weekWrapper.appendChild(weekNumbers);
    return {
      weekWrapper,
      weekNumbers
    };
  }
  function changeMonth(value, isOffset) {
    if (isOffset === void 0) {
      isOffset = true;
    }
    var delta = isOffset ? value : value - self2.currentMonth;
    if (delta < 0 && self2._hidePrevMonthArrow === true || delta > 0 && self2._hideNextMonthArrow === true)
      return;
    self2.currentMonth += delta;
    if (self2.currentMonth < 0 || self2.currentMonth > 11) {
      self2.currentYear += self2.currentMonth > 11 ? 1 : -1;
      self2.currentMonth = (self2.currentMonth + 12) % 12;
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
    buildDays();
    triggerEvent("onMonthChange");
    updateNavigationCurrentMonth();
  }
  function clear(triggerChangeEvent, toInitial) {
    if (triggerChangeEvent === void 0) {
      triggerChangeEvent = true;
    }
    if (toInitial === void 0) {
      toInitial = true;
    }
    self2.input.value = "";
    if (self2.altInput !== void 0)
      self2.altInput.value = "";
    if (self2.mobileInput !== void 0)
      self2.mobileInput.value = "";
    self2.selectedDates = [];
    self2.latestSelectedDateObj = void 0;
    if (toInitial === true) {
      self2.currentYear = self2._initialDate.getFullYear();
      self2.currentMonth = self2._initialDate.getMonth();
    }
    if (self2.config.enableTime === true) {
      var _a = getDefaultHours(self2.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
      setHours(hours, minutes, seconds);
    }
    self2.redraw();
    if (triggerChangeEvent)
      triggerEvent("onChange");
  }
  function close() {
    self2.isOpen = false;
    if (!self2.isMobile) {
      if (self2.calendarContainer !== void 0) {
        self2.calendarContainer.classList.remove("open");
      }
      if (self2._input !== void 0) {
        self2._input.classList.remove("active");
      }
    }
    triggerEvent("onClose");
  }
  function destroy() {
    if (self2.config !== void 0)
      triggerEvent("onDestroy");
    for (var i = self2._handlers.length; i--; ) {
      self2._handlers[i].remove();
    }
    self2._handlers = [];
    if (self2.mobileInput) {
      if (self2.mobileInput.parentNode)
        self2.mobileInput.parentNode.removeChild(self2.mobileInput);
      self2.mobileInput = void 0;
    } else if (self2.calendarContainer && self2.calendarContainer.parentNode) {
      if (self2.config.static && self2.calendarContainer.parentNode) {
        var wrapper = self2.calendarContainer.parentNode;
        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
        if (wrapper.parentNode) {
          while (wrapper.firstChild)
            wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
          wrapper.parentNode.removeChild(wrapper);
        }
      } else
        self2.calendarContainer.parentNode.removeChild(self2.calendarContainer);
    }
    if (self2.altInput) {
      self2.input.type = "text";
      if (self2.altInput.parentNode)
        self2.altInput.parentNode.removeChild(self2.altInput);
      delete self2.altInput;
    }
    if (self2.input) {
      self2.input.type = self2.input._type;
      self2.input.classList.remove("flatpickr-input");
      self2.input.removeAttribute("readonly");
    }
    [
      "_showTimeInput",
      "latestSelectedDateObj",
      "_hideNextMonthArrow",
      "_hidePrevMonthArrow",
      "__hideNextMonthArrow",
      "__hidePrevMonthArrow",
      "isMobile",
      "isOpen",
      "selectedDateElem",
      "minDateHasTime",
      "maxDateHasTime",
      "days",
      "daysContainer",
      "_input",
      "_positionElement",
      "innerContainer",
      "rContainer",
      "monthNav",
      "todayDateElem",
      "calendarContainer",
      "weekdayContainer",
      "prevMonthNav",
      "nextMonthNav",
      "monthsDropdownContainer",
      "currentMonthElement",
      "currentYearElement",
      "navigationCurrentMonth",
      "selectedDateElem",
      "config"
    ].forEach(function(k) {
      try {
        delete self2[k];
      } catch (_) {
      }
    });
  }
  function isCalendarElem(elem) {
    return self2.calendarContainer.contains(elem);
  }
  function documentClick(e2) {
    if (self2.isOpen && !self2.config.inline) {
      var eventTarget_1 = getEventTarget(e2);
      var isCalendarElement = isCalendarElem(eventTarget_1);
      var isInput3 = eventTarget_1 === self2.input || eventTarget_1 === self2.altInput || self2.element.contains(eventTarget_1) || e2.path && e2.path.indexOf && (~e2.path.indexOf(self2.input) || ~e2.path.indexOf(self2.altInput));
      var lostFocus = !isInput3 && !isCalendarElement && !isCalendarElem(e2.relatedTarget);
      var isIgnored = !self2.config.ignoredFocusElements.some(function(elem) {
        return elem.contains(eventTarget_1);
      });
      if (lostFocus && isIgnored) {
        if (self2.config.allowInput) {
          self2.setDate(self2._input.value, false, self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
        }
        if (self2.timeContainer !== void 0 && self2.minuteElement !== void 0 && self2.hourElement !== void 0 && self2.input.value !== "" && self2.input.value !== void 0) {
          updateTime();
        }
        self2.close();
        if (self2.config && self2.config.mode === "range" && self2.selectedDates.length === 1)
          self2.clear(false);
      }
    }
  }
  function changeYear(newYear) {
    if (!newYear || self2.config.minDate && newYear < self2.config.minDate.getFullYear() || self2.config.maxDate && newYear > self2.config.maxDate.getFullYear())
      return;
    var newYearNum = newYear, isNewYear = self2.currentYear !== newYearNum;
    self2.currentYear = newYearNum || self2.currentYear;
    if (self2.config.maxDate && self2.currentYear === self2.config.maxDate.getFullYear()) {
      self2.currentMonth = Math.min(self2.config.maxDate.getMonth(), self2.currentMonth);
    } else if (self2.config.minDate && self2.currentYear === self2.config.minDate.getFullYear()) {
      self2.currentMonth = Math.max(self2.config.minDate.getMonth(), self2.currentMonth);
    }
    if (isNewYear) {
      self2.redraw();
      triggerEvent("onYearChange");
      buildMonthSwitch();
    }
  }
  function isEnabled(date, timeless) {
    var _a;
    if (timeless === void 0) {
      timeless = true;
    }
    var dateToCheck = self2.parseDate(date, void 0, timeless);
    if (self2.config.minDate && dateToCheck && compareDates(dateToCheck, self2.config.minDate, timeless !== void 0 ? timeless : !self2.minDateHasTime) < 0 || self2.config.maxDate && dateToCheck && compareDates(dateToCheck, self2.config.maxDate, timeless !== void 0 ? timeless : !self2.maxDateHasTime) > 0)
      return false;
    if (!self2.config.enable && self2.config.disable.length === 0)
      return true;
    if (dateToCheck === void 0)
      return false;
    var bool = !!self2.config.enable, array = (_a = self2.config.enable) !== null && _a !== void 0 ? _a : self2.config.disable;
    for (var i = 0, d = void 0; i < array.length; i++) {
      d = array[i];
      if (typeof d === "function" && d(dateToCheck))
        return bool;
      else if (d instanceof Date && dateToCheck !== void 0 && d.getTime() === dateToCheck.getTime())
        return bool;
      else if (typeof d === "string") {
        var parsed = self2.parseDate(d, void 0, true);
        return parsed && parsed.getTime() === dateToCheck.getTime() ? bool : !bool;
      } else if (typeof d === "object" && dateToCheck !== void 0 && d.from && d.to && dateToCheck.getTime() >= d.from.getTime() && dateToCheck.getTime() <= d.to.getTime())
        return bool;
    }
    return !bool;
  }
  function isInView(elem) {
    if (self2.daysContainer !== void 0)
      return elem.className.indexOf("hidden") === -1 && elem.className.indexOf("flatpickr-disabled") === -1 && self2.daysContainer.contains(elem);
    return false;
  }
  function onBlur(e2) {
    var isInput3 = e2.target === self2._input;
    var valueChanged = self2._input.value.trimEnd() !== getDateStr();
    if (isInput3 && valueChanged && !(e2.relatedTarget && isCalendarElem(e2.relatedTarget))) {
      self2.setDate(self2._input.value, true, e2.target === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
    }
  }
  function onKeyDown(e2) {
    var eventTarget = getEventTarget(e2);
    var isInput3 = self2.config.wrap ? element.contains(eventTarget) : eventTarget === self2._input;
    var allowInput = self2.config.allowInput;
    var allowKeydown = self2.isOpen && (!allowInput || !isInput3);
    var allowInlineKeydown = self2.config.inline && isInput3 && !allowInput;
    if (e2.keyCode === 13 && isInput3) {
      if (allowInput) {
        self2.setDate(self2._input.value, true, eventTarget === self2.altInput ? self2.config.altFormat : self2.config.dateFormat);
        self2.close();
        return eventTarget.blur();
      } else {
        self2.open();
      }
    } else if (isCalendarElem(eventTarget) || allowKeydown || allowInlineKeydown) {
      var isTimeObj = !!self2.timeContainer && self2.timeContainer.contains(eventTarget);
      switch (e2.keyCode) {
        case 13:
          if (isTimeObj) {
            e2.preventDefault();
            updateTime();
            focusAndClose();
          } else
            selectDate(e2);
          break;
        case 27:
          e2.preventDefault();
          focusAndClose();
          break;
        case 8:
        case 46:
          if (isInput3 && !self2.config.allowInput) {
            e2.preventDefault();
            self2.clear();
          }
          break;
        case 37:
        case 39:
          if (!isTimeObj && !isInput3) {
            e2.preventDefault();
            var activeElement2 = getClosestActiveElement();
            if (self2.daysContainer !== void 0 && (allowInput === false || activeElement2 && isInView(activeElement2))) {
              var delta_1 = e2.keyCode === 39 ? 1 : -1;
              if (!e2.ctrlKey)
                focusOnDay(void 0, delta_1);
              else {
                e2.stopPropagation();
                changeMonth(delta_1);
                focusOnDay(getFirstAvailableDay(1), 0);
              }
            }
          } else if (self2.hourElement)
            self2.hourElement.focus();
          break;
        case 38:
        case 40:
          e2.preventDefault();
          var delta = e2.keyCode === 40 ? 1 : -1;
          if (self2.daysContainer && eventTarget.$i !== void 0 || eventTarget === self2.input || eventTarget === self2.altInput) {
            if (e2.ctrlKey) {
              e2.stopPropagation();
              changeYear(self2.currentYear - delta);
              focusOnDay(getFirstAvailableDay(1), 0);
            } else if (!isTimeObj)
              focusOnDay(void 0, delta * 7);
          } else if (eventTarget === self2.currentYearElement) {
            changeYear(self2.currentYear - delta);
          } else if (self2.config.enableTime) {
            if (!isTimeObj && self2.hourElement)
              self2.hourElement.focus();
            updateTime(e2);
            self2._debouncedChange();
          }
          break;
        case 9:
          if (isTimeObj) {
            var elems = [
              self2.hourElement,
              self2.minuteElement,
              self2.secondElement,
              self2.amPM
            ].concat(self2.pluginElements).filter(function(x) {
              return x;
            });
            var i = elems.indexOf(eventTarget);
            if (i !== -1) {
              var target = elems[i + (e2.shiftKey ? -1 : 1)];
              e2.preventDefault();
              (target || self2._input).focus();
            }
          } else if (!self2.config.noCalendar && self2.daysContainer && self2.daysContainer.contains(eventTarget) && e2.shiftKey) {
            e2.preventDefault();
            self2._input.focus();
          }
          break;
        default:
          break;
      }
    }
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      switch (e2.key) {
        case self2.l10n.amPM[0].charAt(0):
        case self2.l10n.amPM[0].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[0];
          setHoursFromInputs();
          updateValue();
          break;
        case self2.l10n.amPM[1].charAt(0):
        case self2.l10n.amPM[1].charAt(0).toLowerCase():
          self2.amPM.textContent = self2.l10n.amPM[1];
          setHoursFromInputs();
          updateValue();
          break;
      }
    }
    if (isInput3 || isCalendarElem(eventTarget)) {
      triggerEvent("onKeyDown", e2);
    }
  }
  function onMouseOver(elem, cellClass) {
    if (cellClass === void 0) {
      cellClass = "flatpickr-day";
    }
    if (self2.selectedDates.length !== 1 || elem && (!elem.classList.contains(cellClass) || elem.classList.contains("flatpickr-disabled")))
      return;
    var hoverDate = elem ? elem.dateObj.getTime() : self2.days.firstElementChild.dateObj.getTime(), initialDate = self2.parseDate(self2.selectedDates[0], void 0, true).getTime(), rangeStartDate = Math.min(hoverDate, self2.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self2.selectedDates[0].getTime());
    var containsDisabled = false;
    var minRange = 0, maxRange = 0;
    for (var t3 = rangeStartDate; t3 < rangeEndDate; t3 += duration.DAY) {
      if (!isEnabled(new Date(t3), true)) {
        containsDisabled = containsDisabled || t3 > rangeStartDate && t3 < rangeEndDate;
        if (t3 < initialDate && (!minRange || t3 > minRange))
          minRange = t3;
        else if (t3 > initialDate && (!maxRange || t3 < maxRange))
          maxRange = t3;
      }
    }
    var hoverableCells = Array.from(self2.rContainer.querySelectorAll("*:nth-child(-n+" + self2.config.showMonths + ") > ." + cellClass));
    hoverableCells.forEach(function(dayElem) {
      var date = dayElem.dateObj;
      var timestamp = date.getTime();
      var outOfRange = minRange > 0 && timestamp < minRange || maxRange > 0 && timestamp > maxRange;
      if (outOfRange) {
        dayElem.classList.add("notAllowed");
        ["inRange", "startRange", "endRange"].forEach(function(c) {
          dayElem.classList.remove(c);
        });
        return;
      } else if (containsDisabled && !outOfRange)
        return;
      ["startRange", "inRange", "endRange", "notAllowed"].forEach(function(c) {
        dayElem.classList.remove(c);
      });
      if (elem !== void 0) {
        elem.classList.add(hoverDate <= self2.selectedDates[0].getTime() ? "startRange" : "endRange");
        if (initialDate < hoverDate && timestamp === initialDate)
          dayElem.classList.add("startRange");
        else if (initialDate > hoverDate && timestamp === initialDate)
          dayElem.classList.add("endRange");
        if (timestamp >= minRange && (maxRange === 0 || timestamp <= maxRange) && isBetween(timestamp, initialDate, hoverDate))
          dayElem.classList.add("inRange");
      }
    });
  }
  function onResize() {
    if (self2.isOpen && !self2.config.static && !self2.config.inline)
      positionCalendar();
  }
  function open2(e2, positionElement) {
    if (positionElement === void 0) {
      positionElement = self2._positionElement;
    }
    if (self2.isMobile === true) {
      if (e2) {
        e2.preventDefault();
        var eventTarget = getEventTarget(e2);
        if (eventTarget) {
          eventTarget.blur();
        }
      }
      if (self2.mobileInput !== void 0) {
        self2.mobileInput.focus();
        self2.mobileInput.click();
      }
      triggerEvent("onOpen");
      return;
    } else if (self2._input.disabled || self2.config.inline) {
      return;
    }
    var wasOpen = self2.isOpen;
    self2.isOpen = true;
    if (!wasOpen) {
      self2.calendarContainer.classList.add("open");
      self2._input.classList.add("active");
      triggerEvent("onOpen");
      positionCalendar(positionElement);
    }
    if (self2.config.enableTime === true && self2.config.noCalendar === true) {
      if (self2.config.allowInput === false && (e2 === void 0 || !self2.timeContainer.contains(e2.relatedTarget))) {
        setTimeout(function() {
          return self2.hourElement.select();
        }, 50);
      }
    }
  }
  function minMaxDateSetter(type) {
    return function(date) {
      var dateObj = self2.config["_" + type + "Date"] = self2.parseDate(date, self2.config.dateFormat);
      var inverseDateObj = self2.config["_" + (type === "min" ? "max" : "min") + "Date"];
      if (dateObj !== void 0) {
        self2[type === "min" ? "minDateHasTime" : "maxDateHasTime"] = dateObj.getHours() > 0 || dateObj.getMinutes() > 0 || dateObj.getSeconds() > 0;
      }
      if (self2.selectedDates) {
        self2.selectedDates = self2.selectedDates.filter(function(d) {
          return isEnabled(d);
        });
        if (!self2.selectedDates.length && type === "min")
          setHoursFromDate(dateObj);
        updateValue();
      }
      if (self2.daysContainer) {
        redraw();
        if (dateObj !== void 0)
          self2.currentYearElement[type] = dateObj.getFullYear().toString();
        else
          self2.currentYearElement.removeAttribute(type);
        self2.currentYearElement.disabled = !!inverseDateObj && dateObj !== void 0 && inverseDateObj.getFullYear() === dateObj.getFullYear();
      }
    };
  }
  function parseConfig() {
    var boolOpts = [
      "wrap",
      "weekNumbers",
      "allowInput",
      "allowInvalidPreload",
      "clickOpens",
      "time_24hr",
      "enableTime",
      "noCalendar",
      "altInput",
      "shorthandCurrentMonth",
      "inline",
      "static",
      "enableSeconds",
      "disableMobile"
    ];
    var userConfig = __assign2(__assign2({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
    var formats2 = {};
    self2.config.parseDate = userConfig.parseDate;
    self2.config.formatDate = userConfig.formatDate;
    Object.defineProperty(self2.config, "enable", {
      get: function() {
        return self2.config._enable;
      },
      set: function(dates) {
        self2.config._enable = parseDateRules(dates);
      }
    });
    Object.defineProperty(self2.config, "disable", {
      get: function() {
        return self2.config._disable;
      },
      set: function(dates) {
        self2.config._disable = parseDateRules(dates);
      }
    });
    var timeMode = userConfig.mode === "time";
    if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
      var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
      formats2.dateFormat = userConfig.noCalendar || timeMode ? "H:i" + (userConfig.enableSeconds ? ":S" : "") : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
    }
    if (userConfig.altInput && (userConfig.enableTime || timeMode) && !userConfig.altFormat) {
      var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
      formats2.altFormat = userConfig.noCalendar || timeMode ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K") : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
    }
    Object.defineProperty(self2.config, "minDate", {
      get: function() {
        return self2.config._minDate;
      },
      set: minMaxDateSetter("min")
    });
    Object.defineProperty(self2.config, "maxDate", {
      get: function() {
        return self2.config._maxDate;
      },
      set: minMaxDateSetter("max")
    });
    var minMaxTimeSetter = function(type) {
      return function(val) {
        self2.config[type === "min" ? "_minTime" : "_maxTime"] = self2.parseDate(val, "H:i:S");
      };
    };
    Object.defineProperty(self2.config, "minTime", {
      get: function() {
        return self2.config._minTime;
      },
      set: minMaxTimeSetter("min")
    });
    Object.defineProperty(self2.config, "maxTime", {
      get: function() {
        return self2.config._maxTime;
      },
      set: minMaxTimeSetter("max")
    });
    if (userConfig.mode === "time") {
      self2.config.noCalendar = true;
      self2.config.enableTime = true;
    }
    Object.assign(self2.config, formats2, userConfig);
    for (var i = 0; i < boolOpts.length; i++)
      self2.config[boolOpts[i]] = self2.config[boolOpts[i]] === true || self2.config[boolOpts[i]] === "true";
    HOOKS.filter(function(hook) {
      return self2.config[hook] !== void 0;
    }).forEach(function(hook) {
      self2.config[hook] = arrayify(self2.config[hook] || []).map(bindToInstance);
    });
    self2.isMobile = !self2.config.disableMobile && !self2.config.inline && self2.config.mode === "single" && !self2.config.disable.length && !self2.config.enable && !self2.config.weekNumbers && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    for (var i = 0; i < self2.config.plugins.length; i++) {
      var pluginConf = self2.config.plugins[i](self2) || {};
      for (var key in pluginConf) {
        if (HOOKS.indexOf(key) > -1) {
          self2.config[key] = arrayify(pluginConf[key]).map(bindToInstance).concat(self2.config[key]);
        } else if (typeof userConfig[key] === "undefined")
          self2.config[key] = pluginConf[key];
      }
    }
    if (!userConfig.altInputClass) {
      self2.config.altInputClass = getInputElem().className + " " + self2.config.altInputClass;
    }
    triggerEvent("onParseConfig");
  }
  function getInputElem() {
    return self2.config.wrap ? element.querySelector("[data-input]") : element;
  }
  function setupLocale() {
    if (typeof self2.config.locale !== "object" && typeof flatpickr.l10ns[self2.config.locale] === "undefined")
      self2.config.errorHandler(new Error("flatpickr: invalid locale " + self2.config.locale));
    self2.l10n = __assign2(__assign2({}, flatpickr.l10ns.default), typeof self2.config.locale === "object" ? self2.config.locale : self2.config.locale !== "default" ? flatpickr.l10ns[self2.config.locale] : void 0);
    tokenRegex.D = "(" + self2.l10n.weekdays.shorthand.join("|") + ")";
    tokenRegex.l = "(" + self2.l10n.weekdays.longhand.join("|") + ")";
    tokenRegex.M = "(" + self2.l10n.months.shorthand.join("|") + ")";
    tokenRegex.F = "(" + self2.l10n.months.longhand.join("|") + ")";
    tokenRegex.K = "(" + self2.l10n.amPM[0] + "|" + self2.l10n.amPM[1] + "|" + self2.l10n.amPM[0].toLowerCase() + "|" + self2.l10n.amPM[1].toLowerCase() + ")";
    var userConfig = __assign2(__assign2({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
    if (userConfig.time_24hr === void 0 && flatpickr.defaultConfig.time_24hr === void 0) {
      self2.config.time_24hr = self2.l10n.time_24hr;
    }
    self2.formatDate = createDateFormatter(self2);
    self2.parseDate = createDateParser({ config: self2.config, l10n: self2.l10n });
  }
  function positionCalendar(customPositionElement) {
    if (typeof self2.config.position === "function") {
      return void self2.config.position(self2, customPositionElement);
    }
    if (self2.calendarContainer === void 0)
      return;
    triggerEvent("onPreCalendarPosition");
    var positionElement = customPositionElement || self2._positionElement;
    var calendarHeight = Array.prototype.reduce.call(self2.calendarContainer.children, function(acc, child) {
      return acc + child.offsetHeight;
    }, 0), calendarWidth = self2.calendarContainer.offsetWidth, configPos = self2.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" || configPosVertical !== "below" && distanceFromBottom < calendarHeight && inputBounds.top > calendarHeight;
    var top = window.pageYOffset + inputBounds.top + (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
    toggleClass2(self2.calendarContainer, "arrowTop", !showOnTop);
    toggleClass2(self2.calendarContainer, "arrowBottom", showOnTop);
    if (self2.config.inline)
      return;
    var left = window.pageXOffset + inputBounds.left;
    var isCenter = false;
    var isRight = false;
    if (configPosHorizontal === "center") {
      left -= (calendarWidth - inputBounds.width) / 2;
      isCenter = true;
    } else if (configPosHorizontal === "right") {
      left -= calendarWidth - inputBounds.width;
      isRight = true;
    }
    toggleClass2(self2.calendarContainer, "arrowLeft", !isCenter && !isRight);
    toggleClass2(self2.calendarContainer, "arrowCenter", isCenter);
    toggleClass2(self2.calendarContainer, "arrowRight", isRight);
    var right = window.document.body.offsetWidth - (window.pageXOffset + inputBounds.right);
    var rightMost = left + calendarWidth > window.document.body.offsetWidth;
    var centerMost = right + calendarWidth > window.document.body.offsetWidth;
    toggleClass2(self2.calendarContainer, "rightMost", rightMost);
    if (self2.config.static)
      return;
    self2.calendarContainer.style.top = top + "px";
    if (!rightMost) {
      self2.calendarContainer.style.left = left + "px";
      self2.calendarContainer.style.right = "auto";
    } else if (!centerMost) {
      self2.calendarContainer.style.left = "auto";
      self2.calendarContainer.style.right = right + "px";
    } else {
      var doc = getDocumentStyleSheet();
      if (doc === void 0)
        return;
      var bodyWidth = window.document.body.offsetWidth;
      var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
      var centerBefore = ".flatpickr-calendar.centerMost:before";
      var centerAfter = ".flatpickr-calendar.centerMost:after";
      var centerIndex = doc.cssRules.length;
      var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
      toggleClass2(self2.calendarContainer, "rightMost", false);
      toggleClass2(self2.calendarContainer, "centerMost", true);
      doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
      self2.calendarContainer.style.left = centerLeft + "px";
      self2.calendarContainer.style.right = "auto";
    }
  }
  function getDocumentStyleSheet() {
    var editableSheet = null;
    for (var i = 0; i < document.styleSheets.length; i++) {
      var sheet = document.styleSheets[i];
      if (!sheet.cssRules)
        continue;
      try {
        sheet.cssRules;
      } catch (err) {
        continue;
      }
      editableSheet = sheet;
      break;
    }
    return editableSheet != null ? editableSheet : createStyleSheet();
  }
  function createStyleSheet() {
    var style = document.createElement("style");
    document.head.appendChild(style);
    return style.sheet;
  }
  function redraw() {
    if (self2.config.noCalendar || self2.isMobile)
      return;
    buildMonthSwitch();
    updateNavigationCurrentMonth();
    buildDays();
  }
  function focusAndClose() {
    self2._input.focus();
    if (window.navigator.userAgent.indexOf("MSIE") !== -1 || navigator.msMaxTouchPoints !== void 0) {
      setTimeout(self2.close, 0);
    } else {
      self2.close();
    }
  }
  function selectDate(e2) {
    e2.preventDefault();
    e2.stopPropagation();
    var isSelectable = function(day) {
      return day.classList && day.classList.contains("flatpickr-day") && !day.classList.contains("flatpickr-disabled") && !day.classList.contains("notAllowed");
    };
    var t3 = findParent(getEventTarget(e2), isSelectable);
    if (t3 === void 0)
      return;
    var target = t3;
    var selectedDate = self2.latestSelectedDateObj = new Date(target.dateObj.getTime());
    var shouldChangeMonth = (selectedDate.getMonth() < self2.currentMonth || selectedDate.getMonth() > self2.currentMonth + self2.config.showMonths - 1) && self2.config.mode !== "range";
    self2.selectedDateElem = target;
    if (self2.config.mode === "single")
      self2.selectedDates = [selectedDate];
    else if (self2.config.mode === "multiple") {
      var selectedIndex = isDateSelected(selectedDate);
      if (selectedIndex)
        self2.selectedDates.splice(parseInt(selectedIndex), 1);
      else
        self2.selectedDates.push(selectedDate);
    } else if (self2.config.mode === "range") {
      if (self2.selectedDates.length === 2) {
        self2.clear(false, false);
      }
      self2.latestSelectedDateObj = selectedDate;
      self2.selectedDates.push(selectedDate);
      if (compareDates(selectedDate, self2.selectedDates[0], true) !== 0)
        self2.selectedDates.sort(function(a, b2) {
          return a.getTime() - b2.getTime();
        });
    }
    setHoursFromInputs();
    if (shouldChangeMonth) {
      var isNewYear = self2.currentYear !== selectedDate.getFullYear();
      self2.currentYear = selectedDate.getFullYear();
      self2.currentMonth = selectedDate.getMonth();
      if (isNewYear) {
        triggerEvent("onYearChange");
        buildMonthSwitch();
      }
      triggerEvent("onMonthChange");
    }
    updateNavigationCurrentMonth();
    buildDays();
    updateValue();
    if (!shouldChangeMonth && self2.config.mode !== "range" && self2.config.showMonths === 1)
      focusOnDayElem(target);
    else if (self2.selectedDateElem !== void 0 && self2.hourElement === void 0) {
      self2.selectedDateElem && self2.selectedDateElem.focus();
    }
    if (self2.hourElement !== void 0)
      self2.hourElement !== void 0 && self2.hourElement.focus();
    if (self2.config.closeOnSelect) {
      var single = self2.config.mode === "single" && !self2.config.enableTime;
      var range = self2.config.mode === "range" && self2.selectedDates.length === 2 && !self2.config.enableTime;
      if (single || range) {
        focusAndClose();
      }
    }
    triggerChange();
  }
  var CALLBACKS = {
    locale: [setupLocale, updateWeekdays],
    showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
    minDate: [jumpToDate],
    maxDate: [jumpToDate],
    positionElement: [updatePositionElement],
    clickOpens: [
      function() {
        if (self2.config.clickOpens === true) {
          bind(self2._input, "focus", self2.open);
          bind(self2._input, "click", self2.open);
        } else {
          self2._input.removeEventListener("focus", self2.open);
          self2._input.removeEventListener("click", self2.open);
        }
      }
    ]
  };
  function set(option, value) {
    if (option !== null && typeof option === "object") {
      Object.assign(self2.config, option);
      for (var key in option) {
        if (CALLBACKS[key] !== void 0)
          CALLBACKS[key].forEach(function(x) {
            return x();
          });
      }
    } else {
      self2.config[option] = value;
      if (CALLBACKS[option] !== void 0)
        CALLBACKS[option].forEach(function(x) {
          return x();
        });
      else if (HOOKS.indexOf(option) > -1)
        self2.config[option] = arrayify(value);
    }
    self2.redraw();
    updateValue(true);
  }
  function setSelectedDate(inputDate, format) {
    var dates = [];
    if (inputDate instanceof Array)
      dates = inputDate.map(function(d) {
        return self2.parseDate(d, format);
      });
    else if (inputDate instanceof Date || typeof inputDate === "number")
      dates = [self2.parseDate(inputDate, format)];
    else if (typeof inputDate === "string") {
      switch (self2.config.mode) {
        case "single":
        case "time":
          dates = [self2.parseDate(inputDate, format)];
          break;
        case "multiple":
          dates = inputDate.split(self2.config.conjunction).map(function(date) {
            return self2.parseDate(date, format);
          });
          break;
        case "range":
          dates = inputDate.split(self2.l10n.rangeSeparator).map(function(date) {
            return self2.parseDate(date, format);
          });
          break;
        default:
          break;
      }
    } else
      self2.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
    self2.selectedDates = self2.config.allowInvalidPreload ? dates : dates.filter(function(d) {
      return d instanceof Date && isEnabled(d, false);
    });
    if (self2.config.mode === "range")
      self2.selectedDates.sort(function(a, b2) {
        return a.getTime() - b2.getTime();
      });
  }
  function setDate(date, triggerChange2, format) {
    if (triggerChange2 === void 0) {
      triggerChange2 = false;
    }
    if (format === void 0) {
      format = self2.config.dateFormat;
    }
    if (date !== 0 && !date || date instanceof Array && date.length === 0)
      return self2.clear(triggerChange2);
    setSelectedDate(date, format);
    self2.latestSelectedDateObj = self2.selectedDates[self2.selectedDates.length - 1];
    self2.redraw();
    jumpToDate(void 0, triggerChange2);
    setHoursFromDate();
    if (self2.selectedDates.length === 0) {
      self2.clear(false);
    }
    updateValue(triggerChange2);
    if (triggerChange2)
      triggerEvent("onChange");
  }
  function parseDateRules(arr) {
    return arr.slice().map(function(rule) {
      if (typeof rule === "string" || typeof rule === "number" || rule instanceof Date) {
        return self2.parseDate(rule, void 0, true);
      } else if (rule && typeof rule === "object" && rule.from && rule.to)
        return {
          from: self2.parseDate(rule.from, void 0),
          to: self2.parseDate(rule.to, void 0)
        };
      return rule;
    }).filter(function(x) {
      return x;
    });
  }
  function setupDates() {
    self2.selectedDates = [];
    self2.now = self2.parseDate(self2.config.now) || /* @__PURE__ */ new Date();
    var preloadedDate = self2.config.defaultDate || ((self2.input.nodeName === "INPUT" || self2.input.nodeName === "TEXTAREA") && self2.input.placeholder && self2.input.value === self2.input.placeholder ? null : self2.input.value);
    if (preloadedDate)
      setSelectedDate(preloadedDate, self2.config.dateFormat);
    self2._initialDate = self2.selectedDates.length > 0 ? self2.selectedDates[0] : self2.config.minDate && self2.config.minDate.getTime() > self2.now.getTime() ? self2.config.minDate : self2.config.maxDate && self2.config.maxDate.getTime() < self2.now.getTime() ? self2.config.maxDate : self2.now;
    self2.currentYear = self2._initialDate.getFullYear();
    self2.currentMonth = self2._initialDate.getMonth();
    if (self2.selectedDates.length > 0)
      self2.latestSelectedDateObj = self2.selectedDates[0];
    if (self2.config.minTime !== void 0)
      self2.config.minTime = self2.parseDate(self2.config.minTime, "H:i");
    if (self2.config.maxTime !== void 0)
      self2.config.maxTime = self2.parseDate(self2.config.maxTime, "H:i");
    self2.minDateHasTime = !!self2.config.minDate && (self2.config.minDate.getHours() > 0 || self2.config.minDate.getMinutes() > 0 || self2.config.minDate.getSeconds() > 0);
    self2.maxDateHasTime = !!self2.config.maxDate && (self2.config.maxDate.getHours() > 0 || self2.config.maxDate.getMinutes() > 0 || self2.config.maxDate.getSeconds() > 0);
  }
  function setupInputs() {
    self2.input = getInputElem();
    if (!self2.input) {
      self2.config.errorHandler(new Error("Invalid input element specified"));
      return;
    }
    self2.input._type = self2.input.type;
    self2.input.type = "text";
    self2.input.classList.add("flatpickr-input");
    self2._input = self2.input;
    if (self2.config.altInput) {
      self2.altInput = createElement(self2.input.nodeName, self2.config.altInputClass);
      self2._input = self2.altInput;
      self2.altInput.placeholder = self2.input.placeholder;
      self2.altInput.disabled = self2.input.disabled;
      self2.altInput.required = self2.input.required;
      self2.altInput.tabIndex = self2.input.tabIndex;
      self2.altInput.type = "text";
      self2.input.setAttribute("type", "hidden");
      if (!self2.config.static && self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.altInput, self2.input.nextSibling);
    }
    if (!self2.config.allowInput)
      self2._input.setAttribute("readonly", "readonly");
    updatePositionElement();
  }
  function updatePositionElement() {
    self2._positionElement = self2.config.positionElement || self2._input;
  }
  function setupMobile() {
    var inputType = self2.config.enableTime ? self2.config.noCalendar ? "time" : "datetime-local" : "date";
    self2.mobileInput = createElement("input", self2.input.className + " flatpickr-mobile");
    self2.mobileInput.tabIndex = 1;
    self2.mobileInput.type = inputType;
    self2.mobileInput.disabled = self2.input.disabled;
    self2.mobileInput.required = self2.input.required;
    self2.mobileInput.placeholder = self2.input.placeholder;
    self2.mobileFormatStr = inputType === "datetime-local" ? "Y-m-d\\TH:i:S" : inputType === "date" ? "Y-m-d" : "H:i:S";
    if (self2.selectedDates.length > 0) {
      self2.mobileInput.defaultValue = self2.mobileInput.value = self2.formatDate(self2.selectedDates[0], self2.mobileFormatStr);
    }
    if (self2.config.minDate)
      self2.mobileInput.min = self2.formatDate(self2.config.minDate, "Y-m-d");
    if (self2.config.maxDate)
      self2.mobileInput.max = self2.formatDate(self2.config.maxDate, "Y-m-d");
    if (self2.input.getAttribute("step"))
      self2.mobileInput.step = String(self2.input.getAttribute("step"));
    self2.input.type = "hidden";
    if (self2.altInput !== void 0)
      self2.altInput.type = "hidden";
    try {
      if (self2.input.parentNode)
        self2.input.parentNode.insertBefore(self2.mobileInput, self2.input.nextSibling);
    } catch (_a) {
    }
    bind(self2.mobileInput, "change", function(e2) {
      self2.setDate(getEventTarget(e2).value, false, self2.mobileFormatStr);
      triggerEvent("onChange");
      triggerEvent("onClose");
    });
  }
  function toggle(e2) {
    if (self2.isOpen === true)
      return self2.close();
    self2.open(e2);
  }
  function triggerEvent(event, data) {
    if (self2.config === void 0)
      return;
    var hooks = self2.config[event];
    if (hooks !== void 0 && hooks.length > 0) {
      for (var i = 0; hooks[i] && i < hooks.length; i++)
        hooks[i](self2.selectedDates, self2.input.value, self2, data);
    }
    if (event === "onChange") {
      self2.input.dispatchEvent(createEvent("change"));
      self2.input.dispatchEvent(createEvent("input"));
    }
  }
  function createEvent(name) {
    var e2 = document.createEvent("Event");
    e2.initEvent(name, true, true);
    return e2;
  }
  function isDateSelected(date) {
    for (var i = 0; i < self2.selectedDates.length; i++) {
      var selectedDate = self2.selectedDates[i];
      if (selectedDate instanceof Date && compareDates(selectedDate, date) === 0)
        return "" + i;
    }
    return false;
  }
  function isDateInRange(date) {
    if (self2.config.mode !== "range" || self2.selectedDates.length < 2)
      return false;
    return compareDates(date, self2.selectedDates[0]) >= 0 && compareDates(date, self2.selectedDates[1]) <= 0;
  }
  function updateNavigationCurrentMonth() {
    if (self2.config.noCalendar || self2.isMobile || !self2.monthNav)
      return;
    self2.yearElements.forEach(function(yearElement, i) {
      var d = new Date(self2.currentYear, self2.currentMonth, 1);
      d.setMonth(self2.currentMonth + i);
      if (self2.config.showMonths > 1 || self2.config.monthSelectorType === "static") {
        self2.monthElements[i].textContent = monthToStr(d.getMonth(), self2.config.shorthandCurrentMonth, self2.l10n) + " ";
      } else {
        self2.monthsDropdownContainer.value = d.getMonth().toString();
      }
      yearElement.value = d.getFullYear().toString();
    });
    self2._hidePrevMonthArrow = self2.config.minDate !== void 0 && (self2.currentYear === self2.config.minDate.getFullYear() ? self2.currentMonth <= self2.config.minDate.getMonth() : self2.currentYear < self2.config.minDate.getFullYear());
    self2._hideNextMonthArrow = self2.config.maxDate !== void 0 && (self2.currentYear === self2.config.maxDate.getFullYear() ? self2.currentMonth + 1 > self2.config.maxDate.getMonth() : self2.currentYear > self2.config.maxDate.getFullYear());
  }
  function getDateStr(specificFormat) {
    var format = specificFormat || (self2.config.altInput ? self2.config.altFormat : self2.config.dateFormat);
    return self2.selectedDates.map(function(dObj) {
      return self2.formatDate(dObj, format);
    }).filter(function(d, i, arr) {
      return self2.config.mode !== "range" || self2.config.enableTime || arr.indexOf(d) === i;
    }).join(self2.config.mode !== "range" ? self2.config.conjunction : self2.l10n.rangeSeparator);
  }
  function updateValue(triggerChange2) {
    if (triggerChange2 === void 0) {
      triggerChange2 = true;
    }
    if (self2.mobileInput !== void 0 && self2.mobileFormatStr) {
      self2.mobileInput.value = self2.latestSelectedDateObj !== void 0 ? self2.formatDate(self2.latestSelectedDateObj, self2.mobileFormatStr) : "";
    }
    self2.input.value = getDateStr(self2.config.dateFormat);
    if (self2.altInput !== void 0) {
      self2.altInput.value = getDateStr(self2.config.altFormat);
    }
    if (triggerChange2 !== false)
      triggerEvent("onValueUpdate");
  }
  function onMonthNavClick(e2) {
    var eventTarget = getEventTarget(e2);
    var isPrevMonth = self2.prevMonthNav.contains(eventTarget);
    var isNextMonth = self2.nextMonthNav.contains(eventTarget);
    if (isPrevMonth || isNextMonth) {
      changeMonth(isPrevMonth ? -1 : 1);
    } else if (self2.yearElements.indexOf(eventTarget) >= 0) {
      eventTarget.select();
    } else if (eventTarget.classList.contains("arrowUp")) {
      self2.changeYear(self2.currentYear + 1);
    } else if (eventTarget.classList.contains("arrowDown")) {
      self2.changeYear(self2.currentYear - 1);
    }
  }
  function timeWrapper(e2) {
    e2.preventDefault();
    var isKeyDown = e2.type === "keydown", eventTarget = getEventTarget(e2), input = eventTarget;
    if (self2.amPM !== void 0 && eventTarget === self2.amPM) {
      self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
    }
    var min2 = parseFloat(input.getAttribute("min")), max2 = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e2.delta || (isKeyDown ? e2.which === 38 ? 1 : -1 : 0);
    var newValue = curValue + step * delta;
    if (typeof input.value !== "undefined" && input.value.length === 2) {
      var isHourElem = input === self2.hourElement, isMinuteElem = input === self2.minuteElement;
      if (newValue < min2) {
        newValue = max2 + newValue + int(!isHourElem) + (int(isHourElem) && int(!self2.amPM));
        if (isMinuteElem)
          incrementNumInput(void 0, -1, self2.hourElement);
      } else if (newValue > max2) {
        newValue = input === self2.hourElement ? newValue - max2 - int(!self2.amPM) : min2;
        if (isMinuteElem)
          incrementNumInput(void 0, 1, self2.hourElement);
      }
      if (self2.amPM && isHourElem && (step === 1 ? newValue + curValue === 23 : Math.abs(newValue - curValue) > step)) {
        self2.amPM.textContent = self2.l10n.amPM[int(self2.amPM.textContent === self2.l10n.amPM[0])];
      }
      input.value = pad(newValue);
    }
  }
  init();
  return self2;
}
function _flatpickr(nodeList, config) {
  var nodes = Array.prototype.slice.call(nodeList).filter(function(x) {
    return x instanceof HTMLElement;
  });
  var instances = [];
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    try {
      if (node.getAttribute("data-fp-omit") !== null)
        continue;
      if (node._flatpickr !== void 0) {
        node._flatpickr.destroy();
        node._flatpickr = void 0;
      }
      node._flatpickr = FlatpickrInstance(node, config || {});
      instances.push(node._flatpickr);
    } catch (e2) {
      console.error(e2);
    }
  }
  return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" && typeof HTMLCollection !== "undefined" && typeof NodeList !== "undefined") {
  HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
  HTMLElement.prototype.flatpickr = function(config) {
    return _flatpickr([this], config);
  };
}
var flatpickr = function(selector, config) {
  if (typeof selector === "string") {
    return _flatpickr(window.document.querySelectorAll(selector), config);
  } else if (selector instanceof Node) {
    return _flatpickr([selector], config);
  } else {
    return _flatpickr(selector, config);
  }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
  en: __assign2({}, default_default),
  default: __assign2({}, default_default)
};
flatpickr.localize = function(l10n2) {
  flatpickr.l10ns.default = __assign2(__assign2({}, flatpickr.l10ns.default), l10n2);
};
flatpickr.setDefaults = function(config) {
  flatpickr.defaultConfig = __assign2(__assign2({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
  jQuery.fn.flatpickr = function(config) {
    return _flatpickr(this, config);
  };
}
Date.prototype.fp_incr = function(days) {
  return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
  window.flatpickr = flatpickr;
}
var esm_default = flatpickr;

// node_modules/@carbon/react/es/components/DatePicker/DatePicker.js
var import_l10n = __toESM(require_l10n());

// node_modules/@carbon/react/es/components/DatePickerInput/DatePickerInput.js
var import_classnames76 = __toESM(require_classnames());
var import_prop_types91 = __toESM(require_prop_types());
var import_react125 = __toESM(require_react());
var didWarnAboutDatePickerInputValue = false;
var DatePickerInput = import_react125.default.forwardRef(function DatePickerInput2(props, ref) {
  const {
    datePickerType,
    decorator,
    disabled = false,
    helperText,
    hideLabel,
    id,
    invalid = false,
    invalidText,
    labelText,
    onClick = () => {
    },
    onChange = () => {
    },
    pattern = "\\d{1,2}\\/\\d{1,2}\\/\\d{4}",
    placeholder,
    size: size4 = "md",
    slug,
    type = "text",
    warn: warn2,
    warnText,
    ...rest
  } = props;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react125.useContext)(FormContext);
  const datePickerInputInstanceId = useId();
  const datePickerInputProps = {
    id,
    onChange: (event) => {
      if (!disabled) {
        onChange(event);
      }
    },
    onClick: (event) => {
      if (!disabled) {
        onClick(event);
      }
    },
    pattern,
    placeholder,
    type
  };
  if ("value" in rest && !didWarnAboutDatePickerInputValue) {
    true ? warning(false, `The 'value' prop is not supported on the DatePickerInput component. For DatePicker components with 'datePickerType="range"', please pass the 'value' prop (as an array of dates) to the parent DatePicker component instead.`) : void 0;
    didWarnAboutDatePickerInputValue = true;
  }
  const wrapperClasses = (0, import_classnames76.default)(`${prefix}--date-picker-input__wrapper`, {
    [`${prefix}--date-picker-input__wrapper--invalid`]: invalid,
    [`${prefix}--date-picker-input__wrapper--warn`]: warn2,
    [`${prefix}--date-picker-input__wrapper--slug`]: slug,
    [`${prefix}--date-picker-input__wrapper--decorator`]: decorator
  });
  const labelClasses = (0, import_classnames76.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--label--readonly`]: rest.readOnly
  });
  const helperTextClasses = (0, import_classnames76.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const inputClasses = (0, import_classnames76.default)(`${prefix}--date-picker__input`, {
    [`${prefix}--date-picker__input--${size4}`]: size4,
    [`${prefix}--date-picker__input--invalid`]: invalid,
    [`${prefix}--date-picker__input--warn`]: warn2
  });
  const containerClasses = (0, import_classnames76.default)(`${prefix}--date-picker-container`, {
    [`${prefix}--date-picker--nolabel`]: !labelText,
    [`${prefix}--date-picker--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--date-picker--fluid--warn`]: isFluid && warn2
  });
  const datePickerInputHelperId = !helperText ? void 0 : `datepicker-input-helper-text-${datePickerInputInstanceId}`;
  const inputProps = {
    ...rest,
    ...datePickerInputProps,
    className: inputClasses,
    disabled,
    ref,
    ["aria-describedby"]: helperText ? datePickerInputHelperId : void 0
  };
  if (invalid) {
    inputProps["data-invalid"] = true;
  }
  const input = import_react125.default.createElement("input", inputProps);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react125.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  return import_react125.default.createElement("div", {
    className: containerClasses
  }, labelText && import_react125.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText), import_react125.default.createElement("div", {
    className: wrapperClasses
  }, import_react125.default.createElement("span", null, input, slug ? normalizedDecorator : decorator ? import_react125.default.createElement("div", {
    className: `${prefix}--date-picker-input-inner-wrapper--decorator`
  }, normalizedDecorator) : "", isFluid && import_react125.default.createElement(DatePickerIcon, {
    datePickerType
  }), import_react125.default.createElement(DatePickerIcon, {
    datePickerType,
    invalid,
    warn: warn2
  }))), invalid && import_react125.default.createElement(import_react125.default.Fragment, null, isFluid && import_react125.default.createElement("hr", {
    className: `${prefix}--date-picker__divider`
  }), import_react125.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement`
  }, invalidText)), warn2 && import_react125.default.createElement(import_react125.default.Fragment, null, isFluid && import_react125.default.createElement("hr", {
    className: `${prefix}--date-picker__divider`
  }), import_react125.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement`
  }, warnText)), helperText && !invalid && import_react125.default.createElement(Text, {
    as: "div",
    id: datePickerInputHelperId,
    className: helperTextClasses
  }, helperText));
});
DatePickerInput.propTypes = {
  /**
   * The type of the date picker:
   *
   * * `simple` - Without calendar dropdown.
   * * `single` - With calendar dropdown and single date.
   * * `range` - With calendar dropdown and a date range.
   */
  datePickerType: import_prop_types91.default.oneOf(["simple", "single", "range"]),
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `RadioButton` component
   */
  decorator: import_prop_types91.default.node,
  /**
   * Specify whether or not the input should be disabled
   */
  disabled: import_prop_types91.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types91.default.node,
  /**
   * Specify if the label should be hidden
   */
  hideLabel: import_prop_types91.default.bool,
  /**
   * Specify an id that uniquely identifies the `<input>`
   */
  id: import_prop_types91.default.string.isRequired,
  /**
   * Specify whether or not the input should be invalid
   */
  invalid: import_prop_types91.default.bool,
  /**
   * Specify the text to be rendered when the input is invalid
   */
  invalidText: import_prop_types91.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types91.default.node.isRequired,
  /**
   * Specify an `onChange` handler that is called whenever a change in the
   * input field has occurred
   */
  onChange: import_prop_types91.default.func,
  /**
   * Provide a function to be called when the input field is clicked
   */
  onClick: import_prop_types91.default.func,
  /**
   * Provide a regular expression that the input value must match
   */
  pattern: (props, propName, componentName) => {
    if (props[propName] === void 0) {
      return;
    }
    try {
      new RegExp(props[propName]);
    } catch (e2) {
      return new Error(`Invalid value of prop '${propName}' supplied to '${componentName}', it should be a valid regular expression`);
    }
  },
  /**
   * Specify the placeholder text
   */
  placeholder: import_prop_types91.default.string,
  /**
   * whether the DatePicker is to be readOnly
   */
  readOnly: import_prop_types91.default.bool,
  /**
   * Specify the size of the Date Picker Input. Currently supports either `sm`, `md`, or `lg` as an option.
   */
  size: import_prop_types91.default.oneOf(["sm", "md", "lg"]),
  slug: deprecate(import_prop_types91.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify the type of the `<input>`
   */
  type: import_prop_types91.default.string,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types91.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types91.default.node
};
function DatePickerIcon({
  datePickerType,
  invalid,
  warn: warn2
}) {
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react125.useContext)(FormContext);
  if (datePickerType === "simple" && !invalid && !warn2) {
    if (!isFluid) {
      return null;
    }
  }
  if (invalid) {
    return import_react125.default.createElement(WarningFilled, {
      className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--invalid`
    });
  }
  if (!invalid && warn2) {
    return import_react125.default.createElement(WarningAltFilled, {
      className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--warn`
    });
  }
  return import_react125.default.createElement(Calendar, {
    className: `${prefix}--date-picker__icon`,
    role: "img",
    "aria-hidden": "true"
  });
}
DatePickerIcon.propTypes = {
  /**
   * The type of the date picker:
   *
   * * `simple` - Without calendar dropdown.
   * * `single` - With calendar dropdown and single date.
   * * `range` - With calendar dropdown and a date range.
   */
  datePickerType: import_prop_types91.default.oneOf(["simple", "single", "range"]),
  /**
   * Specify whether or not the input should be invalid
   */
  invalid: import_prop_types91.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types91.default.bool
};

// node_modules/@carbon/react/es/components/DatePicker/plugins/appendToPlugin.js
var appendToPlugin = (config) => (fp) => {
  const handlePreCalendarPosition = () => {
    Promise.resolve().then(() => {
      var _a;
      const {
        calendarContainer,
        config: fpConfig,
        _positionElement: positionElement
      } = fp;
      const appendTo = fpConfig.appendTo;
      if (!appendTo) {
        throw new Error("[appendToPlugin] Missing `appendTo` element.");
      }
      const {
        left: containerLeft,
        top: containerTop
      } = appendTo.getBoundingClientRect();
      const {
        left: refLeft,
        bottom: refBottom
      } = positionElement.getBoundingClientRect();
      if ((appendTo !== appendTo.ownerDocument.body || containerLeft !== 0 || containerTop !== 0) && ((_a = appendTo.ownerDocument.defaultView) == null ? void 0 : _a.getComputedStyle(appendTo).getPropertyValue("position")) === "static") {
        throw new Error("Floating menu container must not have `position: static`.");
      }
      calendarContainer.style.top = `${refBottom - containerTop + 2}px`;
      calendarContainer.style.left = `${refLeft - containerLeft}px`;
    });
  };
  const register = () => {
    fp.loadedPlugins.push("carbonFlatpickrAppendToPlugin");
  };
  return {
    appendTo: config.appendTo,
    onReady: register,
    onPreCalendarPosition: handlePreCalendarPosition
  };
};

// node_modules/@carbon/react/es/components/DatePicker/plugins/fixEventsPlugin.js
var carbonFlatpickrFixEventsPlugin = (config) => (fp) => {
  const {
    inputFrom,
    inputTo,
    lastStartValue
  } = config;
  const handleClickOutside = (event) => {
    if (!fp.isOpen || fp.calendarContainer.contains(event.target) || event.target === inputFrom || event.target === inputTo) {
      return;
    }
    fp.close();
  };
  const handleKeydown = (event) => {
    const {
      target
    } = event;
    if (inputFrom === target || inputTo === target) {
      if (match(event, Enter)) {
        fp.setDate([inputFrom.value, inputTo && inputTo.value], true, fp.config.dateFormat);
        event.stopPropagation();
      } else if (match(event, ArrowLeft) || match(event, ArrowRight2)) {
        event.stopPropagation();
      } else if (match(event, ArrowDown)) {
        event.preventDefault();
        fp.open();
      } else if (!fp.config.allowInput) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
  };
  const parseDateWithFormat = (dateStr) => fp.parseDate(dateStr, fp.config.dateFormat);
  const handleBlur = (event) => {
    const {
      target
    } = event;
    if (inputTo === target && fp.selectedDates[1]) {
      const withoutTime = (date) => date == null ? void 0 : date.setHours(0, 0, 0, 0);
      const selectedToDate = withoutTime(new Date(fp.selectedDates[1]));
      const currentValueToDate = withoutTime(parseDateWithFormat(inputTo.value));
      if (selectedToDate && currentValueToDate && selectedToDate !== currentValueToDate) {
        fp.setDate([inputFrom.value, inputTo && inputTo.value], true, fp.config.dateFormat);
      }
    }
    const isValidDate = (date) => (date == null ? void 0 : date.toString()) !== "Invalid Date";
    if (inputTo === target && fp.selectedDates.length === 1 && inputTo.value) {
      if (isValidDate(parseDateWithFormat(inputTo.value))) {
        fp.setDate([inputFrom.value, inputTo.value], true, fp.config.dateFormat);
      }
    }
    if (inputTo === target && !inputFrom.value && lastStartValue.current) {
      if (isValidDate(parseDateWithFormat(lastStartValue.current))) {
        inputFrom.value = lastStartValue.current;
        if (inputTo.value) {
          fp.setDate([inputFrom.value, inputTo.value], true, fp.config.dateFormat);
        }
      }
    }
  };
  const release = () => {
    const {
      inputFrom: inputFrom2,
      inputTo: inputTo2
    } = config;
    if (inputTo2) {
      inputTo2.removeEventListener("keydown", handleKeydown, true);
      inputTo2.removeEventListener("blur", handleBlur, true);
    }
    inputFrom2.removeEventListener("keydown", handleKeydown, true);
    document.removeEventListener("click", handleClickOutside, true);
  };
  const init = () => {
    release();
    const {
      inputFrom: inputFrom2,
      inputTo: inputTo2
    } = config;
    inputFrom2.addEventListener("keydown", handleKeydown, true);
    if (inputTo2) {
      inputTo2.addEventListener("keydown", handleKeydown, true);
      inputTo2.addEventListener("blur", handleBlur, true);
    }
    document.addEventListener("click", handleClickOutside, true);
  };
  const register = () => {
    fp.loadedPlugins.push("carbonFlatpickrFixEventsPlugin");
  };
  return {
    onReady: [register, init],
    onDestroy: [release]
  };
};

// node_modules/@carbon/react/es/components/DatePicker/plugins/rangePlugin.js
var import_rangePlugin = __toESM(require_rangePlugin());
var carbonFlatpickrRangePlugin = (config) => {
  const factory = (0, import_rangePlugin.default)(Object.assign({
    position: "left"
  }, config));
  return (fp) => {
    const origSetDate = fp.setDate;
    const init = () => {
      fp.setDate = function setDate(dates, triggerChange, format) {
        origSetDate.call(this, dates, triggerChange, format);
        if (!triggerChange && dates.length === 2) {
          const {
            _input: inputFrom
          } = fp;
          const {
            input: inputTo
          } = config;
          [inputFrom, inputTo].forEach((input, i) => {
            if (input) {
              input.value = !dates[i] ? "" : fp.formatDate(new Date(dates[i]), fp.config.dateFormat);
            }
          });
        }
      };
    };
    const origRangePlugin = factory(fp);
    const {
      onReady: origOnReady
    } = origRangePlugin;
    return Object.assign(origRangePlugin, {
      onReady: [init, origOnReady],
      onPreCalendarPosition() {
      }
    });
  };
};

// node_modules/@carbon/react/es/internal/useSavedCallback.js
var import_react126 = __toESM(require_react());
var useSavedCallback = (callback) => {
  const savedCallback = (0, import_react126.useRef)(callback);
  (0, import_react126.useEffect)(() => {
    savedCallback.current = callback;
  }, [callback]);
  return (0, import_react126.useCallback)((...args) => savedCallback.current ? savedCallback.current(...args) : void 0, []);
};

// node_modules/@carbon/react/es/components/DatePicker/DatePicker.js
function initializeWeekdayShorthand() {
  var _a, _b, _c;
  if ((_c = (_b = (_a = import_l10n.default) == null ? void 0 : _a.en) == null ? void 0 : _b.weekdays) == null ? void 0 : _c.shorthand) {
    import_l10n.default.en.weekdays.shorthand.forEach((_day, index3) => {
      const currentDay = import_l10n.default.en.weekdays.shorthand;
      if (currentDay[index3] === "Thu" || currentDay[index3] === "Th") {
        currentDay[index3] = "Th";
      } else {
        currentDay[index3] = currentDay[index3].charAt(0);
      }
    });
  }
}
var forEach = Array.prototype.forEach;
var monthToStr2 = (monthNumber, shorthand, locale) => locale.months[shorthand ? "shorthand" : "longhand"][monthNumber];
var carbonFlatpickrMonthSelectPlugin = (config) => (fp) => {
  const setupElements = () => {
    if (!fp.monthElements) {
      return;
    }
    fp.monthElements.forEach((elem) => {
      if (!elem.parentNode) {
        return;
      }
      elem.parentNode.removeChild(elem);
    });
    fp.monthElements.splice(0, fp.monthElements.length, ...fp.monthElements.map(() => {
      const monthElement = fp._createElement("span", config.classFlatpickrCurrentMonth);
      monthElement.textContent = monthToStr2(fp.currentMonth, config.shorthand === true, fp.l10n);
      fp.yearElements[0].closest(config.selectorFlatpickrMonthYearContainer).insertBefore(monthElement, fp.yearElements[0].closest(config.selectorFlatpickrYearContainer));
      return monthElement;
    }));
  };
  const updateCurrentMonth = () => {
    if (fp.monthElements) {
      const monthStr = monthToStr2(fp.currentMonth, config.shorthand === true, fp.l10n);
      fp.yearElements.forEach((elem) => {
        const currentMonthContainer = elem.closest(config.selectorFlatpickrMonthYearContainer);
        Array.prototype.forEach.call(currentMonthContainer.querySelectorAll(".cur-month"), (monthElement) => {
          monthElement.textContent = monthStr;
        });
      });
    }
  };
  const register = () => {
    fp.loadedPlugins.push("carbonFlatpickrMonthSelectPlugin");
  };
  return {
    onMonthChange: updateCurrentMonth,
    onValueUpdate: updateCurrentMonth,
    onOpen: updateCurrentMonth,
    onReady: [setupElements, updateCurrentMonth, register]
  };
};
function isLabelTextEmpty(children) {
  return children.every((child) => !child.props.labelText);
}
var rightArrowHTML = `<svg width="16px" height="16px" viewBox="0 0 16 16">
  <polygon points="11,8 6,13 5.3,12.3 9.6,8 5.3,3.7 6,3 "/>
</svg>`;
var leftArrowHTML = `<svg width="16px" height="16px" viewBox="0 0 16 16">
  <polygon points="5,8 10,3 10.7,3.7 6.4,8 10.7,12.3 10,13 "/>
</svg>`;
function updateClassNames(calendar, prefix) {
  const calendarContainer = calendar.calendarContainer;
  const daysContainer = calendar.days;
  if (calendarContainer && daysContainer) {
    calendarContainer.classList.add(`${prefix}--date-picker__calendar`);
    calendarContainer.querySelector(".flatpickr-month").classList.add(`${prefix}--date-picker__month`);
    calendarContainer.querySelector(".flatpickr-weekdays").classList.add(`${prefix}--date-picker__weekdays`);
    calendarContainer.querySelector(".flatpickr-days").classList.add(`${prefix}--date-picker__days`);
    forEach.call(calendarContainer.querySelectorAll(".flatpickr-weekday"), (item) => {
      const currentItem = item;
      currentItem.innerHTML = currentItem.innerHTML.replace(/\s+/g, "");
      currentItem.classList.add(`${prefix}--date-picker__weekday`);
    });
    forEach.call(daysContainer.querySelectorAll(".flatpickr-day"), (item) => {
      item.classList.add(`${prefix}--date-picker__day`);
      item.setAttribute("role", "button");
      if (item.classList.contains("today") && calendar.selectedDates.length > 0) {
        item.classList.add("no-border");
      } else if (item.classList.contains("today") && calendar.selectedDates.length === 0) {
        item.classList.remove("no-border");
      }
    });
  }
}
var DatePicker = import_react127.default.forwardRef(function DatePicker2({
  allowInput,
  appendTo,
  children,
  className,
  closeOnSelect = true,
  dateFormat = "m/d/Y",
  datePickerType,
  disable,
  enable,
  inline: inline4,
  invalid,
  invalidText,
  warn: warn2,
  warnText,
  light = false,
  locale = "en",
  maxDate,
  minDate,
  onChange,
  onClose,
  onOpen,
  readOnly = false,
  short = false,
  value,
  parseDate: parseDateProp,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react127.useContext)(FormContext);
  const [hasInput, setHasInput] = (0, import_react127.useState)(false);
  const startInputField = (0, import_react127.useCallback)((node) => {
    if (node !== null) {
      startInputField.current = node;
      setHasInput(true);
    }
  }, []);
  const lastStartValue = (0, import_react127.useRef)("");
  const calendarRef = (0, import_react127.useRef)(null);
  const [calendarCloseEvent, setCalendarCloseEvent] = (0, import_react127.useState)(null);
  const handleCalendarClose = (0, import_react127.useCallback)((selectedDates, dateStr, instance) => {
    var _a, _b;
    if (lastStartValue.current && selectedDates[0] && !startInputField.current.value) {
      startInputField.current.value = lastStartValue.current;
      (_b = calendarRef.current) == null ? void 0 : _b.setDate([startInputField.current.value, (_a = endInputField == null ? void 0 : endInputField.current) == null ? void 0 : _a.value], true, calendarRef.current.config.dateFormat);
    }
    if (onClose) {
      onClose(selectedDates, dateStr, instance);
    }
  }, [onClose]);
  const onCalendarClose = (selectedDates, dateStr, instance, e2) => {
    if (e2 && e2.type === "clickOutside") {
      return;
    }
    setCalendarCloseEvent({
      selectedDates,
      dateStr,
      instance
    });
  };
  (0, import_react127.useEffect)(() => {
    if (calendarCloseEvent) {
      const {
        selectedDates,
        dateStr,
        instance
      } = calendarCloseEvent;
      handleCalendarClose(selectedDates, dateStr, instance);
      setCalendarCloseEvent(null);
    }
  }, [calendarCloseEvent, handleCalendarClose]);
  const endInputField = (0, import_react127.useRef)(null);
  const lastFocusedField = (0, import_react127.useRef)(null);
  const savedOnChange = useSavedCallback(onChange);
  const savedOnOpen = useSavedCallback(onOpen);
  const datePickerClasses = (0, import_classnames77.default)(`${prefix}--date-picker`, {
    [`${prefix}--date-picker--short`]: short,
    [`${prefix}--date-picker--light`]: light,
    [`${prefix}--date-picker--simple`]: datePickerType === "simple",
    [`${prefix}--date-picker--single`]: datePickerType === "single",
    [`${prefix}--date-picker--range`]: datePickerType === "range",
    [`${prefix}--date-picker--nolabel`]: datePickerType === "range" && isLabelTextEmpty(children)
  });
  const wrapperClasses = (0, import_classnames77.default)(`${prefix}--form-item`, {
    [String(className)]: className
  });
  const childrenWithProps = import_react127.default.Children.toArray(children).map((child, index3) => {
    if (index3 === 0 && child.type === import_react127.default.createElement(DatePickerInput, child.props).type) {
      return import_react127.default.cloneElement(child, {
        datePickerType,
        ref: startInputField,
        readOnly
      });
    }
    if (index3 === 1 && child.type === import_react127.default.createElement(DatePickerInput, child.props).type) {
      return import_react127.default.cloneElement(child, {
        datePickerType,
        ref: endInputField,
        readOnly
      });
    }
    if (index3 === 0) {
      return import_react127.default.cloneElement(child, {
        ref: startInputField,
        readOnly
      });
    }
    if (index3 === 1) {
      return import_react127.default.cloneElement(child, {
        ref: endInputField,
        readOnly
      });
    }
  });
  (0, import_react127.useEffect)(() => {
    initializeWeekdayShorthand();
  }, []);
  (0, import_react127.useEffect)(() => {
    if (datePickerType !== "single" && datePickerType !== "range") {
      return;
    }
    if (!startInputField.current) {
      return;
    }
    const onHook = (_electedDates, _dateStr, instance) => {
      updateClassNames(instance, prefix);
      if (startInputField == null ? void 0 : startInputField.current) {
        startInputField.current.readOnly = readOnly;
      }
      if (endInputField == null ? void 0 : endInputField.current) {
        endInputField.current.readOnly = readOnly;
      }
    };
    const enableOrDisable = enable ? "enable" : "disable";
    let enableOrDisableArr;
    if (!enable && !disable) {
      enableOrDisableArr = [];
    } else if (enable) {
      enableOrDisableArr = enable;
    } else {
      enableOrDisableArr = disable;
    }
    let localeData;
    if (typeof locale === "object") {
      const location = locale.locale ? locale.locale : "en";
      localeData = {
        ...import_l10n.default[location],
        ...locale
      };
    } else {
      localeData = import_l10n.default[locale];
    }
    let parseDate;
    if (!parseDateProp && dateFormat === "m/d/Y") {
      parseDate = (date) => {
        const month = date.split("/")[0] <= 12 && date.split("/")[0] > 0 ? parseInt(date.split("/")[0]) : 1;
        const year = parseInt(date.split("/")[2]);
        if (month && year) {
          const daysInMonth = new Date(year, month, 0).getDate();
          const day = date.split("/")[1] <= daysInMonth && date.split("/")[1] > 0 ? parseInt(date.split("/")[1]) : 1;
          return /* @__PURE__ */ new Date(`${year}/${month}/${day}`);
        } else {
          return false;
        }
      };
    } else if (parseDateProp) {
      parseDate = parseDateProp;
    }
    const {
      current: start
    } = startInputField;
    const {
      current: end
    } = endInputField;
    const flatpickerConfig = {
      inline: inline4 ?? false,
      onClose: onCalendarClose,
      disableMobile: true,
      defaultDate: value,
      closeOnSelect,
      mode: datePickerType,
      allowInput: allowInput ?? true,
      dateFormat,
      locale: localeData,
      [enableOrDisable]: enableOrDisableArr,
      minDate,
      maxDate,
      parseDate,
      plugins: [datePickerType === "range" ? carbonFlatpickrRangePlugin({
        input: endInputField.current
      }) : () => {
      }, appendTo ? appendToPlugin({
        appendTo
      }) : () => {
      }, carbonFlatpickrMonthSelectPlugin({
        selectorFlatpickrMonthYearContainer: ".flatpickr-current-month",
        selectorFlatpickrYearContainer: ".numInputWrapper",
        classFlatpickrCurrentMonth: "cur-month"
      }), carbonFlatpickrFixEventsPlugin({
        inputFrom: startInputField.current,
        inputTo: endInputField.current,
        lastStartValue
      })],
      clickOpens: !readOnly,
      noCalendar: readOnly,
      nextArrow: rightArrowHTML,
      prevArrow: leftArrowHTML,
      onChange: (...args) => {
        if (!readOnly) {
          savedOnChange(...args);
        }
      },
      onReady: onHook,
      onMonthChange: onHook,
      onYearChange: onHook,
      onOpen: (...args) => {
        onHook(...args);
        savedOnOpen(...args);
      },
      onValueUpdate: onHook
    };
    const calendar = esm_default(start, flatpickerConfig);
    calendarRef.current = calendar;
    const handleInputFieldKeyDown = (event) => {
      var _a;
      const {
        calendarContainer,
        selectedDateElem: fpSelectedDateElem,
        todayDateElem: fpTodayDateElem
      } = calendar;
      if (match(event, Escape)) {
        calendarContainer.classList.remove("open");
      }
      if (match(event, Tab)) {
        if (!event.shiftKey) {
          event.preventDefault();
          calendarContainer.classList.add("open");
          const selectedDateElem = calendarContainer.querySelector(".selected") && fpSelectedDateElem;
          const todayDateElem = calendarContainer.querySelector(".today") && fpTodayDateElem;
          (selectedDateElem || todayDateElem || calendarContainer.querySelector(".flatpickr-day[tabindex]") || calendarContainer).focus();
          if (event.target === startInputField.current) {
            lastFocusedField.current = startInputField.current;
          } else if (event.target === endInputField.current) {
            lastFocusedField.current = endInputField.current;
          }
        } else if (((_a = calendarRef.current) == null ? void 0 : _a.isOpen) && event.target === startInputField.current) {
          calendarRef.current.close();
          onCalendarClose(calendarRef.current.selectedDates, "", calendarRef.current, event);
        }
      }
    };
    const handleCalendarKeyDown = (event) => {
      if (!calendarRef.current || !startInputField.current) return;
      const lastInputField = datePickerType == "range" ? endInputField.current : startInputField.current;
      if (match(event, Tab)) {
        if (!event.shiftKey) {
          if (lastFocusedField.current === lastInputField) {
            lastInputField.focus();
            calendarRef.current.close();
            onCalendarClose(calendarRef.current.selectedDates, "", calendarRef.current, event);
          } else {
            event.preventDefault();
            lastInputField.focus();
          }
        } else {
          event.preventDefault();
          (lastFocusedField.current || startInputField.current).focus();
        }
      }
    };
    function handleOnChange(event) {
      const {
        target
      } = event;
      if (target === start) {
        lastStartValue.current = start.value;
      }
      if (start.value !== "") {
        return;
      }
      if (!calendar.selectedDates) {
        return;
      }
      if (calendar.selectedDates.length === 0) {
        return;
      }
    }
    function handleKeyPress(event) {
      if (match(event, Enter) && closeOnSelect && datePickerType == "single") {
        calendar.calendarContainer.classList.remove("open");
      }
    }
    if (start) {
      start.addEventListener("keydown", handleInputFieldKeyDown);
      start.addEventListener("change", handleOnChange);
      start.addEventListener("keypress", handleKeyPress);
      if (calendar && calendar.calendarContainer) {
        calendar.calendarContainer.setAttribute("role", "application");
        calendar.calendarContainer.setAttribute("aria-label", "calendar-container");
      }
    }
    if (end) {
      end.addEventListener("keydown", handleInputFieldKeyDown);
      end.addEventListener("change", handleOnChange);
      end.addEventListener("keypress", handleKeyPress);
    }
    if (calendar.calendarContainer) {
      calendar.calendarContainer.addEventListener("keydown", handleCalendarKeyDown);
    }
    return () => {
      if (calendar && calendar.destroy) {
        calendar.destroy();
      }
      if (value) {
        if (startInputField == null ? void 0 : startInputField.current) {
          startInputField.current.value = "";
        }
        if (endInputField == null ? void 0 : endInputField.current) {
          endInputField.current.value = "";
        }
      }
      if (start) {
        start.removeEventListener("keydown", handleInputFieldKeyDown);
        start.removeEventListener("change", handleOnChange);
        start.removeEventListener("keypress", handleKeyPress);
      }
      if (end) {
        end.removeEventListener("keydown", handleInputFieldKeyDown);
        end.removeEventListener("change", handleOnChange);
        end.removeEventListener("keypress", handleKeyPress);
      }
      if (calendar.calendarContainer) {
        calendar.calendarContainer.removeEventListener("keydown", handleCalendarKeyDown);
      }
    };
  }, [savedOnChange, savedOnOpen, readOnly, closeOnSelect, hasInput, datePickerType]);
  (0, import_react127.useImperativeHandle)(ref, () => ({
    get calendar() {
      return calendarRef.current;
    }
  }));
  (0, import_react127.useEffect)(() => {
    var _a;
    if ((_a = calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set({
        dateFormat
      });
    }
  }, [dateFormat]);
  (0, import_react127.useEffect)(() => {
    var _a;
    if ((_a = calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set("minDate", minDate);
    }
  }, [minDate]);
  (0, import_react127.useEffect)(() => {
    var _a;
    if ((_a = calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set("allowInput", allowInput);
    }
  }, [allowInput]);
  (0, import_react127.useEffect)(() => {
    var _a;
    if ((_a = calendarRef.current) == null ? void 0 : _a.set) {
      calendarRef.current.set("maxDate", maxDate);
    }
  }, [maxDate]);
  (0, import_react127.useEffect)(() => {
    var _a;
    if (((_a = calendarRef.current) == null ? void 0 : _a.set) && disable) {
      calendarRef.current.set("disable", disable);
    }
  }, [disable]);
  (0, import_react127.useEffect)(() => {
    var _a;
    if (((_a = calendarRef.current) == null ? void 0 : _a.set) && enable) {
      calendarRef.current.set("enable", enable);
    }
  }, [enable]);
  (0, import_react127.useEffect)(() => {
    var _a;
    if (((_a = calendarRef.current) == null ? void 0 : _a.set) && inline4) {
      calendarRef.current.set("inline", inline4);
    }
  }, [inline4]);
  (0, import_react127.useEffect)(() => {
    var _a, _b;
    if ((!value || Array.isArray(value) && value.every((date) => !date)) && ((_a = calendarRef.current) == null ? void 0 : _a.selectedDates.length)) {
      (_b = calendarRef.current) == null ? void 0 : _b.clear();
      if (startInputField.current) {
        startInputField.current.value = "";
      }
      if (endInputField.current) {
        endInputField.current.value = "";
      }
    }
  }, [value]);
  (0, import_react127.useEffect)(() => {
    const handleMouseDown = (event) => {
      var _a;
      if (calendarRef.current && calendarRef.current.isOpen && !calendarRef.current.calendarContainer.contains(event.target) && !startInputField.current.contains(event.target) && !((_a = endInputField.current) == null ? void 0 : _a.contains(event.target))) {
        closeCalendar();
      }
    };
    const closeCalendar = (event) => {
      var _a, _b;
      (_a = calendarRef.current) == null ? void 0 : _a.close();
      onCalendarClose((_b = calendarRef.current) == null ? void 0 : _b.selectedDates, "", calendarRef.current, {
        type: "clickOutside"
      });
    };
    document.addEventListener("mousedown", handleMouseDown, true);
    return () => {
      document.removeEventListener("mousedown", handleMouseDown, true);
    };
  }, [calendarRef, startInputField, endInputField, onCalendarClose]);
  (0, import_react127.useEffect)(() => {
    var _a;
    if ((_a = calendarRef.current) == null ? void 0 : _a.set) {
      if (value !== void 0) {
        calendarRef.current.setDate(value);
      }
      updateClassNames(calendarRef.current, prefix);
    } else if (!calendarRef.current && value) {
      startInputField.current.value = value;
    }
  }, [value, prefix]);
  let fluidError;
  if (isFluid) {
    if (invalid) {
      fluidError = import_react127.default.createElement(import_react127.default.Fragment, null, import_react127.default.createElement(WarningFilled, {
        className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--invalid`
      }), import_react127.default.createElement("hr", {
        className: `${prefix}--date-picker__divider`
      }), import_react127.default.createElement("div", {
        className: `${prefix}--form-requirement`
      }, invalidText));
    }
    if (warn2 && !invalid) {
      fluidError = import_react127.default.createElement(import_react127.default.Fragment, null, import_react127.default.createElement(WarningAltFilled, {
        className: `${prefix}--date-picker__icon ${prefix}--date-picker__icon--warn`
      }), import_react127.default.createElement("hr", {
        className: `${prefix}--date-picker__divider`
      }), import_react127.default.createElement("div", {
        className: `${prefix}--form-requirement`
      }, warnText));
    }
  }
  return import_react127.default.createElement("div", _extends({
    className: wrapperClasses,
    ref
  }, rest), import_react127.default.createElement("div", {
    className: datePickerClasses
  }, childrenWithProps), fluidError);
});
DatePicker.propTypes = {
  /**
   * Flatpickr prop passthrough enables direct date input, and when set to false,
   * we must clear dates manually by resetting the value prop to a falsy value (such as `""`, `null`, or `undefined`) or an array of all falsy values, making it a controlled input.
   */
  allowInput: import_prop_types92.default.bool,
  /**
   * The DOM element the Flatpicker should be inserted into. `<body>` by default.
   */
  appendTo: import_prop_types92.default.object,
  /**
   * The child nodes.
   */
  children: import_prop_types92.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types92.default.string,
  /**
   * flatpickr prop passthrough. Controls whether the calendar dropdown closes upon selection.
   */
  closeOnSelect: import_prop_types92.default.bool,
  /**
   * The date format.
   */
  dateFormat: import_prop_types92.default.string,
  /**
   * The type of the date picker:
   *
   * * `simple` - Without calendar dropdown.
   * * `single` - With calendar dropdown and single date.
   * * `range` - With calendar dropdown and a date range.
   */
  datePickerType: import_prop_types92.default.oneOf(["simple", "single", "range"]),
  /**
   * The flatpickr `disable` option that allows a user to disable certain dates.
   */
  disable: import_prop_types92.default.array,
  /**
   * The flatpickr `enable` option that allows a user to enable certain dates.
   */
  enable: import_prop_types92.default.array,
  /**
   * The flatpickr `inline` option.
   */
  inline: import_prop_types92.default.bool,
  /**
   * Specify whether or not the control is invalid (Fluid only)
   */
  invalid: import_prop_types92.default.bool,
  /**
   * Provide the text that is displayed when the control is in error state (Fluid Only)
   */
  invalidText: import_prop_types92.default.node,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types92.default.bool, "The `light` prop for `DatePicker` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   *  The language locale used to format the days of the week, months, and numbers. The full list of supported locales can be found here https://github.com/flatpickr/flatpickr/tree/master/src/l10n
   */
  locale: import_prop_types92.default.oneOfType([import_prop_types92.default.object, import_prop_types92.default.oneOf([
    "ar",
    // Arabic
    "at",
    // Austria
    "az",
    // Azerbaijan
    "be",
    // Belarusian
    "bg",
    // Bulgarian
    "bn",
    // Bangla
    "bs",
    // Bosnia
    "cat",
    // Catalan
    "cs",
    // Czech
    "cy",
    // Welsh
    "da",
    // Danish
    "de",
    // German
    "en",
    // English
    "eo",
    // Esperanto
    "es",
    // Spanish
    "et",
    // Estonian
    "fa",
    // Persian
    "fi",
    // Finnish
    "fo",
    // Faroese
    "fr",
    // French
    "ga",
    // Gaelic
    "gr",
    // Greek
    "he",
    // Hebrew
    "hi",
    // Hindi
    "hr",
    // Croatian
    "hu",
    // Hungarian
    "id",
    // Indonesian
    "is",
    // Icelandic
    "it",
    // Italian
    "ja",
    // Japanese
    "ka",
    // Georgian
    "km",
    // Khmer
    "ko",
    // Korean
    "kz",
    // Kazakh
    "lt",
    // Lithuanian
    "lv",
    // Latvian
    "mk",
    // Macedonian
    "mn",
    // Mongolian
    "ms",
    // Malaysian
    "my",
    // Burmese
    "nl",
    // Dutch
    "no",
    // Norwegian
    "pa",
    // Punjabi
    "pl",
    // Polish
    "pt",
    // Portuguese
    "ro",
    // Romanian
    "ru",
    // Russian
    "si",
    // Sinhala
    "sk",
    // Slovak
    "sl",
    // Slovenian
    "sq",
    // Albanian
    "sr",
    // Serbian
    "sv",
    // Swedish
    "th",
    // Thai
    "tr",
    // Turkish
    "uk",
    // Ukrainian
    "uz",
    // Uzbek
    "uz_latn",
    // Uzbek Latin
    "vn",
    // Vietnamese
    "zh_tw",
    // Mandarin Traditional
    "zh"
    // Mandarin
  ])]),
  /**
   * The maximum date that a user can pick to.
   */
  maxDate: import_prop_types92.default.oneOfType([import_prop_types92.default.string, import_prop_types92.default.number]),
  /**
   * The minimum date that a user can start picking from.
   */
  minDate: import_prop_types92.default.oneOfType([import_prop_types92.default.string, import_prop_types92.default.number]),
  /**
   * The `change` event handler.
   * `(dates: Date[], dStr: string, fp: Instance, data?: any):void;`
   */
  onChange: import_prop_types92.default.func,
  /**
   * The `close` event handler.
   * `(dates: Date[], dStr: string, fp: Instance, data?: any):void;`
   */
  onClose: import_prop_types92.default.func,
  /**
   * The `open` event handler.
   * `(dates: Date[], dStr: string, fp: Instance, data?: any):void;`
   */
  onOpen: import_prop_types92.default.func,
  /**
   * flatpickr prop passthrough. Controls how dates are parsed.
   */
  parseDate: import_prop_types92.default.func,
  /**
   * whether the DatePicker is to be readOnly
   * if boolean applies to all inputs
   * if array applies to each input in order
   */
  readOnly: import_prop_types92.default.oneOfType([import_prop_types92.default.bool, import_prop_types92.default.array]),
  /**
   * `true` to use the short version.
   */
  short: import_prop_types92.default.bool,
  /**
   * The value of the date value provided to flatpickr, could
   * be a date, a date number, a date string, an array of dates.
   */
  value: import_prop_types92.default.oneOfType([import_prop_types92.default.string, import_prop_types92.default.arrayOf(import_prop_types92.default.oneOfType([import_prop_types92.default.string, import_prop_types92.default.number, import_prop_types92.default.object])), import_prop_types92.default.object, import_prop_types92.default.number]),
  /**
   * Specify whether the control is currently in warning state (Fluid only)
   */
  warn: import_prop_types92.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state (Fluid only)
   */
  warnText: import_prop_types92.default.node
};

// node_modules/@carbon/react/es/components/DatePicker/DatePicker.Skeleton.js
var import_prop_types93 = __toESM(require_prop_types());
var import_react128 = __toESM(require_react());
var import_classnames78 = __toESM(require_classnames());
var DatePickerSkeleton = ({
  range,
  id,
  hideLabel,
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const dateInput = import_react128.default.createElement("div", {
    className: `${prefix}--date-picker-container`
  }, !hideLabel && import_react128.default.createElement("span", {
    className: `${prefix}--label`,
    id
  }), import_react128.default.createElement("div", {
    className: `${prefix}--date-picker__input ${prefix}--skeleton`
  }));
  if (range) {
    return import_react128.default.createElement("div", {
      className: `${prefix}--form-item`
    }, import_react128.default.createElement("div", _extends({
      className: (0, import_classnames78.default)(`${prefix}--date-picker`, `${prefix}--date-picker--range`, `${prefix}--skeleton`, className)
    }, rest), dateInput, dateInput));
  }
  return import_react128.default.createElement("div", {
    className: `${prefix}--form-item`
  }, import_react128.default.createElement("div", _extends({
    className: (0, import_classnames78.default)(`${prefix}--date-picker`, `${prefix}--date-picker--short`, `${prefix}--date-picker--simple`, `${prefix}--skeleton`, className)
  }, rest), dateInput));
};
DatePickerSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types93.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types93.default.bool,
  /**
   * Specify the id to add.
   */
  id: import_prop_types93.default.string,
  /**
   * Specify whether the skeleton should be of range date picker.
   */
  range: import_prop_types93.default.bool
};

// node_modules/@carbon/react/es/components/Dropdown/Dropdown.js
var import_react129 = __toESM(require_react());
var import_classnames79 = __toESM(require_classnames());
var import_prop_types94 = __toESM(require_prop_types());
var {
  ItemMouseMove: ItemMouseMove3,
  MenuMouseLeave: MenuMouseLeave3
} = useSelect.stateChangeTypes;
var defaultItemToString3 = (item) => {
  if (typeof item === "string") {
    return item;
  }
  if (typeof item === "number") {
    return `${item}`;
  }
  if (item !== null && typeof item === "object" && "label" in item && typeof item["label"] === "string") {
    return item["label"];
  }
  return "";
};
function stateReducer2(state, actionAndChanges) {
  const {
    changes,
    type
  } = actionAndChanges;
  switch (type) {
    case ItemMouseMove3:
    case MenuMouseLeave3:
      if (changes.highlightedIndex === state.highlightedIndex) {
        return state;
      }
      return changes;
    default:
      return changes;
  }
}
var Dropdown = import_react129.default.forwardRef(({
  autoAlign = false,
  className: containerClassName,
  decorator,
  disabled = false,
  direction = "bottom",
  items: itemsProp,
  label,
  ["aria-label"]: ariaLabel,
  ariaLabel: deprecatedAriaLabel,
  itemToString: itemToString3 = defaultItemToString3,
  itemToElement = null,
  renderSelectedItem,
  type = "default",
  size: size$1,
  onChange,
  id,
  titleText = "",
  hideLabel,
  helperText = "",
  translateWithId: translateWithId8,
  light,
  invalid,
  invalidText,
  warn: warn2,
  warnText,
  initialSelectedItem,
  selectedItem: controlledSelectedItem,
  downshiftProps,
  readOnly,
  slug,
  ...other
}, ref) => {
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles");
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(
    enableFloatingStyles || autoAlign ? {
      placement: direction,
      // The floating element is positioned relative to its nearest
      // containing block (usually the viewport). It will in many cases also
      // “break” the floating element out of a clipping ancestor.
      // https://floating-ui.com/docs/misc#clipping
      strategy: "fixed",
      // Middleware order matters, arrow should be last
      middleware: [size3({
        apply({
          rects,
          elements
        }) {
          Object.assign(elements.floating.style, {
            width: `${rects.reference.width}px`
          });
        }
      }), autoAlign && flip3(), autoAlign && hide3()],
      whileElementsMounted: autoUpdate
    } : {}
    // When autoAlign is turned off & the `enable-v12-dynamic-floating-styles` feature flag is not
    // enabled, floating-ui will not be used
  );
  (0, import_react129.useEffect)(() => {
    var _a;
    if (enableFloatingStyles || autoAlign) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
    }
  }, [floatingStyles, autoAlign, refs.floating]);
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react129.useContext)(FormContext);
  const onSelectedItemChange = (0, import_react129.useCallback)(({
    selectedItem: selectedItem2
  }) => {
    if (onChange) {
      onChange({
        selectedItem: selectedItem2 ?? null
      });
    }
  }, [onChange]);
  const isItemDisabled2 = (0, import_react129.useCallback)((item, _index) => {
    const isObject = item !== null && typeof item === "object";
    return isObject && "disabled" in item && item.disabled === true;
  }, []);
  const onHighlightedIndexChange = (0, import_react129.useCallback)((changes) => {
    const {
      highlightedIndex: highlightedIndex2
    } = changes;
    if (highlightedIndex2 !== void 0 && highlightedIndex2 > -1 && typeof window !== void 0) {
      const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
      const highlightedItem = itemArray[highlightedIndex2];
      if (highlightedItem) {
        highlightedItem.scrollIntoView({
          behavior: "smooth",
          block: "nearest"
        });
      }
    }
  }, [prefix]);
  const items = (0, import_react129.useMemo)(() => itemsProp, [itemsProp]);
  const selectProps = (0, import_react129.useMemo)(() => ({
    items,
    itemToString: itemToString3,
    initialSelectedItem,
    onSelectedItemChange,
    stateReducer: stateReducer2,
    isItemDisabled: isItemDisabled2,
    onHighlightedIndexChange,
    ...downshiftProps
  }), [items, itemToString3, initialSelectedItem, onSelectedItemChange, stateReducer2, isItemDisabled2, onHighlightedIndexChange, downshiftProps]);
  const dropdownInstanceId = useId();
  if (controlledSelectedItem !== void 0) {
    selectProps.selectedItem = controlledSelectedItem;
  }
  const {
    isOpen,
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    selectedItem,
    highlightedIndex
  } = useSelect(selectProps);
  const inline4 = type === "inline";
  const showWarning = !invalid && warn2;
  const [isFocused, setIsFocused] = (0, import_react129.useState)(false);
  const className = (0, import_classnames79.default)(`${prefix}--dropdown`, {
    [`${prefix}--dropdown--invalid`]: invalid,
    [`${prefix}--dropdown--warning`]: showWarning,
    [`${prefix}--dropdown--open`]: isOpen,
    [`${prefix}--dropdown--focus`]: isFocused,
    [`${prefix}--dropdown--inline`]: inline4,
    [`${prefix}--dropdown--disabled`]: disabled,
    [`${prefix}--dropdown--light`]: light,
    [`${prefix}--dropdown--readonly`]: readOnly,
    [`${prefix}--dropdown--${size$1}`]: size$1,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--autoalign`]: autoAlign
  });
  const titleClasses = (0, import_classnames79.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const helperClasses = (0, import_classnames79.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const wrapperClasses = (0, import_classnames79.default)(`${prefix}--dropdown__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {
    [`${prefix}--dropdown__wrapper--inline`]: inline4,
    [`${prefix}--list-box__wrapper--inline`]: inline4,
    [`${prefix}--dropdown__wrapper--inline--invalid`]: inline4 && invalid,
    [`${prefix}--list-box__wrapper--inline--invalid`]: inline4 && invalid,
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator
  });
  const helperId = !helperText ? void 0 : `dropdown-helper-text-${dropdownInstanceId}`;
  const ItemToElement = itemToElement;
  const toggleButtonProps = getToggleButtonProps({
    "aria-label": ariaLabel || deprecatedAriaLabel
  });
  const helper = helperText && !isFluid ? import_react129.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText) : null;
  const handleFocus = (evt) => {
    setIsFocused(evt.type === "focus" && !selectedItem ? true : false);
  };
  const mergedRef = mergeRefs(toggleButtonProps.ref, ref);
  const [currTimer, setCurrTimer] = (0, import_react129.useState)();
  const [isTyping, setIsTyping] = (0, import_react129.useState)(false);
  const onKeyDownHandler = (0, import_react129.useCallback)((evt) => {
    if (evt.code !== "Space" || !["ArrowDown", "ArrowUp", " ", "Enter"].includes(evt.key)) {
      setIsTyping(true);
    }
    if (isTyping && evt.code === "Space" || !["ArrowDown", "ArrowUp", " ", "Enter"].includes(evt.key)) {
      if (currTimer) {
        clearTimeout(currTimer);
      }
      setCurrTimer(setTimeout(() => {
        setIsTyping(false);
      }, 3e3));
    }
    if (["ArrowDown"].includes(evt.key)) {
      setIsFocused(false);
    }
    if (["Enter"].includes(evt.key) && !selectedItem && !isOpen) {
      setIsFocused(true);
    }
    if (toggleButtonProps.onKeyDown && (evt.key !== "ArrowUp" || isOpen && evt.key === "ArrowUp")) {
      toggleButtonProps.onKeyDown(evt);
    }
  }, [isTyping, currTimer, toggleButtonProps]);
  const readOnlyEventHandlers = (0, import_react129.useMemo)(() => {
    if (readOnly) {
      return {
        onClick: (evt) => {
          var _a;
          evt.preventDefault();
          (_a = mergedRef == null ? void 0 : mergedRef.current) == null ? void 0 : _a.focus();
        },
        onKeyDown: (evt) => {
          const selectAccessKeys = ["ArrowDown", "ArrowUp", " ", "Enter"];
          if (selectAccessKeys.includes(evt.key)) {
            evt.preventDefault();
          }
        }
      };
    } else {
      return {
        onKeyDown: onKeyDownHandler
      };
    }
  }, [readOnly, onKeyDownHandler]);
  const menuProps = (0, import_react129.useMemo)(() => getMenuProps({
    ref: enableFloatingStyles || autoAlign ? refs.setFloating : null
  }), [autoAlign, getMenuProps, refs.setFloating, enableFloatingStyles]);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react129.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  const allLabelProps = getLabelProps();
  const labelProps = (0, import_react129.isValidElement)(titleText) ? {
    id: allLabelProps.id
  } : allLabelProps;
  return import_react129.default.createElement("div", _extends({
    className: wrapperClasses
  }, other), titleText && import_react129.default.createElement("label", _extends({
    className: titleClasses
  }, labelProps), titleText), import_react129.default.createElement(ListBox2, {
    onFocus: handleFocus,
    onBlur: handleFocus,
    size: size$1,
    className,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    light,
    isOpen,
    ref: enableFloatingStyles || autoAlign ? refs.setReference : null,
    id
  }, invalid && import_react129.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react129.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), import_react129.default.createElement("button", _extends({
    type: "button",
    className: `${prefix}--list-box__field`,
    disabled,
    "aria-disabled": readOnly ? true : void 0,
    "aria-describedby": !inline4 && !invalid && !warn2 && helper ? helperId : void 0,
    title: selectedItem && itemToString3 !== void 0 ? itemToString3(selectedItem) : defaultItemToString3(label)
  }, toggleButtonProps, readOnlyEventHandlers, {
    ref: mergedRef
  }), import_react129.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }, selectedItem ? renderSelectedItem ? renderSelectedItem(selectedItem) : itemToString3(selectedItem) : label), import_react129.default.createElement(ListBox2.MenuIcon, {
    isOpen,
    translateWithId: translateWithId8
  })), slug ? normalizedDecorator : decorator ? import_react129.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react129.default.createElement(ListBox2.Menu, menuProps, isOpen && items.map((item, index3) => {
    const isObject = item !== null && typeof item === "object";
    const itemProps = getItemProps({
      item,
      index: index3
    });
    const title = isObject && "text" in item && itemToElement ? item.text : itemToString3(item);
    return import_react129.default.createElement(ListBox2.MenuItem, _extends({
      key: itemProps.id,
      isActive: selectedItem === item,
      isHighlighted: highlightedIndex === index3,
      title,
      disabled: itemProps["aria-disabled"]
    }, itemProps), typeof item === "object" && ItemToElement !== void 0 && ItemToElement !== null ? import_react129.default.createElement(ItemToElement, _extends({
      key: itemProps.id
    }, item)) : itemToString3(item), selectedItem === item && import_react129.default.createElement(Checkmark, {
      className: `${prefix}--list-box__menu-item__selected-icon`
    }));
  }))), !inline4 && !invalid && !warn2 && helper);
});
Dropdown.displayName = "Dropdown";
Dropdown.propTypes = {
  /**
   * 'aria-label' of the ListBox component.
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types94.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types94.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * **Experimental**: Will attempt to automatically align the floating element
   * to avoid collisions with the viewport and being clipped by ancestor
   * elements. Requires React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types94.default.bool,
  /**
   * Provide a custom className to be applied on the cds--dropdown node
   */
  className: import_prop_types94.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `Dropdown` component
   */
  decorator: import_prop_types94.default.node,
  /**
   * Specify the direction of the dropdown. Can be either top or bottom.
   */
  direction: import_prop_types94.default.oneOf(["top", "bottom"]),
  /**
   * Disable the control
   */
  disabled: import_prop_types94.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types94.default.object,
  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: import_prop_types94.default.node,
  /**
   * Specify whether the title text should be hidden or not
   */
  hideLabel: import_prop_types94.default.bool,
  /**
   * Specify a custom `id`
   */
  id: import_prop_types94.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types94.default.oneOfType([import_prop_types94.default.object, import_prop_types94.default.string, import_prop_types94.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types94.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types94.default.node,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types94.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types94.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types94.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types94.default.node.isRequired,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types94.default.bool, "The `light` prop for `Dropdown` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types94.default.func,
  /**
   * Whether or not the Dropdown is readonly
   */
  readOnly: import_prop_types94.default.bool,
  /**
   * An optional callback to render the currently selected item as a react element instead of only
   * as a string.
   */
  renderSelectedItem: import_prop_types94.default.func,
  /**
   * In the case you want to control the dropdown selection entirely.
   */
  selectedItem: import_prop_types94.default.oneOfType([import_prop_types94.default.object, import_prop_types94.default.string, import_prop_types94.default.number]),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSizePropType,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `Dropdown` component
   */
  slug: deprecate(import_prop_types94.default.node, "The `slug` prop for `Dropdown` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types94.default.node.isRequired,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types94.default.func,
  /**
   * The dropdown type, `default` or `inline`
   */
  type: ListBoxTypePropType,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types94.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types94.default.node
};

// node_modules/@carbon/react/es/components/Dropdown/Dropdown.Skeleton.js
var import_prop_types95 = __toESM(require_prop_types());
var import_react131 = __toESM(require_react());
var import_classnames80 = __toESM(require_classnames());
var DropdownSkeleton = ({
  className,
  size: size4,
  hideLabel,
  ...rest
}) => {
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames80.default)(className, `${prefix}--skeleton`, `${prefix}--form-item`);
  return import_react131.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest), !hideLabel && import_react131.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react131.default.createElement("div", {
    className: (0, import_classnames80.default)(`${prefix}--skeleton ${prefix}--dropdown`, {
      [`${prefix}--list-box--${size4}`]: size4
    })
  }));
};
DropdownSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types95.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types95.default.bool,
  /**
   * Specify the size of the ListBox.
   */
  size: ListBoxSizePropType
};

// node_modules/@carbon/react/es/components/ErrorBoundary/ErrorBoundary.js
var import_react133 = __toESM(require_react());
var import_prop_types96 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/components/ErrorBoundary/ErrorBoundaryContext.js
var import_react132 = __toESM(require_react());
var ErrorBoundaryContext = (0, import_react132.createContext)({
  log(error2, info) {
    console.log(info.componentStack);
  }
});

// node_modules/@carbon/react/es/components/ErrorBoundary/ErrorBoundary.js
var ErrorBoundary = class extends import_react133.default.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "context", void 0);
    _defineProperty(this, "state", {
      hasError: false
    });
  }
  static getDerivedStateFromError() {
    return {
      hasError: true
    };
  }
  componentDidCatch(error2, info) {
    this.context.log(error2, info);
  }
  componentDidUpdate(prevProps) {
    if (prevProps.children !== this.props.children) {
      this.setState({
        hasError: false
      });
    }
  }
  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
};
_defineProperty(ErrorBoundary, "propTypes", {
  children: import_prop_types96.default.node,
  fallback: import_prop_types96.default.node
});
_defineProperty(ErrorBoundary, "contextType", ErrorBoundaryContext);

// node_modules/@carbon/react/es/components/ExpandableSearch/ExpandableSearch.js
var import_react134 = __toESM(require_react());
var import_classnames81 = __toESM(require_classnames());
var ExpandableSearch = import_react134.default.forwardRef(function ExpandableSearch2({
  onBlur,
  onChange,
  onExpand,
  onKeyDown,
  defaultValue,
  isExpanded,
  ...props
}, forwardedRef) {
  const [expanded, setExpanded] = (0, import_react134.useState)(isExpanded || false);
  const [hasContent, setHasContent] = (0, import_react134.useState)(defaultValue ? true : false);
  const searchRef = (0, import_react134.useRef)(null);
  const prefix = usePrefix();
  function handleBlur(evt) {
    const relatedTargetIsAllowed = evt.relatedTarget && evt.relatedTarget.classList.contains(`${prefix}--search-close`);
    if (expanded && !relatedTargetIsAllowed && !hasContent && !isExpanded) {
      setExpanded(false);
    }
  }
  (0, import_react134.useEffect)(() => {
    setExpanded(!!isExpanded);
  }, [isExpanded]);
  function handleChange(evt) {
    setHasContent(evt.target.value !== "");
  }
  function handleExpand() {
    var _a, _b;
    setExpanded(true);
    (_b = (_a = searchRef.current) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
  }
  function handleKeyDown(evt) {
    var _a;
    if (expanded && match(evt, Escape)) {
      evt.stopPropagation();
      if (!((_a = evt.target) == null ? void 0 : _a.value) && !isExpanded) {
        setExpanded(false);
      }
    }
  }
  const classes = (0, import_classnames81.default)(`${prefix}--search--expandable`, {
    [`${prefix}--search--expanded`]: expanded
  }, props.className);
  return import_react134.default.createElement(Search2, _extends({}, props, {
    defaultValue,
    isExpanded: expanded,
    ref: mergeRefs(searchRef, forwardedRef),
    className: classes,
    onBlur: composeEventHandlers([onBlur, handleBlur]),
    onChange: composeEventHandlers([onChange, handleChange]),
    onExpand: composeEventHandlers([onExpand, handleExpand]),
    onKeyDown: composeEventHandlers([onKeyDown, handleKeyDown])
  }));
});
ExpandableSearch.propTypes = Search2.propTypes;
ExpandableSearch.displayName = "ExpandableSearch";

// node_modules/@carbon/react/es/components/FileUploader/FileUploader.js
var import_classnames83 = __toESM(require_classnames());
var import_prop_types99 = __toESM(require_prop_types());
var import_react137 = __toESM(require_react());

// node_modules/@carbon/react/es/components/FileUploader/Filename.js
var import_prop_types97 = __toESM(require_prop_types());
var import_react135 = __toESM(require_react());
var _Close5;
function Filename({
  iconDescription = "Uploading file",
  status = "uploading",
  invalid,
  name,
  tabIndex = 0,
  ["aria-describedby"]: ariaDescribedBy,
  ...rest
}) {
  const prefix = usePrefix();
  switch (status) {
    case "uploading":
      return import_react135.default.createElement(Loading, {
        description: iconDescription,
        small: true,
        withOverlay: false,
        className: `${prefix}--file-loading`
      });
    case "edit":
      return import_react135.default.createElement(import_react135.default.Fragment, null, invalid && import_react135.default.createElement(WarningFilled, {
        className: `${prefix}--file-invalid`
      }), import_react135.default.createElement("button", _extends({
        "aria-label": `${iconDescription} - ${name}`,
        className: `${prefix}--file-close`,
        type: "button",
        tabIndex
      }, rest, {
        "aria-describedby": invalid ? ariaDescribedBy : void 0
      }), _Close5 || (_Close5 = import_react135.default.createElement(Close, null))));
    case "complete":
      return import_react135.default.createElement(CheckmarkFilled, _extends({
        "aria-label": iconDescription,
        className: `${prefix}--file-complete`
      }, rest, {
        tabIndex: -1
      }), iconDescription && import_react135.default.createElement("title", null, iconDescription));
    default:
      return null;
  }
}
Filename.propTypes = {
  /**
   * Specify an id that describes the error to be read by screen readers when the filename is invalid
   */
  ["aria-describedby"]: import_prop_types97.default.string,
  /**
   * Provide a description of the SVG icon to denote file upload status
   */
  iconDescription: import_prop_types97.default.string,
  /**
   * Specify if the file is invalid
   */
  invalid: import_prop_types97.default.bool,
  /**
   * Name of the uploaded file
   */
  name: import_prop_types97.default.string,
  /**
   * Status of the file upload
   */
  status: import_prop_types97.default.oneOf(["edit", "complete", "uploading"]),
  /**
   * Provide a custom tabIndex value for the `<Filename>`
   */
  tabIndex: import_prop_types97.default.number
};

// node_modules/@carbon/react/es/components/FileUploader/FileUploaderButton.js
var import_classnames82 = __toESM(require_classnames());
var import_prop_types98 = __toESM(require_prop_types());
var import_react136 = __toESM(require_react());
function FileUploaderButton({
  accept,
  buttonKind = "primary",
  className,
  disabled = false,
  disableLabelChanges = false,
  id,
  labelText: ownerLabelText = "Add file",
  multiple = false,
  onChange = noopFn,
  name,
  size: size4 = "md",
  // eslint-disable-next-line react/prop-types
  innerRef,
  ...other
}) {
  const prefix = usePrefix();
  const [labelText, setLabelText] = (0, import_react136.useState)(ownerLabelText);
  const [prevOwnerLabelText, setPrevOwnerLabelText] = (0, import_react136.useState)(ownerLabelText);
  const {
    current: inputId
  } = (0, import_react136.useRef)(id || useId());
  const inputNode = (0, import_react136.useRef)(null);
  const classes = (0, import_classnames82.default)(`${prefix}--btn`, className, {
    [`${prefix}--btn--${buttonKind}`]: buttonKind,
    [`${prefix}--btn--disabled`]: disabled,
    // V11: remove field, small
    [`${prefix}--btn--md`]: size4 === "field" || size4 === "md",
    [`${prefix}--btn--sm`]: size4 === "small" || size4 === "sm",
    [`${prefix}--layout--size-${size4}`]: size4
  });
  if (ownerLabelText !== prevOwnerLabelText) {
    setLabelText(ownerLabelText);
    setPrevOwnerLabelText(ownerLabelText);
  }
  function onClick(event) {
    event.target.value = null;
    if (inputNode.current) {
      inputNode.current.value = "";
      inputNode.current.click();
    }
  }
  function onKeyDown(event) {
    if (matches(event, [Enter, Space])) {
      event.preventDefault();
      if (inputNode.current) {
        inputNode.current.value = "";
        inputNode.current.click();
      }
    }
  }
  function handleOnChange(event) {
    var _a;
    const files = event.target.files;
    const length = ((_a = event.target.files) == null ? void 0 : _a.length) || 0;
    if (files && !disableLabelChanges) {
      if (length > 1) {
        setLabelText(`${length} files`);
      } else if (length === 1) {
        setLabelText(files[0].name);
      }
    }
    onChange(event);
  }
  return import_react136.default.createElement(import_react136.default.Fragment, null, import_react136.default.createElement("button", _extends({
    type: "button",
    disabled,
    className: classes,
    onClick,
    onKeyDown
  }, other, {
    tabIndex: other.tabIndex !== void 0 ? parseInt(other.tabIndex) : void 0
  }), labelText), import_react136.default.createElement("label", {
    className: `${prefix}--visually-hidden`,
    ref: innerRef,
    htmlFor: inputId
  }, import_react136.default.createElement("span", null, labelText)), import_react136.default.createElement("input", {
    className: `${prefix}--visually-hidden`,
    ref: inputNode,
    id: inputId,
    disabled,
    type: "file",
    tabIndex: -1,
    multiple,
    accept: accept == null ? void 0 : accept.toString(),
    name,
    onChange: handleOnChange
  }));
}
FileUploaderButton.propTypes = {
  /**
   * Specify the types of files that this input should be able to receive
   */
  accept: import_prop_types98.default.arrayOf(import_prop_types98.default.string),
  /**
   * Specify the type of underlying button
   */
  buttonKind: import_prop_types98.default.oneOf(ButtonKinds),
  /**
   * Provide a custom className to be applied to the container node
   */
  className: import_prop_types98.default.string,
  /**
   * Specify whether you want to disable any updates to the FileUploaderButton
   * label
   */
  disableLabelChanges: import_prop_types98.default.bool,
  /**
   * Specify whether file input is disabled
   */
  disabled: import_prop_types98.default.bool,
  /**
   * Provide a unique id for the underlying `<input>` node
   */
  id: import_prop_types98.default.string,
  /**
   * Provide the label text to be read by screen readers when interacting with
   * this control
   */
  labelText: import_prop_types98.default.node,
  /**
   * Specify if the component should accept multiple files to upload
   */
  multiple: import_prop_types98.default.bool,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types98.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the `<input>`
   * value changes
   */
  onChange: import_prop_types98.default.func,
  /**
   * Provide an optional `onClick` hook that is called each time the button is
   * clicked
   */
  onClick: import_prop_types98.default.func,
  /**
   * Provide an accessibility role for the `<FileUploaderButton>`
   */
  role: import_prop_types98.default.string,
  /**
   * Specify the size of the FileUploaderButton, from a list of available
   * sizes.
   */
  size: import_prop_types98.default.oneOf(["sm", "md", "lg"]),
  /**
   * Provide a custom tabIndex value for the `<FileUploaderButton>`
   */
  tabIndex: deprecate(import_prop_types98.default.number, "The `tabIndex` prop for `FileUploaderButton` has been deprecated since it now renders a button element by default.")
};

// node_modules/@carbon/react/es/components/FileUploader/FileUploader.js
var FileUploader = import_react137.default.forwardRef(({
  accept,
  buttonKind,
  buttonLabel,
  className,
  disabled,
  filenameStatus,
  iconDescription,
  labelDescription,
  labelTitle,
  multiple,
  name,
  onChange,
  onClick,
  onDelete,
  size: size4,
  ...other
}, ref) => {
  const fileUploaderInstanceId = useId("file-uploader");
  const prefix = usePrefix();
  const enhancedFileUploaderEnabled = useFeatureFlag("enable-enhanced-file-uploader");
  const [fileItems, setFileItems] = (0, import_react137.useState)([]);
  const [legacyFileNames, setLegacyFileNames] = (0, import_react137.useState)([]);
  const [fileObjects, setFileObjects] = (0, import_react137.useState)(/* @__PURE__ */ new Map());
  const nodes = [];
  const createFileItem = (file) => ({
    name: file.name,
    uuid: `${fileUploaderInstanceId}-${Date.now()}-${Array.from(crypto.getRandomValues(new Uint8Array(8))).map((b2) => b2.toString(36)).join("")}`,
    file
  });
  const handleChange = (0, import_react137.useCallback)((evt) => {
    evt.stopPropagation();
    const newFiles = Array.from(evt.target.files);
    if (enhancedFileUploaderEnabled) {
      const newFileItems = newFiles.map(createFileItem);
      let updatedFileItems;
      if (multiple) {
        const existingNames = new Set(fileItems.map((item) => item.name));
        const uniqueNewItems = newFileItems.filter((item) => !existingNames.has(item.name));
        updatedFileItems = [...fileItems, ...uniqueNewItems];
      } else {
        updatedFileItems = newFileItems;
      }
      setFileItems(updatedFileItems);
      if (onChange) {
        const allFiles = updatedFileItems.map((item) => item.file);
        const enhancedEvent = {
          ...evt,
          target: {
            ...evt.target,
            files: Object.assign(allFiles, {
              item: (index3) => allFiles[index3] || null
            }),
            addedFiles: newFileItems,
            currentFiles: updatedFileItems,
            action: "add"
          }
        };
        onChange(enhancedEvent);
      }
    } else {
      const filenames = newFiles.map((file) => file.name);
      const updatedFileNames = multiple ? [.../* @__PURE__ */ new Set([...legacyFileNames, ...filenames])] : filenames;
      setLegacyFileNames(updatedFileNames);
      setFileObjects((prevMap) => {
        const newMap = multiple ? new Map(prevMap) : /* @__PURE__ */ new Map();
        newFiles.forEach((file) => {
          newMap.set(file.name, file);
        });
        return newMap;
      });
      if (onChange) {
        onChange(evt);
      }
    }
  }, [enhancedFileUploaderEnabled, fileItems, legacyFileNames, multiple, onChange]);
  const handleClick2 = (0, import_react137.useCallback)((evt, {
    index: index3,
    filenameStatus: filenameStatus2
  }) => {
    var _a, _b;
    if (filenameStatus2 === "edit") {
      evt.stopPropagation();
      if (enhancedFileUploaderEnabled) {
        const deletedItem = fileItems[index3];
        if (!deletedItem) return;
        const remainingItems = fileItems.filter((_, i) => i !== index3);
        setFileItems(remainingItems);
        const remainingFiles = remainingItems.map((item) => item.file);
        const enhancedEvent = {
          ...evt,
          target: {
            ...evt.target,
            files: Object.assign(remainingFiles, {
              item: (index4) => remainingFiles[index4] || null
            }),
            deletedFile: deletedItem,
            deletedFileName: deletedItem.name,
            remainingFiles: remainingItems,
            currentFiles: remainingItems,
            action: "remove"
          }
        };
        if (onDelete) {
          onDelete(enhancedEvent);
        }
        if (onChange) {
          onChange(enhancedEvent);
        }
      } else {
        const deletedFileName = legacyFileNames[index3];
        const filteredArray = legacyFileNames.filter((filename) => filename !== deletedFileName);
        setLegacyFileNames(filteredArray);
        setFileObjects((prevMap) => {
          const newMap = new Map(prevMap);
          if (deletedFileName) {
            newMap.delete(deletedFileName);
          }
          return newMap;
        });
        if (onDelete) {
          onDelete(evt);
        }
      }
      if (onClick) {
        onClick(evt);
      }
      (_b = (_a = uploaderButton.current) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
    }
  }, [enhancedFileUploaderEnabled, fileItems, legacyFileNames, onDelete, onChange, onClick]);
  (0, import_react137.useImperativeHandle)(ref, () => ({
    clearFiles() {
      if (enhancedFileUploaderEnabled) {
        const previousItems = [...fileItems];
        setFileItems([]);
        if (onChange && previousItems.length > 0) {
          const enhancedEvent = {
            target: {
              files: Object.assign([], {
                item: () => null
              }),
              clearedFiles: previousItems,
              currentFiles: [],
              action: "clear"
            },
            preventDefault: () => {
            },
            stopPropagation: () => {
            }
          };
          onChange(enhancedEvent);
        }
      } else {
        setLegacyFileNames([]);
        setFileObjects(/* @__PURE__ */ new Map());
      }
    },
    ...enhancedFileUploaderEnabled && {
      getCurrentFiles() {
        return [...fileItems];
      }
    }
  }), [enhancedFileUploaderEnabled, fileItems, onChange]);
  const uploaderButton = import_react137.default.createRef();
  const classes = (0, import_classnames83.default)({
    [`${prefix}--form-item`]: true,
    [className]: className
  });
  const getHelperLabelClasses = (baseClass) => (0, import_classnames83.default)(baseClass, {
    [`${prefix}--label-description--disabled`]: disabled
  });
  const selectedFileClasses = (0, import_classnames83.default)(`${prefix}--file__selected-file`, {
    [`${prefix}--file__selected-file--md`]: size4 === "field" || size4 === "md",
    [`${prefix}--file__selected-file--sm`]: size4 === "small" || size4 === "sm"
  });
  const displayFiles = enhancedFileUploaderEnabled ? fileItems.map((item, index3) => ({
    name: item.name,
    key: item.uuid,
    index: index3
  })) : legacyFileNames.map((name2, index3) => ({
    name: name2,
    key: index3,
    index: index3
  }));
  return import_react137.default.createElement("div", _extends({
    className: classes
  }, other), !labelTitle ? null : import_react137.default.createElement(Text, {
    as: "h3",
    className: getHelperLabelClasses(`${prefix}--file--label`)
  }, labelTitle), import_react137.default.createElement(Text, {
    as: "p",
    className: getHelperLabelClasses(`${prefix}--label-description`),
    id: fileUploaderInstanceId
  }, labelDescription), import_react137.default.createElement(FileUploaderButton, {
    innerRef: uploaderButton,
    disabled,
    labelText: buttonLabel,
    multiple,
    buttonKind,
    onChange: handleChange,
    disableLabelChanges: true,
    accept,
    name,
    size: size4,
    "aria-describedby": fileUploaderInstanceId
  }), import_react137.default.createElement("div", {
    className: `${prefix}--file-container`
  }, displayFiles.length === 0 ? null : displayFiles.map((file) => {
    var _a;
    return import_react137.default.createElement("span", _extends({
      key: file.key,
      className: selectedFileClasses,
      ref: (node) => {
        nodes[file.index] = node;
      }
    }, other), import_react137.default.createElement(Text, {
      as: "p",
      className: `${prefix}--file-filename`,
      id: enhancedFileUploaderEnabled ? `${fileUploaderInstanceId}-file-${((_a = fileItems[file.index]) == null ? void 0 : _a.uuid) || file.index}` : `${fileUploaderInstanceId}-file-${file.index}`
    }, file.name), import_react137.default.createElement("span", {
      className: `${prefix}--file__state-container`
    }, import_react137.default.createElement(Filename, {
      name: file.name,
      iconDescription,
      status: filenameStatus,
      onKeyDown: (evt) => {
        if (matches(evt, [Enter, Space])) {
          handleClick2(evt, {
            index: file.index,
            filenameStatus
          });
        }
      },
      onClick: (evt) => handleClick2(evt, {
        index: file.index,
        filenameStatus
      })
    })));
  })));
});
FileUploader.propTypes = {
  /**
   * Specify the types of files that this input should be able to receive
   */
  accept: import_prop_types99.default.arrayOf(import_prop_types99.default.string),
  /**
   * Specify the type of the `<FileUploaderButton>`
   */
  buttonKind: import_prop_types99.default.oneOf(ButtonKinds),
  /**
   * Provide the label text to be read by screen readers when interacting with
   * the `<FileUploaderButton>`
   */
  buttonLabel: import_prop_types99.default.string,
  /**
   * Provide a custom className to be applied to the container node
   */
  className: import_prop_types99.default.string,
  /**
   * Specify whether file input is disabled
   */
  disabled: import_prop_types99.default.bool,
  /**
   * Specify the status of the File Upload
   */
  filenameStatus: import_prop_types99.default.oneOf(["edit", "complete", "uploading"]).isRequired,
  /**
   * Provide a description for the complete/close icon that can be read by screen readers
   */
  iconDescription: import_prop_types99.default.string,
  /**
   * Specify the description text of this `<FileUploader>`
   */
  labelDescription: import_prop_types99.default.string,
  /**
   * Specify the title text of this `<FileUploader>`
   */
  labelTitle: import_prop_types99.default.string,
  /**
   * Specify if the component should accept multiple files to upload
   */
  multiple: import_prop_types99.default.bool,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types99.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the input is
   * changed
   */
  onChange: import_prop_types99.default.func,
  /**
   * Provide an optional `onClick` hook that is called each time the
   * FileUploader is clicked
   */
  onClick: import_prop_types99.default.func,
  /**
   * Provide an optional `onDelete` hook that is called when an uploaded item
   * is removed
   */
  onDelete: import_prop_types99.default.func,
  /**
   * Specify the size of the FileUploaderButton, from a list of available
   * sizes.
   */
  size: import_prop_types99.default.oneOf(["sm", "small", "md", "field", "lg"])
};

// node_modules/@carbon/react/es/components/FileUploader/FileUploader.Skeleton.js
var import_prop_types100 = __toESM(require_prop_types());
var import_react138 = __toESM(require_react());
var import_classnames84 = __toESM(require_classnames());
var _SkeletonText4;
var _ButtonSkeleton;
function FileUploaderSkeleton({
  className,
  ...rest
}) {
  const prefix = usePrefix();
  return import_react138.default.createElement("div", _extends({
    className: (0, import_classnames84.default)(`${prefix}--form-item`, className)
  }, rest), _SkeletonText4 || (_SkeletonText4 = import_react138.default.createElement(SkeletonText, {
    heading: true,
    width: "100px"
  })), import_react138.default.createElement(SkeletonText, {
    width: "225px",
    className: `${prefix}--label-description`
  }), _ButtonSkeleton || (_ButtonSkeleton = import_react138.default.createElement(ButtonSkeleton, null)));
}
FileUploaderSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types100.default.string
};

// node_modules/@carbon/react/es/components/FileUploader/FileUploaderDropContainer.js
var import_react139 = __toESM(require_react());
var import_prop_types101 = __toESM(require_prop_types());
var import_classnames85 = __toESM(require_classnames());
function FileUploaderDropContainer({
  accept = [],
  className,
  id,
  disabled,
  labelText = "Add file",
  multiple = false,
  name,
  onAddFiles = noopFn,
  onClick,
  pattern = ".[0-9a-z]+$",
  // eslint-disable-next-line react/prop-types
  innerRef,
  ...rest
}) {
  const prefix = usePrefix();
  const inputRef = (0, import_react139.useRef)(null);
  const {
    current: uid
  } = (0, import_react139.useRef)(id || useId());
  const [isActive, setActive] = (0, import_react139.useState)(false);
  const dropareaClasses = (0, import_classnames85.default)(`${prefix}--file__drop-container`, `${prefix}--file-browse-btn`, {
    [`${prefix}--file__drop-container--drag-over`]: isActive,
    [`${prefix}--file-browse-btn--disabled`]: disabled
  }, className);
  function validateFiles(transferredFiles) {
    if (!accept.length) {
      return transferredFiles;
    }
    const acceptedTypes = new Set(accept);
    return transferredFiles.reduce((acc, curr) => {
      const {
        name: name2,
        type: mimeType = ""
      } = curr;
      const fileExtensionRegExp = new RegExp(pattern, "i");
      const [fileExtension] = name2.match(fileExtensionRegExp) ?? [];
      if (fileExtension === void 0) {
        return acc;
      }
      if (acceptedTypes.has(mimeType) || acceptedTypes.has(fileExtension.toLowerCase())) {
        return acc.concat([curr]);
      }
      curr.invalidFileType = true;
      return acc.concat([curr]);
    }, []);
  }
  function handleChange(event) {
    const files = [...event.target.files ?? []];
    const filesToValidate = multiple ? files : [files[0]];
    const addedFiles = validateFiles(filesToValidate);
    return onAddFiles(event, {
      addedFiles
    });
  }
  function handleDrop(event) {
    const files = [...event.dataTransfer.files];
    const filesToValidate = multiple ? files : [files[0]];
    const addedFiles = validateFiles(filesToValidate);
    return onAddFiles(event, {
      addedFiles
    });
  }
  const handleClick2 = () => {
    var _a;
    if (!disabled) {
      (_a = inputRef.current) == null ? void 0 : _a.click();
    }
  };
  return import_react139.default.createElement("div", {
    className: `${prefix}--file`,
    onDragOver: (evt) => {
      evt.stopPropagation();
      evt.preventDefault();
      if (disabled) {
        return;
      }
      setActive(true);
      evt.dataTransfer.dropEffect = "copy";
    },
    onDragLeave: (evt) => {
      evt.stopPropagation();
      evt.preventDefault();
      if (disabled) {
        return;
      }
      setActive(false);
      evt.dataTransfer.dropEffect = "move";
    },
    onDrop: (evt) => {
      evt.stopPropagation();
      evt.preventDefault();
      if (disabled) {
        return;
      }
      setActive(false);
      handleDrop(evt);
    }
  }, import_react139.default.createElement("button", _extends({
    type: "button",
    className: dropareaClasses,
    ref: innerRef,
    onKeyDown: (evt) => {
      var _a;
      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
        (_a = inputRef.current) == null ? void 0 : _a.click();
      }
    },
    onClick: composeEventHandlers([onClick, handleClick2])
  }, rest), labelText), import_react139.default.createElement("label", {
    htmlFor: uid,
    className: `${prefix}--visually-hidden`
  }, labelText), import_react139.default.createElement("input", {
    type: "file",
    id: uid,
    className: `${prefix}--file-input`,
    ref: inputRef,
    tabIndex: -1,
    disabled,
    accept: accept.join(","),
    name,
    multiple,
    onChange: handleChange,
    onClick: (evt) => {
      evt.target.value = "";
    }
  }));
}
FileUploaderDropContainer.propTypes = {
  /**
   * Specify the types of files that this input should be able to receive
   */
  accept: import_prop_types101.default.arrayOf(import_prop_types101.default.string),
  /**
   * Provide a custom className to be applied to the container node
   */
  className: import_prop_types101.default.string,
  /**
   * Specify whether file input is disabled
   */
  disabled: import_prop_types101.default.bool,
  /**
   * Provide a unique id for the underlying `<input>` node
   */
  id: import_prop_types101.default.string,
  /**
   * Provide the label text to be read by screen readers when interacting with
   * this control
   */
  labelText: import_prop_types101.default.string.isRequired,
  /**
   * Specify if the component should accept multiple files to upload
   */
  multiple: import_prop_types101.default.bool,
  /**
   * Provide a name for the underlying `<input>` node
   */
  name: import_prop_types101.default.string,
  /**
   * Event handler that is called after files are added to the uploader
   * The event handler signature looks like `onAddFiles(evt, { addedFiles })`
   */
  onAddFiles: import_prop_types101.default.func,
  /**
   * Provide an optional function to be called when the button element
   * is clicked
   */
  onClick: import_prop_types101.default.func,
  /**
   * Provide a custom regex pattern for the acceptedTypes
   */
  pattern: import_prop_types101.default.string,
  /**
   * Provide an accessibility role for the `<FileUploaderButton>`
   */
  role: deprecate(import_prop_types101.default.number, "The `role` prop for `FileUploaderButton` has been deprecated since it now renders a button element by default, and has an implicit role of button."),
  /**
   * Provide a custom tabIndex value for the `<FileUploaderButton>`
   */
  tabIndex: deprecate(import_prop_types101.default.number, "The `tabIndex` prop for `FileUploaderButton` has been deprecated since it now renders a button element by default.")
};

// node_modules/@carbon/react/es/components/FileUploader/FileUploaderItem.js
var import_classnames86 = __toESM(require_classnames());
var import_prop_types102 = __toESM(require_prop_types());
var import_react140 = __toESM(require_react());
function FileUploaderItem({
  uuid,
  name,
  status = "uploading",
  iconDescription,
  onDelete = noopFn,
  invalid,
  errorSubject,
  errorBody,
  size: size4,
  className,
  ...other
}) {
  const textRef = (0, import_react140.useRef)(null);
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react140.useState)(false);
  const prefix = usePrefix();
  const {
    current: id
  } = (0, import_react140.useRef)(uuid || useId());
  const classes = (0, import_classnames86.default)(`${prefix}--file__selected-file`, className, {
    [`${prefix}--file__selected-file--invalid`]: invalid,
    [`${prefix}--file__selected-file--md`]: size4 === "md",
    [`${prefix}--file__selected-file--sm`]: size4 === "sm"
  });
  const isInvalid = invalid ? `${prefix}--file-filename-container-wrap-invalid` : `${prefix}--file-filename-container-wrap`;
  const filterSpaceName = (name2) => {
    return name2 == null ? void 0 : name2.replace(/\s+/g, "");
  };
  const isEllipsisActive2 = (element) => {
    setIsEllipsisApplied(element.offsetWidth < element.scrollWidth);
    return element.offsetWidth < element.scrollWidth;
  };
  (0, import_react140.useLayoutEffect)(() => {
    isEllipsisActive2(textRef.current);
  }, [prefix, name]);
  return import_react140.default.createElement("span", _extends({
    className: classes
  }, other), isEllipsisApplied ? import_react140.default.createElement("div", {
    className: isInvalid
  }, import_react140.default.createElement(Tooltip, {
    label: name,
    align: "bottom",
    className: `${prefix}--file-filename-tooltip`
  }, import_react140.default.createElement("button", {
    className: `${prefix}--file-filename-button`,
    type: "button"
  }, import_react140.default.createElement(Text, {
    ref: textRef,
    as: "p",
    title: name,
    className: `${prefix}--file-filename-button`,
    id: filterSpaceName(name)
  }, name)))) : import_react140.default.createElement(Text, {
    ref: textRef,
    as: "p",
    title: name,
    className: `${prefix}--file-filename`,
    id: filterSpaceName(name)
  }, name), import_react140.default.createElement("div", {
    className: `${prefix}--file-container-item`
  }, import_react140.default.createElement("span", {
    className: `${prefix}--file__state-container`
  }, import_react140.default.createElement(Filename, {
    name,
    iconDescription,
    status,
    invalid,
    "aria-describedby": invalid && errorSubject ? `${filterSpaceName(name)}-id-error` : void 0,
    onKeyDown: (evt) => {
      if (matches(evt, [Enter, Space])) {
        if (status === "edit") {
          evt.preventDefault();
          onDelete(evt, {
            uuid: id
          });
        }
      }
    },
    onClick: (evt) => {
      if (status === "edit") {
        onDelete(evt, {
          uuid: id
        });
      }
    }
  }))), invalid && errorSubject && import_react140.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    role: "alert",
    id: `${filterSpaceName(name)}-id-error`
  }, import_react140.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement__title`
  }, errorSubject), errorBody && import_react140.default.createElement(Text, {
    as: "p",
    className: `${prefix}--form-requirement__supplement`
  }, errorBody)));
}
FileUploaderItem.propTypes = {
  /**
   * Error message body for an invalid file upload
   */
  errorBody: import_prop_types102.default.string,
  /**
   * Error message subject for an invalid file upload
   */
  errorSubject: import_prop_types102.default.string,
  /**
   * Description of status icon (displayed in native tooltip)
   */
  iconDescription: import_prop_types102.default.string,
  /**
   * Specify if the currently uploaded file is invalid
   */
  invalid: import_prop_types102.default.bool,
  /**
   * Name of the uploaded file
   */
  name: import_prop_types102.default.string,
  /**
   * Event handler that is called after removing a file from the file uploader
   * The event handler signature looks like `onDelete(evt, { uuid })`
   */
  onDelete: import_prop_types102.default.func,
  /**
   * Specify the size of the FileUploaderButton, from a list of available
   * sizes.
   */
  size: import_prop_types102.default.oneOf(["sm", "md", "lg"]),
  /**
   * Status of the file upload
   */
  status: import_prop_types102.default.oneOf(["uploading", "edit", "complete"]),
  /**
   * Unique identifier for the file object
   */
  uuid: import_prop_types102.default.string
};

// node_modules/@carbon/react/es/components/FormGroup/FormGroup.js
var import_prop_types103 = __toESM(require_prop_types());
var import_react141 = __toESM(require_react());
var import_classnames87 = __toESM(require_classnames());
var FormGroup = ({
  disabled = false,
  legendId,
  legendText,
  invalid = false,
  children,
  className,
  message = false,
  messageText = "",
  ...rest
}) => {
  const prefix = usePrefix();
  const classNamesFieldset = (0, import_classnames87.default)(`${prefix}--fieldset`, className);
  return import_react141.default.createElement("fieldset", _extends({
    disabled
  }, invalid && {
    "data-invalid": ""
  }, {
    className: classNamesFieldset
  }, rest, {
    "aria-labelledby": rest["aria-labelledby"] || legendId
  }), import_react141.default.createElement("legend", {
    className: `${prefix}--label`,
    id: legendId || rest["aria-labelledby"]
  }, legendText), children, message ? import_react141.default.createElement("div", {
    className: `${prefix}--form__requirements`
  }, messageText) : null);
};
FormGroup.propTypes = {
  /**
   * Provide the children form elements to be rendered inside of the <fieldset>
   */
  children: import_prop_types103.default.node,
  /**
   * Provide a custom className to be applied to the containing <fieldset> node
   */
  className: import_prop_types103.default.string,
  /**
   * Specify whether the FormGroup should be disabled
   */
  disabled: import_prop_types103.default.bool,
  /**
   * Specify whether the <FormGroup> is invalid
   */
  invalid: import_prop_types103.default.bool,
  /**
   * Provide id for the fieldset <legend> which corresponds to the fieldset
   * `aria-labelledby`
   */
  legendId: import_prop_types103.default.node,
  /**
   * Provide the text to be rendered inside of the fieldset <legend>
   */
  legendText: import_prop_types103.default.node.isRequired,
  /**
   * Specify whether the message should be displayed in the <FormGroup>
   */
  message: import_prop_types103.default.bool,
  /**
   * Provide the text for the message in the <FormGroup>
   */
  messageText: import_prop_types103.default.string
};

// node_modules/@carbon/react/es/components/FormItem/FormItem.js
var import_prop_types104 = __toESM(require_prop_types());
var import_react142 = __toESM(require_react());
var import_classnames88 = __toESM(require_classnames());
function FormItem({
  className,
  children,
  ...rest
}) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames88.default)(`${prefix}--form-item`, className);
  return import_react142.default.createElement("div", _extends({
    className: classNames
  }, rest), children);
}
FormItem.propTypes = {
  /**
   * Provide content to be rendered in the form item
   */
  children: import_prop_types104.default.node,
  /**
   * Provide a custom className to be applied to the containing node
   */
  className: import_prop_types104.default.string
};

// node_modules/@carbon/react/es/components/FormLabel/FormLabel.js
var import_prop_types105 = __toESM(require_prop_types());
var import_react143 = __toESM(require_react());
var import_classnames89 = __toESM(require_classnames());
function FormLabel({
  className: customClassName,
  children,
  id,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames89.default)(`${prefix}--label`, `${prefix}--label--no-margin`, customClassName);
  return import_react143.default.createElement(Text, _extends({
    as: "label",
    htmlFor: id,
    className
  }, rest), children);
}
FormLabel.propTypes = {
  /**
   * Specify the content of the form label
   */
  children: import_prop_types105.default.node,
  /**
   * Provide a custom className to be applied to the containing <label> node
   */
  className: import_prop_types105.default.string,
  /**
   * Provide a unique id for the given <FormLabel>
   */
  id: import_prop_types105.default.string
};

// node_modules/@carbon/react/es/components/Grid/FlexGrid.js
var import_classnames90 = __toESM(require_classnames());
var import_prop_types107 = __toESM(require_prop_types());
var import_react145 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Grid/GridContext.js
var import_prop_types106 = __toESM(require_prop_types());
var import_react144 = __toESM(require_react());
var GridSettingsContext = import_react144.default.createContext({
  mode: "flexbox",
  subgrid: false
});
var GridSettings = ({
  children,
  mode,
  subgrid = false
}) => {
  const value = import_react144.default.useMemo(() => {
    return {
      mode,
      subgrid
    };
  }, [mode, subgrid]);
  return import_react144.default.createElement(GridSettingsContext.Provider, {
    value
  }, children);
};
var gridModes = ["flexbox", "css-grid"];
GridSettings.propTypes = {
  /**
   * Pass in components which will be rendered within the `GridSettings`
   * component
   */
  children: import_prop_types106.default.node,
  /**
   * Specify the gutter mode for the GridContext
   */
  mode: import_prop_types106.default.oneOf(gridModes).isRequired,
  /**
   * Specify whether subgrid should be enabled
   */
  subgrid: import_prop_types106.default.bool
};
var useGridSettings = () => {
  return import_react144.default.useContext(GridSettingsContext);
};

// node_modules/@carbon/react/es/components/Grid/FlexGrid.js
var FlexGrid = import_react145.default.forwardRef(({
  as,
  condensed = false,
  narrow = false,
  fullWidth = false,
  className: containerClassName,
  children,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const className = (0, import_classnames90.default)(containerClassName, {
    [`${prefix}--grid`]: true,
    [`${prefix}--grid--condensed`]: condensed,
    [`${prefix}--grid--narrow`]: narrow,
    [`${prefix}--grid--full-width`]: fullWidth
  });
  const BaseComponent = as || "div";
  return import_react145.default.createElement(GridSettings, {
    mode: "flexbox",
    subgrid: false
  }, import_react145.default.createElement(BaseComponent, _extends({
    className,
    ref
  }, rest), children));
});
FlexGrid.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types107.default.oneOfType([import_prop_types107.default.string, import_prop_types107.default.elementType]),
  /**
   * Pass in content that will be rendered within the `FlexGrid`
   */
  children: import_prop_types107.default.node,
  /**
   * Specify a custom className to be applied to the `FlexGrid`
   */
  className: import_prop_types107.default.string,
  /**
   * Collapse the gutter to 1px. Useful for fluid layouts.
   * Rows have 1px of margin between them to match gutter.
   */
  condensed: import_prop_types107.default.bool,
  /**
   * Remove the default max width that the grid has set
   */
  fullWidth: import_prop_types107.default.bool,
  /**
   * Container hangs 16px into the gutter. Useful for
   * typographic alignment with and without containers.
   */
  narrow: import_prop_types107.default.bool
};
var FlexGridComponent = FlexGrid;

// node_modules/@carbon/react/es/components/Grid/Grid.js
var import_prop_types109 = __toESM(require_prop_types());
var import_react147 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Grid/CSSGrid.js
var import_classnames91 = __toESM(require_classnames());
var import_prop_types108 = __toESM(require_prop_types());
var import_react146 = __toESM(require_react());
var CSSGrid = import_react146.default.forwardRef(({
  align,
  as,
  children,
  className: customClassName,
  condensed = false,
  fullWidth = false,
  narrow = false,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const {
    subgrid
  } = useGridSettings();
  let mode = "wide";
  if (narrow) {
    mode = "narrow";
  } else if (condensed) {
    mode = "condensed";
  }
  if (subgrid) {
    return import_react146.default.createElement(GridSettings, {
      mode: "css-grid",
      subgrid: true
    }, import_react146.default.createElement(Subgrid, _extends({
      ref,
      as,
      className: customClassName,
      mode
    }, rest), children));
  }
  const className = (0, import_classnames91.default)(customClassName, {
    [`${prefix}--css-grid`]: true,
    [`${prefix}--css-grid--condensed`]: mode === "condensed",
    [`${prefix}--css-grid--narrow`]: mode === "narrow",
    [`${prefix}--css-grid--full-width`]: fullWidth,
    [`${prefix}--css-grid--start`]: align === "start",
    [`${prefix}--css-grid--end`]: align === "end"
  });
  const BaseComponent = as || "div";
  return import_react146.default.createElement(GridSettings, {
    mode: "css-grid",
    subgrid: true
  }, import_react146.default.createElement(BaseComponent, _extends({
    className,
    ref
  }, rest), children));
});
CSSGrid.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types108.default.oneOfType([import_prop_types108.default.string, import_prop_types108.default.elementType]),
  /**
   * Specify grid alignment. Default is center
   */
  align: import_prop_types108.default.oneOf(["start", "center", "end"]),
  /**
   * Pass in content that will be rendered within the `Grid`
   */
  children: import_prop_types108.default.node,
  /**
   * Specify a custom className to be applied to the `Grid`
   */
  className: import_prop_types108.default.string,
  /**
   * Collapse the gutter to 1px. Useful for fluid layouts.
   * Rows have 1px of margin between them to match gutter.
   */
  condensed: import_prop_types108.default.bool,
  /**
   * Remove the default max width that the grid has set
   */
  fullWidth: import_prop_types108.default.bool,
  /**
   * Container hangs 16px into the gutter. Useful for
   * typographic alignment with and without containers.
   */
  narrow: import_prop_types108.default.bool
};
var Subgrid = import_react146.default.forwardRef(({
  as,
  className: customClassName,
  children,
  mode,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const className = (0, import_classnames91.default)(customClassName, {
    [`${prefix}--subgrid`]: true,
    [`${prefix}--subgrid--condensed`]: mode === "condensed",
    [`${prefix}--subgrid--narrow`]: mode === "narrow",
    [`${prefix}--subgrid--wide`]: mode === "wide"
  });
  const BaseComponent = as || "div";
  return import_react146.default.createElement(BaseComponent, _extends({}, rest, {
    ref,
    className
  }), children);
});
Subgrid.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types108.default.oneOfType([import_prop_types108.default.string, import_prop_types108.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Subgrid`
   */
  children: import_prop_types108.default.node,
  /**
   * Specify a custom className to be applied to the `Subgrid`
   */
  className: import_prop_types108.default.string,
  /**
   * Specify the gutter mode for the subgrid
   */
  mode: import_prop_types108.default.oneOf(["wide", "narrow", "condensed"])
};
var CSSGridComponent = CSSGrid;

// node_modules/@carbon/react/es/components/Grid/Grid.js
function Grid(props) {
  const enableCSSGrid = useFeatureFlag("enable-css-grid");
  if (enableCSSGrid) {
    return import_react147.default.createElement(CSSGridComponent, props);
  }
  return import_react147.default.createElement(FlexGridComponent, props);
}
Grid.propTypes = {
  /**
   * Specify grid alignment. Default is center
   */
  align: import_prop_types109.default.oneOf(["start", "center", "end"]),
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types109.default.oneOfType([import_prop_types109.default.string, import_prop_types109.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Grid`
   */
  children: import_prop_types109.default.node,
  /**
   * Specify a custom className to be applied to the `Grid`
   */
  className: import_prop_types109.default.string,
  /**
   * Collapse the gutter to 1px. Useful for fluid layouts.
   * Rows have 1px of margin between them to match gutter.
   */
  condensed: import_prop_types109.default.bool,
  /**
   * Remove the default max width that the grid has set
   */
  fullWidth: import_prop_types109.default.bool,
  /**
   * Container hangs 16px into the gutter. Useful for
   * typographic alignment with and without containers.
   */
  narrow: import_prop_types109.default.bool
};
var GridAsGridComponent = Grid;

// node_modules/@carbon/react/es/components/Grid/Row.js
var import_classnames92 = __toESM(require_classnames());
var import_prop_types110 = __toESM(require_prop_types());
var import_react148 = __toESM(require_react());
function Row({
  as: BaseComponent = "div",
  condensed = false,
  narrow = false,
  className: containerClassName,
  children,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames92.default)(containerClassName, {
    [`${prefix}--row`]: true,
    [`${prefix}--row--condensed`]: condensed,
    [`${prefix}--row--narrow`]: narrow
  });
  const BaseComponentAsAny = BaseComponent;
  return import_react148.default.createElement(BaseComponentAsAny, _extends({
    className
  }, rest), children);
}
Row.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types110.default.oneOfType([import_prop_types110.default.string, import_prop_types110.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Row`
   */
  children: import_prop_types110.default.node,
  /**
   * Specify a custom className to be applied to the `Row`
   */
  className: import_prop_types110.default.string,
  /**
   * Specify a single row as condensed.Rows that are adjacent
   * and are condensed will have 2px of margin between them to match gutter.
   */
  condensed: import_prop_types110.default.bool,
  /**
   * Specify a single row as narrow. The container will hang
   * 16px into the gutter.
   */
  narrow: import_prop_types110.default.bool
};

// node_modules/@carbon/react/es/components/Grid/Column.js
var import_classnames93 = __toESM(require_classnames());
var import_prop_types111 = __toESM(require_prop_types());
var import_react149 = __toESM(require_react());
var Column = import_react149.default.forwardRef(({
  as,
  children,
  className: customClassName,
  sm,
  md,
  lg,
  xlg,
  max: max2,
  ...rest
}, ref) => {
  const {
    mode
  } = useGridSettings();
  const prefix = usePrefix();
  const BaseComponent = as || "div";
  if (mode === "css-grid") {
    return import_react149.default.createElement(CSSGridColumn, _extends({
      as: BaseComponent,
      className: customClassName,
      sm,
      md,
      ref,
      lg,
      xlg,
      max: max2
    }, rest), children);
  }
  const columnClassName = getClassNameForFlexGridBreakpoints([sm, md, lg, xlg, max2], prefix);
  const className = (0, import_classnames93.default)(customClassName, columnClassName, {
    [`${prefix}--col`]: columnClassName.length === 0
  });
  return import_react149.default.createElement(BaseComponent, _extends({
    className,
    ref
  }, rest), children);
});
var percentSpanType = import_prop_types111.default.oneOf(["25%", "50%", "75%", "100%"]);
var spanPropType = enabled("enable-css-grid") ? import_prop_types111.default.oneOfType([import_prop_types111.default.bool, import_prop_types111.default.number, import_prop_types111.default.shape({
  span: import_prop_types111.default.oneOfType([import_prop_types111.default.number, percentSpanType]),
  offset: import_prop_types111.default.number,
  start: import_prop_types111.default.number,
  end: import_prop_types111.default.number
}), percentSpanType]) : import_prop_types111.default.oneOfType([import_prop_types111.default.bool, import_prop_types111.default.number, import_prop_types111.default.shape({
  span: import_prop_types111.default.number,
  offset: import_prop_types111.default.number
})]);
Column.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types111.default.oneOfType([import_prop_types111.default.string, import_prop_types111.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Column`
   */
  children: import_prop_types111.default.node,
  /**
   * Specify a custom className to be applied to the `Column`
   */
  className: import_prop_types111.default.string,
  /**
   * Specify column span for the `lg` breakpoint (Default breakpoint up to 1312px)
   * This breakpoint supports 16 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  lg: spanPropType,
  /**
   * Specify column span for the `max` breakpoint. This breakpoint supports 16
   * columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  max: spanPropType,
  /**
   * Specify column span for the `md` breakpoint (Default breakpoint up to 1056px)
   * This breakpoint supports 8 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  md: spanPropType,
  /**
   * Specify column span for the `sm` breakpoint (Default breakpoint up to 672px)
   * This breakpoint supports 4 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  sm: spanPropType,
  /**
   * Specify constant column span, start, or end values that will not change
   * based on breakpoint
   */
  span: import_prop_types111.default.oneOfType([import_prop_types111.default.number, percentSpanType]),
  /**
   * Specify column span for the `xlg` breakpoint (Default breakpoint up to
   * 1584px) This breakpoint supports 16 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  xlg: spanPropType
};
var CSSGridColumn = import_react149.default.forwardRef(({
  as: BaseComponent = "div",
  children,
  className: containerClassName,
  sm,
  md,
  lg,
  xlg,
  max: max2,
  span,
  ...rest
}, ref) => {
  const prefix = usePrefix();
  const breakpointClassName = getClassNameForBreakpoints([sm, md, lg, xlg, max2], prefix);
  const spanClassName = getClassNameForSpan(span, prefix);
  const className = (0, import_classnames93.default)(containerClassName, breakpointClassName, spanClassName, {
    [`${prefix}--css-grid-column`]: true
  });
  return import_react149.default.createElement(BaseComponent, _extends({
    className,
    ref
  }, rest), children);
});
CSSGridColumn.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types111.default.oneOfType([import_prop_types111.default.string, import_prop_types111.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Column`
   */
  children: import_prop_types111.default.node,
  /**
   * Specify a custom className to be applied to the `Column`
   */
  className: import_prop_types111.default.string,
  /**
   * Specify column span for the `lg` breakpoint (Default breakpoint up to 1312px)
   * This breakpoint supports 16 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  lg: spanPropType,
  /**
   * Specify column span for the `max` breakpoint. This breakpoint supports 16
   * columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  max: spanPropType,
  /**
   * Specify column span for the `md` breakpoint (Default breakpoint up to 1056px)
   * This breakpoint supports 8 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  md: spanPropType,
  /**
   * Specify column span for the `sm` breakpoint (Default breakpoint up to 672px)
   * This breakpoint supports 4 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  sm: spanPropType,
  /**
   * Specify constant column span, start,  or end values that will not change
   * based on breakpoint
   */
  span: import_prop_types111.default.oneOfType([import_prop_types111.default.number, percentSpanType, import_prop_types111.default.shape({
    span: import_prop_types111.default.oneOfType([import_prop_types111.default.number, percentSpanType]),
    start: import_prop_types111.default.number,
    end: import_prop_types111.default.number
  })]),
  /**
   * Specify column span for the `xlg` breakpoint (Default breakpoint up to
   * 1584px) This breakpoint supports 16 columns by default.
   *
   * @see https://carbondesignsystem.com/elements/2x-grid/overview/#breakpoints
   */
  xlg: spanPropType
};
var breakpointNames = ["sm", "md", "lg", "xlg", "max"];
function getClassNameForBreakpoints(breakpoints2, prefix) {
  const classNames = [];
  for (let i = 0; i < breakpoints2.length; i++) {
    const breakpoint = breakpoints2[i];
    if (breakpoint === void 0 || breakpoint === null) {
      continue;
    }
    const name = breakpointNames[i];
    if (breakpoint === true) {
      classNames.push(`${prefix}--${name}:col-span-auto`);
      continue;
    }
    if (typeof breakpoint === "string") {
      classNames.push(`${prefix}--${name}:col-span-${breakpoint.replace("%", "")}`);
      continue;
    }
    if (typeof breakpoint === "number") {
      classNames.push(`${prefix}--${name}:col-span-${breakpoint}`);
      continue;
    }
    if (typeof breakpoint === "object") {
      const {
        span,
        offset: offset4,
        start,
        end
      } = breakpoint;
      if (typeof offset4 === "number") {
        classNames.push(`${prefix}--${name}:col-start-${offset4 > 0 ? offset4 + 1 : "auto"}`);
      }
      if (typeof start === "number") {
        classNames.push(`${prefix}--${name}:col-start-${start ? start : "auto"}`);
      }
      if (typeof end === "number") {
        classNames.push(`${prefix}--${name}:col-end-${end}`);
      }
      if (typeof span === "number") {
        classNames.push(`${prefix}--${name}:col-span-${span}`);
      } else if (typeof span === "string") {
        classNames.push(`${prefix}--${name}:col-span-${span.slice(0, -1)}`);
        continue;
      }
    }
  }
  return classNames.join(" ");
}
function getClassNameForFlexGridBreakpoints(breakpoints2, prefix) {
  const classNames = [];
  for (let i = 0; i < breakpoints2.length; i++) {
    const breakpoint = breakpoints2[i];
    if (breakpoint === void 0 || breakpoint === null) {
      continue;
    }
    const name = breakpointNames[i];
    if (breakpoint === true) {
      classNames.push(`${prefix}--col-${name}`);
      continue;
    }
    if (typeof breakpoint === "number") {
      classNames.push(`${prefix}--col-${name}-${breakpoint}`);
      continue;
    }
    if (typeof breakpoint === "object") {
      const {
        span,
        offset: offset4
      } = breakpoint;
      if (typeof span === "number") {
        classNames.push(`${prefix}--col-${name}-${span}`);
      }
      if (span === true) {
        classNames.push(`${prefix}--col-${name}`);
      }
      if (typeof offset4 === "number") {
        classNames.push(`${prefix}--offset-${name}-${offset4}`);
      }
    }
  }
  return classNames.join(" ");
}
function getClassNameForSpan(value, prefix) {
  const classNames = [];
  if (typeof value === "number") {
    classNames.push(`${prefix}--col-span-${value}`);
  } else if (typeof value === "string") {
    classNames.push(`${prefix}--col-span-${value.slice(0, -1)}`);
  } else if (typeof value === "object") {
    const {
      span,
      start,
      end
    } = value;
    if (span !== void 0 && span !== null) {
      classNames.push(`${prefix}--col-span-${span}`);
    }
    if (start !== void 0 && start !== null) {
      classNames.push(`${prefix}--col-start-${start}`);
    }
    if (end !== void 0 && end !== null) {
      classNames.push(`${prefix}--col-end-${end}`);
    }
  }
  return classNames.join("");
}

// node_modules/@carbon/react/es/components/Grid/ColumnHang.js
var import_classnames94 = __toESM(require_classnames());
var import_prop_types112 = __toESM(require_prop_types());
var import_react150 = __toESM(require_react());
function ColumnHang({
  as: BaseComponent = "div",
  className: customClassName,
  children,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames94.default)(customClassName, `${prefix}--grid-column-hang`);
  const BaseComponentAsAny = BaseComponent;
  return import_react150.default.createElement(BaseComponentAsAny, _extends({}, rest, {
    className
  }), children);
}
ColumnHang.propTypes = {
  /**
   * Provide a custom element to render instead of the default <div>
   */
  as: import_prop_types112.default.oneOfType([import_prop_types112.default.string, import_prop_types112.default.elementType]),
  /**
   * Pass in content that will be rendered within the `Grid`
   */
  children: import_prop_types112.default.node,
  /**
   * Specify a custom className to be applied to the `Grid`
   */
  className: import_prop_types112.default.string
};
var ColumnHangComponent = ColumnHang;

// node_modules/@carbon/react/es/components/Icon/Icon.Skeleton.js
var import_prop_types113 = __toESM(require_prop_types());
var import_react151 = __toESM(require_react());
var import_classnames95 = __toESM(require_classnames());
var IconSkeleton = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  return import_react151.default.createElement("div", _extends({
    className: (0, import_classnames95.default)(`${prefix}--icon--skeleton`, className)
  }, rest));
};
IconSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types113.default.string
};

// node_modules/@carbon/react/es/components/IdPrefix/index.js
var import_prop_types114 = __toESM(require_prop_types());
var import_react152 = __toESM(require_react());
function IdPrefix({
  children,
  prefix
}) {
  return import_react152.default.createElement(IdPrefixContext.Provider, {
    value: prefix
  }, children);
}
IdPrefix.propTypes = {
  children: import_prop_types114.default.node,
  /**
   * The value used to prefix the auto-generated id placed on some DOM elements
   */
  prefix: import_prop_types114.default.string
};

// node_modules/@carbon/react/es/components/ListItem/ListItem.js
var import_prop_types115 = __toESM(require_prop_types());
var import_react153 = __toESM(require_react());
var import_classnames96 = __toESM(require_classnames());
function ListItem({
  className,
  children,
  ...other
}) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames96.default)(`${prefix}--list__item`, className);
  return import_react153.default.createElement(Text, _extends({
    as: "li",
    className: classNames
  }, other), children);
}
ListItem.propTypes = {
  /**
   * Specify the content for the ListItem
   */
  children: import_prop_types115.default.node,
  /**
   * Specify an optional className to apply to the underlying `<li>` node
   */
  className: import_prop_types115.default.string
};

// node_modules/@carbon/react/es/components/MenuButton/index.js
var import_react154 = __toESM(require_react());
var import_prop_types116 = __toESM(require_prop_types());
var import_classnames97 = __toESM(require_classnames());
var validButtonKinds = ["primary", "tertiary", "ghost"];
var defaultButtonKind = "primary";
var MenuButton = (0, import_react154.forwardRef)(function MenuButton2({
  children,
  className,
  disabled,
  kind = defaultButtonKind,
  label,
  size: size$1 = "lg",
  menuAlignment = "bottom",
  tabIndex = 0,
  menuTarget,
  ...rest
}, forwardRef36) {
  const enableOnlyFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles");
  const id = useId("MenuButton");
  const prefix = usePrefix();
  const triggerRef = (0, import_react154.useRef)(null);
  let middlewares = [];
  if (!enableOnlyFloatingStyles) {
    middlewares = [flip3({
      crossAxis: false
    })];
  }
  if (menuAlignment === "bottom" || menuAlignment === "top") {
    middlewares.push(size3({
      apply({
        rects,
        elements
      }) {
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }));
  }
  const {
    refs,
    floatingStyles,
    placement,
    middlewareData
  } = useFloating2({
    placement: menuAlignment,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Submenus are using a fixed position to break out of the parent menu's
    // box avoiding clipping while allowing for vertical scroll. When an
    // element is using transform it establishes a new containing block
    // block for all of its descendants. Therefore, its padding box will be
    // used for fixed-positioned descendants. This would cause the submenu
    // to be clipped by its parent menu.
    // Reference: https://www.w3.org/TR/2019/CR-css-transforms-1-20190214/#current-transformation-matrix-computation
    // Reference: https://github.com/carbon-design-system/carbon/pull/18153#issuecomment-2498548835
    transform: false,
    // Middleware order matters, arrow should be last
    middleware: middlewares,
    whileElementsMounted: autoUpdate
  });
  const ref = mergeRefs(forwardRef36, triggerRef);
  const {
    open: open2,
    handleClick: hookOnClick,
    handleMousedown,
    handleClose
  } = useAttachedMenu(triggerRef);
  (0, import_react154.useLayoutEffect)(() => {
    Object.keys(floatingStyles).forEach((style) => {
      if (refs.floating.current) {
        let value = floatingStyles[style];
        if (["top", "right", "bottom", "left"].includes(style) && Number(value)) {
          value += "px";
        }
        refs.floating.current.style[style] = value;
      }
    });
  }, [floatingStyles, refs.floating, middlewareData, placement, open2]);
  function handleClick2() {
    if (triggerRef.current) {
      hookOnClick();
    }
  }
  const containerClasses = (0, import_classnames97.default)(`${prefix}--menu-button__container`, className);
  const triggerClasses = (0, import_classnames97.default)(`${prefix}--menu-button__trigger`, {
    [`${prefix}--menu-button__trigger--open`]: open2
  });
  const menuClasses = (0, import_classnames97.default)(`${prefix}--menu-button__${menuAlignment}`);
  return import_react154.default.createElement("div", _extends({}, rest, {
    ref,
    "aria-owns": open2 ? id : void 0,
    className: containerClasses
  }), import_react154.default.createElement(Button, {
    ref: refs.setReference,
    className: triggerClasses,
    size: size$1,
    tabIndex,
    kind,
    renderIcon: ChevronDown,
    disabled,
    "aria-haspopup": true,
    "aria-expanded": open2,
    onClick: handleClick2,
    onMouseDown: handleMousedown,
    "aria-controls": open2 ? id : void 0
  }, label), import_react154.default.createElement(Menu2, {
    containerRef: triggerRef,
    menuAlignment,
    className: menuClasses,
    ref: refs.setFloating,
    id,
    legacyAutoalign: false,
    label,
    size: size$1,
    open: open2,
    onClose: handleClose,
    target: menuTarget
  }, children));
});
MenuButton.propTypes = {
  /**
   * A collection of MenuItems to be rendered as actions for this MenuButton.
   */
  children: import_prop_types116.default.node.isRequired,
  /**
   * Additional CSS class names.
   */
  className: import_prop_types116.default.string,
  /**
   * Specify whether the MenuButton should be disabled, or not.
   */
  disabled: import_prop_types116.default.bool,
  /**
   * Specify the type of button to be used as the base for the trigger button.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  kind: import_prop_types116.default.oneOf(validButtonKinds),
  /**
   * Provide the label to be rendered on the trigger button.
   */
  label: import_prop_types116.default.string.isRequired,
  /**
   * Experimental property. Specify how the menu should align with the button element
   */
  menuAlignment: import_prop_types116.default.oneOf(["top", "top-start", "top-end", "bottom", "bottom-start", "bottom-end"]),
  /**
   * Specify the size of the button and menu.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  size: import_prop_types116.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the tabIndex of the button.
   */
  // @ts-ignore-next-line -- avoid spurious (?) TS2322 error
  tabIndex: import_prop_types116.default.number,
  /**
   * Specify a DOM node where the Menu should be rendered in. Defaults to document.body.
   */
  menuTarget: import_prop_types116.default.instanceOf(typeof Element !== "undefined" ? Element : Object)
};

// node_modules/@carbon/react/es/components/Modal/Modal.js
var import_prop_types117 = __toESM(require_prop_types());
var import_react157 = __toESM(require_react());
var import_classnames98 = __toESM(require_classnames());

// node_modules/@carbon/react/es/internal/usePreviousValue.js
var import_react156 = __toESM(require_react());
var usePreviousValue = (value) => {
  const ref = (0, import_react156.useRef)(void 0);
  (0, import_react156.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
};

// node_modules/@carbon/react/es/components/Modal/Modal.js
var ModalSizes = ["xs", "sm", "md", "lg"];
var invalidOutsideClickMessage = "`Modal`: `preventCloseOnClickOutside` should not be `false` when `passiveModal` is `false`. Non-passive `Modal`s should not be dismissible by clicking outside.";
var Modal = import_react157.default.forwardRef(function Modal2({
  "aria-label": ariaLabelProp,
  children,
  className,
  decorator,
  modalHeading = "",
  modalLabel = "",
  modalAriaLabel,
  passiveModal = false,
  secondaryButtonText,
  primaryButtonText,
  open: open2,
  onRequestClose = noopFn,
  onRequestSubmit = noopFn,
  onSecondarySubmit,
  primaryButtonDisabled = false,
  danger,
  alert,
  secondaryButtons,
  selectorPrimaryFocus = "[data-modal-primary-focus]",
  selectorsFloatingMenus,
  shouldSubmitOnEnter,
  size: size4,
  hasScrollingContent = false,
  closeButtonLabel = "Close",
  preventCloseOnClickOutside = !passiveModal,
  isFullWidth,
  launcherButtonRef,
  loadingStatus = "inactive",
  loadingDescription,
  loadingIconDescription,
  onLoadingSuccess = noopFn,
  slug,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const button = (0, import_react157.useRef)(null);
  const secondaryButton = (0, import_react157.useRef)(null);
  const contentRef = (0, import_react157.useRef)(null);
  const innerModal = (0, import_react157.useRef)(null);
  const startTrap = (0, import_react157.useRef)(null);
  const endTrap = (0, import_react157.useRef)(null);
  const wrapFocusTimeout = (0, import_react157.useRef)(null);
  const [isScrollable, setIsScrollable] = (0, import_react157.useState)(false);
  const prevOpen = usePreviousValue(open2);
  const modalInstanceId = `modal-${useId()}`;
  const modalLabelId = `${prefix}--modal-header__label--${modalInstanceId}`;
  const modalHeadingId = `${prefix}--modal-header__heading--${modalInstanceId}`;
  const modalBodyId = `${prefix}--modal-body--${modalInstanceId}`;
  const modalCloseButtonClass = `${prefix}--modal-close`;
  const primaryButtonClass = (0, import_classnames98.default)({
    [`${prefix}--btn--loading`]: loadingStatus !== "inactive"
  });
  const loadingActive = loadingStatus !== "inactive";
  const focusTrapWithoutSentinels = useFeatureFlag("enable-experimental-focus-wrap-without-sentinels");
  const enableDialogElement = useFeatureFlag("enable-dialog-element");
  true ? warning(!(focusTrapWithoutSentinels && enableDialogElement), "`<Modal>` detected both `focusTrapWithoutSentinels` and `enableDialogElement` feature flags are enabled. The native dialog element handles focus, so `enableDialogElement` must be off for `focusTrapWithoutSentinels` to have any effect.") : void 0;
  if (!passiveModal && preventCloseOnClickOutside === false) {
    console.error(invalidOutsideClickMessage);
  }
  function isCloseButton(element) {
    return !onSecondarySubmit && element === secondaryButton.current || element.classList.contains(modalCloseButtonClass);
  }
  function handleKeyDown(evt) {
    const {
      target
    } = evt;
    evt.stopPropagation();
    if (open2 && target instanceof HTMLElement) {
      if (match(evt, Enter) && shouldSubmitOnEnter && !isCloseButton(target) && document.activeElement !== button.current) {
        onRequestSubmit(evt);
      }
      if (focusTrapWithoutSentinels && !enableDialogElement && match(evt, Tab) && innerModal.current) {
        wrapFocusWithoutSentinels({
          containerNode: innerModal.current,
          currentActiveNode: target,
          event: evt
        });
      }
    }
  }
  function handleOnClick(evt) {
    const {
      target
    } = evt;
    evt.stopPropagation();
    if (!preventCloseOnClickOutside && target instanceof Node && !elementOrParentIsFloatingMenu(target, selectorsFloatingMenus) && innerModal.current && !innerModal.current.contains(target)) {
      onRequestClose(evt);
    }
  }
  function handleBlur({
    target: oldActiveNode,
    relatedTarget: currentActiveNode
  }) {
    if (!enableDialogElement && open2 && oldActiveNode instanceof HTMLElement && currentActiveNode instanceof HTMLElement) {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startTrapNode
      } = startTrap;
      const {
        current: endTrapNode
      } = endTrap;
      wrapFocusTimeout.current = setTimeout(() => {
        wrapFocus({
          bodyNode,
          startTrapNode,
          endTrapNode,
          currentActiveNode,
          oldActiveNode,
          selectorsFloatingMenus
        });
        if (wrapFocusTimeout.current) {
          clearTimeout(wrapFocusTimeout.current);
        }
      });
    }
    const modalContent = document.querySelector(`.${prefix}--modal-content`);
    if (!modalContent || !modalContent.classList.contains(`${prefix}--modal-scroll-content`) || !currentActiveNode || !modalContent.contains(currentActiveNode)) {
      return;
    }
    const lastContent = modalContent.children[modalContent.children.length - 1];
    const gradientSpacing = modalContent.scrollHeight - lastContent.offsetTop - lastContent.clientHeight;
    for (let elem of modalContent.children) {
      if (elem.contains(currentActiveNode)) {
        const spaceBelow = modalContent.clientHeight - elem.offsetTop + modalContent.scrollTop - elem.clientHeight;
        if (spaceBelow < gradientSpacing) {
          modalContent.scrollTop = modalContent.scrollTop + (gradientSpacing - spaceBelow);
        }
        break;
      }
    }
  }
  const onSecondaryButtonClick = onSecondarySubmit ? onSecondarySubmit : onRequestClose;
  const modalClasses = (0, import_classnames98.default)(`${prefix}--modal`, {
    [`${prefix}--modal-tall`]: !passiveModal,
    "is-visible": open2,
    [`${prefix}--modal--danger`]: danger,
    [`${prefix}--modal--slug`]: slug,
    [`${prefix}--modal--decorator`]: decorator
  }, className);
  const containerClasses = (0, import_classnames98.default)(`${prefix}--modal-container`, {
    [`${prefix}--modal-container--${size4}`]: size4,
    [`${prefix}--modal-container--full-width`]: isFullWidth
  });
  const contentClasses = (0, import_classnames98.default)(`${prefix}--modal-content`, {
    [`${prefix}--modal-scroll-content`]: hasScrollingContent || isScrollable
  });
  const footerClasses = (0, import_classnames98.default)(`${prefix}--modal-footer`, {
    [`${prefix}--modal-footer--three-button`]: Array.isArray(secondaryButtons) && secondaryButtons.length === 2
  });
  const asStringOrUndefined = (node) => {
    return typeof node === "string" ? node : void 0;
  };
  const modalLabelStr = asStringOrUndefined(modalLabel);
  const modalHeadingStr = asStringOrUndefined(modalHeading);
  const ariaLabel = modalLabelStr || ariaLabelProp || modalAriaLabel || modalHeadingStr;
  const getAriaLabelledBy = modalLabel ? modalLabelId : modalHeadingId;
  const hasScrollingContentProps = hasScrollingContent || isScrollable ? {
    tabIndex: 0,
    role: "region",
    "aria-label": ariaLabel,
    "aria-labelledby": getAriaLabelledBy
  } : {};
  const alertDialogProps = {};
  if (alert && passiveModal) {
    alertDialogProps.role = "alert";
  }
  if (alert && !passiveModal) {
    alertDialogProps.role = "alertdialog";
    alertDialogProps["aria-describedby"] = modalBodyId;
  }
  (0, import_react157.useEffect)(() => {
    if (!open2) return;
    const handleEscapeKey = (event) => {
      if (match(event, Escape)) {
        event.preventDefault();
        event.stopPropagation();
        onRequestClose(event);
      }
    };
    document.addEventListener("keydown", handleEscapeKey, true);
    return () => {
      document.removeEventListener("keydown", handleEscapeKey, true);
    };
  }, [open2]);
  (0, import_react157.useEffect)(() => {
    return () => {
      if (!enableDialogElement) {
        toggleClass(document.body, `${prefix}--body--with-modal-open`, false);
      }
    };
  }, [prefix, enableDialogElement]);
  (0, import_react157.useEffect)(() => {
    if (!enableDialogElement) {
      toggleClass(document.body, `${prefix}--body--with-modal-open`, open2 ?? false);
    }
  }, [open2, prefix, enableDialogElement]);
  (0, import_react157.useEffect)(() => {
    if (!enableDialogElement && prevOpen && !open2 && launcherButtonRef) {
      setTimeout(() => {
        var _a;
        if ("current" in launcherButtonRef) {
          (_a = launcherButtonRef.current) == null ? void 0 : _a.focus();
        }
      });
    }
  }, [open2, prevOpen, launcherButtonRef, enableDialogElement]);
  (0, import_react157.useEffect)(() => {
    if (!enableDialogElement) {
      const initialFocus = (focusContainerElement) => {
        const containerElement = focusContainerElement || innerModal.current;
        const primaryFocusElement = containerElement && (containerElement.querySelector(selectorPrimaryFocus) || danger && containerElement.querySelector(`.${prefix}--btn--secondary`));
        if (primaryFocusElement) {
          return primaryFocusElement;
        }
        return button && button.current;
      };
      const focusButton = (focusContainerElement) => {
        const target = initialFocus(focusContainerElement);
        if (target !== null) {
          target.focus();
        }
      };
      if (open2) {
        focusButton(innerModal.current);
      }
    }
  }, [open2, selectorPrimaryFocus, danger, prefix, enableDialogElement]);
  useIsomorphicEffect(() => {
    if (contentRef.current) {
      setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
    }
    function handler() {
      if (contentRef.current) {
        setIsScrollable(contentRef.current.scrollHeight > contentRef.current.clientHeight);
      }
    }
    const debouncedHandler = debounce2(handler, 200);
    window.addEventListener("resize", debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener("resize", debouncedHandler);
    };
  }, []);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react157.cloneElement)(candidate, {
    size: "sm"
  }) : null;
  const modalButton = import_react157.default.createElement("div", {
    className: `${prefix}--modal-close-button`
  }, import_react157.default.createElement(IconButton, {
    className: modalCloseButtonClass,
    label: closeButtonLabel,
    onClick: onRequestClose,
    "aria-label": closeButtonLabel,
    align: "left",
    ref: button
  }, import_react157.default.createElement(Close, {
    size: 20,
    "aria-hidden": "true",
    tabIndex: "-1",
    className: `${modalCloseButtonClass}__icon`
  })));
  const isAlertDialog = alert && !passiveModal;
  const modalBody = enableDialogElement ? import_react157.default.createElement(Dialog, {
    open: open2,
    focusAfterCloseRef: launcherButtonRef,
    modal: true,
    ref: innerModal,
    role: isAlertDialog ? "alertdialog" : "",
    "aria-describedby": isAlertDialog ? modalBodyId : "",
    className: containerClasses,
    "aria-label": ariaLabel
  }, import_react157.default.createElement("div", {
    className: `${prefix}--modal-header`
  }, modalLabel && import_react157.default.createElement(Text, {
    as: "h2",
    id: modalLabelId,
    className: `${prefix}--modal-header__label`
  }, modalLabel), import_react157.default.createElement(Text, {
    as: "h2",
    id: modalHeadingId,
    className: `${prefix}--modal-header__heading`
  }, modalHeading), decorator ? import_react157.default.createElement("div", {
    className: `${prefix}--modal--inner__decorator`
  }, normalizedDecorator) : "", import_react157.default.createElement("div", {
    className: `${prefix}--modal-close-button`
  }, import_react157.default.createElement(IconButton, {
    className: modalCloseButtonClass,
    label: closeButtonLabel,
    onClick: onRequestClose,
    "aria-label": closeButtonLabel,
    align: "left",
    ref: button
  }, import_react157.default.createElement(Close, {
    size: 20,
    "aria-hidden": "true",
    tabIndex: "-1",
    className: `${modalCloseButtonClass}__icon`
  })))), import_react157.default.createElement(Layer, _extends({
    ref: contentRef,
    id: modalBodyId,
    className: contentClasses
  }, hasScrollingContentProps), children), !passiveModal && import_react157.default.createElement(ButtonSet, {
    className: footerClasses,
    "aria-busy": loadingActive
  }, Array.isArray(secondaryButtons) && secondaryButtons.length <= 2 ? secondaryButtons.map(({
    buttonText,
    onClick: onButtonClick
  }, i) => import_react157.default.createElement(Button, {
    key: `${buttonText}-${i}`,
    kind: "secondary",
    onClick: onButtonClick
  }, buttonText)) : secondaryButtonText && import_react157.default.createElement(Button, {
    disabled: loadingActive,
    kind: "secondary",
    onClick: onSecondaryButtonClick,
    ref: secondaryButton
  }, secondaryButtonText), import_react157.default.createElement(Button, {
    className: primaryButtonClass,
    kind: danger ? "danger" : "primary",
    disabled: loadingActive || primaryButtonDisabled,
    onClick: onRequestSubmit,
    ref: button
  }, loadingStatus === "inactive" ? primaryButtonText : import_react157.default.createElement(InlineLoading, {
    status: loadingStatus,
    description: loadingDescription,
    iconDescription: loadingIconDescription,
    className: `${prefix}--inline-loading--btn`,
    onSuccess: onLoadingSuccess
  })))) : import_react157.default.createElement(import_react157.default.Fragment, null, !enableDialogElement && !focusTrapWithoutSentinels && import_react157.default.createElement("span", {
    ref: startTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), import_react157.default.createElement("div", _extends({
    ref: innerModal,
    role: "dialog"
  }, alertDialogProps, {
    className: containerClasses,
    "aria-label": ariaLabel,
    "aria-modal": "true",
    tabIndex: -1
  }), import_react157.default.createElement("div", {
    className: `${prefix}--modal-header`
  }, passiveModal && modalButton, modalLabel && import_react157.default.createElement(Text, {
    as: "h2",
    id: modalLabelId,
    className: `${prefix}--modal-header__label`
  }, modalLabel), import_react157.default.createElement(Text, {
    as: "h2",
    id: modalHeadingId,
    className: `${prefix}--modal-header__heading`
  }, modalHeading), slug ? normalizedDecorator : decorator ? import_react157.default.createElement("div", {
    className: `${prefix}--modal--inner__decorator`
  }, normalizedDecorator) : "", !passiveModal && modalButton), import_react157.default.createElement(Layer, _extends({
    ref: contentRef,
    id: modalBodyId,
    className: contentClasses
  }, hasScrollingContentProps), children), !passiveModal && import_react157.default.createElement(ButtonSet, {
    className: footerClasses,
    "aria-busy": loadingActive
  }, Array.isArray(secondaryButtons) && secondaryButtons.length <= 2 ? secondaryButtons.map(({
    buttonText,
    onClick: onButtonClick
  }, i) => import_react157.default.createElement(Button, {
    key: `${buttonText}-${i}`,
    kind: "secondary",
    onClick: onButtonClick
  }, buttonText)) : secondaryButtonText && import_react157.default.createElement(Button, {
    disabled: loadingActive,
    kind: "secondary",
    onClick: onSecondaryButtonClick,
    ref: secondaryButton
  }, secondaryButtonText), import_react157.default.createElement(Button, {
    className: primaryButtonClass,
    kind: danger ? "danger" : "primary",
    disabled: loadingActive || primaryButtonDisabled,
    onClick: onRequestSubmit,
    ref: button
  }, loadingStatus === "inactive" ? primaryButtonText : import_react157.default.createElement(InlineLoading, {
    status: loadingStatus,
    description: loadingDescription,
    iconDescription: loadingIconDescription,
    className: `${prefix}--inline-loading--btn`,
    onSuccess: onLoadingSuccess
  })))), !enableDialogElement && !focusTrapWithoutSentinels && import_react157.default.createElement("span", {
    ref: endTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"));
  return import_react157.default.createElement(Layer, _extends({}, rest, {
    level: 0,
    onKeyDown: handleKeyDown,
    onClick: composeEventHandlers([rest == null ? void 0 : rest.onClick, handleOnClick]),
    onBlur: handleBlur,
    className: modalClasses,
    role: "presentation",
    ref
  }), modalBody);
});
Modal.propTypes = {
  /**
   * Specify whether the Modal is displaying an alert, error or warning
   * Should go hand in hand with the danger prop.
   */
  alert: import_prop_types117.default.bool,
  /**
   * Required props for the accessibility label of the header
   */
  ["aria-label"]: requiredIfGivenPropIsTruthy("hasScrollingContent", import_prop_types117.default.string),
  /**
   * Provide the contents of your Modal
   */
  children: import_prop_types117.default.node,
  /**
   * Specify an optional className to be applied to the modal root node
   */
  className: import_prop_types117.default.string,
  /**
   * Specify label for the close button of the modal; defaults to close
   */
  closeButtonLabel: import_prop_types117.default.string,
  /**
   * Specify whether the Modal is for dangerous actions
   */
  danger: import_prop_types117.default.bool,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `Modal` component
   */
  decorator: import_prop_types117.default.node,
  /**
   * Specify whether the modal contains scrolling content
   */
  hasScrollingContent: import_prop_types117.default.bool,
  /**
   * Specify the DOM element ID of the top-level node.
   */
  id: import_prop_types117.default.string,
  /**
   * Specify whether or not the Modal content should have any inner padding.
   */
  isFullWidth: import_prop_types117.default.bool,
  /**
   * Provide a ref to return focus to once the modal is closed.
   */
  launcherButtonRef: import_prop_types117.default.oneOfType([import_prop_types117.default.func, import_prop_types117.default.shape({
    current: import_prop_types117.default.oneOfType([
      // `PropTypes.instanceOf(HTMLButtonElement)` alone won't work because
      // `HTMLButtonElement` is not defined in the test environment even
      // though `testEnvironment` is set to `jsdom`.
      typeof HTMLButtonElement !== "undefined" ? import_prop_types117.default.instanceOf(HTMLButtonElement) : import_prop_types117.default.any,
      import_prop_types117.default.oneOf([null])
    ]).isRequired
  })]),
  /**
   * Specify the description for the loading text
   */
  loadingDescription: import_prop_types117.default.string,
  /**
   * Specify the description for the loading text
   */
  loadingIconDescription: import_prop_types117.default.string,
  /**
   * loading status
   */
  loadingStatus: import_prop_types117.default.oneOf(["inactive", "active", "finished", "error"]),
  /**
   * Specify a label to be read by screen readers on the modal root node
   */
  modalAriaLabel: import_prop_types117.default.string,
  /**
   * Specify the content of the modal header title.
   */
  modalHeading: import_prop_types117.default.node,
  /**
   * Specify the content of the modal header label.
   */
  modalLabel: import_prop_types117.default.node,
  /**
   * Specify a handler for keypresses.
   */
  onKeyDown: import_prop_types117.default.func,
  /**
   * Provide an optional handler to be invoked when loading is
   * successful
   */
  onLoadingSuccess: import_prop_types117.default.func,
  /**
   * Specify a handler for closing modal.
   * The handler should care of closing modal, e.g. changing `open` prop.
   */
  onRequestClose: import_prop_types117.default.func,
  /**
   * Specify a handler for "submitting" modal.
   * The handler should care of closing modal, e.g. changing `open` prop, if necessary.
   */
  onRequestSubmit: import_prop_types117.default.func,
  /**
   * Specify a handler for the secondary button.
   * Useful if separate handler from `onRequestClose` is desirable
   */
  onSecondarySubmit: import_prop_types117.default.func,
  /**
   * Specify whether the Modal is currently open
   */
  open: import_prop_types117.default.bool,
  /**
   * Specify whether the modal should be button-less
   */
  passiveModal: import_prop_types117.default.bool,
  /**
   * Prevent closing on click outside of modal
   */
  preventCloseOnClickOutside: (props, propName) => {
    if (!props.passiveModal && props[propName] === false) {
      return new Error(invalidOutsideClickMessage);
    }
    return null;
  },
  /**
   * Specify whether the Button should be disabled, or not
   */
  primaryButtonDisabled: import_prop_types117.default.bool,
  /**
   * Specify the text for the primary button
   */
  primaryButtonText: import_prop_types117.default.node,
  /**
   * Specify the text for the secondary button
   */
  secondaryButtonText: import_prop_types117.default.node,
  /**
   * Specify an array of config objects for secondary buttons
   * (`Array<{
   *   buttonText: string,
   *   onClick: function,
   * }>`).
   */
  secondaryButtons: (props, propName, componentName) => {
    if (props.secondaryButtons) {
      if (!Array.isArray(props.secondaryButtons) || props.secondaryButtons.length !== 2) {
        return new Error(`${propName} needs to be an array of two button config objects`);
      }
      const shape = {
        buttonText: import_prop_types117.default.node,
        onClick: import_prop_types117.default.func
      };
      props[propName].forEach((secondaryButton) => {
        import_prop_types117.default.checkPropTypes(shape, secondaryButton, propName, componentName);
      });
    }
    return null;
  },
  /**
   * Specify a CSS selector that matches the DOM element that should
   * be focused when the Modal opens
   */
  selectorPrimaryFocus: import_prop_types117.default.string,
  /**
   * Specify CSS selectors that match DOM elements working as floating menus.
   * Focusing on those elements won't trigger "focus-wrap" behavior
   */
  selectorsFloatingMenus: import_prop_types117.default.arrayOf(import_prop_types117.default.string.isRequired),
  /**
   * Specify if Enter key should be used as "submit" action
   */
  shouldSubmitOnEnter: import_prop_types117.default.bool,
  /**
   * Specify the size variant.
   */
  size: import_prop_types117.default.oneOf(ModalSizes),
  slug: deprecate(import_prop_types117.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead.")
};

// node_modules/@carbon/react/es/components/ModalWrapper/ModalWrapper.js
var import_prop_types118 = __toESM(require_prop_types());
var import_react158 = __toESM(require_react());
var didWarnAboutDeprecation3 = false;
var ModalWrapper = class extends import_react158.default.Component {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "triggerButton", import_react158.default.createRef());
    _defineProperty(this, "modal", import_react158.default.createRef());
    _defineProperty(this, "state", {
      isOpen: false
    });
    _defineProperty(this, "handleOpen", () => {
      this.setState({
        isOpen: true
      });
    });
    _defineProperty(this, "handleClose", (evt) => {
      var _a;
      const innerModal = (_a = this.modal.current) == null ? void 0 : _a.querySelector("div");
      if (this.modal.current && evt && !(innerModal == null ? void 0 : innerModal.contains(evt.target)) && this.props.preventCloseOnClickOutside) {
        return;
      } else {
        this.setState({
          isOpen: false
        }, () => {
          var _a2;
          return (_a2 = this.triggerButton.current) == null ? void 0 : _a2.focus();
        });
      }
    });
    _defineProperty(this, "handleOnRequestSubmit", (evt) => {
      const {
        handleSubmit,
        shouldCloseAfterSubmit
      } = this.props;
      if (handleSubmit && shouldCloseAfterSubmit) {
        handleSubmit(evt);
        this.handleClose(evt);
      }
      handleSubmit == null ? void 0 : handleSubmit(evt);
    });
  }
  if(isDev) {
    true ? warning(didWarnAboutDeprecation3, "`<ModalWrapper>` has been deprecated in favor of `<ComposedModal/>` and will be removed in the next major version, `@carbon/react@v2.x`") : void 0;
    didWarnAboutDeprecation3 = true;
  }
  render() {
    const {
      children,
      onKeyDown = noopFn,
      buttonTriggerText,
      buttonTriggerClassName,
      renderTriggerButtonIcon,
      primaryButtonText = "Save",
      secondaryButtonText = "Cancel",
      triggerButtonIconDescription = "Provide icon description if icon is used",
      triggerButtonKind = "primary",
      disabled = false,
      handleSubmit,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      shouldCloseAfterSubmit = true,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      selectorPrimaryFocus = "[data-modal-primary-focus]",
      preventCloseOnClickOutside = false,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      ...other
    } = this.props;
    const props = {
      ...other,
      selectorPrimaryFocus,
      open: this.state.isOpen,
      onRequestClose: this.handleClose,
      onRequestSubmit: this.handleOnRequestSubmit
    };
    return import_react158.default.createElement("div", {
      role: "presentation",
      onKeyDown: (evt) => {
        if (match(evt, Escape)) {
          this.handleClose(evt);
          onKeyDown(evt);
        }
      }
    }, import_react158.default.createElement(Button, {
      className: buttonTriggerClassName,
      disabled,
      kind: triggerButtonKind,
      renderIcon: renderTriggerButtonIcon,
      iconDescription: triggerButtonIconDescription,
      onClick: this.handleOpen,
      ref: this.triggerButton
    }, buttonTriggerText), import_react158.default.createElement(Modal, _extends({
      ref: this.modal,
      primaryButtonText,
      secondaryButtonText
    }, props), children));
  }
};
_defineProperty(ModalWrapper, "propTypes", {
  buttonTriggerClassName: import_prop_types118.default.string,
  buttonTriggerText: import_prop_types118.default.node,
  children: import_prop_types118.default.node,
  disabled: import_prop_types118.default.bool,
  handleOpen: import_prop_types118.default.func,
  handleSubmit: import_prop_types118.default.func,
  id: import_prop_types118.default.string,
  modalBeforeContent: import_prop_types118.default.bool,
  modalHeading: import_prop_types118.default.string,
  modalLabel: import_prop_types118.default.string,
  modalText: import_prop_types118.default.string,
  onKeyDown: import_prop_types118.default.func,
  passiveModal: import_prop_types118.default.bool,
  preventCloseOnClickOutside: import_prop_types118.default.bool,
  primaryButtonText: import_prop_types118.default.string,
  renderTriggerButtonIcon: import_prop_types118.default.oneOfType([import_prop_types118.default.func, import_prop_types118.default.object]),
  secondaryButtonText: import_prop_types118.default.string,
  selectorPrimaryFocus: import_prop_types118.default.string,
  shouldCloseAfterSubmit: import_prop_types118.default.bool,
  status: import_prop_types118.default.string,
  triggerButtonIconDescription: import_prop_types118.default.string,
  triggerButtonKind: import_prop_types118.default.oneOf(ButtonKinds),
  withHeader: import_prop_types118.default.bool
});

// node_modules/@carbon/react/es/components/MultiSelect/FilterableMultiSelect.js
var import_classnames99 = __toESM(require_classnames());
var import_react_fast_compare4 = __toESM(require_react_fast_compare());
var import_prop_types120 = __toESM(require_prop_types());
var import_react160 = __toESM(require_react());

// node_modules/@carbon/react/es/components/MultiSelect/filter.js
var defaultFilterItems = (items, {
  itemToString: itemToString3,
  inputValue
}) => {
  if (!inputValue) return items;
  const normalizedInput = inputValue.toLowerCase();
  return items.filter((item) => itemToString3(item).toLowerCase().includes(normalizedInput));
};

// node_modules/@carbon/react/es/components/MultiSelect/MultiSelectPropTypes.js
var import_prop_types119 = __toESM(require_prop_types());
var sortingPropTypes = {
  /**
   * Provide a compare function that is used to determine the ordering of
   * options. `compareItems` has the following function signature:
   *
   * compareFunction :
   *  (itemA: string, itemB: string, { locale: string }) => number
   */
  compareItems: import_prop_types119.default.func,
  /**
   * Provide a method that sorts all options in the control. Overriding this
   * prop means that you also have to handle the sort logic for selected versus
   * un-selected items. If you just want to control ordering, consider the
   * `compareItems` prop instead.
   *
   * `sortItems` has the following signature:
   *
   * sortItems :
   *   (items: Array<Item>, {
   *     selectedItems: Array<Item>,
   *     itemToString: Item => string,
   *     compareItems: (itemA: string, itemB: string, {
   *       locale: string
   *     }) => number,
   *     locale: string,
   *   }) => Array<Item>
   */
  sortItems: import_prop_types119.default.func
};

// node_modules/@carbon/react/es/components/MultiSelect/tools/itemToString.js
var import_invariant2 = __toESM(require_browser());
var itemToString2 = (item) => {
  !(typeof item.label === "string") ? true ? (0, import_invariant2.default)(false, "[MultiSelect] the default `itemToString` method expected to receive an item with a `label` field of type `string`. Instead received: `%s`", typeof item.label) : (0, import_invariant2.default)(false) : void 0;
  return item.label || "";
};
var defaultItemToString4 = (item) => {
  if (Array.isArray(item)) {
    return item.map(itemToString2);
  }
  return itemToString2(item);
};

// node_modules/@carbon/react/es/components/MultiSelect/tools/sorting.js
var defaultCompareItems = (itemA, itemB, {
  locale
}) => itemA.localeCompare(itemB, locale, {
  numeric: true
});
var defaultSortItems = (items, {
  selectedItems = [],
  itemToString: itemToString3,
  compareItems,
  locale = "en"
}) => {
  return items.sort((itemA, itemB) => {
    if (itemA.isSelectAll) return -1;
    if (itemB.isSelectAll) return 1;
    const hasItemA = selectedItems.includes(itemA);
    const hasItemB = selectedItems.includes(itemB);
    if (hasItemA && !hasItemB) return -1;
    if (hasItemB && !hasItemA) return 1;
    return compareItems(itemToString3(itemA), itemToString3(itemB), {
      locale
    });
  });
};

// node_modules/@carbon/react/es/internal/Selection.js
var import_react159 = __toESM(require_react());
var import_react_fast_compare3 = __toESM(require_react_fast_compare());
var callOnChangeHandler = ({
  isControlled,
  isMounted,
  onChangeHandlerControlled,
  onChangeHandlerUncontrolled,
  selectedItems
}) => {
  if (isControlled) {
    if (isMounted && onChangeHandlerControlled) {
      setTimeout(() => {
        onChangeHandlerControlled({
          selectedItems
        });
      }, 0);
    }
  } else {
    onChangeHandlerUncontrolled(selectedItems);
  }
};
var useSelection = ({
  disabled,
  onChange,
  initialSelectedItems = [],
  selectedItems: controlledItems,
  selectAll = false,
  filteredItems = []
}) => {
  const isMounted = (0, import_react159.useRef)(false);
  const savedOnChange = (0, import_react159.useRef)(onChange);
  const [uncontrolledItems, setUncontrolledItems] = (0, import_react159.useState)(initialSelectedItems);
  const isControlled = !!controlledItems;
  const selectedItems = isControlled ? controlledItems : uncontrolledItems;
  const onItemChange = (0, import_react159.useCallback)((item) => {
    if (disabled) return;
    const allSelectableItems = filteredItems.filter((item2) => !(item2 == null ? void 0 : item2.disabled) && !(item2 == null ? void 0 : item2.isSelectAll));
    const disabledItemCount = filteredItems.filter((item2) => item2 == null ? void 0 : item2.disabled).length;
    let newSelectedItems;
    if ((item == null ? void 0 : item.isSelectAll) && selectedItems.length > 0) {
      newSelectedItems = [];
    } else if ((item == null ? void 0 : item.isSelectAll) && selectedItems.length === 0) {
      newSelectedItems = allSelectableItems;
    } else {
      const selectedIndex = selectedItems.findLastIndex((selectedItem) => (0, import_react_fast_compare3.default)(selectedItem, item));
      if (selectedIndex === -1) {
        newSelectedItems = selectedItems.concat(item);
        if (selectAll && filteredItems.length - 1 === newSelectedItems.length + disabledItemCount) {
          newSelectedItems = allSelectableItems;
        }
      } else {
        newSelectedItems = removeAtIndex(selectedItems, selectedIndex);
        newSelectedItems = newSelectedItems.filter((item2) => !(item2 == null ? void 0 : item2.isSelectAll));
      }
    }
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: newSelectedItems
    });
  }, [disabled, selectedItems, filteredItems, selectAll, isControlled]);
  const clearSelection = (0, import_react159.useCallback)(() => {
    if (disabled) return;
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: []
    });
  }, [disabled, isControlled]);
  const toggleAll = (0, import_react159.useCallback)((items) => {
    callOnChangeHandler({
      isControlled,
      isMounted: isMounted.current,
      onChangeHandlerControlled: savedOnChange.current,
      onChangeHandlerUncontrolled: setUncontrolledItems,
      selectedItems: items
    });
  }, [isControlled]);
  (0, import_react159.useEffect)(() => {
    savedOnChange.current = onChange;
  }, [onChange]);
  (0, import_react159.useEffect)(() => {
    if (isMounted.current && savedOnChange.current && !isControlled) {
      savedOnChange.current({
        selectedItems
      });
    }
  }, [isControlled, selectedItems]);
  (0, import_react159.useEffect)(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return {
    clearSelection,
    onItemChange,
    toggleAll,
    selectedItems
  };
};
var removeAtIndex = (array, index3) => {
  const result = array.slice();
  result.splice(index3, 1);
  return result;
};

// node_modules/@carbon/react/es/components/MultiSelect/FilterableMultiSelect.js
var {
  InputBlur: InputBlur3,
  InputKeyDownEnter: InputKeyDownEnter3,
  ItemClick: ItemClick3,
  MenuMouseLeave: MenuMouseLeave4,
  InputKeyDownArrowUp: InputKeyDownArrowUp3,
  InputKeyDownArrowDown: InputKeyDownArrowDown3,
  ItemMouseMove: ItemMouseMove4,
  InputClick: InputClick2,
  ToggleButtonClick: ToggleButtonClick3,
  FunctionToggleMenu: FunctionToggleMenu3,
  InputChange: InputChange2,
  InputKeyDownEscape: InputKeyDownEscape2,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex2
} = useCombobox.stateChangeTypes;
var {
  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace2,
  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete2,
  DropdownKeyDownBackspace: DropdownKeyDownBackspace2,
  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem2
} = useMultipleSelection.stateChangeTypes;
var FilterableMultiSelect = (0, import_react160.forwardRef)(function FilterableMultiSelect2({
  autoAlign = false,
  className: containerClassName,
  clearSelectionDescription = "Total items selected: ",
  clearSelectionText = "To clear selection, press Delete or Backspace",
  compareItems = defaultCompareItems,
  decorator,
  direction = "bottom",
  disabled = false,
  downshiftProps,
  filterItems = defaultFilterItems,
  helperText,
  hideLabel,
  id,
  initialSelectedItems = [],
  invalid,
  invalidText,
  items,
  itemToElement: ItemToElement,
  // needs to be capitalized for react to render it correctly
  itemToString: itemToString3 = defaultItemToString4,
  light,
  locale = "en",
  onInputValueChange,
  open: open2 = false,
  onChange,
  onMenuChange,
  placeholder,
  readOnly,
  titleText,
  type,
  selectionFeedback = "top-after-reopen",
  selectedItems: selected,
  size: size$1,
  sortItems = defaultSortItems,
  translateWithId: translateWithId8,
  useTitleInItem,
  warn: warn2,
  warnText,
  slug,
  inputProps
}, ref) {
  const {
    isFluid
  } = (0, import_react160.useContext)(FormContext);
  const isFirstRender = (0, import_react160.useRef)(true);
  const [isFocused, setIsFocused] = (0, import_react160.useState)(false);
  const [isOpen, setIsOpen] = (0, import_react160.useState)(!!open2);
  const [prevOpen, setPrevOpen] = (0, import_react160.useState)(!!open2);
  const [inputValue, setInputValue] = (0, import_react160.useState)("");
  const [topItems, setTopItems] = (0, import_react160.useState)(initialSelectedItems ?? []);
  const [inputFocused, setInputFocused] = (0, import_react160.useState)(false);
  const filteredItems = (0, import_react160.useMemo)(() => filterItems(items, {
    itemToString: itemToString3,
    inputValue
  }), [items, inputValue, itemToString3, filterItems]);
  const nonSelectAllItems = (0, import_react160.useMemo)(() => filteredItems.filter((item) => !item.isSelectAll), [filteredItems]);
  const selectAll = filteredItems.some((item) => item.isSelectAll);
  const {
    selectedItems: controlledSelectedItems,
    onItemChange,
    clearSelection,
    toggleAll
  } = useSelection({
    disabled,
    initialSelectedItems,
    onChange,
    selectedItems: selected,
    selectAll,
    filteredItems
  });
  const selectAllStatus = (0, import_react160.useMemo)(() => {
    const selectable = nonSelectAllItems.filter((item) => !item.disabled);
    const nonSelectedCount = selectable.filter((item) => !controlledSelectedItems.some((sel) => (0, import_react_fast_compare4.default)(sel, item))).length;
    const totalCount = selectable.length;
    return {
      checked: totalCount > 0 && nonSelectedCount === 0,
      indeterminate: nonSelectedCount > 0 && nonSelectedCount < totalCount
    };
  }, [controlledSelectedItems, nonSelectAllItems]);
  const handleSelectAllClick = (0, import_react160.useCallback)(() => {
    const selectable = nonSelectAllItems.filter((i) => !i.disabled);
    const {
      checked,
      indeterminate
    } = selectAllStatus;
    if (checked || indeterminate) {
      const remainingSelectedItems = controlledSelectedItems.filter((sel) => !filteredItems.some((e2) => (0, import_react_fast_compare4.default)(e2, sel)));
      toggleAll(remainingSelectedItems);
    } else {
      const toSelect = selectable.filter((e2) => !controlledSelectedItems.some((sel) => (0, import_react_fast_compare4.default)(sel, e2)));
      toggleAll([...controlledSelectedItems, ...toSelect]);
    }
  }, [nonSelectAllItems, selectAllStatus, controlledSelectedItems, toggleAll]);
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(autoAlign ? {
    placement: direction,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Middleware order matters, arrow should be last
    middleware: [flip3({
      crossAxis: false
    }), size3({
      apply({
        rects,
        elements
      }) {
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }), hide3()],
    whileElementsMounted: autoUpdate
  } : {});
  (0, import_react160.useLayoutEffect)(() => {
    var _a;
    if (autoAlign) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
    }
  }, [autoAlign, floatingStyles, refs.floating, middlewareData, open2]);
  const textInput = (0, import_react160.useRef)(null);
  const filterableMultiSelectInstanceId = useId();
  const prefix = usePrefix();
  if (prevOpen !== open2) {
    setIsOpen(open2);
    setPrevOpen(open2);
  }
  const sortedItems = (0, import_react160.useMemo)(() => {
    const selectAllItem = items.find((item) => item.isSelectAll);
    const selectableRealItems = nonSelectAllItems.filter((item) => !item.disabled);
    const sortedReal = sortItems(nonSelectAllItems, {
      selectedItems: {
        top: controlledSelectedItems,
        fixed: [],
        "top-after-reopen": topItems
      }[selectionFeedback],
      itemToString: itemToString3,
      compareItems,
      locale
    });
    if (selectAllItem && selectableRealItems.length > 0) {
      return [selectAllItem, ...sortedReal];
    }
    return sortedReal;
  }, [items, inputValue, controlledSelectedItems, topItems, selectionFeedback, itemToString3, compareItems, locale, sortItems, nonSelectAllItems]);
  const inline4 = type === "inline";
  const showWarning = !invalid && warn2;
  const wrapperClasses = (0, import_classnames99.default)(`${prefix}--multi-select__wrapper`, `${prefix}--multi-select--filterable__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {
    [`${prefix}--multi-select__wrapper--inline`]: inline4,
    [`${prefix}--list-box__wrapper--inline`]: inline4,
    [`${prefix}--multi-select__wrapper--inline--invalid`]: inline4 && invalid,
    [`${prefix}--list-box__wrapper--inline--invalid`]: inline4 && invalid,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator,
    [`${prefix}--autoalign`]: autoAlign
  });
  const helperId = !helperText ? void 0 : `filterablemultiselect-helper-text-${filterableMultiSelectInstanceId}`;
  const labelId = `${id}-label`;
  const titleClasses = (0, import_classnames99.default)({
    [`${prefix}--label`]: true,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const helperClasses = (0, import_classnames99.default)({
    [`${prefix}--form__helper-text`]: true,
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const inputClasses = (0, import_classnames99.default)({
    [`${prefix}--text-input`]: true,
    [`${prefix}--text-input--empty`]: !inputValue,
    [`${prefix}--text-input--light`]: light
  });
  const helper = helperText ? import_react160.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText) : null;
  const menuId = `${id}__menu`;
  const inputId = `${id}-input`;
  (0, import_react160.useEffect)(() => {
    if (!isOpen) {
      setTopItems(controlledSelectedItems);
    }
  }, [controlledSelectedItems, isOpen, setTopItems]);
  const validateHighlightFocus = () => {
    if (controlledSelectedItems.length > 0) {
      setHighlightedIndex(0);
    }
  };
  function handleMenuChange(forceIsOpen) {
    if (!readOnly) {
      const nextIsOpen = forceIsOpen ?? !isOpen;
      setIsOpen(nextIsOpen);
      validateHighlightFocus();
    }
  }
  (0, import_react160.useEffect)(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
      if (open2) {
        onMenuChange == null ? void 0 : onMenuChange(isOpen);
      }
    } else {
      onMenuChange == null ? void 0 : onMenuChange(isOpen);
    }
  }, [isOpen, onMenuChange, open2]);
  (0, import_react160.useEffect)(() => {
    const handleClickOutside = (event) => {
      var _a;
      const target = event.target;
      const wrapper = (_a = document.getElementById(id)) == null ? void 0 : _a.closest(`.${prefix}--multi-select__wrapper`);
      if (wrapper && !wrapper.contains(target)) {
        if (isOpen || inputFocused) {
          setIsOpen(false);
          setInputFocused(false);
          setInputValue("");
        }
      }
    };
    if (inputFocused || isOpen) {
      document.addEventListener("mousedown", handleClickOutside);
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [isOpen, inputFocused]);
  const {
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getInputProps,
    highlightedIndex,
    setHighlightedIndex,
    getItemProps,
    openMenu,
    isOpen: isMenuOpen
  } = useCombobox({
    isOpen,
    items: sortedItems,
    // defaultHighlightedIndex: 0, // after selection, highlight the first item.
    itemToString: itemToString3,
    id,
    labelId,
    menuId,
    inputId,
    inputValue,
    stateReducer: stateReducer3,
    isItemDisabled(item, _index) {
      return item == null ? void 0 : item.disabled;
    }
  });
  function stateReducer3(state, actionAndChanges) {
    const {
      type: type2,
      props,
      changes
    } = actionAndChanges;
    const {
      highlightedIndex: highlightedIndex2
    } = changes;
    if (changes.isOpen && !isOpen) {
      setTopItems(controlledSelectedItems);
    }
    switch (type2) {
      case InputKeyDownEnter3:
        if (sortedItems.length === 0) {
          return changes;
        }
        if (changes.selectedItem && changes.selectedItem.disabled !== true) {
          if (changes.selectedItem.isSelectAll) {
            handleSelectAllClick();
          } else {
            onItemChange(changes.selectedItem);
          }
        }
        setHighlightedIndex(changes.selectedItem);
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case ItemClick3:
        if (changes.selectedItem.isSelectAll) {
          handleSelectAllClick();
        } else {
          onItemChange(changes.selectedItem);
        }
        setHighlightedIndex(changes.selectedItem);
        return changes;
      case InputBlur3:
      case InputKeyDownEscape2:
        setIsOpen(false);
        return changes;
      case FunctionToggleMenu3:
      case ToggleButtonClick3:
        validateHighlightFocus();
        if (changes.isOpen && !changes.selectedItem) {
          return {
            ...changes
          };
        }
        return {
          ...changes,
          highlightedIndex: controlledSelectedItems.length > 0 ? 0 : -1
        };
      case InputChange2:
        if (onInputValueChange) {
          onInputValueChange(changes.inputValue);
        }
        setInputValue(changes.inputValue ?? "");
        setIsOpen(true);
        return {
          ...changes,
          highlightedIndex: 0
        };
      case InputClick2:
        setIsOpen(changes.isOpen || false);
        validateHighlightFocus();
        if (changes.isOpen && !changes.selectedItem) {
          return {
            ...changes
          };
        }
        return {
          ...changes,
          isOpen: false,
          highlightedIndex: controlledSelectedItems.length > 0 ? 0 : -1
        };
      case MenuMouseLeave4:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case InputKeyDownArrowUp3:
      case InputKeyDownArrowDown3:
        if (InputKeyDownArrowDown3 === type2 && !isOpen) {
          setIsOpen(true);
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        if (highlightedIndex2 > -1) {
          const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
          props.scrollIntoView(itemArray[highlightedIndex2]);
        }
        if (highlightedIndex2 === -1) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        return changes;
      case ItemMouseMove4:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case FunctionSetHighlightedIndex2:
        if (!isOpen) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        } else {
          return {
            ...changes,
            highlightedIndex: props.items.indexOf(highlightedIndex2)
          };
        }
      default:
        return changes;
    }
  }
  const {
    getDropdownProps
  } = useMultipleSelection({
    activeIndex: highlightedIndex,
    initialSelectedItems,
    selectedItems: controlledSelectedItems,
    onStateChange(changes) {
      switch (changes.type) {
        case SelectedItemKeyDownBackspace2:
        case SelectedItemKeyDownDelete2:
        case DropdownKeyDownBackspace2:
        case FunctionRemoveSelectedItem2: {
          clearSelection();
          break;
        }
      }
    },
    ...downshiftProps
  });
  (0, import_react160.useEffect)(() => {
    if (isOpen && !isMenuOpen) {
      openMenu();
    }
  });
  function clearInputValue(event) {
    var _a;
    const value = (_a = textInput.current) == null ? void 0 : _a.value;
    if ((value == null ? void 0 : value.length) === 1 || event && "key" in event && match(event, Escape)) {
      setInputValue("");
    } else {
      setInputValue(value ?? "");
    }
    if (textInput.current) {
      textInput.current.focus();
    }
  }
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react160.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  const selectedItemsLength = controlledSelectedItems.filter((item) => !item.isSelectAll).length;
  const className = (0, import_classnames99.default)(`${prefix}--multi-select`, `${prefix}--combo-box`, `${prefix}--multi-select--filterable`, {
    [`${prefix}--multi-select--invalid`]: invalid,
    [`${prefix}--multi-select--invalid--focused`]: invalid && inputFocused,
    [`${prefix}--multi-select--open`]: isOpen,
    [`${prefix}--multi-select--inline`]: inline4,
    [`${prefix}--multi-select--selected`]: (controlledSelectedItems == null ? void 0 : controlledSelectedItems.length) > 0,
    [`${prefix}--multi-select--filterable--input-focused`]: inputFocused,
    [`${prefix}--multi-select--readonly`]: readOnly,
    [`${prefix}--multi-select--selectall`]: selectAll
  });
  const labelProps = getLabelProps();
  const buttonProps = getToggleButtonProps({
    disabled,
    onClick: () => {
      var _a;
      handleMenuChange(!isOpen);
      (_a = textInput.current) == null ? void 0 : _a.focus();
    },
    // When we moved the "root node" of Downshift to the <input> for
    // ARIA 1.2 compliance, we unfortunately hit this branch for the
    // "mouseup" event that downshift listens to:
    // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
    //
    // As a result, it will reset the state of the component and so we
    // stop the event from propagating to prevent this. This allows the
    // toggleMenu behavior for the toggleButton to correctly open and
    // close the menu.
    onMouseUp(event) {
      if (isOpen) {
        event.stopPropagation();
      }
    }
  });
  const inputProp = getInputProps(getDropdownProps({
    "aria-controls": isOpen ? menuId : void 0,
    "aria-describedby": helperText ? helperId : void 0,
    "aria-haspopup": "listbox",
    // Remove excess aria `aria-labelledby`. HTML <label for>
    // provides this aria information.
    "aria-labelledby": void 0,
    disabled,
    placeholder,
    preventKeyAction: isOpen,
    ...inputProps,
    onClick: () => handleMenuChange(true),
    onKeyDown(event) {
      const $input = event.target;
      const $value = $input.value;
      if (match(event, Space)) {
        event.stopPropagation();
      }
      if (match(event, Enter)) {
        handleMenuChange(true);
      }
      if (!disabled) {
        if (match(event, Delete) || match(event, Escape)) {
          if (isOpen) {
            handleMenuChange(true);
            clearInputValue(event);
            event.stopPropagation();
          } else if (!isOpen) {
            clearInputValue(event);
            clearSelection();
            event.stopPropagation();
          }
        }
      }
      if (match(event, Tab)) {
        handleMenuChange(false);
      }
      if (match(event, Home)) {
        $input.setSelectionRange(0, 0);
      }
      if (match(event, End)) {
        $input.setSelectionRange($value.length, $value.length);
      }
    },
    onFocus: () => setInputFocused(true),
    onBlur: () => {
      setInputFocused(false);
      setInputValue("");
    }
  }));
  const menuProps = (0, import_react160.useMemo)(() => getMenuProps({
    ref: autoAlign ? refs.setFloating : null
  }, {
    suppressRefError: true
  }), [autoAlign, getMenuProps, refs.setFloating]);
  const handleFocus = (evt) => {
    if ((evt == null ? void 0 : evt.target.classList.contains(`${prefix}--tag__close-icon`)) || (evt == null ? void 0 : evt.target.classList.contains(`${prefix}--list-box__selection`))) {
      setIsFocused(false);
    } else {
      setIsFocused((evt == null ? void 0 : evt.type) === "focus" ? true : false);
    }
  };
  const mergedRef = mergeRefs(textInput, inputProp.ref);
  const readOnlyEventHandlers = readOnly ? {
    onClick: (evt) => {
      evt.preventDefault();
      if (mergedRef.current !== void 0) {
        mergedRef.current.focus();
      }
    },
    onKeyDown: (evt) => {
      const selectAccessKeys = ["ArrowDown", "ArrowUp", " ", "Enter"];
      if (selectAccessKeys.includes(evt.key)) {
        evt.preventDefault();
      }
    }
  } : {};
  const clearSelectionContent = controlledSelectedItems.length > 0 ? `${clearSelectionDescription} ${controlledSelectedItems.length}. ${clearSelectionText}.` : `${clearSelectionDescription} 0.`;
  return import_react160.default.createElement("div", {
    className: wrapperClasses
  }, titleText ? import_react160.default.createElement("label", _extends({
    className: titleClasses
  }, labelProps), titleText, import_react160.default.createElement("span", {
    className: `${prefix}--visually-hidden`
  }, clearSelectionContent)) : null, import_react160.default.createElement(ListBox2, {
    onFocus: isFluid ? handleFocus : void 0,
    onBlur: isFluid ? handleFocus : void 0,
    className,
    disabled,
    light,
    ref,
    id,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    isOpen: !readOnly && isOpen,
    size: size$1
  }, import_react160.default.createElement("div", {
    className: `${prefix}--list-box__field`,
    ref: autoAlign ? refs.setReference : null
  }, controlledSelectedItems.length > 0 && import_react160.default.createElement(ListBoxSelection2, {
    readOnly,
    clearSelection: () => {
      clearSelection();
      if (textInput.current) {
        textInput.current.focus();
      }
    },
    selectionCount: selectedItemsLength,
    translateWithId: translateWithId8,
    disabled
  }), import_react160.default.createElement("input", _extends({
    className: inputClasses
  }, inputProp, {
    ref: mergedRef
  }, readOnlyEventHandlers, {
    readOnly
  })), invalid && import_react160.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react160.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), inputValue && import_react160.default.createElement(ListBoxSelection2, {
    clearSelection: clearInputValue,
    disabled,
    translateWithId: translateWithId8,
    readOnly,
    onMouseUp: (event) => {
      event.stopPropagation();
    }
  }), import_react160.default.createElement(ListBoxTrigger, _extends({}, buttonProps, {
    isOpen,
    translateWithId: translateWithId8
  }))), slug ? normalizedDecorator : decorator ? import_react160.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react160.default.createElement(ListBox2.Menu, menuProps, isOpen ? sortedItems.map((item, index3) => {
    let isChecked;
    let isIndeterminate = false;
    if (item.isSelectAll) {
      isChecked = selectAllStatus.checked;
      isIndeterminate = selectAllStatus.indeterminate;
    } else {
      isChecked = controlledSelectedItems.filter((selected2) => (0, import_react_fast_compare4.default)(selected2, item)).length > 0;
    }
    const itemProps = getItemProps({
      item,
      ["aria-selected"]: isChecked
    });
    const itemText = itemToString3(item);
    const disabled2 = itemProps["aria-disabled"];
    const {
      "aria-disabled": unusedAriaDisabled,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      ...modifiedItemProps
    } = itemProps;
    return import_react160.default.createElement(ListBox2.MenuItem, _extends({
      key: itemProps.id,
      "aria-label": itemText,
      isActive: isChecked && !item["isSelectAll"],
      isHighlighted: highlightedIndex === index3,
      title: itemText,
      disabled: disabled2
    }, modifiedItemProps), import_react160.default.createElement("div", {
      className: `${prefix}--checkbox-wrapper`
    }, import_react160.default.createElement(Checkbox2, {
      id: `${itemProps.id}-item`,
      labelText: ItemToElement ? import_react160.default.createElement(ItemToElement, _extends({
        key: itemProps.id
      }, item)) : itemText,
      checked: isChecked,
      title: useTitleInItem ? itemText : void 0,
      indeterminate: isIndeterminate,
      disabled: disabled2,
      tabIndex: -1
    })));
  }) : null)), !inline4 && !invalid && !warn2 ? helper : null);
});
FilterableMultiSelect.displayName = "FilterableMultiSelect";
FilterableMultiSelect.propTypes = {
  /**
   * Deprecated, aria-label is no longer needed
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: deprecate(import_prop_types120.default.string, "ariaLabel / aria-label props are no longer required for FilterableMultiSelect"),
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types120.default.string, "ariaLabel / aria-label props are no longer required for FilterableMultiSelect"),
  /**
   * **Experimental**: Will attempt to automatically align the floating
   * element to avoid collisions with the viewport and being clipped by
   * ancestor elements. Requires React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types120.default.bool,
  /**
   * Specify the text that should be read for screen readers that describes total items selected
   */
  clearSelectionDescription: import_prop_types120.default.string,
  /**
   * Specify the text that should be read for screen readers to clear selection.
   */
  clearSelectionText: import_prop_types120.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `FilterableMultiSelect` component
   */
  decorator: import_prop_types120.default.node,
  /**
   * Provide a method that filters the dropdown options based on the current input. Overriding this
   * prop means that you have to handle the filtering logic when the user types in the text input.
   * Otherwise, a default built-in filtering function will be used.
   */
  filterItems: import_prop_types120.default.func,
  /**
   * Specify the direction of the multiselect dropdown. Can be either top or bottom.
   */
  direction: import_prop_types120.default.oneOf(["top", "bottom"]),
  /**
   * Disable the control
   */
  disabled: import_prop_types120.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  // @ts-ignore
  downshiftProps: import_prop_types120.default.shape(Downshift.propTypes),
  /**
   * Specify whether the title text should be hidden or not
   */
  hideLabel: import_prop_types120.default.bool,
  /**
   * Specify a custom `id`
   */
  id: import_prop_types120.default.string.isRequired,
  /**
   * Allow users to pass in arbitrary items from their collection that are
   * pre-selected
   */
  initialSelectedItems: import_prop_types120.default.array,
  /**
   * Is the current selection invalid?
   */
  invalid: import_prop_types120.default.bool,
  /**
   * If invalid, what is the error?
   */
  invalidText: import_prop_types120.default.node,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types120.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types120.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types120.default.array.isRequired,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types120.default.bool, "The `light` prop for `FilterableMultiSelect` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the locale of the control. Used for the default `compareItems`
   * used for sorting the list of items in the control.
   */
  locale: import_prop_types120.default.string,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types120.default.func,
  /**
   * `onInputValueChange` is a utility for this controlled component to communicate to
   * the currently typed input.
   */
  onInputValueChange: import_prop_types120.default.func,
  /**
   * `onMenuChange` is a utility for this controlled component to communicate to a
   * consuming component that the menu was opened(`true`)/closed(`false`).
   */
  onMenuChange: import_prop_types120.default.func,
  /**
   * Initialize the component with an open(`true`)/closed(`false`) menu.
   */
  open: import_prop_types120.default.bool,
  /**
   * Generic `placeholder` that will be used as the textual representation of
   * what this field is for
   */
  placeholder: import_prop_types120.default.string,
  /**
   * Specify feedback (mode) of the selection.
   * `top`: selected item jumps to top
   * `fixed`: selected item stays at it's position
   * `top-after-reopen`: selected item jump to top after reopen dropdown
   */
  selectionFeedback: import_prop_types120.default.oneOf(["top", "fixed", "top-after-reopen"]),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSizePropType,
  slug: deprecate(import_prop_types120.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  ...sortingPropTypes,
  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * combobox via ARIA attributes.
   */
  titleText: import_prop_types120.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types120.default.func,
  type: ListBoxTypePropType,
  /**
   * Specify title to show title on hover
   */
  useTitleInItem: import_prop_types120.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types120.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types120.default.node,
  /**
   * Specify native input attributes to place on the `<input>`, like maxLength.
   * These are passed to downshift's getInputProps() and will override the
   * internal input props.
   * https://github.com/downshift-js/downshift?tab=readme-ov-file#getinputprops
   */
  inputProps: import_prop_types120.default.object
};

// node_modules/@carbon/react/es/components/MultiSelect/MultiSelect.js
var import_classnames100 = __toESM(require_classnames());
var import_react_fast_compare5 = __toESM(require_react_fast_compare());
var import_prop_types121 = __toESM(require_prop_types());
var import_react162 = __toESM(require_react());
var {
  ItemClick: ItemClick4,
  ToggleButtonBlur: ToggleButtonBlur2,
  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown2,
  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp2,
  ToggleButtonKeyDownEnter: ToggleButtonKeyDownEnter2,
  ToggleButtonKeyDownEscape: ToggleButtonKeyDownEscape2,
  ToggleButtonKeyDownSpaceButton: ToggleButtonKeyDownSpaceButton2,
  ItemMouseMove: ItemMouseMove5,
  MenuMouseLeave: MenuMouseLeave5,
  ToggleButtonClick: ToggleButtonClick4,
  ToggleButtonKeyDownPageDown: ToggleButtonKeyDownPageDown2,
  ToggleButtonKeyDownPageUp: ToggleButtonKeyDownPageUp2,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex3
} = useSelect.stateChangeTypes;
var defaultItemToString5 = (item) => {
  if (typeof item === "string") {
    return item;
  }
  if (typeof item === "number") {
    return `${item}`;
  }
  if (item !== null && typeof item === "object" && "label" in item && typeof item["label"] === "string") {
    return item["label"];
  }
  return "";
};
var MultiSelect = import_react162.default.forwardRef(({
  autoAlign = false,
  className: containerClassName,
  decorator,
  id,
  items,
  itemToElement,
  itemToString: itemToString3 = defaultItemToString5,
  titleText = false,
  hideLabel,
  helperText,
  label,
  type = "default",
  size: size$1,
  disabled = false,
  initialSelectedItems = [],
  sortItems = defaultSortItems,
  compareItems = defaultCompareItems,
  clearSelectionText = "To clear selection, press Delete or Backspace",
  clearAnnouncement = "all items have been cleared",
  clearSelectionDescription = "Total items selected: ",
  light,
  invalid,
  invalidText,
  warn: warn2,
  warnText,
  useTitleInItem,
  translateWithId: translateWithId8,
  downshiftProps,
  open: open2 = false,
  selectionFeedback = "top-after-reopen",
  onChange,
  onMenuChange,
  direction = "bottom",
  selectedItems: selected,
  readOnly,
  locale = "en",
  slug
}, ref) => {
  const filteredItems = (0, import_react162.useMemo)(() => {
    return items.filter((item) => {
      if (typeof item === "object" && item !== null) {
        for (const key in item) {
          if (Object.hasOwn(item, key) && item[key] === void 0) {
            return false;
          }
        }
      }
      return true;
    });
  }, [items]);
  const selectAll = filteredItems.some((item) => item.isSelectAll);
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react162.useContext)(FormContext);
  const multiSelectInstanceId = useId();
  const [isFocused, setIsFocused] = (0, import_react162.useState)(false);
  const [inputFocused, setInputFocused] = (0, import_react162.useState)(false);
  const [isOpen, setIsOpen] = (0, import_react162.useState)(open2 || false);
  const [prevOpenProp, setPrevOpenProp] = (0, import_react162.useState)(open2);
  const [topItems, setTopItems] = (0, import_react162.useState)([]);
  const [itemsCleared, setItemsCleared] = (0, import_react162.useState)(false);
  const enableFloatingStyles = useFeatureFlag("enable-v12-dynamic-floating-styles") || autoAlign;
  const {
    refs,
    floatingStyles,
    middlewareData
  } = useFloating2(enableFloatingStyles ? {
    placement: direction,
    // The floating element is positioned relative to its nearest
    // containing block (usually the viewport). It will in many cases also
    // “break” the floating element out of a clipping ancestor.
    // https://floating-ui.com/docs/misc#clipping
    strategy: "fixed",
    // Middleware order matters, arrow should be last
    middleware: [autoAlign && flip3({
      crossAxis: false
    }), size3({
      apply({
        rects,
        elements
      }) {
        Object.assign(elements.floating.style, {
          width: `${rects.reference.width}px`
        });
      }
    }), autoAlign && hide3()],
    whileElementsMounted: autoUpdate
  } : {});
  (0, import_react162.useLayoutEffect)(() => {
    var _a;
    if (enableFloatingStyles) {
      const updatedFloatingStyles = {
        ...floatingStyles,
        visibility: ((_a = middlewareData.hide) == null ? void 0 : _a.referenceHidden) ? "hidden" : "visible"
      };
      Object.keys(updatedFloatingStyles).forEach((style) => {
        if (refs.floating.current) {
          refs.floating.current.style[style] = updatedFloatingStyles[style];
        }
      });
    }
  }, [enableFloatingStyles, floatingStyles, refs.floating, middlewareData, open2]);
  const {
    selectedItems: controlledSelectedItems,
    onItemChange,
    clearSelection
  } = useSelection({
    disabled,
    initialSelectedItems,
    onChange,
    selectedItems: selected,
    selectAll,
    filteredItems
  });
  const sortOptions = {
    selectedItems: controlledSelectedItems,
    itemToString: itemToString3,
    compareItems,
    locale
  };
  const selectProps = {
    stateReducer: stateReducer3,
    isOpen,
    itemToString: (filteredItems2) => {
      return Array.isArray(filteredItems2) && filteredItems2.map(function(item) {
        return itemToString3(item);
      }).join(", ") || "";
    },
    selectedItem: controlledSelectedItems,
    items: filteredItems,
    isItemDisabled(item, _index) {
      return item == null ? void 0 : item.disabled;
    },
    ...downshiftProps
  };
  const {
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    selectedItem,
    highlightedIndex,
    setHighlightedIndex
  } = useSelect(selectProps);
  const toggleButtonProps = getToggleButtonProps({
    onFocus: () => {
      setInputFocused(true);
    },
    onBlur: () => {
      setInputFocused(false);
    },
    onKeyDown: (e2) => {
      if (!disabled) {
        if ((match(e2, Delete) || match(e2, Escape)) && !isOpen) {
          clearSelection();
          e2.stopPropagation();
        }
        if (!isOpen && match(e2, Delete) && selectedItems.length > 0) {
          setItemsCleared(true);
        }
        if ((match(e2, Space) || match(e2, ArrowDown) || match(e2, Enter)) && !isOpen) {
          setHighlightedIndex(0);
          setItemsCleared(false);
          setIsOpenWrapper(true);
        }
        if (match(e2, ArrowDown) && selectedItems.length === 0) {
          setInputFocused(false);
          setIsFocused(false);
        }
        if (match(e2, Escape) && isOpen) {
          setInputFocused(true);
        }
        if (match(e2, Enter) && isOpen) {
          setInputFocused(true);
        }
      }
    }
  });
  const mergedRef = mergeRefs(toggleButtonProps.ref, ref);
  const selectedItems = selectedItem;
  const setIsOpenWrapper = (open3) => {
    setIsOpen(open3);
    if (onMenuChange) {
      onMenuChange(open3);
    }
  };
  if (prevOpenProp !== open2) {
    setIsOpenWrapper(open2);
    setPrevOpenProp(open2);
  }
  const inline4 = type === "inline";
  const showWarning = !invalid && warn2;
  const wrapperClasses = (0, import_classnames100.default)(`${prefix}--multi-select__wrapper`, `${prefix}--list-box__wrapper`, containerClassName, {
    [`${prefix}--multi-select__wrapper--inline`]: inline4,
    [`${prefix}--list-box__wrapper--inline`]: inline4,
    [`${prefix}--multi-select__wrapper--inline--invalid`]: inline4 && invalid,
    [`${prefix}--list-box__wrapper--inline--invalid`]: inline4 && invalid,
    [`${prefix}--list-box__wrapper--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--list-box__wrapper--slug`]: slug,
    [`${prefix}--list-box__wrapper--decorator`]: decorator
  });
  const titleClasses = (0, import_classnames100.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const helperId = !helperText ? void 0 : `multiselect-helper-text-${multiSelectInstanceId}`;
  const fieldLabelId = `multiselect-field-label-${multiSelectInstanceId}`;
  const helperClasses = (0, import_classnames100.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const className = (0, import_classnames100.default)(`${prefix}--multi-select`, {
    [`${prefix}--multi-select--invalid`]: invalid,
    [`${prefix}--multi-select--invalid--focused`]: invalid && inputFocused,
    [`${prefix}--multi-select--warning`]: showWarning,
    [`${prefix}--multi-select--inline`]: inline4,
    [`${prefix}--multi-select--selected`]: selectedItems && selectedItems.length > 0,
    [`${prefix}--list-box--up`]: direction === "top",
    [`${prefix}--multi-select--readonly`]: readOnly,
    [`${prefix}--autoalign`]: enableFloatingStyles,
    [`${prefix}--multi-select--selectall`]: selectAll
  });
  const ItemToElement = itemToElement;
  if (selectionFeedback === "fixed") {
    sortOptions.selectedItems = [];
  } else if (selectionFeedback === "top-after-reopen") {
    sortOptions.selectedItems = topItems;
  }
  function stateReducer3(state, actionAndChanges) {
    const {
      changes,
      props,
      type: type2
    } = actionAndChanges;
    const {
      highlightedIndex: highlightedIndex2
    } = changes;
    if (changes.isOpen && !isOpen) {
      setTopItems(controlledSelectedItems);
    }
    switch (type2) {
      case ToggleButtonKeyDownSpaceButton2:
      case ToggleButtonKeyDownEnter2:
        if (changes.selectedItem === void 0) {
          break;
        }
        if (Array.isArray(changes.selectedItem)) {
          break;
        }
        onItemChange(changes.selectedItem);
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case ToggleButtonBlur2:
      case ToggleButtonKeyDownEscape2:
        setIsOpenWrapper(false);
        break;
      case ToggleButtonClick4:
        setIsOpenWrapper(changes.isOpen || false);
        return {
          ...changes,
          highlightedIndex: controlledSelectedItems.length > 0 ? 0 : void 0
        };
      case ItemClick4:
        setHighlightedIndex(changes.selectedItem);
        onItemChange(changes.selectedItem);
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case MenuMouseLeave5:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
      case FunctionSetHighlightedIndex3:
        if (!isOpen) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        } else {
          return {
            ...changes,
            highlightedIndex: filteredItems.indexOf(highlightedIndex2)
          };
        }
      case ToggleButtonKeyDownArrowDown2:
      case ToggleButtonKeyDownArrowUp2:
      case ToggleButtonKeyDownPageDown2:
      case ToggleButtonKeyDownPageUp2:
        if (highlightedIndex2 > -1) {
          const itemArray = document.querySelectorAll(`li.${prefix}--list-box__menu-item[role="option"]`);
          props.scrollIntoView(itemArray[highlightedIndex2]);
        }
        if (highlightedIndex2 === -1) {
          return {
            ...changes,
            highlightedIndex: 0
          };
        }
        return changes;
      case ItemMouseMove5:
        return {
          ...changes,
          highlightedIndex: state.highlightedIndex
        };
    }
    return changes;
  }
  const multiSelectFieldWrapperClasses = (0, import_classnames100.default)(`${prefix}--list-box__field--wrapper`, {
    [`${prefix}--list-box__field--wrapper--input-focused`]: inputFocused
  });
  const handleFocus = (evt) => {
    evt.target.classList.contains(`${prefix}--tag__close-icon`) ? setIsFocused(false) : setIsFocused(evt.type === "focus" ? true : false);
  };
  const readOnlyEventHandlers = readOnly ? {
    onClick: (evt) => {
      evt.preventDefault();
      if (mergedRef.current !== void 0) {
        mergedRef.current.focus();
      }
    },
    onKeyDown: (evt) => {
      const selectAccessKeys = ["ArrowDown", "ArrowUp", " ", "Enter"];
      if (selectAccessKeys.includes(evt.key)) {
        evt.preventDefault();
      }
    }
  } : {};
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react162.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  const itemsSelectedText = selectedItems.length > 0 && selectedItems.map((item) => item == null ? void 0 : item.text);
  const selectedItemsLength = selectAll ? selectedItems.filter((item) => !item.isSelectAll).length : selectedItems.length;
  const menuProps = (0, import_react162.useMemo)(() => getMenuProps({
    ref: enableFloatingStyles ? refs.setFloating : null
  }), [enableFloatingStyles, getMenuProps, refs.setFloating]);
  const allLabelProps = getLabelProps();
  const labelProps = (0, import_react162.isValidElement)(titleText) ? {
    id: allLabelProps.id
  } : allLabelProps;
  const getSelectionStats = (0, import_react162.useCallback)((selectedItems2, filteredItems2) => {
    const hasIndividualSelections = selectedItems2.some((selected2) => !selected2.isSelectAll);
    const nonSelectAllSelectedCount = selectedItems2.filter((selected2) => !selected2.isSelectAll).length;
    const totalSelectableCount = filteredItems2.filter((item) => !item.isSelectAll && !item.disabled).length;
    return {
      hasIndividualSelections,
      nonSelectAllSelectedCount,
      totalSelectableCount
    };
  }, [selectedItems, filteredItems]);
  return import_react162.default.createElement("div", {
    className: wrapperClasses
  }, import_react162.default.createElement("label", _extends({
    className: titleClasses
  }, labelProps), titleText && titleText, selectedItems.length > 0 && import_react162.default.createElement("span", {
    className: `${prefix}--visually-hidden`
  }, clearSelectionDescription, " ", selectedItems.length, " ", itemsSelectedText, ",", clearSelectionText)), import_react162.default.createElement(ListBox2, {
    onFocus: isFluid ? handleFocus : void 0,
    onBlur: isFluid ? handleFocus : void 0,
    type,
    size: size$1,
    className,
    disabled,
    light,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    isOpen,
    id
  }, invalid && import_react162.default.createElement(WarningFilled, {
    className: `${prefix}--list-box__invalid-icon`
  }), showWarning && import_react162.default.createElement(WarningAltFilled, {
    className: `${prefix}--list-box__invalid-icon ${prefix}--list-box__invalid-icon--warning`
  }), import_react162.default.createElement("div", {
    className: multiSelectFieldWrapperClasses,
    ref: enableFloatingStyles ? refs.setReference : null
  }, selectedItems.length > 0 && import_react162.default.createElement(ListBox2.Selection, {
    readOnly,
    clearSelection: !disabled && !readOnly ? clearSelection : noopFn,
    selectionCount: selectedItemsLength,
    translateWithId: translateWithId8,
    disabled
  }), import_react162.default.createElement("button", _extends({
    type: "button",
    className: `${prefix}--list-box__field`,
    disabled,
    "aria-disabled": disabled || readOnly,
    "aria-describedby": !inline4 && !invalid && !warn2 && helperText ? helperId : void 0
  }, toggleButtonProps, {
    ref: mergedRef
  }, readOnlyEventHandlers), import_react162.default.createElement("span", {
    id: fieldLabelId,
    className: `${prefix}--list-box__label`
  }, label), import_react162.default.createElement(ListBox2.MenuIcon, {
    isOpen,
    translateWithId: translateWithId8
  })), slug ? normalizedDecorator : decorator ? import_react162.default.createElement("div", {
    className: `${prefix}--list-box__inner-wrapper--decorator`
  }, normalizedDecorator) : ""), import_react162.default.createElement(ListBox2.Menu, menuProps, isOpen && sortItems(filteredItems, sortOptions).map((item, index3) => {
    const {
      hasIndividualSelections,
      nonSelectAllSelectedCount,
      totalSelectableCount
    } = getSelectionStats(selectedItems, filteredItems);
    const isChecked = item.isSelectAll ? nonSelectAllSelectedCount === totalSelectableCount && totalSelectableCount > 0 : selectedItems.some((selected2) => (0, import_react_fast_compare5.default)(selected2, item));
    const isIndeterminate = item.isSelectAll && hasIndividualSelections && nonSelectAllSelectedCount < totalSelectableCount;
    const itemProps = getItemProps({
      item,
      // we don't want Downshift to set aria-selected for us
      // we also don't want to set 'false' for reader verbosity's sake
      ["aria-selected"]: isChecked
    });
    const itemText = itemToString3(item);
    return import_react162.default.createElement(ListBox2.MenuItem, _extends({
      key: itemProps.id,
      isActive: isChecked && !item["isSelectAll"],
      "aria-label": itemText,
      isHighlighted: highlightedIndex === index3,
      title: itemText,
      disabled: itemProps["aria-disabled"]
    }, itemProps), import_react162.default.createElement("div", {
      className: `${prefix}--checkbox-wrapper`
    }, import_react162.default.createElement(Checkbox2, {
      id: `${itemProps.id}__checkbox`,
      labelText: itemToElement ? import_react162.default.createElement(ItemToElement, _extends({
        key: itemProps.id
      }, item)) : itemText,
      checked: isChecked,
      title: useTitleInItem ? itemText : void 0,
      indeterminate: isIndeterminate,
      disabled
    })));
  })), itemsCleared && import_react162.default.createElement("span", {
    "aria-live": "assertive",
    "aria-label": clearAnnouncement
  })), !inline4 && !invalid && !warn2 && helperText && import_react162.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText));
});
MultiSelect.displayName = "MultiSelect";
MultiSelect.propTypes = {
  ...sortingPropTypes,
  /**
   * **Experimental**: Will attempt to automatically align the floating
   * element to avoid collisions with the viewport and being clipped by
   * ancestor elements. Requires React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types121.default.bool,
  /**
   * Provide a custom class name to be added to the outermost node in the
   * component
   */
  className: import_prop_types121.default.string,
  /**
   * Specify the text that should be read for screen readers that describes total items selected
   */
  clearSelectionDescription: import_prop_types121.default.string,
  /**
   * Specify the text that should be read for screen readers to clear selection.
   */
  clearSelectionText: import_prop_types121.default.string,
  /**
   * Provide a compare function that is used to determine the ordering of
   * options. See 'sortItems' for more control. Consider
   * declaring function with `useCallback` to prevent unnecessary re-renders.
   */
  compareItems: import_prop_types121.default.func,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `MultiSelect` component
   */
  decorator: import_prop_types121.default.node,
  /**
   * Specify the direction of the multiselect dropdown. Can be either top or bottom.
   */
  direction: import_prop_types121.default.oneOf(["top", "bottom"]),
  /**
   * Disable the control
   */
  disabled: import_prop_types121.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types121.default.object,
  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: import_prop_types121.default.node,
  /**
   * Specify whether the title text should be hidden or not
   */
  hideLabel: import_prop_types121.default.bool,
  /**
   * Specify a custom `id`
   */
  id: import_prop_types121.default.string.isRequired,
  /**
   * Allow users to pass in arbitrary items from their collection that are
   * pre-selected
   */
  initialSelectedItems: import_prop_types121.default.array,
  /**
   * Is the current selection invalid?
   */
  invalid: import_prop_types121.default.bool,
  /**
   * If invalid, what is the error?
   */
  invalidText: import_prop_types121.default.node,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types121.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list. Consider
   * declaring function with `useCallback` to prevent unnecessary re-renders.
   */
  itemToString: import_prop_types121.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types121.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types121.default.node.isRequired,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types121.default.bool, "The `light` prop for `MultiSelect` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Specify the locale of the control. Used for the default `compareItems`
   * used for sorting the list of items in the control.
   */
  locale: import_prop_types121.default.string,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types121.default.func,
  /**
   * `onMenuChange` is a utility for this controlled component to communicate to a
   * consuming component that the menu was open(`true`)/closed(`false`).
   */
  onMenuChange: import_prop_types121.default.func,
  /**
   * Initialize the component with an open(`true`)/closed(`false`) menu.
   */
  open: import_prop_types121.default.bool,
  /**
   * Whether or not the Dropdown is readonly
   */
  readOnly: import_prop_types121.default.bool,
  /**
   * For full control of the selected items
   */
  selectedItems: import_prop_types121.default.array,
  /**
   * Specify feedback (mode) of the selection.
   * `top`: selected item jumps to top
   * `fixed`: selected item stays at it's position
   * `top-after-reopen`: selected item jump to top after reopen dropdown
   */
  selectionFeedback: import_prop_types121.default.oneOf(["top", "fixed", "top-after-reopen"]),
  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSizePropType,
  slug: deprecate(import_prop_types121.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Provide a method that sorts all options in the control. Overriding this
   * prop means that you also have to handle the sort logic for selected versus
   * un-selected items. If you just want to control ordering, consider the
   * `compareItems` prop instead.
   *
   * The return value should be a number whose sign indicates the relative order
   * of the two elements: negative if a is less than b, positive if a is greater
   * than b, and zero if they are equal.
   *
   * sortItems :
   *   (items: Array<Item>, {
   *     selectedItems: Array<Item>,
   *     itemToString: Item => string,
   *     compareItems: (itemA: string, itemB: string, {
   *       locale: string
   *     }) => number,
   *     locale: string,
   *   }) => Array<Item>
   */
  sortItems: import_prop_types121.default.func,
  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * multiselect via ARIA attributes.
   */
  titleText: import_prop_types121.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types121.default.func,
  /**
   * Specify 'inline' to create an inline multi-select.
   */
  type: ListBoxTypePropType,
  /**
   * Specify title to show title on hover
   */
  useTitleInItem: import_prop_types121.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types121.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types121.default.node
};

// node_modules/@carbon/react/es/components/Notification/Notification.js
var import_prop_types122 = __toESM(require_prop_types());
var import_react164 = __toESM(require_react());
var import_classnames101 = __toESM(require_classnames());
function useEscapeToClose(ref, callback, override = true) {
  const handleKeyDown = (event) => {
    var _a;
    const elementContainsFocus = ref.current && document.activeElement === ref.current || ((_a = ref.current) == null ? void 0 : _a.contains(document.activeElement));
    if (matches(event, [Escape]) && override && elementContainsFocus) {
      callback(event);
    }
  };
  useIsomorphicEffect(() => {
    if (ref.current !== null) {
      document.addEventListener("keydown", handleKeyDown, false);
    }
    return () => document.removeEventListener("keydown", handleKeyDown, false);
  });
}
function NotificationActionButton({
  children,
  className: customClassName,
  onClick,
  inline: inline4,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames101.default)(customClassName, {
    [`${prefix}--actionable-notification__action-button`]: true
  });
  return import_react164.default.createElement(Button, _extends({
    className,
    kind: inline4 ? "ghost" : "tertiary",
    onClick,
    size: "sm"
  }, rest), children);
}
NotificationActionButton.propTypes = {
  /**
   * Specify the content of the notification action button.
   */
  children: import_prop_types122.default.node,
  /**
   * Specify an optional className to be applied to the notification action button
   */
  className: import_prop_types122.default.string,
  /**
   * Specify if the visual treatment of the button should be for an inline notification
   */
  inline: import_prop_types122.default.bool,
  /**
   * Optionally specify a click handler for the notification action button.
   */
  onClick: import_prop_types122.default.func
};
function NotificationButton({
  "aria-label": ariaLabel = "close notification",
  ariaLabel: deprecatedAriaLabel,
  className,
  type = "button",
  renderIcon: IconTag = Close,
  name,
  notificationType = "toast",
  ...rest
}) {
  const prefix = usePrefix();
  const buttonClassName = (0, import_classnames101.default)(className, {
    [`${prefix}--${notificationType}-notification__close-button`]: notificationType
  });
  const iconClassName = (0, import_classnames101.default)({
    [`${prefix}--${notificationType}-notification__close-icon`]: notificationType
  });
  return import_react164.default.createElement("button", _extends({}, rest, {
    // eslint-disable-next-line react/button-has-type
    type,
    "aria-label": deprecatedAriaLabel || ariaLabel,
    title: deprecatedAriaLabel || ariaLabel,
    className: buttonClassName
  }), IconTag && import_react164.default.createElement(IconTag, {
    className: iconClassName,
    name
  }));
}
NotificationButton.propTypes = {
  /**
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types122.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types122.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify an optional className to be applied to the notification button
   */
  className: import_prop_types122.default.string,
  /**
   * Specify an optional icon for the Button through a string,
   * if something but regular "close" icon is desirable
   */
  name: import_prop_types122.default.string,
  /**
   * Specify the notification type
   */
  notificationType: import_prop_types122.default.oneOf(["toast", "inline", "actionable"]),
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types122.default.oneOfType([import_prop_types122.default.func, import_prop_types122.default.object]),
  /**
   * Optional prop to specify the type of the Button
   */
  type: import_prop_types122.default.string
};
var iconTypes = {
  error: ErrorFilled,
  success: CheckmarkFilled,
  warning: WarningFilled,
  ["warning-alt"]: WarningAltFilled,
  info: InformationFilled,
  ["info-square"]: InformationSquareFilled
};
function NotificationIcon({
  iconDescription,
  kind,
  notificationType
}) {
  const prefix = usePrefix();
  const IconForKind = iconTypes[kind];
  if (!IconForKind) {
    return null;
  }
  return import_react164.default.createElement(IconForKind, {
    className: `${prefix}--${notificationType}-notification__icon`,
    size: 20
  }, import_react164.default.createElement("title", null, iconDescription));
}
NotificationIcon.propTypes = {
  iconDescription: import_prop_types122.default.string.isRequired,
  kind: import_prop_types122.default.oneOf(["error", "success", "warning", "warning-alt", "info", "info-square"]).isRequired,
  notificationType: import_prop_types122.default.oneOf(["inline", "toast"]).isRequired
};
function ToastNotification({
  ["aria-label"]: ariaLabel,
  // @ts-expect-error: deprecated prop
  ariaLabel: deprecatedAriaLabel,
  role = "status",
  onClose,
  onCloseButtonClick = noopFn,
  statusIconDescription,
  className,
  children,
  kind = "error",
  lowContrast,
  hideCloseButton = false,
  timeout = 0,
  title,
  caption,
  subtitle,
  ...rest
}) {
  const [isOpen, setIsOpen] = (0, import_react164.useState)(true);
  const prefix = usePrefix();
  const containerClassName = (0, import_classnames101.default)(className, {
    [`${prefix}--toast-notification`]: true,
    [`${prefix}--toast-notification--low-contrast`]: lowContrast,
    [`${prefix}--toast-notification--${kind}`]: kind
  });
  const contentRef = (0, import_react164.useRef)(null);
  useNoInteractiveChildren(contentRef);
  const handleClose = (evt) => {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  };
  const ref = (0, import_react164.useRef)(null);
  function handleCloseButtonClick(event) {
    onCloseButtonClick(event);
    handleClose(event);
  }
  const savedOnClose = (0, import_react164.useRef)(onClose);
  (0, import_react164.useEffect)(() => {
    savedOnClose.current = onClose;
  });
  (0, import_react164.useEffect)(() => {
    if (!timeout) {
      return;
    }
    const timeoutId = window.setTimeout((event) => {
      setIsOpen(false);
      if (savedOnClose.current) {
        savedOnClose.current(event);
      }
    }, timeout);
    return () => {
      window.clearTimeout(timeoutId);
    };
  }, [timeout]);
  if (!isOpen) {
    return null;
  }
  return import_react164.default.createElement("div", _extends({
    ref
  }, rest, {
    role,
    className: containerClassName
  }), import_react164.default.createElement(NotificationIcon, {
    notificationType: "toast",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react164.default.createElement("div", {
    ref: contentRef,
    className: `${prefix}--toast-notification__details`
  }, title && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--toast-notification__title`
  }, title), subtitle && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--toast-notification__subtitle`
  }, subtitle), caption && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--toast-notification__caption`
  }, caption), children), !hideCloseButton && import_react164.default.createElement(NotificationButton, {
    notificationType: "toast",
    onClick: handleCloseButtonClick,
    "aria-label": deprecatedAriaLabel || ariaLabel
  }));
}
ToastNotification.propTypes = {
  /**
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ["aria-label"]: import_prop_types122.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ariaLabel: deprecate(import_prop_types122.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify the caption
   */
  caption: import_prop_types122.default.string,
  /**
   * Specify the content
   */
  children: import_prop_types122.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types122.default.string,
  /**
   * Specify the close button should be disabled, or not
   */
  hideCloseButton: import_prop_types122.default.bool,
  /**
   * Specify what state the notification represents
   */
  kind: import_prop_types122.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]),
  /**
   * Specify whether you are using the low contrast variant of the ToastNotification.
   */
  lowContrast: import_prop_types122.default.bool,
  /**
   * Provide a function that is called when menu is closed
   */
  onClose: import_prop_types122.default.func,
  /**
   * Provide a function that is called when the close button is clicked
   */
  onCloseButtonClick: import_prop_types122.default.func,
  /**
   * By default, this value is "status". You can also provide an alternate
   * role if it makes sense from the accessibility-side
   */
  role: import_prop_types122.default.oneOf(["alert", "log", "status"]),
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types122.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types122.default.string,
  /**
   * Specify an optional duration the notification should be closed in
   */
  timeout: import_prop_types122.default.number,
  /**
   * Specify the title
   */
  title: import_prop_types122.default.string
};
function InlineNotification({
  ["aria-label"]: ariaLabel,
  children,
  title,
  subtitle,
  role = "status",
  onClose,
  onCloseButtonClick = noopFn,
  statusIconDescription,
  className,
  kind = "error",
  lowContrast,
  hideCloseButton = false,
  ...rest
}) {
  const [isOpen, setIsOpen] = (0, import_react164.useState)(true);
  const prefix = usePrefix();
  const containerClassName = (0, import_classnames101.default)(className, {
    [`${prefix}--inline-notification`]: true,
    [`${prefix}--inline-notification--low-contrast`]: lowContrast,
    [`${prefix}--inline-notification--${kind}`]: kind,
    [`${prefix}--inline-notification--hide-close-button`]: hideCloseButton
  });
  const contentRef = (0, import_react164.useRef)(null);
  useNoInteractiveChildren(contentRef);
  const handleClose = (evt) => {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  };
  const ref = (0, import_react164.useRef)(null);
  function handleCloseButtonClick(event) {
    onCloseButtonClick(event);
    handleClose(event);
  }
  if (!isOpen) {
    return null;
  }
  return import_react164.default.createElement("div", _extends({
    ref
  }, rest, {
    role,
    className: containerClassName
  }), import_react164.default.createElement("div", {
    className: `${prefix}--inline-notification__details`
  }, import_react164.default.createElement(NotificationIcon, {
    notificationType: "inline",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react164.default.createElement("div", {
    ref: contentRef,
    className: `${prefix}--inline-notification__text-wrapper`
  }, title && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--inline-notification__title`
  }, title), subtitle && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--inline-notification__subtitle`
  }, subtitle), children)), !hideCloseButton && import_react164.default.createElement(NotificationButton, {
    notificationType: "inline",
    onClick: handleCloseButtonClick,
    "aria-label": ariaLabel
  }));
}
InlineNotification.propTypes = {
  /**
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ["aria-label"]: import_prop_types122.default.string,
  /**
   * Specify the content
   */
  children: import_prop_types122.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types122.default.string,
  /**
   * Specify the close button should be disabled, or not
   */
  hideCloseButton: import_prop_types122.default.bool,
  /**
   * Specify what state the notification represents
   */
  kind: import_prop_types122.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]),
  /**
   * Specify whether you are using the low contrast variant of the InlineNotification.
   */
  lowContrast: import_prop_types122.default.bool,
  /**
   * Provide a function that is called when menu is closed
   */
  onClose: import_prop_types122.default.func,
  /**
   * Provide a function that is called when the close button is clicked
   */
  onCloseButtonClick: import_prop_types122.default.func,
  /**
   * By default, this value is "status". You can also provide an alternate
   * role if it makes sense from the accessibility-side.
   */
  role: import_prop_types122.default.oneOf(["alert", "log", "status"]),
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types122.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types122.default.string,
  /**
   * Specify the title
   */
  title: import_prop_types122.default.string
};
function ActionableNotification({
  actionButtonLabel,
  ["aria-label"]: ariaLabel,
  // @ts-expect-error: deprecated prop
  ariaLabel: deprecatedAriaLabel,
  caption,
  children,
  role = "alertdialog",
  onActionButtonClick,
  onClose,
  onCloseButtonClick = noopFn,
  statusIconDescription,
  className,
  inline: inline4 = false,
  kind = "error",
  lowContrast,
  hideCloseButton = false,
  hasFocus = true,
  closeOnEscape = true,
  title,
  subtitle,
  ...rest
}) {
  const [isOpen, setIsOpen] = (0, import_react164.useState)(true);
  const prefix = usePrefix();
  const id = useId("actionable-notification");
  const subtitleId = useId("actionable-notification-subtitle");
  const containerClassName = (0, import_classnames101.default)(className, {
    [`${prefix}--actionable-notification`]: true,
    [`${prefix}--actionable-notification--toast`]: !inline4,
    [`${prefix}--actionable-notification--low-contrast`]: lowContrast,
    [`${prefix}--actionable-notification--${kind}`]: kind,
    [`${prefix}--actionable-notification--hide-close-button`]: hideCloseButton
  });
  const innerModal = (0, import_react164.useRef)(null);
  const startTrap = (0, import_react164.useRef)(null);
  const endTrap = (0, import_react164.useRef)(null);
  const ref = (0, import_react164.useRef)(null);
  const focusTrapWithoutSentinels = useFeatureFlag("enable-experimental-focus-wrap-without-sentinels");
  useIsomorphicEffect(() => {
    if (hasFocus && role === "alertdialog") {
      const button = document.querySelector("button.cds--actionable-notification__action-button");
      button == null ? void 0 : button.focus();
    }
  });
  function handleBlur({
    target: oldActiveNode,
    relatedTarget: currentActiveNode
  }) {
    if (isOpen && currentActiveNode && oldActiveNode && role === "alertdialog") {
      const {
        current: bodyNode
      } = innerModal;
      const {
        current: startTrapNode
      } = startTrap;
      const {
        current: endTrapNode
      } = endTrap;
      wrapFocus({
        bodyNode,
        startTrapNode,
        endTrapNode,
        currentActiveNode,
        oldActiveNode
      });
    }
  }
  function handleKeyDown(event) {
    if (isOpen && match(event, Tab) && ref.current && role === "alertdialog") {
      wrapFocusWithoutSentinels({
        containerNode: ref.current,
        currentActiveNode: event.target,
        event
      });
    }
  }
  const handleClose = (evt) => {
    if (!onClose || onClose(evt) !== false) {
      setIsOpen(false);
    }
  };
  useEscapeToClose(ref, handleCloseButtonClick, closeOnEscape);
  function handleCloseButtonClick(event) {
    onCloseButtonClick(event);
    handleClose(event);
  }
  if (!isOpen) {
    return null;
  }
  return import_react164.default.createElement("div", _extends({}, rest, {
    ref,
    role,
    className: containerClassName,
    "aria-labelledby": title ? id : subtitleId,
    onBlur: !focusTrapWithoutSentinels ? handleBlur : () => {
    },
    onKeyDown: focusTrapWithoutSentinels ? handleKeyDown : () => {
    }
  }), !focusTrapWithoutSentinels && import_react164.default.createElement("span", {
    ref: startTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"), import_react164.default.createElement("div", {
    className: `${prefix}--actionable-notification__details`
  }, import_react164.default.createElement(NotificationIcon, {
    notificationType: inline4 ? "inline" : "toast",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react164.default.createElement("div", {
    className: `${prefix}--actionable-notification__text-wrapper`
  }, import_react164.default.createElement("div", {
    className: `${prefix}--actionable-notification__content`
  }, title && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--actionable-notification__title`,
    id
  }, title), subtitle && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--actionable-notification__subtitle`,
    id: subtitleId
  }, subtitle), caption && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--actionable-notification__caption`
  }, caption), children))), import_react164.default.createElement("div", {
    className: `${prefix}--actionable-notification__button-wrapper`,
    ref: innerModal
  }, actionButtonLabel && import_react164.default.createElement(NotificationActionButton, {
    onClick: onActionButtonClick,
    inline: inline4
  }, actionButtonLabel), !hideCloseButton && import_react164.default.createElement(NotificationButton, {
    "aria-label": deprecatedAriaLabel || ariaLabel,
    notificationType: "actionable",
    onClick: handleCloseButtonClick
  })), !focusTrapWithoutSentinels && import_react164.default.createElement("span", {
    ref: endTrap,
    tabIndex: 0,
    role: "link",
    className: `${prefix}--visually-hidden`
  }, "Focus sentinel"));
}
ActionableNotification.propTypes = {
  /**
   * Pass in the action button label that will be rendered within the ActionableNotification.
   */
  actionButtonLabel: import_prop_types122.default.string,
  /**
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ["aria-label"]: import_prop_types122.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Provide a description for "close" icon button that can be read by screen readers
   */
  ariaLabel: deprecate(import_prop_types122.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Specify the caption
   */
  caption: import_prop_types122.default.string,
  /**
   * Specify the content
   */
  children: import_prop_types122.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types122.default.string,
  /**
   * Specify if pressing the escape key should close notifications
   */
  closeOnEscape: import_prop_types122.default.bool,
  /**
   * Specify if focus should be moved to the component when the notification contains actions
   */
  hasFocus: deprecate(import_prop_types122.default.bool, "hasFocus is deprecated. To conform to accessibility requirements hasFocus should always be `true` for ActionableNotification. If you were setting this prop to `false`, consider using the Callout component instead."),
  /**
   * Specify the close button should be disabled, or not
   */
  hideCloseButton: import_prop_types122.default.bool,
  /*
   * Specify if the notification should have inline styling applied instead of toast
   */
  inline: import_prop_types122.default.bool,
  /**
   * Specify what state the notification represents
   */
  kind: import_prop_types122.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]),
  /**
   * Specify whether you are using the low contrast variant of the ActionableNotification.
   */
  lowContrast: import_prop_types122.default.bool,
  /**
   * Provide a function that is called when the action is clicked
   */
  onActionButtonClick: import_prop_types122.default.func,
  /**
   * Provide a function that is called when menu is closed
   */
  onClose: import_prop_types122.default.func,
  /**
   * Provide a function that is called when the close button is clicked
   */
  onCloseButtonClick: import_prop_types122.default.func,
  /**
   * Provide an accessible role to be used. Defaults to `alertdialog`. Any other
   * value will disable the wrapping of focus. To remain accessible, additional
   * work is required. See the storybook docs for more info:
   * https://react.carbondesignsystem.com/?path=/docs/components-notifications-actionable--overview#using-the-role-prop
   */
  role: import_prop_types122.default.string,
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types122.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types122.default.node,
  /**
   * Specify the title
   */
  title: import_prop_types122.default.string
};
var propMappingFunction = (deprecatedValue) => {
  const mapping = {
    error: "warning",
    // only redirect error -> warning
    success: "info"
    // only redirect success -> info
  };
  return mapping[deprecatedValue];
};
function Callout({
  actionButtonLabel,
  children,
  onActionButtonClick,
  title,
  titleId,
  subtitle,
  statusIconDescription,
  className,
  kind = "info",
  lowContrast,
  ...rest
}) {
  const prefix = usePrefix();
  const containerClassName = (0, import_classnames101.default)(className, {
    [`${prefix}--actionable-notification`]: true,
    [`${prefix}--actionable-notification--low-contrast`]: lowContrast,
    [`${prefix}--actionable-notification--${kind}`]: kind,
    [`${prefix}--actionable-notification--hide-close-button`]: true
  });
  const childrenContainer = (0, import_react164.useRef)(null);
  useInteractiveChildrenNeedDescription(childrenContainer, `interactive child node(s) should have an \`aria-describedby\` property with a value matching the value of \`titleId\``);
  return import_react164.default.createElement("div", _extends({}, rest, {
    className: containerClassName
  }), import_react164.default.createElement("div", {
    className: `${prefix}--actionable-notification__details`
  }, import_react164.default.createElement(NotificationIcon, {
    notificationType: "inline",
    kind,
    iconDescription: statusIconDescription || `${kind} icon`
  }), import_react164.default.createElement("div", {
    ref: childrenContainer,
    className: `${prefix}--actionable-notification__text-wrapper`
  }, title && import_react164.default.createElement(Text, {
    as: "div",
    id: titleId,
    className: `${prefix}--actionable-notification__title`
  }, title), subtitle && import_react164.default.createElement(Text, {
    as: "div",
    className: `${prefix}--actionable-notification__subtitle`
  }, subtitle), children)), import_react164.default.createElement("div", {
    className: `${prefix}--actionable-notification__button-wrapper`
  }, actionButtonLabel && import_react164.default.createElement(NotificationActionButton, {
    onClick: onActionButtonClick,
    "aria-describedby": titleId,
    inline: true
  }, actionButtonLabel)));
}
Callout.propTypes = {
  /**
   * Pass in the action button label that will be rendered within the ActionableNotification.
   */
  actionButtonLabel: import_prop_types122.default.string,
  /**
   * Specify the content
   */
  children: import_prop_types122.default.node,
  /**
   * Specify an optional className to be applied to the notification box
   */
  className: import_prop_types122.default.string,
  /**
   * Specify what state the notification represents
   */
  kind: deprecateValuesWithin(import_prop_types122.default.oneOf(["error", "info", "info-square", "success", "warning", "warning-alt"]), ["warning", "info"], propMappingFunction),
  /**
   * Specify whether you are using the low contrast variant of the Callout.
   */
  lowContrast: import_prop_types122.default.bool,
  /**
   * Provide a function that is called when the action is clicked
   */
  onActionButtonClick: import_prop_types122.default.func,
  /**
   * Provide a description for "status" icon that can be read by screen readers
   */
  statusIconDescription: import_prop_types122.default.string,
  /**
   * Specify the subtitle
   */
  subtitle: import_prop_types122.default.node,
  /**
   * Specify the title
   */
  title: import_prop_types122.default.string,
  /**
   * Specify the id for the element containing the title
   */
  titleId: import_prop_types122.default.string
};
var didWarnAboutDeprecation4 = false;
var StaticNotification = (props) => {
  if (true) {
    true ? warning(didWarnAboutDeprecation4, "`StaticNotification` has been renamed to `Callout`.Run the following codemod to automatically update usages in yourproject: `npx @carbon/upgrade migrate refactor-to-callout --write`") : void 0;
    didWarnAboutDeprecation4 = true;
  }
  return import_react164.default.createElement(Callout, props);
};

// node_modules/@carbon/react/es/components/NumberInput/NumberInput.Skeleton.js
var import_prop_types123 = __toESM(require_prop_types());
var import_react165 = __toESM(require_react());
var import_classnames102 = __toESM(require_classnames());
function NumberInputSkeleton({
  hideLabel,
  className,
  size: size4 = "md",
  ...rest
}) {
  const prefix = usePrefix();
  return import_react165.default.createElement("div", _extends({
    className: (0, import_classnames102.default)(`${prefix}--form-item`, className)
  }, rest), !hideLabel && import_react165.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react165.default.createElement("div", {
    className: `${prefix}--number ${prefix}--skeleton ${prefix}--number--${size4}`
  }));
}
NumberInputSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types123.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types123.default.bool,
  /**
   * Specify the size of the Number Input.
   */
  size: import_prop_types123.default.oneOf(["sm", "md", "lg"])
};

// node_modules/@carbon/react/es/components/NumberInput/NumberInput.js
var import_classnames103 = __toESM(require_classnames());
var import_prop_types125 = __toESM(require_prop_types());
var import_react167 = __toESM(require_react());

// node_modules/@carbon/react/es/internal/useNormalizedInputProps.js
var import_react166 = __toESM(require_react());
var useNormalizedInputProps = ({
  id,
  readOnly,
  disabled,
  invalid,
  invalidText,
  warn: warn2,
  warnText
}) => {
  const prefix = usePrefix();
  const normalizedProps = {
    disabled: !readOnly && disabled,
    invalid: !readOnly && invalid,
    invalidId: `${id}-error-msg`,
    warn: !readOnly && !invalid && warn2,
    warnId: `${id}-warn-msg`,
    validation: null,
    icon: null,
    helperId: `${id}-helper-text`
  };
  if (normalizedProps.invalid) {
    normalizedProps.icon = WarningFilled;
    normalizedProps.validation = import_react166.default.createElement(Text, {
      as: "div",
      className: `${prefix}--form-requirement`,
      id: normalizedProps.invalidId
    }, invalidText);
  } else if (normalizedProps.warn) {
    normalizedProps.icon = WarningAltFilled;
    normalizedProps.validation = import_react166.default.createElement(Text, {
      as: "div",
      className: `${prefix}--form-requirement`,
      id: normalizedProps.warnId
    }, warnText);
  }
  return normalizedProps;
};

// node_modules/@carbon/utilities/es/overflowHandler/overflowHandler.js
function v(e2, t3) {
  if (!e2) return 0;
  const a = e2.style.display;
  !e2.offsetParent && getComputedStyle(e2).display === "none" && (e2.style.display = "inline-block");
  const o3 = e2.getBoundingClientRect()[t3];
  return e2.style.display = a, o3;
}
function w({ container: e2, items: t3, offset: a, sizes: o3, fixedSizes: f, offsetSize: c, maxVisibleItems: l2, dimension: m, onChange: E, previousHiddenItems: u = [] }) {
  const H = m === "width" ? e2.clientWidth : e2.clientHeight;
  let s = [], i = [];
  const p = o3.reduce((r2, d) => r2 + d, 0), n2 = f.reduce((r2, d) => r2 + d, 0);
  if (p + n2 <= H) s = l2 ? t3.slice(0, l2) : [...t3], i = l2 ? t3.slice(l2) : [];
  else {
    const r2 = H - c;
    let d = 0;
    for (let h = 0; h < t3.length; h++) {
      const g = o3[h];
      d + g + n2 <= r2 && (!l2 || s.length < l2) ? (s.push(t3[h]), d += g) : i.push(t3[h]);
    }
  }
  return u.length === i.length && u.every((r2, d) => r2 === i[d]) ? u : (s.forEach((r2) => r2.removeAttribute("data-hidden")), i.forEach((r2) => r2.setAttribute("data-hidden", "")), a && a.toggleAttribute("data-hidden", i.length === 0), E(s, i), i);
}
function L({ container: e2, maxVisibleItems: t3, onChange: a, dimension: o3 = "width" }) {
  if (!(e2 instanceof HTMLElement)) throw new Error("container must be an HTMLElement");
  if (typeof a != "function") throw new Error("onChange must be a function");
  if (t3 !== void 0 && (!Number.isInteger(t3) || t3 <= 0)) throw new Error("maxVisibleItems must be a positive integer");
  const f = Array.from(e2.children), c = f.find((n2) => n2.hasAttribute("data-offset")), l2 = f.filter((n2) => n2.hasAttribute("data-fixed")), m = f.filter((n2) => n2 !== c && !l2.includes(n2)), E = l2.map((n2) => v(n2, o3)), u = m.map((n2) => v(n2, o3)), H = v(c, o3);
  let s = [];
  function i() {
    s = w({ container: e2, items: m, offset: c, sizes: u, fixedSizes: E, offsetSize: H, maxVisibleItems: t3, dimension: o3, onChange: a, previousHiddenItems: s });
  }
  const p = new ResizeObserver(() => requestAnimationFrame(i));
  return p.observe(e2), requestAnimationFrame(i), { disconnect() {
    p.disconnect();
  } };
}

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "°",
      "ja-JP": " 度",
      "zh-TW": "度",
      "sl-SI": " °"
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit) return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function") return this.numberFormatter.formatRange(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    return `${this.format(start)} – ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function") return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start) throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: " – ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {
      ...options,
      signDisplay: this.options.signDisplay
    };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit") options = {
      ...options,
      style: "unit",
      unit: this.options.unit,
      unitDisplay: this.options.unitDisplay
    };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-")) locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit) throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b2) => a[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto") return numberFormat.format(num);
  else if (signDisplay === "never") return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always") needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);
      else needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1) console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec",
  "deva",
  "beng",
  "fullwide"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS) if (numberingSystem !== defaultParser.options.numberingSystem) {
      let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
      if (parser.isValidPartialNumber(value)) return parser;
    }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a, b2) => a[0] < b2[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign) fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      fullySanitizedValue = fullySanitizedValue.replace("+", "");
      let index3 = fullySanitizedValue.indexOf(".");
      if (index3 === -1) index3 = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index3 - 2 === 0) fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index3 - 2 === -1) fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index3 - 2 === -2) fullySanitizedValue = "0.00";
      else fullySanitizedValue = `${fullySanitizedValue.slice(0, index3 - 2)}.${fullySanitizedValue.slice(index3 - 2)}`;
      if (isNegative > -1) fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue)) return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign) value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.symbols.group === "’" && value.includes("'")) value = $6c7bd7858deea686$var$replaceAll(value, "'", this.symbols.group);
    if (this.options.locale === "fr-FR" && this.symbols.group) {
      value = $6c7bd7858deea686$var$replaceAll(value, " ", this.symbols.group);
      value = $6c7bd7858deea686$var$replaceAll(value, /\u00A0/g, this.symbols.group);
    }
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group)) return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0) return false;
    if (this.symbols.group) value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal) value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    if (options.roundingIncrement !== 1 && options.roundingIncrement != null) {
      if (options.maximumFractionDigits == null && options.minimumFractionDigits == null) {
        options.maximumFractionDigits = 0;
        options.minimumFractionDigits = 0;
      } else if (options.maximumFractionDigits == null) options.maximumFractionDigits = options.minimumFractionDigits;
      else if (options.minimumFractionDigits == null) options.minimumFractionDigits = options.maximumFractionDigits;
    }
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18)) console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    // Resets so we get the full range of symbols
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21,
    roundingIncrement: 1,
    roundingPriority: "auto",
    roundingMode: "halfExpand"
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n2) => symbolFormatter.formatToParts(n2));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always")) plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a, b2) => b2.length - a.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index3 = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group,
    literals,
    numeral,
    index: index3
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
  if (str.replaceAll) return str.replaceAll(find, replace);
  return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@carbon/utilities/es/documentLang/documentLang.js
var t2 = typeof document < "u";
var o2 = t2 ? document.documentElement.lang : "";

// node_modules/@carbon/react/es/components/NumberInput/NumberFormatPropTypes.js
var import_prop_types124 = __toESM(require_prop_types());
var NumberFormatOptionsPropType = import_prop_types124.default.shape({
  // Locale Options
  localeMatcher: import_prop_types124.default.oneOf(["best fit", "lookup"]),
  // Style Options
  style: import_prop_types124.default.oneOf(["decimal", "currency", "percent", "unit"]),
  currency: import_prop_types124.default.string,
  // e.g., 'USD'
  currencyDisplay: import_prop_types124.default.oneOf(["symbol", "narrowSymbol", "code", "name"]),
  currencySign: import_prop_types124.default.oneOf(["standard", "accounting"]),
  unit: import_prop_types124.default.string,
  // e.g., 'liter', 'mile-per-hour'
  unitDisplay: import_prop_types124.default.oneOf(["short", "narrow", "long"]),
  notation: import_prop_types124.default.oneOf(["standard", "scientific", "engineering", "compact"]),
  compactDisplay: import_prop_types124.default.oneOf(["short", "long"]),
  signDisplay: import_prop_types124.default.oneOf(["auto", "never", "always", "exceptZero"]),
  // Digit Options
  minimumIntegerDigits: import_prop_types124.default.number,
  minimumFractionDigits: import_prop_types124.default.number,
  maximumFractionDigits: import_prop_types124.default.number,
  minimumSignificantDigits: import_prop_types124.default.number,
  maximumSignificantDigits: import_prop_types124.default.number,
  useGrouping: import_prop_types124.default.oneOfType([import_prop_types124.default.bool, import_prop_types124.default.oneOf(["always", "auto", "min2"])]),
  // Misc/Other Options
  numberingSystem: import_prop_types124.default.string,
  // e.g., 'latn', 'arab'
  roundingIncrement: import_prop_types124.default.number,
  roundingMode: import_prop_types124.default.oneOf(["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"]),
  trailingZeroDisplay: import_prop_types124.default.oneOf(["auto", "stripIfInteger"])
});

// node_modules/@carbon/react/es/components/NumberInput/NumberInput.js
var _Subtract;
var _Add;
var translationIds3 = {
  "increment.number": "increment.number",
  "decrement.number": "decrement.number"
};
var defaultTranslations7 = {
  [translationIds3["increment.number"]]: "Increment number",
  [translationIds3["decrement.number"]]: "Decrement number"
};
var NumberInput = import_react167.default.forwardRef(function NumberInput2(props, forwardRef36) {
  const {
    allowEmpty = false,
    className: customClassName,
    decorator,
    disabled = false,
    disableWheel: disableWheelProp = false,
    formatOptions,
    helperText = "",
    hideLabel = false,
    hideSteppers,
    iconDescription,
    id,
    inputMode = "decimal",
    invalid = false,
    invalidText,
    label,
    light,
    locale = "en-US",
    max: max2,
    min: min2,
    onBlur,
    onChange,
    onClick,
    onKeyUp,
    pattern = "[0-9]*",
    readOnly,
    size: size4 = "md",
    slug,
    step = 1,
    translateWithId: t3 = (id2) => defaultTranslations7[id2],
    type = "number",
    defaultValue = type === "number" ? 0 : NaN,
    warn: warn2 = false,
    warnText = "",
    stepStartValue = 0,
    value: controlledValue,
    ...rest
  } = props;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react167.useContext)(FormContext);
  const [isFocused, setIsFocused] = (0, import_react167.useState)(false);
  const [value, setValue] = (0, import_react167.useState)(() => {
    if (controlledValue !== void 0) {
      return controlledValue;
    }
    if (defaultValue !== void 0) {
      return defaultValue;
    }
    if (allowEmpty) {
      return "";
    }
    return 0;
  });
  const [prevControlledValue, setPrevControlledValue] = (0, import_react167.useState)(controlledValue);
  const numberParser = (0, import_react167.useMemo)(() => new $6c7bd7858deea686$export$cd11ab140839f11d(locale, formatOptions), [locale, formatOptions]);
  const [numberValue, setNumberValue, isControlled] = useControllableState({
    name: "NumberInput",
    defaultValue: typeof defaultValue === "string" ? numberParser.parse(defaultValue) : defaultValue,
    value: typeof controlledValue === "string" ? numberParser.parse(controlledValue) : controlledValue
  });
  const [previousNumberValue, setPreviousNumberValue] = (0, import_react167.useState)(numberValue);
  const [inputValue, setInputValue] = import_react167.default.useState(() => isNaN(numberValue) ? "" : new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(locale, formatOptions).format(numberValue));
  const numberingSystem = (0, import_react167.useMemo)(() => numberParser.getNumberingSystem(inputValue), [numberParser, inputValue]);
  const numberFormatter = (0, import_react167.useMemo)(() => new $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5(locale, {
    ...formatOptions,
    numberingSystem
  }), [locale, formatOptions, numberingSystem]);
  const format = (0, import_react167.useCallback)((value2) => isNaN(value2) || value2 === null ? "" : numberFormatter.format(value2), [numberFormatter]);
  if (isControlled && !(isNaN(previousNumberValue) && isNaN(numberValue)) && previousNumberValue !== numberValue) {
    setInputValue(format(numberValue));
    setPreviousNumberValue(numberValue);
  }
  const inputRef = (0, import_react167.useRef)(null);
  const ref = useMergedRefs([forwardRef36, inputRef]);
  const numberInputClasses = (0, import_classnames103.default)({
    [`${prefix}--number`]: true,
    [`${prefix}--number--helpertext`]: true,
    [`${prefix}--number--readonly`]: readOnly,
    [`${prefix}--number--light`]: light,
    [`${prefix}--number--nolabel`]: hideLabel,
    [`${prefix}--number--nosteppers`]: hideSteppers,
    [`${prefix}--number--${size4}`]: size4
  });
  const isInputValid = getInputValidity({
    allowEmpty,
    invalid,
    value: type === "number" ? value : numberValue,
    max: max2,
    min: min2
  });
  const normalizedProps = useNormalizedInputProps({
    id,
    readOnly,
    disabled,
    invalid: !isInputValid,
    invalidText,
    warn: warn2,
    warnText
  });
  const [incrementNumLabel, decrementNumLabel] = [t3("increment.number"), t3("decrement.number")];
  const wrapperClasses = (0, import_classnames103.default)(`${prefix}--number__input-wrapper`, {
    [`${prefix}--number__input-wrapper--warning`]: normalizedProps.warn,
    [`${prefix}--number__input-wrapper--slug`]: slug,
    [`${prefix}--number__input-wrapper--decorator`]: decorator
  });
  const iconClasses = (0, import_classnames103.default)({
    [`${prefix}--number__invalid`]: normalizedProps.invalid || normalizedProps.warn,
    [`${prefix}--number__invalid--warning`]: normalizedProps.warn
  });
  if (controlledValue !== prevControlledValue && !(isNaN(Number(controlledValue)) === isNaN(Number(prevControlledValue)))) {
    setValue(controlledValue);
    setPrevControlledValue(controlledValue);
  }
  let ariaDescribedBy = void 0;
  if (normalizedProps.invalid) {
    ariaDescribedBy = normalizedProps.invalidId;
  }
  if (normalizedProps.warn) {
    ariaDescribedBy = normalizedProps.warnId;
  }
  if (!normalizedProps.validation) {
    ariaDescribedBy = helperText ? normalizedProps.helperId : void 0;
  }
  function handleOnChange(event) {
    if (disabled) {
      return;
    }
    if (type === "number") {
      const state = {
        value: allowEmpty && event.target.value === "" ? "" : Number(event.target.value),
        direction: value < event.target.value ? "up" : "down"
      };
      setValue(state.value);
      if (onChange) {
        onChange(event, state);
      }
      return;
    }
    if (type === "text") {
      const _value = allowEmpty && event.target.value === "" ? "" : event.target.value;
      setNumberValue(numberParser.parse(_value));
      setInputValue(_value);
    }
  }
  const handleFocus = (evt) => {
    if ("type" in evt.target && evt.target.type === "button") {
      setIsFocused(false);
    } else {
      setIsFocused(evt.type === "focus" ? true : false);
    }
  };
  const outerElementClasses = (0, import_classnames103.default)(`${prefix}--form-item`, {
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    [customClassName]: !!customClassName,
    [`${prefix}--number-input--fluid--invalid`]: isFluid && normalizedProps.invalid,
    [`${prefix}--number-input--fluid--focus`]: isFluid && isFocused,
    [`${prefix}--number-input--fluid--disabled`]: isFluid && disabled
  });
  const Icon = normalizedProps.icon;
  const getDecimalPlaces = (num) => {
    const parts = num.toString().split(".");
    return parts[1] ? parts[1].length : 0;
  };
  const handleStep = (event, direction) => {
    if (inputRef.current) {
      const currentValue = type === "number" ? Number(inputRef.current.value) : numberValue;
      let rawValue;
      if (Number.isNaN(currentValue) || !currentValue) {
        if (typeof stepStartValue === "number" && stepStartValue) {
          rawValue = stepStartValue;
        } else if (min2 && min2 < 0 && max2 && max2 > 0 || !max2 && !min2 || max2) {
          if (direction === `up`) rawValue = 1;
          if (direction === `down`) rawValue = -1;
        } else if (min2 && min2 > 0 && max2 && max2 > 0 || min2) {
          rawValue = min2;
        } else {
          rawValue = 0;
        }
      } else if (direction === "up") {
        rawValue = currentValue + step;
      } else {
        rawValue = currentValue - step;
      }
      const precision = Math.max(getDecimalPlaces(currentValue), getDecimalPlaces(step));
      const floatValue = parseFloat(rawValue.toFixed(precision));
      const newValue = clamp2(floatValue, min2 ?? -Infinity, max2 ?? Infinity);
      const state = {
        value: newValue,
        direction
      };
      if (type === "number") {
        setValue(state.value);
      }
      if (type === "text") {
        const formattedNewValue = format(newValue);
        const parsedFormattedNewValue = numberParser.parse(formattedNewValue);
        setNumberValue(parsedFormattedNewValue);
        setInputValue(formattedNewValue);
        setPreviousNumberValue(parsedFormattedNewValue);
      }
      if (onChange) {
        onChange(event, state);
      }
      return state;
    }
  };
  const handleStepperClick = (event, direction) => {
    if (inputRef.current) {
      const state = handleStep(event, direction);
      if (onClick) {
        onClick(event, state);
      }
    }
  };
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react167.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  let isRevertActive;
  if ((normalizedDecorator == null ? void 0 : normalizedDecorator.type) === AILabel) {
    isRevertActive = normalizedDecorator.props.revertActive;
  }
  (0, import_react167.useEffect)(() => {
    if (!isRevertActive && slug && defaultValue) {
      setValue(defaultValue);
    }
  }, [defaultValue, isRevertActive, slug]);
  return import_react167.default.createElement("div", {
    className: outerElementClasses,
    onFocus: isFluid ? handleFocus : void 0,
    onBlur: isFluid ? handleFocus : void 0
  }, import_react167.default.createElement("div", {
    className: numberInputClasses,
    "data-invalid": normalizedProps.invalid ? true : void 0
  }, import_react167.default.createElement(Label, {
    disabled: normalizedProps.disabled,
    hideLabel,
    id,
    label
  }), import_react167.default.createElement("div", {
    className: wrapperClasses
  }, import_react167.default.createElement("input", _extends({}, rest, {
    "data-invalid": normalizedProps.invalid ? true : void 0,
    "aria-invalid": normalizedProps.invalid,
    "aria-describedby": ariaDescribedBy,
    "aria-readonly": readOnly,
    disabled: normalizedProps.disabled,
    ref,
    id,
    max: max2,
    min: min2,
    onClick,
    onChange: handleOnChange,
    onKeyUp,
    onKeyDown: (e2) => {
      if (type === "text") {
        match(e2, ArrowUp2) && handleStep(e2, "up");
        match(e2, ArrowDown) && handleStep(e2, "down");
      }
      if (rest == null ? void 0 : rest.onKeyDown) {
        rest == null ? void 0 : rest.onKeyDown(e2);
      }
    },
    onFocus: (e2) => {
      if (disableWheelProp) {
        e2.target.addEventListener("wheel", disableWheel);
      }
      if (rest.onFocus) {
        rest.onFocus(e2);
      }
    },
    onBlur: (e2) => {
      if (disableWheelProp) {
        e2.target.removeEventListener("wheel", disableWheel);
      }
      if (type === "text") {
        const _numberValue = isControlled ? numberParser.parse(inputValue) : numberValue;
        const formattedValue = isNaN(_numberValue) ? "" : format(_numberValue);
        setInputValue(formattedValue);
        const parsedFormattedNewValue = numberParser.parse(formattedValue);
        if (onChange) {
          const state = {
            value: parsedFormattedNewValue,
            direction: previousNumberValue < parsedFormattedNewValue ? "up" : "down"
          };
          if (!(isNaN(previousNumberValue) && isNaN(parsedFormattedNewValue))) {
            onChange(e2, state);
          }
        }
        if (!(isNaN(previousNumberValue) && isNaN(numberValue))) {
          setPreviousNumberValue(numberValue);
        }
        if (!(isNaN(numberValue) && isNaN(parsedFormattedNewValue))) {
          setNumberValue(parsedFormattedNewValue);
        }
      }
      if (onBlur) {
        onBlur(e2);
      }
    },
    pattern,
    inputMode,
    readOnly,
    step,
    type,
    value: type === "number" ? value : inputValue
  })), slug ? normalizedDecorator : decorator ? import_react167.default.createElement("div", {
    className: `${prefix}--number__input-inner-wrapper--decorator`
  }, normalizedDecorator) : "", Icon ? import_react167.default.createElement(Icon, {
    className: iconClasses
  }) : null, !hideSteppers && import_react167.default.createElement("div", {
    className: `${prefix}--number__controls`
  }, import_react167.default.createElement("button", {
    "aria-label": decrementNumLabel || iconDescription,
    className: `${prefix}--number__control-btn down-icon`,
    disabled: disabled || readOnly,
    onClick: (event) => handleStepperClick(event, "down"),
    onBlur,
    tabIndex: -1,
    title: decrementNumLabel || iconDescription,
    type: "button"
  }, _Subtract || (_Subtract = import_react167.default.createElement(Subtract, {
    className: "down-icon"
  }))), import_react167.default.createElement("div", {
    className: `${prefix}--number__rule-divider`
  }), import_react167.default.createElement("button", {
    "aria-label": incrementNumLabel || iconDescription,
    className: `${prefix}--number__control-btn up-icon`,
    disabled: disabled || readOnly,
    onClick: (event) => handleStepperClick(event, "up"),
    onBlur,
    tabIndex: -1,
    title: incrementNumLabel || iconDescription,
    type: "button"
  }, _Add || (_Add = import_react167.default.createElement(Add, {
    className: "up-icon"
  }))), import_react167.default.createElement("div", {
    className: `${prefix}--number__rule-divider`
  }))), isFluid && import_react167.default.createElement("hr", {
    className: `${prefix}--number-input__divider`
  }), normalizedProps.validation ? normalizedProps.validation : import_react167.default.createElement(HelperText, {
    id: normalizedProps.helperId,
    disabled,
    description: helperText
  })));
});
NumberInput.propTypes = {
  /**
   * `true` to allow empty string.
   */
  allowEmpty: import_prop_types125.default.bool,
  /**
   * Specify an optional className to be applied to the wrapper node
   */
  className: import_prop_types125.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `NumberInput` component
   */
  decorator: import_prop_types125.default.node,
  /**
   * Optional starting value for uncontrolled state
   */
  defaultValue: import_prop_types125.default.oneOfType([import_prop_types125.default.number, import_prop_types125.default.string]),
  /**
   * Specify if the wheel functionality for the input should be disabled, or no t
   */
  disableWheel: import_prop_types125.default.bool,
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: import_prop_types125.default.bool,
  /**
   * **Experimental:** Specify Intl.NumberFormat options applied to internal
   * number parsing and formatting. Use with `type="text"`, has no effect when
   * `type="number"`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   */
  formatOptions: NumberFormatOptionsPropType,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types125.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types125.default.bool,
  /**
   * Specify whether you want the steppers to be hidden
   */
  hideSteppers: import_prop_types125.default.bool,
  /**
   * Provide a description for up/down icons that can be read by screen readers
   */
  iconDescription: import_prop_types125.default.string,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types125.default.string.isRequired,
  /**
   * Instruct the browser which keyboard to display on mobile devices. Defaults
   * to `decimal`, but note that standard numeric keyboards vary across devices
   * and operating systems.
   * @see https://css-tricks.com/everything-you-ever-wanted-to-know-about-inputmode/
   */
  inputMode: import_prop_types125.default.oneOf(["none", "text", "tel", "url", "email", "numeric", "decimal", "search"]),
  /**
   * Specify if the currently value is invalid.
   */
  invalid: import_prop_types125.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types125.default.node,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types125.default.node,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types125.default.bool, "The `light` prop for `NumberInput` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * **Experimental:** Specify a [BCP47](https://www.ietf.org/rfc/bcp/bcp47.txt)
   * language code for parsing and formatting. Use with `type="text"`, has no
   * effect when `type="number"`.
   */
  locale: import_prop_types125.default.string,
  /**
   * The maximum value.
   */
  max: import_prop_types125.default.number,
  /**
   * The minimum value.
   */
  min: import_prop_types125.default.number,
  /**
   * Provide the value stepping should begin at when the input is empty
   */
  stepStartValue: import_prop_types125.default.number,
  /**
   * Provide an optional handler that is called when the input or stepper
   * buttons are blurred.
   */
  onBlur: import_prop_types125.default.func,
  /**
   * Provide an optional handler that is called when the internal state of
   * NumberInput changes. This handler is called with event and state info.
   * When type="number", this is called on every change of the input.
   * When type="text", this is only called on blur after the number has been
   * parsed and formatted.
   * `(event, { value, direction }) => void`
   */
  onChange: import_prop_types125.default.func,
  /**
   * Provide an optional function to be called when the up/down button is clicked
   */
  onClick: import_prop_types125.default.func,
  /**
   * Provide an optional function to be called when a key is pressed in the number input
   */
  onKeyUp: import_prop_types125.default.func,
  /**
   * When type="text", provide an optional pattern to restrict user input. Has
   * no effect when type="number".
   */
  pattern: import_prop_types125.default.string,
  /**
   * Specify if the component should be read-only
   */
  readOnly: import_prop_types125.default.bool,
  /**
   * Specify the size of the Number Input.
   */
  size: import_prop_types125.default.oneOf(["sm", "md", "lg"]),
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the
   * `NumberInput` component
   */
  slug: deprecate(import_prop_types125.default.node, "The `slug` prop for `NumberInput` is no longer needed and has been deprecated in v11 in favor of the new `decorator` prop. It will be moved in the next major release."),
  /**
   * Specify how much the values should increase/decrease upon clicking on
   * up/down button
   */
  step: import_prop_types125.default.number,
  /**
   * Provide custom text for the component for each translation id
   */
  translateWithId: import_prop_types125.default.func,
  /**
   * **Experimental**: Specify if the input should be of type text or number.
   * Use type="text" with `locale`, `formatOptions`, and guide user input with
   * `pattern` and `inputMode`.
   */
  type: import_prop_types125.default.oneOf(["number", "text"]),
  /**
   * Specify the value of the input
   */
  value: import_prop_types125.default.oneOfType([import_prop_types125.default.number, import_prop_types125.default.string]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types125.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types125.default.node
};
var Label = ({
  disabled,
  id,
  hideLabel,
  label
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames103.default)({
    [`${prefix}--label`]: true,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--visually-hidden`]: hideLabel
  });
  if (label) {
    return import_react167.default.createElement(Text, {
      as: "label",
      htmlFor: id,
      className
    }, label);
  }
  return null;
};
Label.propTypes = {
  disabled: import_prop_types125.default.bool,
  hideLabel: import_prop_types125.default.bool,
  id: import_prop_types125.default.string,
  label: import_prop_types125.default.node
};
function HelperText({
  disabled,
  description,
  id
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames103.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  if (description) {
    return import_react167.default.createElement(Text, {
      as: "div",
      id,
      className
    }, description);
  }
  return null;
}
HelperText.propTypes = {
  description: import_prop_types125.default.node,
  disabled: import_prop_types125.default.bool,
  id: import_prop_types125.default.string
};
function getInputValidity({
  allowEmpty,
  invalid,
  value,
  max: max2,
  min: min2
}) {
  if (invalid) {
    return false;
  }
  if (value === "") {
    return allowEmpty;
  }
  if (value > max2 || value < min2) {
    return false;
  }
  return true;
}
function disableWheel(e2) {
  e2.preventDefault();
}

// node_modules/@carbon/react/es/components/OrderedList/OrderedList.js
var import_prop_types126 = __toESM(require_prop_types());
var import_react168 = __toESM(require_react());
var import_classnames104 = __toESM(require_classnames());
function OrderedList({
  className,
  nested = false,
  native = false,
  isExpressive = false,
  ...other
}) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames104.default)({
    [`${prefix}--list--ordered`]: !native,
    [`${prefix}--list--ordered--native`]: native,
    [`${prefix}--list--nested`]: nested,
    [`${prefix}--list--expressive`]: isExpressive
  }, className);
  return import_react168.default.createElement("ol", _extends({
    className: classNames
  }, other));
}
OrderedList.propTypes = {
  /**
   * Provide list items to be rendered in the ordered list
   */
  children: import_prop_types126.default.node,
  /**
   * Provide an optional className to be applied to the containing <ol> node
   */
  className: import_prop_types126.default.string,
  /**
   * Specify whether this ordered list expressive or not
   */
  isExpressive: import_prop_types126.default.bool,
  /**
   * Specify whether this ordered list should use native list styles instead of custom counter
   */
  native: import_prop_types126.default.bool,
  /**
   * Specify whether this ordered list is nested inside of another nested list
   */
  nested: import_prop_types126.default.bool
};

// node_modules/@carbon/react/es/components/PageHeader/index.js
var PageHeader_exports = {};
__export(PageHeader_exports, {
  BreadcrumbBar: () => BreadcrumbBar,
  Content: () => Content,
  ContentPageActions: () => ContentPageActions,
  ContentText: () => ContentText,
  HeroImage: () => HeroImage,
  PageHeader: () => PageHeader,
  PageHeaderBreadcrumbBar: () => PageHeaderBreadcrumbBar,
  PageHeaderContent: () => PageHeaderContent,
  PageHeaderContentPageActions: () => PageHeaderContentPageActions,
  PageHeaderContentText: () => PageHeaderContentText,
  PageHeaderHeroImage: () => PageHeaderHeroImage,
  PageHeaderTabBar: () => PageHeaderTabBar,
  Root: () => Root,
  TabBar: () => TabBar
});

// node_modules/@carbon/react/es/components/PageHeader/PageHeader.js
var import_react176 = __toESM(require_react());
var import_prop_types132 = __toESM(require_prop_types());
var import_classnames110 = __toESM(require_classnames());

// node_modules/@carbon/layout/es/index.js
var baseFontSize = 16;
function rem(px) {
  return "".concat(px / baseFontSize, "rem");
}
var breakpoints = {
  sm: {
    width: rem(320),
    columns: 4,
    margin: "0"
  },
  md: {
    width: rem(672),
    columns: 8,
    margin: rem(16)
  },
  lg: {
    width: rem(1056),
    columns: 16,
    margin: rem(16)
  },
  xlg: {
    width: rem(1312),
    columns: 16,
    margin: rem(16)
  },
  max: {
    width: rem(1584),
    columns: 16,
    margin: rem(24)
  }
};
var miniUnit = 8;
function miniUnits(count2) {
  return rem(miniUnit * count2);
}
var spacing01 = miniUnits(0.25);
var spacing02 = miniUnits(0.5);
var spacing03 = miniUnits(1);
var spacing04 = miniUnits(1.5);
var spacing05 = miniUnits(2);
var spacing06 = miniUnits(3);
var spacing07 = miniUnits(4);
var spacing08 = miniUnits(5);
var spacing09 = miniUnits(6);
var spacing10 = miniUnits(8);
var spacing11 = miniUnits(10);
var spacing12 = miniUnits(12);
var spacing13 = miniUnits(20);
var spacing2 = [spacing01, spacing02, spacing03, spacing04, spacing05, spacing06, spacing07, spacing08, spacing09, spacing10, spacing11, spacing12, spacing13];
var layout01 = miniUnits(2);
var layout02 = miniUnits(3);
var layout03 = miniUnits(4);
var layout04 = miniUnits(6);
var layout05 = miniUnits(8);
var layout06 = miniUnits(12);
var layout07 = miniUnits(20);
var container01 = miniUnits(3);
var container02 = miniUnits(4);
var container03 = miniUnits(5);
var container04 = miniUnits(6);
var container05 = miniUnits(8);
var sizeXSmall = rem(24);
var sizeSmall = rem(32);
var sizeMedium = rem(40);
var sizeLarge = rem(48);
var sizeXLarge = rem(64);
var size2XLarge = rem(80);

// node_modules/@carbon/react/es/internal/useMatchMedia.js
var import_react169 = __toESM(require_react());
var useMatchMedia = (mediaQuery, defaultState = false) => {
  const [matches3, setMatches] = (0, import_react169.useState)(defaultState);
  (0, import_react169.useEffect)(() => {
    const listener = (event) => {
      setMatches(event.matches);
    };
    const mediaQueryList = window.matchMedia(mediaQuery);
    mediaQueryList.addEventListener("change", listener);
    setMatches(mediaQueryList.matches);
    return () => {
      mediaQueryList.removeEventListener("change", listener);
    };
  }, [mediaQuery]);
  return matches3;
};

// node_modules/@carbon/react/es/components/Tag/Tag.js
var import_prop_types127 = __toESM(require_prop_types());
var import_react170 = __toESM(require_react());
var import_classnames105 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Tag/isEllipsisActive.js
var isEllipsisActive = (element) => {
  if (element) {
    return (element == null ? void 0 : element.offsetWidth) < (element == null ? void 0 : element.scrollWidth);
  }
  return false;
};

// node_modules/@carbon/react/es/components/Tag/Tag.js
var _Close6;
var TYPES = {
  red: "Red",
  magenta: "Magenta",
  purple: "Purple",
  blue: "Blue",
  cyan: "Cyan",
  teal: "Teal",
  green: "Green",
  gray: "Gray",
  "cool-gray": "Cool-Gray",
  "warm-gray": "Warm-Gray",
  "high-contrast": "High-Contrast",
  outline: "Outline"
};
var SIZES = {
  sm: "sm",
  md: "md",
  lg: "lg"
};
var TagBase = import_react170.default.forwardRef(({
  children,
  className,
  decorator,
  id,
  type,
  filter,
  // remove filter in next major release - V12
  renderIcon: CustomIconElement,
  title = "Clear filter",
  // remove title in next major release - V12
  disabled,
  onClose,
  // remove onClose in next major release - V12
  size: size4,
  as: BaseComponent,
  slug,
  ...other
}, forwardRef36) => {
  const prefix = usePrefix();
  const tagRef = (0, import_react170.useRef)(null);
  if (filter) {
    console.warn("The `filter` prop for Tag has been deprecated and will be removed in the next major version. Use DismissibleTag instead.");
  }
  if (onClose) {
    console.warn("The `onClose` prop for Tag has been deprecated and will be removed in the next major version. Use DismissibleTag instead.");
  }
  const ref = useMergedRefs([forwardRef36, tagRef]);
  const tagId = id || `tag-${useId()}`;
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react170.useState)(false);
  (0, import_react170.useLayoutEffect)(() => {
    var _a;
    const newElement = (_a = tagRef.current) == null ? void 0 : _a.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagRef]);
  const conditions = [`${prefix}--tag--selectable`, `${prefix}--tag--filter`, `${prefix}--tag--operational`];
  const isInteractiveTag = conditions.some((el) => className == null ? void 0 : className.includes(el));
  const tagClasses = (0, import_classnames105.default)(`${prefix}--tag`, className, {
    [`${prefix}--tag--disabled`]: disabled,
    [`${prefix}--tag--filter`]: filter,
    [`${prefix}--tag--${size4}`]: size4,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4,
    [`${prefix}--tag--${type}`]: type,
    [`${prefix}--tag--interactive`]: other.onClick && !isInteractiveTag && isEllipsisApplied
  });
  const typeText = type !== void 0 && type in Object.keys(TYPES) ? TYPES[type] : "";
  const handleClose = (event) => {
    if (onClose) {
      event.stopPropagation();
      onClose(event);
    }
  };
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel && !isInteractiveTag ? (0, import_react170.cloneElement)(candidate, {
    size: "sm",
    kind: "inline"
  }) : null;
  if (filter) {
    const ComponentTag2 = BaseComponent ?? "div";
    return import_react170.default.createElement(ComponentTag2, _extends({
      className: tagClasses,
      id: tagId
    }, other), CustomIconElement && size4 !== "sm" ? import_react170.default.createElement("div", {
      className: `${prefix}--tag__custom-icon`
    }, import_react170.default.createElement(CustomIconElement, null)) : "", import_react170.default.createElement(Text, {
      title: typeof children === "string" ? children : void 0,
      className: `${prefix}--tag__label`
    }, children !== null && children !== void 0 ? children : typeText), normalizedDecorator, import_react170.default.createElement("button", {
      type: "button",
      className: `${prefix}--tag__close-icon`,
      onClick: handleClose,
      disabled,
      "aria-label": title,
      title
    }, _Close6 || (_Close6 = import_react170.default.createElement(Close, null))));
  }
  const ComponentTag = BaseComponent ?? (other.onClick || (className == null ? void 0 : className.includes(`${prefix}--tag--operational`)) ? "button" : "div");
  const labelClasses = (0, import_classnames105.default)({
    [`${prefix}--tag__label`]: !isInteractiveTag
  });
  return import_react170.default.createElement(ComponentTag, _extends({
    ref,
    disabled,
    className: tagClasses,
    id: tagId,
    type: ComponentTag === "button" ? "button" : void 0
  }, other), CustomIconElement && size4 !== "sm" ? import_react170.default.createElement("div", {
    className: `${prefix}--tag__custom-icon`
  }, import_react170.default.createElement(CustomIconElement, null)) : "", isEllipsisApplied && !isInteractiveTag ? import_react170.default.createElement(DefinitionTooltip, {
    openOnHover: false,
    definition: children !== null && children !== void 0 ? children : typeText,
    className: `${prefix}--definition--tooltip--tag`
  }, import_react170.default.createElement(Text, {
    title: children !== null && children !== void 0 && typeof children === "string" ? children : typeText,
    className: labelClasses
  }, children !== null && children !== void 0 ? children : typeText)) : import_react170.default.createElement(Text, {
    title: children !== null && children !== void 0 && typeof children === "string" ? children : typeText,
    className: labelClasses
  }, children !== null && children !== void 0 ? children : typeText), slug ? normalizedDecorator : decorator ? import_react170.default.createElement("div", {
    className: `${prefix}--tag__decorator`
  }, normalizedDecorator) : "");
});
var Tag = TagBase;
Tag.propTypes = {
  /**
   * Provide an alternative tag or component to use instead of the default
   * wrapping element
   */
  as: import_prop_types127.default.elementType,
  /**
   * Provide content to be rendered inside of a `Tag`
   */
  children: import_prop_types127.default.node,
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types127.default.string,
  /**
   * **Experimental:** Provide a `decorator` component to be rendered inside the `Tag` component
   */
  decorator: import_prop_types127.default.node,
  /**
   * Specify if the `Tag` is disabled
   */
  disabled: import_prop_types127.default.bool,
  /**
   * Determine if `Tag` is a filter/chip
   */
  filter: deprecate(import_prop_types127.default.bool, "The `filter` prop has been deprecated and will be removed in the next major version. Use DismissibleTag instead."),
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types127.default.string,
  /**
   * Click handler for filter tag close button.
   */
  onClose: deprecate(import_prop_types127.default.func, "The `onClose` prop has been deprecated and will be removed in the next major version. Use DismissibleTag instead."),
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types127.default.oneOfType([import_prop_types127.default.func, import_prop_types127.default.object]),
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types127.default.oneOf(Object.keys(SIZES)),
  /**
   * **Experimental:** Provide a `Slug` component to be rendered inside the `Tag` component
   */
  slug: deprecate(import_prop_types127.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Text to show on clear filters
   */
  title: deprecate(import_prop_types127.default.string, "The `title` prop has been deprecated and will be removed in the next major version. Use DismissibleTag instead."),
  /**
   * Specify the type of the `Tag`
   */
  type: import_prop_types127.default.oneOf(Object.keys(TYPES))
};

// node_modules/@carbon/react/es/components/Tag/DismissibleTag.js
var import_prop_types128 = __toESM(require_prop_types());
var import_react171 = __toESM(require_react());
var import_classnames106 = __toESM(require_classnames());
var _Close7;
var DismissibleTag = (0, import_react171.forwardRef)(({
  className,
  decorator,
  disabled,
  id,
  renderIcon,
  title = "Dismiss",
  onClose,
  slug,
  size: size4,
  text,
  tagTitle,
  type,
  dismissTooltipLabel = "Dismiss tag",
  ...other
}, forwardRef36) => {
  const prefix = usePrefix();
  const tagLabelRef = (0, import_react171.useRef)(null);
  const tagId = id || `tag-${useId()}`;
  const tagClasses = (0, import_classnames106.default)(`${prefix}--tag--filter`, className);
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react171.useState)(false);
  (0, import_react171.useLayoutEffect)(() => {
    var _a;
    const newElement = (_a = tagLabelRef.current) == null ? void 0 : _a.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagLabelRef]);
  const combinedRef = mergeRefs(tagLabelRef, forwardRef36);
  const handleClose = (event) => {
    if (onClose) {
      event.stopPropagation();
      onClose(event);
    }
  };
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react171.cloneElement)(candidate, {
    size: "sm",
    kind: "inline"
  }) : null;
  const tooltipClasses = (0, import_classnames106.default)(`${prefix}--icon-tooltip`, `${prefix}--tag-label-tooltip`);
  const {
    onClick,
    ...otherProps
  } = other;
  const dismissActionLabel = isEllipsisApplied ? dismissTooltipLabel : title;
  return import_react171.default.createElement(Tag, _extends({
    ref: combinedRef,
    type,
    size: size4,
    renderIcon,
    disabled,
    className: tagClasses,
    id: tagId
  }, otherProps), import_react171.default.createElement("div", {
    className: `${prefix}--interactive--tag-children`
  }, import_react171.default.createElement(Text, {
    title: tagTitle ? tagTitle : text,
    className: `${prefix}--tag__label`
  }, text), slug ? normalizedDecorator : decorator ? import_react171.default.createElement("div", {
    className: `${prefix}--tag__decorator`
  }, normalizedDecorator) : "", import_react171.default.createElement(Tooltip, {
    label: dismissActionLabel,
    align: "bottom",
    className: tooltipClasses,
    leaveDelayMs: 0,
    closeOnActivation: true
  }, import_react171.default.createElement("button", {
    type: "button",
    className: `${prefix}--tag__close-icon`,
    onClick: handleClose,
    disabled,
    "aria-label": dismissActionLabel
  }, _Close7 || (_Close7 = import_react171.default.createElement(Close, null))))));
});
DismissibleTag.propTypes = {
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types128.default.string,
  /**
   * **Experimental:** Provide a `decorator` component to be rendered inside the `DismissibleTag` component
   */
  decorator: import_prop_types128.default.node,
  /**
   * Specify if the `DismissibleTag` is disabled
   */
  disabled: import_prop_types128.default.bool,
  /**
   * Provide a custom tooltip label for the dismiss button
   */
  dismissTooltipLabel: import_prop_types128.default.string,
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types128.default.string,
  /**
   * Click handler for filter tag close button.
   */
  onClose: import_prop_types128.default.func,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types128.default.oneOfType([import_prop_types128.default.func, import_prop_types128.default.object]),
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types128.default.oneOf(Object.keys(SIZES)),
  /**
   * **Experimental:** Provide a `Slug` component to be rendered inside the `DismissibleTag` component
   */
  slug: deprecate(import_prop_types128.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Provide text to be rendered inside of a the tag.
   */
  text: import_prop_types128.default.string,
  /**
   * Provide a custom `title` to be inserted in the tag.
   */
  tagTitle: import_prop_types128.default.string,
  /**
   * Text to show on clear filters
   */
  title: import_prop_types128.default.string,
  /**
   * Specify the type of the `Tag`
   */
  type: import_prop_types128.default.oneOf(Object.keys(TYPES))
};

// node_modules/@carbon/react/es/components/Tag/OperationalTag.js
var import_prop_types129 = __toESM(require_prop_types());
var import_react172 = __toESM(require_react());
var import_classnames107 = __toESM(require_classnames());
var TYPES2 = {
  red: "Red",
  magenta: "Magenta",
  purple: "Purple",
  blue: "Blue",
  cyan: "Cyan",
  teal: "Teal",
  green: "Green",
  gray: "Gray",
  "cool-gray": "Cool-Gray",
  "warm-gray": "Warm-Gray"
};
var OperationalTag = (0, import_react172.forwardRef)(({
  className,
  disabled,
  id,
  renderIcon,
  size: size4,
  text,
  type = "gray",
  ...other
}, forwardRef36) => {
  const prefix = usePrefix();
  const tagRef = (0, import_react172.useRef)(null);
  const tagId = id || `tag-${useId()}`;
  const tagClasses = (0, import_classnames107.default)(`${prefix}--tag--operational`, className);
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react172.useState)(false);
  (0, import_react172.useLayoutEffect)(() => {
    var _a;
    const newElement = (_a = tagRef.current) == null ? void 0 : _a.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagRef]);
  const tooltipClasses = (0, import_classnames107.default)(`${prefix}--icon-tooltip`, `${prefix}--tag-label-tooltip`);
  const combinedRef = mergeRefs(tagRef, forwardRef36);
  if (isEllipsisApplied) {
    return import_react172.default.createElement(Tooltip, {
      label: text,
      align: "bottom",
      className: tooltipClasses,
      leaveDelayMs: 0,
      onMouseEnter: () => false,
      closeOnActivation: true
    }, import_react172.default.createElement(Tag, _extends({
      ref: combinedRef,
      type,
      size: size4,
      renderIcon,
      disabled,
      className: tagClasses,
      id: tagId
    }, other), import_react172.default.createElement(Text, {
      title: text,
      className: `${prefix}--tag__label`
    }, text)));
  }
  return import_react172.default.createElement(Tag, _extends({
    ref: combinedRef,
    type,
    size: size4,
    renderIcon,
    disabled,
    className: tagClasses,
    id: tagId
  }, other), import_react172.default.createElement(Text, {
    title: text,
    className: `${prefix}--tag__label`
  }, text));
});
OperationalTag.propTypes = {
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types129.default.string,
  /**
   * Specify if the `OperationalTag` is disabled
   */
  disabled: import_prop_types129.default.bool,
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types129.default.string,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types129.default.oneOfType([import_prop_types129.default.func, import_prop_types129.default.object]),
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types129.default.oneOf(Object.keys(SIZES)),
  /**
   * Provide text to be rendered inside of a the tag.
   */
  text: import_prop_types129.default.string,
  /**
   * Specify the type of the `Tag`
   */
  type: import_prop_types129.default.oneOf(Object.keys(TYPES2))
};

// node_modules/@carbon/react/es/components/Tag/SelectableTag.js
var import_prop_types130 = __toESM(require_prop_types());
var import_react173 = __toESM(require_react());
var import_classnames108 = __toESM(require_classnames());
var SelectableTag = (0, import_react173.forwardRef)(({
  className,
  disabled,
  id,
  renderIcon,
  onChange,
  onClick,
  selected,
  size: size4,
  text,
  defaultSelected = false,
  ...other
}, forwardRef36) => {
  const prefix = usePrefix();
  const tagRef = (0, import_react173.useRef)(null);
  const tagId = id || `tag-${useId()}`;
  const [selectedTag, setSelectedTag] = useControllableState({
    value: selected,
    onChange,
    defaultValue: defaultSelected
  });
  const tagClasses = (0, import_classnames108.default)(`${prefix}--tag--selectable`, className, {
    [`${prefix}--tag--selectable-selected`]: selectedTag
  });
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react173.useState)(false);
  (0, import_react173.useLayoutEffect)(() => {
    var _a;
    const newElement = (_a = tagRef.current) == null ? void 0 : _a.getElementsByClassName(`${prefix}--tag__label`)[0];
    setIsEllipsisApplied(isEllipsisActive(newElement));
  }, [prefix, tagRef]);
  const tooltipClasses = (0, import_classnames108.default)(`${prefix}--icon-tooltip`, `${prefix}--tag-label-tooltip`);
  const combinedRef = mergeRefs(tagRef, forwardRef36);
  const handleClick2 = (e2) => {
    setSelectedTag(!selectedTag);
    onClick == null ? void 0 : onClick(e2);
  };
  if (isEllipsisApplied) {
    return import_react173.default.createElement(Tooltip, {
      label: text,
      align: "bottom",
      className: tooltipClasses,
      leaveDelayMs: 0,
      onMouseEnter: () => false
    }, import_react173.default.createElement(Tag, _extends({
      "aria-pressed": selectedTag !== false,
      ref: combinedRef,
      size: size4,
      renderIcon,
      disabled,
      className: tagClasses,
      id: tagId,
      onClick: handleClick2
    }, other), import_react173.default.createElement(Text, {
      title: text,
      className: `${prefix}--tag__label`
    }, text)));
  }
  return import_react173.default.createElement(Tag, _extends({
    "aria-pressed": selectedTag !== false,
    ref: combinedRef,
    size: size4,
    renderIcon,
    disabled,
    className: tagClasses,
    id: tagId,
    onClick: handleClick2
  }, other), import_react173.default.createElement(Text, {
    title: text,
    className: `${prefix}--tag__label`
  }, text));
});
SelectableTag.propTypes = {
  /**
   * Provide a custom className that is applied to the containing <span>
   */
  className: import_prop_types130.default.string,
  /**
   * Specify if the `SelectableTag` is disabled
   */
  disabled: import_prop_types130.default.bool,
  /**
   * Specify the id for the tag.
   */
  id: import_prop_types130.default.string,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types130.default.oneOfType([import_prop_types130.default.func, import_prop_types130.default.object]),
  /**
   * Provide an optional hook that is called when selected is changed
   */
  onChange: import_prop_types130.default.func,
  /**
   * Provide an optional function to be called when the tag is clicked.
   */
  onClick: import_prop_types130.default.func,
  /**
   * Specify the state of the selectable tag.
   */
  selected: import_prop_types130.default.bool,
  /**
   * Specify the default state of the selectable tag.
   */
  defaultSelected: import_prop_types130.default.bool,
  /**
   * Specify the size of the Tag. Currently supports either `sm`,
   * `md` (default) or `lg` sizes.
   */
  size: import_prop_types130.default.oneOf(Object.keys(SIZES)),
  /**
   * Provide text to be rendered inside of a the tag.
   */
  text: import_prop_types130.default.string
};

// node_modules/@carbon/react/es/components/Tag/Tag.Skeleton.js
var import_prop_types131 = __toESM(require_prop_types());
var import_react174 = __toESM(require_react());
var import_classnames109 = __toESM(require_classnames());
function TagSkeleton({
  className,
  size: size4,
  ...rest
}) {
  const prefix = usePrefix();
  const tagClasses = (0, import_classnames109.default)(`${prefix}--tag`, `${prefix}--skeleton`, className, {
    [`${prefix}--tag--${size4}`]: size4,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4
  });
  return import_react174.default.createElement("span", _extends({
    className: tagClasses
  }, rest));
}
TagSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types131.default.string,
  /**
   * Specify the size of the Tag. Currently supports either `sm` or
   * default sizes.
   */
  size: import_prop_types131.default.oneOf(["sm"])
};

// node_modules/@carbon/react/es/internal/useOverflowItems.js
var import_react175 = __toESM(require_react());
var useOverflowItems = (items, containerRef, offsetRef, maxItems, onChange) => {
  const itemsRef = (0, import_react175.useRef)(null);
  const [maxWidth, setMaxWidth] = (0, import_react175.useState)(0);
  if (!items || !Array.isArray(items)) {
    return {
      visibleItems: [],
      hiddenItems: [],
      itemRefHandler: () => {
      }
    };
  }
  const handleResize = () => {
    var _a;
    if (containerRef.current) {
      const offset4 = ((_a = offsetRef == null ? void 0 : offsetRef.current) == null ? void 0 : _a.offsetWidth) || 0;
      const newMax = containerRef.current.offsetWidth - offset4;
      setMaxWidth(newMax);
    }
  };
  useResizeObserver({
    ref: containerRef,
    onResize: handleResize
  });
  const getMap = () => {
    if (!itemsRef.current) {
      itemsRef.current = /* @__PURE__ */ new Map();
    }
    return itemsRef.current;
  };
  const itemRefHandler = (id, node) => {
    const map = getMap();
    if (node) {
      const style = getComputedStyle == null ? void 0 : getComputedStyle(node);
      const totalWidth = node.offsetWidth + parseInt(style.marginLeft) + parseInt(style.marginRight);
      map.set(id, totalWidth);
    }
    return () => {
      map.delete(id);
    };
  };
  const getVisibleItems = () => {
    if (!items || Array.isArray(items) === false) {
      return [];
    }
    if (!containerRef) {
      return items;
    }
    const map = getMap();
    let maxReached = false;
    let accumulatedWidth = 0;
    const visibleItems2 = items.slice(0, maxItems).reduce((prev, cur) => {
      if (maxReached) {
        return prev;
      }
      const itemWidth = map.get(cur.id) || 0;
      const willFit = accumulatedWidth + itemWidth <= maxWidth;
      if (willFit) {
        accumulatedWidth += itemWidth;
        prev.push(cur);
      } else {
        maxReached = true;
      }
      return prev;
    }, []);
    return visibleItems2;
  };
  const visibleItems = (0, import_react175.useMemo)(() => {
    if (!Array.isArray(items)) {
      return [];
    }
    return getVisibleItems();
  }, [items, maxWidth, maxItems]);
  const hiddenItems = (0, import_react175.useMemo)(() => {
    if (!Array.isArray(items)) {
      return [];
    }
    return items.slice(visibleItems.length);
  }, [items, visibleItems]);
  const previousHiddenItems = usePreviousValue(hiddenItems);
  (0, import_react175.useEffect)(() => {
  }, [hiddenItems, previousHiddenItems, onChange]);
  return {
    visibleItems,
    itemRefHandler,
    hiddenItems
  };
};

// node_modules/@carbon/react/es/components/PageHeader/PageHeader.js
var PageHeader = import_react176.default.forwardRef(function PageHeader2({
  className,
  children,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames110.default)({
    [`${prefix}--page-header`]: true
  }, className);
  return import_react176.default.createElement("div", _extends({
    className: classNames,
    ref
  }, other), children);
});
PageHeader.displayName = "PageHeader";
var PageHeaderBreadcrumbBar = import_react176.default.forwardRef(function PageHeaderBreadcrumbBar2({
  border = true,
  className,
  children,
  renderIcon: IconElement,
  contentActions,
  contentActionsFlush,
  pageActions,
  pageActionsFlush,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames110.default)({
    [`${prefix}--page-header__breadcrumb-bar`]: true,
    [`${prefix}--page-header__breadcrumb-bar-border`]: border,
    [`${prefix}--page-header__breadcrumb__actions-flush`]: pageActionsFlush
  }, className);
  const contentActionsClasses = (0, import_classnames110.default)({
    [`${prefix}--page-header__breadcrumb__content-actions`]: !contentActionsFlush
  });
  return import_react176.default.createElement("div", _extends({
    className: classNames,
    ref
  }, other), import_react176.default.createElement(GridAsGridComponent, null, import_react176.default.createElement(Column, {
    lg: 16,
    md: 8,
    sm: 4
  }, import_react176.default.createElement("div", {
    className: `${prefix}--page-header__breadcrumb-container`
  }, import_react176.default.createElement("div", {
    className: `${prefix}--page-header__breadcrumb-wrapper`
  }, IconElement && import_react176.default.createElement("div", {
    className: `${prefix}--page-header__breadcrumb__icon`
  }, import_react176.default.createElement(IconElement, null)), children), import_react176.default.createElement("div", {
    className: `${prefix}--page-header__breadcrumb__actions`
  }, import_react176.default.createElement("div", {
    className: contentActionsClasses
  }, contentActions), pageActions)))));
});
PageHeaderBreadcrumbBar.displayName = "PageHeaderBreadcrumbBar";
var PageHeaderContent = import_react176.default.forwardRef(function PageHeaderContent2({
  className,
  children,
  title,
  renderIcon: IconElement,
  contextualActions,
  pageActions,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames110.default)({
    [`${prefix}--page-header__content`]: true
  }, className);
  const titleRef = (0, import_react176.useRef)(null);
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react176.useState)(false);
  const isEllipsisActive2 = (element) => {
    setIsEllipsisApplied(element.offsetHeight < element.scrollHeight);
    return element.offsetHeight < element.scrollHeight;
  };
  (0, import_react176.useLayoutEffect)(() => {
    titleRef.current && isEllipsisActive2(titleRef.current);
  }, [title]);
  return import_react176.default.createElement("div", _extends({
    className: classNames,
    ref
  }, other), import_react176.default.createElement(GridAsGridComponent, null, import_react176.default.createElement(Column, {
    lg: 16,
    md: 8,
    sm: 4
  }, import_react176.default.createElement("div", {
    className: `${prefix}--page-header__content__title-wrapper`
  }, import_react176.default.createElement("div", {
    className: `${prefix}--page-header__content__start`
  }, import_react176.default.createElement("div", {
    className: `${prefix}--page-header__content__title-container`
  }, IconElement && import_react176.default.createElement("div", {
    className: `${prefix}--page-header__content__icon`
  }, import_react176.default.createElement(IconElement, null)), isEllipsisApplied ? import_react176.default.createElement(DefinitionTooltip, {
    definition: title
  }, import_react176.default.createElement(Text, {
    ref: titleRef,
    as: "h4",
    className: `${prefix}--page-header__content__title`
  }, title)) : import_react176.default.createElement(Text, {
    ref: titleRef,
    as: "h4",
    className: `${prefix}--page-header__content__title`
  }, title)), contextualActions && import_react176.default.createElement("div", {
    className: `${prefix}--page-header__content__contextual-actions`
  }, contextualActions)), pageActions), children)));
});
PageHeaderContent.displayName = "PageHeaderContent";
PageHeaderContent.propTypes = {
  /**
   * Provide child elements to be rendered inside PageHeaderContent.
   */
  children: import_prop_types132.default.node,
  /**
   * Specify an optional className to be added to your PageHeaderContent
   */
  className: import_prop_types132.default.string,
  /**
   * Provide an optional icon to render in front of the PageHeaderContent's title.
   */
  renderIcon: import_prop_types132.default.oneOfType([import_prop_types132.default.func, import_prop_types132.default.object]),
  /**
   * The PageHeaderContent's title
   */
  title: import_prop_types132.default.string.isRequired,
  /**
   * The PageHeaderContent's subtitle
   */
  subtitle: import_prop_types132.default.string,
  /**
   * The PageHeaderContent's contextual actions
   */
  contextualActions: import_prop_types132.default.node,
  /**
   * The PageHeaderContent's page actions
   */
  pageActions: import_prop_types132.default.node
};
var PageHeaderContentPageActions = ({
  className,
  children,
  menuButtonLabel = "Actions",
  actions,
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames110.default)({
    [`${prefix}--page-header__content__page-actions`]: true
  }, className);
  const containerRef = (0, import_react176.useRef)(null);
  const offsetRef = (0, import_react176.useRef)(null);
  const [menuButtonVisibility, setMenuButtonVisibility] = (0, import_react176.useState)(false);
  const [hiddenItems, setHiddenItems] = (0, import_react176.useState)([]);
  (0, import_react176.useLayoutEffect)(() => {
    if (menuButtonVisibility && offsetRef.current) {
      const width = offsetRef.current.offsetWidth;
      document.documentElement.style.setProperty("--pageheader-title-grid-width", `${width}px`);
    }
  }, [menuButtonVisibility]);
  (0, import_react176.useEffect)(() => {
    if (!containerRef.current || !Array.isArray(actions)) return;
    L({
      container: containerRef.current,
      // exclude the hidden menu button from children
      maxVisibleItems: containerRef.current.children.length - 1,
      onChange: (visible, hidden) => {
        setHiddenItems(actions == null ? void 0 : actions.slice(visible.length));
        if (hidden.length > 0) {
          setMenuButtonVisibility(true);
        }
      }
    });
  }, []);
  return import_react176.default.createElement("div", _extends({
    className: classNames,
    ref: containerRef
  }, other), actions && import_react176.default.createElement(import_react176.default.Fragment, null, Array.isArray(actions) && import_react176.default.createElement(import_react176.default.Fragment, null, actions.map((action) => import_react176.default.createElement("div", {
    key: action.id
  }, import_react176.default.cloneElement(action.body, {
    ...action.body.props,
    onClick: action.onClick
  }))), import_react176.default.createElement("span", {
    "data-offset": true,
    "data-hidden": true,
    ref: offsetRef
  }, import_react176.default.createElement(MenuButton, {
    menuAlignment: "bottom-end",
    label: menuButtonLabel,
    size: "md"
  }, [...hiddenItems].reverse().map((item) => import_react176.default.createElement(MenuItem, _extends({
    key: item.id,
    onClick: item.onClick
  }, item.menuItem))))))));
};
PageHeaderContentPageActions.displayName = "PageHeaderContentPageActions";
PageHeaderContentPageActions.propTypes = {
  /**
   * Provide child elements to be rendered inside PageHeaderContentPageActions.
   */
  children: import_prop_types132.default.node,
  /**
   * Specify an optional className to be added to your PageHeaderContentPageActions
   */
  className: import_prop_types132.default.string,
  /**
   * The PageHeaderContent's collapsible Menu button label
   */
  menuButtonLabel: import_prop_types132.default.string,
  /**
   * The PageHeaderContent's page actions
   */
  actions: import_prop_types132.default.oneOfType([import_prop_types132.default.node, import_prop_types132.default.array])
};
var PageHeaderContentText = ({
  className,
  children,
  subtitle,
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames110.default)({
    [`${prefix}--page-header__content__body`]: true
  }, className);
  return import_react176.default.createElement("div", _extends({
    className: classNames
  }, other), subtitle && import_react176.default.createElement(Text, {
    as: "h3",
    className: `${prefix}--page-header__content__subtitle`
  }, subtitle), children);
};
PageHeaderContentText.displayName = "PageHeaderContentText";
PageHeaderContentText.propTypes = {
  /**
   * Provide child elements to be rendered inside PageHeaderContentText.
   */
  children: import_prop_types132.default.node,
  /**
   * Specify an optional className to be added to your PageHeaderContentText
   */
  className: import_prop_types132.default.string,
  /**
   * The PageHeaderContent's subtitle
   */
  subtitle: import_prop_types132.default.string
};
var PageHeaderHeroImage = ({
  className,
  children,
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames110.default)({
    [`${prefix}--page-header__hero-image`]: true
  }, className);
  const lgMediaQuery2 = `(min-width: ${breakpoints.lg.width})`;
  const isLg = useMatchMedia(lgMediaQuery2);
  return import_react176.default.createElement(AspectRatio, _extends({
    className: classNames
  }, other, {
    ratio: isLg ? "2x1" : "3x2"
  }), children);
};
PageHeaderHeroImage.displayName = "PageHeaderHeroImage";
PageHeaderHeroImage.propTypes = {
  /**
   * Provide child elements to be rendered inside PageHeaderHeroImage.
   */
  children: import_prop_types132.default.node,
  /**
   * Specify an optional className to be added to your PageHeaderHeroImage
   */
  className: import_prop_types132.default.string
};
var PageHeaderTabBar = import_react176.default.forwardRef(function PageHeaderTabBar2({
  className,
  children,
  tags = [],
  ...other
}, ref) {
  var _a;
  const prefix = usePrefix();
  const classNames = (0, import_classnames110.default)({
    [`${prefix}--page-header__tab-bar`]: true
  }, className);
  if (!tags.length) {
    return import_react176.default.createElement("div", _extends({
      className: classNames,
      ref
    }, other), import_react176.default.createElement(GridAsGridComponent, null, import_react176.default.createElement(Column, {
      lg: 16,
      md: 8,
      sm: 4
    }, children)));
  }
  const [openPopover, setOpenPopover] = (0, import_react176.useState)(false);
  const tagSize = ((_a = tags[0]) == null ? void 0 : _a.size) || "md";
  const instanceId2 = useId("PageHeaderTabBar");
  const tagsWithIds = (0, import_react176.useMemo)(() => {
    return tags.map((tag, index3) => ({
      ...tag,
      id: tag.id || `tag-${index3}-${instanceId2}`
    }));
  }, [tags]);
  const tagsContainerRef = (0, import_react176.useRef)(null);
  const offsetRef = (0, import_react176.useRef)(null);
  (0, import_react176.useEffect)(() => {
    const handleResize = () => {
      setOpenPopover(false);
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, []);
  const {
    visibleItems = [],
    hiddenItems = [],
    itemRefHandler = () => {
    }
  } = useOverflowItems(tagsWithIds, tagsContainerRef, offsetRef) || {
    visibleItems: [],
    hiddenItems: [],
    itemRefHandler: () => {
    }
  };
  const handleOverflowClick = (0, import_react176.useCallback)((event) => {
    event.stopPropagation();
    setOpenPopover((prev) => !prev);
  }, []);
  const renderTags = () => import_react176.default.createElement("div", {
    className: `${prefix}--page-header__tags`,
    ref: tagsContainerRef
  }, visibleItems.map((tag) => import_react176.default.createElement(Tag, {
    key: tag.id,
    ref: (node) => itemRefHandler(tag.id, node),
    type: tag.type,
    size: tag.size,
    className: `${prefix}--page-header__tag-item`
  }, tag.text)), hiddenItems.length > 0 && import_react176.default.createElement(Popover, {
    open: openPopover,
    onRequestClose: () => setOpenPopover(false)
  }, import_react176.default.createElement(OperationalTag, {
    onClick: handleOverflowClick,
    "aria-expanded": openPopover,
    text: `+${hiddenItems.length}`,
    size: tagSize
  }), import_react176.default.createElement(PopoverContent, {
    className: "tag-popover-content"
  }, import_react176.default.createElement("div", {
    className: `${prefix}--page-header__tags-popover-list`
  }, hiddenItems.map((tag) => import_react176.default.createElement(Tag, {
    key: tag.id,
    type: tag.type,
    size: tag.size
  }, tag.text))))));
  return import_react176.default.createElement("div", _extends({
    className: classNames,
    ref
  }, other), import_react176.default.createElement(GridAsGridComponent, null, import_react176.default.createElement(Column, {
    lg: 16,
    md: 8,
    sm: 4
  }, import_react176.default.createElement("div", {
    className: `${prefix}--page-header__tab-bar--tablist`
  }, children, tags.length > 0 && renderTags()))));
});
PageHeaderTabBar.displayName = "PageHeaderTabBar";
var Root = PageHeader;
Root.displayName = "PageHeader.Root";
var BreadcrumbBar = PageHeaderBreadcrumbBar;
BreadcrumbBar.displayName = "PageHeaderBreadcrumbBar";
var Content = PageHeaderContent;
Content.displayName = "PageHeaderContent";
var ContentPageActions = PageHeaderContentPageActions;
ContentPageActions.displayName = "PageHeaderContentPageActions";
var ContentText = PageHeaderContentText;
ContentText.displayName = "PageHeaderContentText";
var HeroImage = PageHeaderHeroImage;
HeroImage.displayName = "PageHeaderHeroImage";
var TabBar = PageHeaderTabBar;
TabBar.displayName = "PageHeaderTabBar";

// node_modules/@carbon/react/es/components/Dialog/index.js
var Dialog_exports = {};
__export(Dialog_exports, {
  Dialog: () => Dialog,
  DialogBody: () => DialogBody,
  DialogCloseButton: () => DialogCloseButton,
  DialogControls: () => DialogControls,
  DialogFooter: () => DialogFooter,
  DialogHeader: () => DialogHeader,
  DialogSubtitle: () => DialogSubtitle,
  DialogTitle: () => DialogTitle
});

// node_modules/@carbon/react/es/components/Pagination/Pagination.js
var import_classnames114 = __toESM(require_classnames());
var import_prop_types136 = __toESM(require_prop_types());
var import_react180 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Select/Select.js
var import_prop_types133 = __toESM(require_prop_types());
var import_react177 = __toESM(require_react());
var import_classnames111 = __toESM(require_classnames());
var Select = import_react177.default.forwardRef(function Select2({
  className,
  decorator,
  id,
  inline: inline4 = false,
  labelText = "Select",
  disabled = false,
  children,
  // reserved for use with Pagination component
  noLabel = false,
  // eslint-disable-next-line no-unused-vars
  hideLabel = false,
  invalid = false,
  invalidText = "",
  helperText = "",
  light = false,
  readOnly,
  size: size4,
  warn: warn2 = false,
  warnText,
  onChange,
  slug,
  ...other
}, ref) {
  var _a, _b, _c;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react177.useContext)(FormContext);
  const [isFocused, setIsFocused] = (0, import_react177.useState)(false);
  const selectInstanceId = useId();
  const validChildren = import_react177.default.Children.toArray(children).filter((child) => import_react177.default.isValidElement(child));
  const defaultOption = validChildren.find((child) => {
    var _a2;
    return ((_a2 = child.props) == null ? void 0 : _a2.value) === (other == null ? void 0 : other.defaultValue);
  });
  const initialTitle = ((_a = defaultOption == null ? void 0 : defaultOption.props) == null ? void 0 : _a.text) || ((_c = (_b = validChildren[0]) == null ? void 0 : _b.props) == null ? void 0 : _c.text) || "";
  const [title, setTitle] = (0, import_react177.useState)(initialTitle);
  const selectClasses = (0, import_classnames111.default)({
    [`${prefix}--select`]: true,
    [`${prefix}--select--inline`]: inline4,
    [`${prefix}--select--light`]: light,
    [`${prefix}--select--invalid`]: invalid,
    [`${prefix}--select--disabled`]: disabled,
    [`${prefix}--select--readonly`]: readOnly,
    [`${prefix}--select--warning`]: warn2,
    [`${prefix}--select--fluid--invalid`]: isFluid && invalid,
    [`${prefix}--select--fluid--focus`]: isFluid && isFocused,
    [`${prefix}--select--slug`]: slug,
    [`${prefix}--select--decorator`]: decorator
  });
  const labelClasses = (0, import_classnames111.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled
  });
  const inputClasses = (0, import_classnames111.default)({
    [`${prefix}--select-input`]: true,
    [`${prefix}--select-input--${size4}`]: size4
  });
  const errorId = `${id}-error-msg`;
  const errorText = (() => {
    if (invalid) {
      return invalidText;
    }
    if (warn2) {
      return warnText;
    }
  })();
  const error2 = invalid || warn2 ? import_react177.default.createElement(Text, {
    as: "div",
    className: `${prefix}--form-requirement`,
    id: errorId
  }, errorText) : null;
  const helperTextClasses = (0, import_classnames111.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const helperId = !helperText ? void 0 : `select-helper-text-${selectInstanceId}`;
  const helper = helperText ? import_react177.default.createElement(Text, {
    as: "div",
    id: helperId,
    className: helperTextClasses
  }, helperText) : null;
  const ariaProps = {};
  if (invalid) {
    ariaProps["aria-describedby"] = errorId;
  } else if (!inline4 && !isFluid) {
    ariaProps["aria-describedby"] = helper ? helperId : void 0;
  }
  const handleFocus = (evt) => {
    setIsFocused(evt.type === "focus" ? true : false);
  };
  const handleChange = (evt) => {
    var _a2;
    const selectedOption = (_a2 = evt == null ? void 0 : evt.target) == null ? void 0 : _a2.options[evt.target.selectedIndex];
    setTitle(selectedOption == null ? void 0 : selectedOption.text);
  };
  const readOnlyEventHandlers = {
    onMouseDown: (evt) => {
      if (readOnly) {
        evt.preventDefault();
        evt.target.focus();
      }
    },
    onKeyDown: (evt) => {
      const selectAccessKeys = ["ArrowDown", "ArrowUp", " "];
      if (readOnly && selectAccessKeys.includes(evt.key)) {
        evt.preventDefault();
      }
    }
  };
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react177.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  const input = (() => {
    return import_react177.default.createElement(import_react177.default.Fragment, null, import_react177.default.createElement("select", _extends({}, other, ariaProps, {
      id,
      className: inputClasses,
      disabled: disabled || void 0,
      "aria-invalid": invalid || void 0,
      "aria-readonly": readOnly || void 0,
      title,
      onChange: composeEventHandlers([onChange, handleChange])
    }, readOnlyEventHandlers, {
      ref
    }), children), import_react177.default.createElement(ChevronDown, {
      className: `${prefix}--select__arrow`
    }), invalid && import_react177.default.createElement(WarningFilled, {
      className: `${prefix}--select__invalid-icon`
    }), !invalid && warn2 && import_react177.default.createElement(WarningAltFilled, {
      className: `${prefix}--select__invalid-icon ${prefix}--select__invalid-icon--warning`
    }));
  })();
  return import_react177.default.createElement("div", {
    className: (0, import_classnames111.default)(`${prefix}--form-item`, className)
  }, import_react177.default.createElement("div", {
    className: selectClasses
  }, !noLabel && import_react177.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText), inline4 && import_react177.default.createElement("div", {
    className: `${prefix}--select-input--inline__wrapper`
  }, import_react177.default.createElement("div", {
    className: `${prefix}--select-input__wrapper`,
    "data-invalid": invalid || null
  }, input), error2), !inline4 && import_react177.default.createElement("div", {
    className: `${prefix}--select-input__wrapper`,
    "data-invalid": invalid || null,
    onFocus: handleFocus,
    onBlur: handleFocus
  }, input, slug ? normalizedDecorator : decorator ? import_react177.default.createElement("div", {
    className: `${prefix}--select__inner-wrapper--decorator`
  }, normalizedDecorator) : "", isFluid && import_react177.default.createElement("hr", {
    className: `${prefix}--select__divider`
  }), isFluid && error2 ? error2 : null), !inline4 && !isFluid && error2 ? error2 : helper));
});
Select.displayName = "Select";
Select.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types133.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types133.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `Select` component
   */
  decorator: import_prop_types133.default.node,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types133.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types133.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types133.default.node,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types133.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types133.default.string.isRequired,
  /**
   * Specify whether you want the inline version of this control
   */
  inline: import_prop_types133.default.bool,
  /**
   * Specify if the currently value is invalid.
   */
  invalid: import_prop_types133.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types133.default.node,
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types133.default.node,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types133.default.bool, "The `light` prop for `Select` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * Reserved for use with Pagination component. Will not render a label for the
   * select since Pagination renders one for us.
   */
  noLabel: import_prop_types133.default.bool,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types133.default.func,
  /**
   * Whether the select should be read-only
   */
  readOnly: import_prop_types133.default.bool,
  /**
   * Specify the size of the Select Input.
   */
  size: import_prop_types133.default.oneOf(["sm", "md", "lg"]),
  slug: deprecate(import_prop_types133.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types133.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types133.default.node
};

// node_modules/@carbon/react/es/components/Select/Select.Skeleton.js
var import_prop_types134 = __toESM(require_prop_types());
var import_react178 = __toESM(require_react());
var import_classnames112 = __toESM(require_classnames());
var SelectSkeleton = ({
  hideLabel,
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  return import_react178.default.createElement("div", _extends({
    className: (0, import_classnames112.default)(`${prefix}--form-item`, className)
  }, rest), !hideLabel && import_react178.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react178.default.createElement("div", {
    className: `${prefix}--select ${prefix}--skeleton`
  }, import_react178.default.createElement("div", {
    className: `${prefix}--select-input`
  })));
};
SelectSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types134.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types134.default.bool
};

// node_modules/@carbon/react/es/components/SelectItem/SelectItem.js
var import_prop_types135 = __toESM(require_prop_types());
var import_react179 = __toESM(require_react());
var import_classnames113 = __toESM(require_classnames());
var SelectItem = ({
  className,
  value = "",
  disabled = false,
  hidden = false,
  text = "",
  ...other
}) => {
  const prefix = usePrefix();
  const selectItemClasses = (0, import_classnames113.default)({
    [`${prefix}--select-option`]: true,
    ...className && {
      [className]: className
    }
  });
  return import_react179.default.createElement("option", _extends({}, other, {
    className: selectItemClasses,
    value,
    disabled,
    hidden
  }), text);
};
SelectItem.propTypes = {
  /**
   * Specify an optional className to be applied to the node
   */
  className: import_prop_types135.default.string,
  /**
   * Specify whether the <SelectItem> should be disabled
   */
  disabled: import_prop_types135.default.bool,
  /**
   * Specify whether the <SelectItem> is hidden
   */
  hidden: import_prop_types135.default.bool,
  /**
   * Provide the contents of your <SelectItem>
   */
  text: import_prop_types135.default.string.isRequired,
  /**
   * Specify the value of the <SelectItem>
   */
  value: import_prop_types135.default.any.isRequired
};

// node_modules/@carbon/react/es/components/Pagination/Pagination.js
var import_react_fast_compare6 = __toESM(require_react_fast_compare());
var _CaretLeft2;
var _CaretRight2;
function mapPageSizesToObject(sizes2) {
  return typeof sizes2[0] === "object" && sizes2[0] !== null ? sizes2 : sizes2.map((size4) => ({
    text: size4,
    value: size4
  }));
}
function renderSelectItems(total) {
  let counter = 1;
  const itemArr = [];
  while (counter <= total) {
    itemArr.push(import_react180.default.createElement(SelectItem, {
      key: counter,
      value: counter,
      text: String(counter)
    }));
    counter++;
  }
  return itemArr;
}
function getPageSize(pageSizes, pageSize) {
  if (pageSize) {
    const hasSize = pageSizes.find((size4) => {
      return pageSize === size4.value;
    });
    if (hasSize) {
      return pageSize;
    }
  }
  return pageSizes[0].value;
}
var Pagination = import_react180.default.forwardRef(function Pagination2({
  backwardText = "Previous page",
  className: customClassName = "",
  disabled = false,
  forwardText = "Next page",
  id,
  isLastPage = false,
  itemText = (min2, max2) => `${min2}–${max2} items`,
  itemRangeText = (min2, max2, total) => `${min2}–${max2} of ${total} items`,
  itemsPerPageText = "Items per page:",
  onChange,
  pageNumberText: _pageNumberText = "Page Number",
  pageRangeText = (_current, total) => `of ${total} ${total === 1 ? "page" : "pages"}`,
  page: controlledPage = 1,
  pageInputDisabled,
  pageSize: controlledPageSize,
  pageSizeInputDisabled,
  pageSizes: controlledPageSizes,
  pageText = (page) => `page ${page}`,
  pagesUnknown = false,
  size: size4 = "md",
  totalItems,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const inputId = useFallbackId(id == null ? void 0 : id.toString());
  const backBtnRef = (0, import_react180.useRef)(null);
  const forwardBtnRef = (0, import_react180.useRef)(null);
  const [pageSizes, setPageSizes] = (0, import_react180.useState)(() => {
    return mapPageSizesToObject(controlledPageSizes);
  });
  const [prevPageSizes, setPrevPageSizes] = (0, import_react180.useState)(controlledPageSizes);
  const [page, setPage] = (0, import_react180.useState)(controlledPage);
  const [prevControlledPage, setPrevControlledPage] = (0, import_react180.useState)(controlledPage);
  const [focusTarget, setFocusTarget] = (0, import_react180.useState)(null);
  const [pageSize, setPageSize] = (0, import_react180.useState)(() => {
    return getPageSize(pageSizes, controlledPageSize);
  });
  const [prevControlledPageSize, setPrevControlledPageSize] = (0, import_react180.useState)(controlledPageSize);
  const className = (0, import_classnames114.default)({
    [`${prefix}--pagination`]: true,
    [`${prefix}--pagination--${size4}`]: size4,
    [customClassName]: !!customClassName
  });
  const totalPages = totalItems ? Math.max(Math.ceil(totalItems / pageSize), 1) : 1;
  const backButtonDisabled = disabled || page === 1;
  const backButtonClasses = (0, import_classnames114.default)({
    [`${prefix}--pagination__button`]: true,
    [`${prefix}--pagination__button--backward`]: true,
    [`${prefix}--pagination__button--no-index`]: backButtonDisabled
  });
  const forwardButtonDisabled = disabled || page === totalPages && !pagesUnknown;
  const forwardButtonClasses = (0, import_classnames114.default)({
    [`${prefix}--pagination__button`]: true,
    [`${prefix}--pagination__button--forward`]: true,
    [`${prefix}--pagination__button--no-index`]: forwardButtonDisabled
  });
  const selectItems = renderSelectItems(totalPages);
  const focusMap = {
    backward: backBtnRef,
    forward: forwardBtnRef
  };
  const handleFocus = (target) => {
    const targetRef = focusMap[target];
    if ((targetRef == null ? void 0 : targetRef.current) && !targetRef.current.disabled) {
      targetRef.current.focus();
    }
  };
  (0, import_react180.useEffect)(() => {
    if (focusTarget) {
      handleFocus(focusTarget);
      setFocusTarget(null);
    }
  }, [focusTarget]);
  if (controlledPage !== prevControlledPage) {
    setPage(controlledPage);
    setPrevControlledPage(controlledPage);
  }
  if (controlledPageSize !== prevControlledPageSize) {
    setPageSize(getPageSize(pageSizes, controlledPageSize));
    setPrevControlledPageSize(controlledPageSize);
  }
  if (!(0, import_react_fast_compare6.default)(controlledPageSizes, prevPageSizes)) {
    const pageSizes2 = mapPageSizesToObject(controlledPageSizes);
    const hasPageSize = pageSizes2.find((size5) => {
      return size5.value === pageSize;
    });
    if (!hasPageSize) {
      setPage(1);
    }
    setPageSizes(pageSizes2);
    setPrevPageSizes(controlledPageSizes);
  }
  function handleSizeChange(event) {
    const pageSize2 = Number(event.target.value);
    const changes = {
      pageSize: pageSize2,
      page: 1
    };
    setPage(changes.page);
    setPageSize(changes.pageSize);
    if (onChange) {
      onChange(changes);
    }
  }
  function handlePageInputChange(event) {
    const page2 = Number(event.target.value);
    if (page2 > 0 && totalItems && page2 <= Math.max(Math.ceil(totalItems / pageSize), 1)) {
      setPage(page2);
      if (onChange) {
        onChange({
          page: page2,
          pageSize
        });
      }
    }
  }
  function incrementPage() {
    const nextPage = page + 1;
    setPage(nextPage);
    if (nextPage === totalPages) {
      setFocusTarget("backward");
    }
    if (onChange) {
      onChange({
        page: nextPage,
        pageSize,
        ref: backBtnRef
      });
    }
  }
  function decrementPage() {
    const nextPage = page - 1;
    setPage(nextPage);
    if (nextPage === 1) {
      setFocusTarget("forward");
    }
    if (onChange) {
      onChange({
        page: nextPage,
        pageSize,
        ref: forwardBtnRef
      });
    }
  }
  return import_react180.default.createElement("div", _extends({
    className,
    ref
  }, rest), import_react180.default.createElement("div", {
    className: `${prefix}--pagination__left`
  }, import_react180.default.createElement("label", {
    id: `${prefix}-pagination-select-${inputId}-count-label`,
    className: `${prefix}--pagination__text`,
    htmlFor: `${prefix}-pagination-select-${inputId}`
  }, itemsPerPageText), import_react180.default.createElement(Select, {
    id: `${prefix}-pagination-select-${inputId}`,
    className: `${prefix}--select__item-count`,
    labelText: "",
    hideLabel: true,
    noLabel: true,
    inline: true,
    onChange: handleSizeChange,
    disabled: pageSizeInputDisabled || disabled,
    value: pageSize
  }, pageSizes.map((sizeObj) => import_react180.default.createElement(SelectItem, {
    key: sizeObj.value,
    value: sizeObj.value,
    text: String(sizeObj.text)
  }))), import_react180.default.createElement("span", {
    className: `${prefix}--pagination__text ${prefix}--pagination__items-count`
  }, pagesUnknown || !totalItems ? totalItems === 0 ? itemRangeText(0, 0, 0) : itemText(pageSize * (page - 1) + 1, page * pageSize) : itemRangeText(Math.min(pageSize * (page - 1) + 1, totalItems), Math.min(page * pageSize, totalItems), totalItems))), import_react180.default.createElement("div", {
    className: `${prefix}--pagination__right`
  }, pagesUnknown ? import_react180.default.createElement("span", {
    className: `${prefix}--pagination__text ${prefix}--pagination__page-text ${prefix}--pagination__unknown-pages-text`
  }, pageText(page)) : import_react180.default.createElement(import_react180.default.Fragment, null, import_react180.default.createElement(Select, {
    id: `${prefix}-pagination-select-${inputId}-right`,
    className: `${prefix}--select__page-number`,
    labelText: `Page of ${totalPages} pages`,
    inline: true,
    hideLabel: true,
    onChange: handlePageInputChange,
    value: page,
    disabled: pageInputDisabled || disabled
  }, selectItems), import_react180.default.createElement("span", {
    className: `${prefix}--pagination__text`
  }, pageRangeText(page, totalPages))), import_react180.default.createElement("div", {
    className: `${prefix}--pagination__control-buttons`
  }, import_react180.default.createElement(IconButton, {
    align: "top",
    disabled: backButtonDisabled,
    kind: "ghost",
    className: backButtonClasses,
    label: backwardText,
    "aria-label": backwardText,
    onClick: decrementPage,
    ref: backBtnRef
  }, _CaretLeft2 || (_CaretLeft2 = import_react180.default.createElement(CaretLeft, null))), import_react180.default.createElement(IconButton, {
    align: "top-end",
    disabled: forwardButtonDisabled || isLastPage,
    kind: "ghost",
    className: forwardButtonClasses,
    label: forwardText,
    "aria-label": forwardText,
    onClick: incrementPage,
    ref: forwardBtnRef
  }, _CaretRight2 || (_CaretRight2 = import_react180.default.createElement(CaretRight, null))))));
});
Pagination.propTypes = {
  /**
   * The description for the backward icon.
   */
  backwardText: import_prop_types136.default.string,
  /**
   * The CSS class names.
   */
  className: import_prop_types136.default.string,
  /**
   * `true` if the backward/forward buttons, as well as the page select elements,  should be disabled.
   */
  disabled: import_prop_types136.default.bool,
  /**
   * The description for the forward icon.
   */
  forwardText: import_prop_types136.default.string,
  /**
   * The unique ID of this component instance.
   */
  id: import_prop_types136.default.oneOfType([import_prop_types136.default.string, import_prop_types136.default.number]),
  // TODO: remove when v9 is deprecated
  /**
   * `true` if the current page should be the last page.
   */
  isLastPage: import_prop_types136.default.bool,
  /**
   * The function returning a translatable text showing where the current page is,
   * in a manner of the range of items.
   */
  itemRangeText: import_prop_types136.default.func,
  /**
   * A variant of `itemRangeText`, used if the total number of items is unknown.
   */
  itemText: import_prop_types136.default.func,
  /**
   * The translatable text indicating the number of items per page.
   */
  itemsPerPageText: import_prop_types136.default.string,
  /**
   * The callback function called when the current page changes.
   */
  onChange: import_prop_types136.default.func,
  /**
   * The current page.
   */
  page: import_prop_types136.default.number,
  /**
   * `true` if the select box to change the page should be disabled.
   */
  pageInputDisabled: import_prop_types136.default.bool,
  pageNumberText: import_prop_types136.default.string,
  /**
   * A function returning PII showing where the current page is.
   */
  pageRangeText: import_prop_types136.default.func,
  /**
   * The number dictating how many items a page contains.
   */
  pageSize: import_prop_types136.default.number,
  /**
   * `true` if the select box to change the items per page should be disabled.
   */
  pageSizeInputDisabled: import_prop_types136.default.bool,
  /**
   * The choices for `pageSize`.
   */
  pageSizes: import_prop_types136.default.oneOfType([import_prop_types136.default.arrayOf(import_prop_types136.default.number.isRequired), import_prop_types136.default.arrayOf(import_prop_types136.default.shape({
    text: import_prop_types136.default.string.isRequired,
    value: import_prop_types136.default.number.isRequired
  }).isRequired)]).isRequired,
  /**
   * The translatable text showing the current page.
   */
  pageText: import_prop_types136.default.func,
  /**
   * `true` if the total number of items is unknown.
   */
  pagesUnknown: import_prop_types136.default.bool,
  /**
   * Specify the size of the Pagination.
   */
  size: import_prop_types136.default.oneOf(["sm", "md", "lg"]),
  /**
   * The total number of items.
   */
  totalItems: import_prop_types136.default.number
};

// node_modules/@carbon/react/es/components/Pagination/Pagination.Skeleton.js
var import_prop_types137 = __toESM(require_prop_types());
var import_react181 = __toESM(require_react());
var import_classnames115 = __toESM(require_classnames());
var _SkeletonText5;
var _SkeletonText22;
var _SkeletonText32;
var _SkeletonText42;
function PaginationSkeleton({
  className,
  ...rest
}) {
  const prefix = usePrefix();
  return import_react181.default.createElement("div", _extends({
    className: (0, import_classnames115.default)(`${prefix}--pagination`, `${prefix}--skeleton`, className)
  }, rest), import_react181.default.createElement("div", {
    className: `${prefix}--pagination__left`
  }, _SkeletonText5 || (_SkeletonText5 = import_react181.default.createElement(SkeletonText, {
    width: "70px"
  })), _SkeletonText22 || (_SkeletonText22 = import_react181.default.createElement(SkeletonText, {
    width: "35px"
  })), _SkeletonText32 || (_SkeletonText32 = import_react181.default.createElement(SkeletonText, {
    width: "105px"
  }))), import_react181.default.createElement("div", {
    className: `${prefix}--pagination__right ${prefix}--pagination--inline`
  }, _SkeletonText42 || (_SkeletonText42 = import_react181.default.createElement(SkeletonText, {
    width: "70px"
  }))));
}
PaginationSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types137.default.string
};

// node_modules/@carbon/react/es/components/PaginationNav/PaginationNav.js
var import_prop_types138 = __toESM(require_prop_types());
var import_react182 = __toESM(require_react());
var import_classnames116 = __toESM(require_classnames());
var _CaretRight3;
var _CaretLeft3;
var _option;
var translationIds4 = {
  "carbon.pagination-nav.next": "Next",
  "carbon.pagination-nav.previous": "Previous",
  "carbon.pagination-nav.item": "Page",
  "carbon.pagination-nav.active": "Active",
  "carbon.pagination-nav.of": "of"
};
function translateWithId5(messageId) {
  return translationIds4[messageId];
}
function usePrevious(value) {
  const ref = (0, import_react182.useRef)(null);
  (0, import_react182.useEffect)(() => {
    ref.current = value;
  });
  return ref.current;
}
function calculateCuts(page, totalItems, itemsDisplayedOnPage, splitPoint = null) {
  if (itemsDisplayedOnPage >= totalItems) {
    return {
      front: 0,
      back: 0
    };
  }
  const split = splitPoint || Math.ceil(itemsDisplayedOnPage / 2) - 1;
  let frontHidden = page + 1 - split;
  let backHidden = totalItems - page - (itemsDisplayedOnPage - split) + 1;
  if (frontHidden <= 1) {
    backHidden -= frontHidden <= 0 ? Math.abs(frontHidden) + 1 : 0;
    frontHidden = 0;
  }
  if (backHidden <= 1) {
    frontHidden -= backHidden <= 0 ? Math.abs(backHidden) + 1 : 0;
    backHidden = 0;
  }
  return {
    front: frontHidden,
    back: backHidden
  };
}
function DirectionButton({
  direction,
  label,
  disabled,
  onClick
}) {
  const prefix = usePrefix();
  return import_react182.default.createElement("li", {
    className: `${prefix}--pagination-nav__list-item`
  }, import_react182.default.createElement(IconButton, {
    align: "bottom",
    disabled,
    kind: "ghost",
    label,
    onClick
  }, direction === "forward" ? _CaretRight3 || (_CaretRight3 = import_react182.default.createElement(CaretRight, null)) : _CaretLeft3 || (_CaretLeft3 = import_react182.default.createElement(CaretLeft, null))));
}
function PaginationItem({
  page,
  isActive,
  onClick,
  translateWithId: t3 = translateWithId5
}) {
  const prefix = usePrefix();
  const itemLabel = t3("carbon.pagination-nav.item");
  return import_react182.default.createElement("li", {
    className: `${prefix}--pagination-nav__list-item`
  }, import_react182.default.createElement("button", {
    type: "button",
    className: (0, import_classnames116.default)(`${prefix}--pagination-nav__page`, {
      [`${prefix}--pagination-nav__page--active`]: isActive
    }),
    onClick,
    "data-page": page,
    "aria-current": isActive ? "page" : void 0
  }, import_react182.default.createElement("span", {
    className: `${prefix}--pagination-nav__accessibility-label`
  }, isActive ? `${t3("carbon.pagination-nav.active")}, ${itemLabel}` : itemLabel), page));
}
function PaginationOverflow({
  fromIndex = NaN,
  count: count2 = NaN,
  onSelect,
  // eslint-disable-next-line react/prop-types
  disableOverflow,
  translateWithId: t3 = translateWithId5
}) {
  const prefix = usePrefix();
  if (disableOverflow === true && count2 > 1) {
    return import_react182.default.createElement("li", {
      className: `${prefix}--pagination-nav__list-item`
    }, import_react182.default.createElement("div", {
      className: `${prefix}--pagination-nav__select`
    }, import_react182.default.createElement("select", {
      className: `${prefix}--pagination-nav__page ${prefix}--pagination-nav__page--select`,
      "aria-label": `Select ${t3("carbon.pagination-nav.item")} number`,
      disabled: true
    }), import_react182.default.createElement("div", {
      className: `${prefix}--pagination-nav__select-icon-wrapper`
    }, import_react182.default.createElement(OverflowMenuHorizontal, {
      className: `${prefix}--pagination-nav__select-icon`
    }))));
  }
  if (count2 > 1) {
    return import_react182.default.createElement("li", {
      className: `${prefix}--pagination-nav__list-item`
    }, import_react182.default.createElement("div", {
      className: `${prefix}--pagination-nav__select`
    }, import_react182.default.createElement("select", {
      className: `${prefix}--pagination-nav__page ${prefix}--pagination-nav__page--select`,
      "aria-label": `Select ${t3("carbon.pagination-nav.item")} number`,
      onChange: (e2) => {
        const index3 = Number(e2.target.value);
        onSelect == null ? void 0 : onSelect(index3);
      }
    }, _option || (_option = import_react182.default.createElement("option", {
      value: "",
      hidden: true
    })), [...Array(count2)].map((e2, i) => import_react182.default.createElement("option", {
      value: (fromIndex + i).toString(),
      "data-page": fromIndex + i + 1,
      key: `overflow-${fromIndex + i}`
    }, fromIndex + i + 1))), import_react182.default.createElement("div", {
      className: `${prefix}--pagination-nav__select-icon-wrapper`
    }, import_react182.default.createElement(OverflowMenuHorizontal, {
      className: `${prefix}--pagination-nav__select-icon`
    }))));
  }
  if (count2 === 1) {
    return import_react182.default.createElement(PaginationItem, {
      page: fromIndex + 1,
      translateWithId: t3,
      onClick: () => {
        onSelect == null ? void 0 : onSelect(fromIndex);
      }
    });
  }
  return null;
}
var PaginationNav = import_react182.default.forwardRef(function PaginationNav2({
  className,
  onChange = () => {
  },
  totalItems = NaN,
  disableOverflow,
  itemsShown = 10,
  page = 0,
  loop = false,
  size: size4 = "lg",
  translateWithId: t3 = translateWithId5,
  ...rest
}, ref) {
  const smMediaQuery2 = `(max-width: ${breakpoints.sm.width})`;
  const isSm = useMatchMedia(smMediaQuery2);
  let numberOfPages;
  switch (size4) {
    case "md":
      numberOfPages = itemsShown === 4 ? itemsShown : 5;
      break;
    case "sm":
      numberOfPages = clamp2(itemsShown, 4, 7);
      break;
    default:
      numberOfPages = 4;
      break;
  }
  const [currentPage, setCurrentPage] = (0, import_react182.useState)(page);
  const [itemsDisplayedOnPage, setItemsDisplayedOnPage] = (0, import_react182.useState)(itemsShown >= 4 && !isSm ? itemsShown : numberOfPages);
  const [cuts, setCuts] = (0, import_react182.useState)(calculateCuts(currentPage, totalItems, itemsDisplayedOnPage));
  const prevPage = usePrevious(currentPage);
  const prefix = usePrefix();
  const [isOverflowDisabled, setIsOverFlowDisabled] = (0, import_react182.useState)(disableOverflow);
  function jumpToItem(index3) {
    if (index3 >= 0 && index3 < totalItems) {
      setCurrentPage(index3);
      onChange(index3);
    }
  }
  function jumpToNext() {
    const nextIndex = currentPage + 1;
    if (nextIndex >= totalItems) {
      if (loop) {
        jumpToItem(0);
      }
    } else {
      jumpToItem(nextIndex);
    }
  }
  function jumpToPrevious() {
    const previousIndex = currentPage - 1;
    if (previousIndex < 0) {
      if (loop) {
        jumpToItem(totalItems - 1);
      }
    } else {
      jumpToItem(previousIndex);
    }
  }
  function pageWouldBeHidden(page2) {
    const startOffset2 = itemsDisplayedOnPage <= 4 && page2 > 1 ? 0 : 1;
    const wouldBeHiddenInFront = page2 >= startOffset2 && page2 <= cuts.front || page2 === 0;
    const wouldBeHiddenInBack = page2 >= totalItems - cuts.back - 1 && page2 <= totalItems - 2;
    return wouldBeHiddenInFront || wouldBeHiddenInBack;
  }
  (0, import_react182.useEffect)(() => {
    setCurrentPage(page);
  }, [page]);
  (0, import_react182.useEffect)(() => {
    const itemsToBeShown = itemsShown >= 4 && !isSm ? itemsShown : numberOfPages;
    setItemsDisplayedOnPage(Math.max(itemsToBeShown, 4));
    setCuts(calculateCuts(currentPage, totalItems, Math.max(itemsToBeShown, 4)));
  }, [totalItems, itemsShown, isSm, size4]);
  (0, import_react182.useEffect)(() => {
    if (pageWouldBeHidden(currentPage)) {
      const delta = currentPage - (prevPage || 0);
      if (delta > 0) {
        const splitPoint = itemsDisplayedOnPage - 3;
        setCuts(calculateCuts(currentPage, totalItems, itemsDisplayedOnPage, splitPoint));
      } else {
        const splitPoint = itemsDisplayedOnPage > 4 ? 2 : 1;
        setCuts(calculateCuts(currentPage, totalItems, itemsDisplayedOnPage, splitPoint));
      }
    }
  }, [currentPage]);
  (0, import_react182.useEffect)(() => {
    setIsOverFlowDisabled(disableOverflow);
  }, [disableOverflow]);
  const classNames = (0, import_classnames116.default)(`${prefix}--pagination-nav`, className, {
    [`${prefix}--layout--size-${size4}`]: size4
  });
  const backwardButtonDisabled = !loop && currentPage === 0;
  const forwardButtonDisabled = !loop && currentPage === totalItems - 1;
  const startOffset = itemsDisplayedOnPage <= 4 && currentPage > 1 ? 0 : 1;
  return import_react182.default.createElement("nav", _extends({
    className: classNames,
    ref
  }, rest, {
    "aria-label": "pagination"
  }), import_react182.default.createElement(
    "ul",
    {
      className: `${prefix}--pagination-nav__list`
    },
    import_react182.default.createElement(DirectionButton, {
      direction: "backward",
      "aria-label": t3("carbon.pagination-nav.previous"),
      label: t3("carbon.pagination-nav.previous"),
      disabled: backwardButtonDisabled,
      onClick: jumpToPrevious
    }),
    // render first item if at least 5 items can be displayed or
    // 4 items can be displayed and the current page is either 0 or 1
    (itemsDisplayedOnPage >= 5 || itemsDisplayedOnPage <= 4 && currentPage <= 1) && import_react182.default.createElement(PaginationItem, {
      page: 1,
      translateWithId: t3,
      isActive: currentPage === 0,
      onClick: () => {
        jumpToItem(0);
      }
    }),
    import_react182.default.createElement(PaginationOverflow, {
      fromIndex: startOffset,
      count: cuts.front,
      onSelect: jumpToItem,
      disableOverflow: isOverflowDisabled
    }),
    // render items between overflows
    [...Array(totalItems)].map((e2, i) => i).slice(startOffset + cuts.front, (1 + cuts.back) * -1).map((item) => import_react182.default.createElement(PaginationItem, {
      key: `item-${item}`,
      page: item + 1,
      translateWithId: t3,
      isActive: currentPage === item,
      onClick: () => {
        jumpToItem(item);
      }
    })),
    import_react182.default.createElement(PaginationOverflow, {
      fromIndex: totalItems - cuts.back - 1,
      count: cuts.back,
      onSelect: jumpToItem,
      disableOverflow: isOverflowDisabled
    }),
    // render last item unless there is only one in total
    totalItems > 1 && import_react182.default.createElement(PaginationItem, {
      page: totalItems,
      translateWithId: t3,
      isActive: currentPage === totalItems - 1,
      onClick: () => {
        jumpToItem(totalItems - 1);
      }
    }),
    import_react182.default.createElement(DirectionButton, {
      direction: "forward",
      "aria-label": t3("carbon.pagination-nav.next"),
      label: t3("carbon.pagination-nav.next"),
      disabled: forwardButtonDisabled,
      onClick: jumpToNext
    })
  ), import_react182.default.createElement("div", {
    "aria-live": "polite",
    "aria-atomic": "true",
    className: `${prefix}--pagination-nav__accessibility-label`
  }, `${t3("carbon.pagination-nav.item")} ${currentPage + 1} ${t3("carbon.pagination-nav.of")} ${totalItems}`));
});
DirectionButton.propTypes = {
  /**
   * The direction this button represents ("forward" or "backward").
   */
  direction: import_prop_types138.default.oneOf(["forward", "backward"]),
  /**
   * Whether or not the button should be disabled.
   */
  disabled: import_prop_types138.default.bool,
  /**
   * The label shown in the button's tooltip.
   */
  label: import_prop_types138.default.string,
  /**
   * The callback function called when the button is clicked.
   */
  onClick: import_prop_types138.default.func
};
PaginationItem.propTypes = {
  /**
   * Whether or not this is the currently active page.
   */
  isActive: import_prop_types138.default.bool,
  /**
   * The callback function called when the item is clicked.
   */
  onClick: import_prop_types138.default.func,
  /**
   * The page number this item represents.
   */
  page: import_prop_types138.default.number,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types138.default.func
};
PaginationOverflow.propTypes = {
  /**
   * How many items to display in this overflow.
   */
  count: import_prop_types138.default.number,
  /**
   * From which index on this overflow should start displaying pages.
   */
  fromIndex: import_prop_types138.default.number,
  /**
   * The callback function called when the user selects a page from the overflow.
   */
  onSelect: import_prop_types138.default.func,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types138.default.func
};
PaginationNav.displayName = "PaginationNav";
PaginationNav.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types138.default.string,
  /**
   * If true, the '...' pagination overflow will not render page links between the first and last rendered buttons.
   * Set this to true if you are having performance problems with large data sets.
   */
  disableOverflow: import_prop_types138.default.bool,
  // eslint-disable-line react/prop-types
  /**
   * The number of items to be shown (minimum of 4 unless props.items < 4).
   */
  itemsShown: import_prop_types138.default.number,
  /**
   * Whether user should be able to loop through the items when reaching first / last.
   */
  loop: import_prop_types138.default.bool,
  /**
   * The callback function called when the current page changes.
   */
  onChange: import_prop_types138.default.func,
  /**
   * The index of current page.
   */
  page: import_prop_types138.default.number,
  /**
   * Specify the size of the PaginationNav.
   */
  size: import_prop_types138.default.oneOf(["sm", "md", "lg"]),
  /**
   * The total number of items.
   */
  totalItems: import_prop_types138.default.number,
  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: import_prop_types138.default.func
};

// node_modules/@carbon/react/es/components/TextInput/ControlledPasswordInput.js
var import_react183 = __toESM(require_react());
var import_classnames117 = __toESM(require_classnames());
var import_prop_types139 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/components/TextInput/util.js
var invalidProps = (invalidId) => ({
  "data-invalid": true,
  "aria-invalid": true,
  "aria-describedby": invalidId
});
var warnProps = (warnId) => ({
  "aria-describedby": warnId
});
var helperProps = (helperId) => ({
  "aria-describedby": helperId
});
var textInputProps = ({
  sharedTextInputProps,
  invalid,
  invalidId,
  warn: warn2,
  warnId,
  hasHelper,
  helperId
}) => ({
  ...sharedTextInputProps,
  ...invalid ? invalidProps(invalidId) : {},
  ...warn2 ? warnProps(warnId) : {},
  ...hasHelper ? helperProps(helperId) : {}
});

// node_modules/@carbon/react/es/components/TextInput/ControlledPasswordInput.js
var ControlledPasswordInput = import_react183.default.forwardRef(function ControlledPasswordInput2({
  labelText,
  className,
  id,
  placeholder,
  onChange = noopFn,
  onClick = noopFn,
  disabled = false,
  hideLabel,
  invalid = false,
  invalidText = "",
  helperText = "",
  light,
  // eslint-disable-next-line react/prop-types
  type = "password",
  // eslint-disable-next-line react/prop-types
  togglePasswordVisibility,
  tooltipPosition = "bottom",
  tooltipAlignment = "center",
  hidePasswordLabel = "Hide password",
  showPasswordLabel = "Show password",
  size: size4 = void 0,
  ...other
}, ref) {
  const prefix = usePrefix();
  const controlledPasswordInstanceId = useId();
  const errorId = id + "-error-msg";
  const textInputClasses = (0, import_classnames117.default)(`${prefix}--text-input`, `${prefix}--password-input`, className, {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--text-input--invalid`]: invalid,
    [`${prefix}--text-input--${size4}`]: size4
  });
  const sharedTextInputProps = {
    id,
    onChange: (evt) => {
      if (!disabled) {
        onChange == null ? void 0 : onChange(evt);
      }
    },
    onClick: (evt) => {
      if (!disabled) {
        onClick == null ? void 0 : onClick(evt);
      }
    },
    placeholder,
    type,
    ref,
    className: textInputClasses,
    ...other
  };
  const labelClasses = (0, import_classnames117.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled
  });
  const helperTextClasses = (0, import_classnames117.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const label = labelText ? import_react183.default.createElement("label", {
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const error2 = invalid ? import_react183.default.createElement("div", {
    className: `${prefix}--form-requirement`,
    id: errorId
  }, invalidText) : null;
  const passwordIsVisible = type === "text";
  const passwordVisibilityIcon = passwordIsVisible ? import_react183.default.createElement(ViewOff, {
    className: `${prefix}--icon-visibility-off`
  }) : import_react183.default.createElement(View, {
    className: `${prefix}--icon-visibility-on`
  });
  const passwordVisibilityToggleClasses = (0, import_classnames117.default)(`${prefix}--text-input--password__visibility__toggle`, `${prefix}--btn`, `${prefix}--btn--icon-only`, `${prefix}--tooltip__trigger`, `${prefix}--tooltip--a11y`, {
    [`${prefix}--tooltip--${tooltipPosition}`]: tooltipPosition,
    [`${prefix}--tooltip--align-${tooltipAlignment}`]: tooltipAlignment
  });
  const helperId = !helperText ? void 0 : `controlled-password-helper-text-${controlledPasswordInstanceId}`;
  const input = import_react183.default.createElement(import_react183.default.Fragment, null, import_react183.default.createElement("input", _extends({}, textInputProps({
    invalid,
    sharedTextInputProps,
    invalidId: errorId,
    hasHelper: !error2 && helperText ? true : false,
    helperId
  }), {
    "data-toggle-password-visibility": type === "password"
  })), import_react183.default.createElement("button", {
    type: "button",
    className: passwordVisibilityToggleClasses,
    onClick: togglePasswordVisibility
  }, import_react183.default.createElement("span", {
    className: `${prefix}--assistive-text`
  }, passwordIsVisible ? hidePasswordLabel : showPasswordLabel), passwordVisibilityIcon));
  const helper = helperText ? import_react183.default.createElement("div", {
    id: helperId,
    className: helperTextClasses
  }, helperText) : null;
  return import_react183.default.createElement("div", {
    className: `${prefix}--form-item ${prefix}--text-input-wrapper ${prefix}--password-input-wrapper`
  }, label, import_react183.default.createElement("div", {
    className: `${prefix}--text-input__field-wrapper`,
    "data-invalid": invalid || null
  }, invalid && import_react183.default.createElement(WarningFilled, {
    className: `${prefix}--text-input__invalid-icon`
  }), input), error2 ? error2 : helper);
});
ControlledPasswordInput.displayName = "ControlledPasswordInput";
ControlledPasswordInput.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<input>` node
   */
  className: import_prop_types139.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types139.default.oneOfType([import_prop_types139.default.string, import_prop_types139.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types139.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types139.default.node,
  /**
   * Specify whether or not the underlying label is visually hidden
   */
  hideLabel: import_prop_types139.default.bool,
  /**
   * "Hide password" tooltip text on password visibility toggle
   */
  hidePasswordLabel: import_prop_types139.default.string,
  /**
   * Provide a unique identifier for the input field
   */
  id: import_prop_types139.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types139.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types139.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types139.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types139.default.bool, "The `light` prop for `ControlledPasswordInput` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types139.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types139.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types139.default.string,
  /**
   * "Show password" tooltip text on password visibility toggle
   */
  showPasswordLabel: import_prop_types139.default.string,
  /**
   * Specify the size of the Text Input.
   */
  size: import_prop_types139.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types139.default.oneOf(["start", "center", "end"]),
  /**
   * Specify the direction of the tooltip for icon-only buttons.
   * Can be either top, right, bottom, or left.
   */
  tooltipPosition: import_prop_types139.default.oneOf(["top", "right", "bottom", "left"]),
  /**
   * Provide the current value of the `<input>`
   */
  value: import_prop_types139.default.oneOfType([import_prop_types139.default.string, import_prop_types139.default.number])
};

// node_modules/@carbon/react/es/components/TextInput/PasswordInput.js
var import_react184 = __toESM(require_react());
var import_classnames118 = __toESM(require_classnames());
var import_prop_types140 = __toESM(require_prop_types());
var PasswordInput = import_react184.default.forwardRef(function PasswordInput2({
  className,
  disabled = false,
  helperText,
  hideLabel,
  hidePasswordLabel = "Hide password",
  id,
  inline: inline4,
  invalid = false,
  invalidText,
  labelText,
  light,
  onChange = () => {
  },
  onClick = () => {
  },
  onTogglePasswordVisibility,
  placeholder,
  readOnly,
  size: size4 = "md",
  showPasswordLabel = "Show password",
  tooltipPosition = "bottom",
  tooltipAlignment = "end",
  type = "password",
  warn: warn2 = false,
  warnText,
  ...rest
}, ref) {
  const [inputType, setInputType] = (0, import_react184.useState)(type);
  const prefix = usePrefix();
  const normalizedProps = useNormalizedInputProps({
    id,
    invalid,
    invalidText,
    warn: warn2,
    warnText,
    readOnly,
    disabled
  });
  const {
    isFluid
  } = (0, import_react184.useContext)(FormContext);
  const handleTogglePasswordVisibility = (event) => {
    setInputType(inputType === "password" ? "text" : "password");
    onTogglePasswordVisibility && onTogglePasswordVisibility(event);
  };
  const textInputClasses = (0, import_classnames118.default)(`${prefix}--text-input`, `${prefix}--password-input`, className, {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--text-input--invalid`]: normalizedProps.invalid,
    [`${prefix}--text-input--warning`]: normalizedProps.warn,
    [`${prefix}--text-input--${size4}`]: size4,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4
  });
  const sharedTextInputProps = {
    id,
    onChange: (evt) => {
      if (!disabled) {
        onChange(evt);
      }
    },
    onClick: (evt) => {
      if (!disabled) {
        onClick(evt);
      }
    },
    placeholder,
    type: inputType,
    className: textInputClasses,
    readOnly,
    ref,
    ...rest
  };
  const inputWrapperClasses = (0, import_classnames118.default)(`${prefix}--form-item`, `${prefix}--text-input-wrapper`, `${prefix}--password-input-wrapper`, {
    [`${prefix}--text-input-wrapper--readonly`]: readOnly,
    [`${prefix}--text-input-wrapper--light`]: light,
    [`${prefix}--text-input-wrapper--inline`]: inline4,
    [`${prefix}--text-input--fluid`]: isFluid
  });
  const labelClasses = (0, import_classnames118.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--label--inline`]: inline4,
    [`${prefix}--label--inline--${size4}`]: inline4 && !!size4
  });
  const helperTextClasses = (0, import_classnames118.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled,
    [`${prefix}--form__helper-text--inline`]: inline4
  });
  const fieldOuterWrapperClasses = (0, import_classnames118.default)(`${prefix}--text-input__field-outer-wrapper`, {
    [`${prefix}--text-input__field-outer-wrapper--inline`]: inline4
  });
  const fieldWrapperClasses = (0, import_classnames118.default)(`${prefix}--text-input__field-wrapper`, {
    [`${prefix}--text-input__field-wrapper--warning`]: normalizedProps.warn
  });
  const iconClasses = (0, import_classnames118.default)({
    [`${prefix}--text-input__invalid-icon`]: normalizedProps.invalid || normalizedProps.warn,
    [`${prefix}--text-input__invalid-icon--warning`]: normalizedProps.warn
  });
  const label = labelText ? import_react184.default.createElement("label", {
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const helper = helperText ? import_react184.default.createElement("div", {
    id: normalizedProps.helperId,
    className: helperTextClasses
  }, helperText) : null;
  const passwordIsVisible = inputType === "text";
  const passwordVisibilityIcon = passwordIsVisible ? import_react184.default.createElement(ViewOff, {
    className: `${prefix}--icon-visibility-off`
  }) : import_react184.default.createElement(View, {
    className: `${prefix}--icon-visibility-on`
  });
  const passwordVisibilityToggleClasses = (0, import_classnames118.default)(`${prefix}--text-input--password__visibility__toggle`, `${prefix}--btn`, `${prefix}--tooltip__trigger`, `${prefix}--tooltip--a11y`, {
    [`${prefix}--tooltip--${tooltipPosition}`]: tooltipPosition,
    [`${prefix}--tooltip--align-${tooltipAlignment}`]: tooltipAlignment
  });
  let align = void 0;
  if (tooltipPosition === "top" || tooltipPosition === "bottom") {
    if (tooltipAlignment === "center") {
      align = tooltipPosition;
    }
    if (tooltipAlignment === "end") {
      align = `${tooltipPosition}-end`;
    }
    if (tooltipAlignment === "start") {
      align = `${tooltipPosition}-start`;
    }
  }
  if (tooltipPosition === "right" || tooltipPosition === "left") {
    align = tooltipPosition;
  }
  if (!hidePasswordLabel || hidePasswordLabel.trim() === "") {
    console.warn('Warning: The "hidePasswordLabel" should not be blank.');
  } else if (!showPasswordLabel || showPasswordLabel.trim() === "") {
    console.warn('Warning: The "showPasswordLabel" should not be blank.');
  }
  const input = import_react184.default.createElement(import_react184.default.Fragment, null, import_react184.default.createElement("input", _extends({}, textInputProps({
    sharedTextInputProps,
    invalid: normalizedProps.invalid,
    invalidId: normalizedProps.invalidId,
    warn: normalizedProps.warn,
    warnId: normalizedProps.warnId,
    hasHelper: Boolean(helperText && !isFluid && (inline4 || !inline4 && !normalizedProps.validation)),
    helperId: normalizedProps.helperId
  }), {
    disabled,
    "data-toggle-password-visibility": inputType === "password"
  })), isFluid && import_react184.default.createElement("hr", {
    className: `${prefix}--text-input__divider`
  }), import_react184.default.createElement(Tooltip, {
    align,
    className: `${prefix}--toggle-password-tooltip`,
    label: passwordIsVisible ? hidePasswordLabel : showPasswordLabel
  }, import_react184.default.createElement("button", {
    type: "button",
    className: passwordVisibilityToggleClasses,
    disabled: disabled || readOnly,
    onClick: handleTogglePasswordVisibility
  }, passwordVisibilityIcon)));
  (0, import_react184.useEffect)(() => {
    setInputType(type);
  }, [type]);
  const Icon = normalizedProps.icon;
  return import_react184.default.createElement("div", {
    className: inputWrapperClasses
  }, !inline4 ? label : import_react184.default.createElement("div", {
    className: `${prefix}--text-input__label-helper-wrapper`
  }, label, !isFluid && helper), import_react184.default.createElement("div", {
    className: fieldOuterWrapperClasses
  }, import_react184.default.createElement("div", {
    className: fieldWrapperClasses,
    "data-invalid": normalizedProps.invalid || null
  }, Icon && import_react184.default.createElement(Icon, {
    className: iconClasses
  }), input, isFluid && !inline4 && normalizedProps.validation), !isFluid && !inline4 && (normalizedProps.validation || helper)));
});
PasswordInput.displayName = "PasswordInput";
PasswordInput.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<input>` node
   */
  className: import_prop_types140.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types140.default.oneOfType([import_prop_types140.default.string, import_prop_types140.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types140.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types140.default.node,
  /**
   * Specify whether or not the underlying label is visually hidden
   */
  hideLabel: import_prop_types140.default.bool,
  /**
   * "Hide password" tooltip text on password visibility toggle
   */
  hidePasswordLabel: import_prop_types140.default.string,
  /**
   * Provide a unique identifier for the input field
   */
  id: import_prop_types140.default.string.isRequired,
  /**
   * `true` to use the inline version.
   */
  inline: import_prop_types140.default.bool,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types140.default.bool,
  /**
   * Whether the PasswordInput should be read-only
   */
  readOnly: import_prop_types140.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types140.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types140.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types140.default.bool, "The `light` prop for `PasswordInput` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types140.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types140.default.func,
  /**
   * Callback function that is called whenever the toggle password visibility
   * button is clicked
   */
  onTogglePasswordVisibility: import_prop_types140.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types140.default.string,
  /**
   * "Show password" tooltip text on password visibility toggle
   */
  showPasswordLabel: import_prop_types140.default.string,
  /**
   * Specify the size of the Text Input. Supports `sm`, `md`, or `lg`.
   */
  size: import_prop_types140.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types140.default.oneOf(["start", "center", "end"]),
  /**
   * Specify the direction of the tooltip for icon-only buttons.
   * Can be either top, right, bottom, or left.
   */
  tooltipPosition: import_prop_types140.default.oneOf(["top", "right", "bottom", "left"]),
  /**
   * The input type, either password or text
   */
  type: import_prop_types140.default.oneOf(["password", "text"]),
  /**
   * Provide the current value of the `<input>`
   */
  value: import_prop_types140.default.oneOfType([import_prop_types140.default.string, import_prop_types140.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types140.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types140.default.node
};

// node_modules/@carbon/react/es/components/PrimaryButton/PrimaryButton.js
var import_react185 = __toESM(require_react());
var PrimaryButton = (props) => import_react185.default.createElement(Button, _extends({
  kind: "primary"
}, props));

// node_modules/@carbon/react/es/components/ProgressIndicator/ProgressIndicator.Skeleton.js
var import_prop_types141 = __toESM(require_prop_types());
var import_react186 = __toESM(require_react());
var import_classnames119 = __toESM(require_classnames());
var _CircleDash;
var _Step;
var _Step2;
var _Step3;
var _Step4;
function Step() {
  const prefix = usePrefix();
  return import_react186.default.createElement("li", {
    className: `${prefix}--progress-step ${prefix}--progress-step--incomplete`
  }, import_react186.default.createElement("div", {
    className: `${prefix}--progress-step-button ${prefix}--progress-step-button--unclickable`
  }, _CircleDash || (_CircleDash = import_react186.default.createElement(CircleDash, null)), import_react186.default.createElement("p", {
    className: `${prefix}--progress-label`
  }), import_react186.default.createElement("span", {
    className: `${prefix}--progress-line`
  })));
}
function ProgressIndicatorSkeleton({
  className,
  vertical,
  ...rest
}) {
  const prefix = usePrefix();
  return import_react186.default.createElement("ul", _extends({
    className: (0, import_classnames119.default)(`${prefix}--progress`, `${prefix}--skeleton`, {
      [`${prefix}--progress--vertical`]: vertical
    }, className)
  }, rest), _Step || (_Step = import_react186.default.createElement(Step, null)), _Step2 || (_Step2 = import_react186.default.createElement(Step, null)), _Step3 || (_Step3 = import_react186.default.createElement(Step, null)), _Step4 || (_Step4 = import_react186.default.createElement(Step, null)));
}
ProgressIndicatorSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types141.default.string,
  /**
   * Determines whether or not the ProgressIndicator should be rendered vertically.
   */
  vertical: import_prop_types141.default.bool
};

// node_modules/@carbon/react/es/components/ProgressIndicator/ProgressIndicator.js
var import_classnames120 = __toESM(require_classnames());
var import_prop_types142 = __toESM(require_prop_types());
var import_react187 = __toESM(require_react());
var defaultTranslations8 = {
  "carbon.progress-step.complete": "Complete",
  "carbon.progress-step.incomplete": "Incomplete",
  "carbon.progress-step.current": "Current",
  "carbon.progress-step.invalid": "Invalid"
};
function translateWithId6(messageId) {
  return defaultTranslations8[messageId];
}
function ProgressIndicator({
  children,
  className: customClassName,
  currentIndex: controlledIndex = 0,
  onChange,
  spaceEqually,
  vertical,
  ...rest
}) {
  const prefix = usePrefix();
  const [currentIndex, setCurrentIndex] = (0, import_react187.useState)(controlledIndex);
  const [prevControlledIndex, setPrevControlledIndex] = (0, import_react187.useState)(controlledIndex);
  const className = (0, import_classnames120.default)({
    [`${prefix}--progress`]: true,
    [`${prefix}--progress--vertical`]: vertical,
    [`${prefix}--progress--space-equal`]: spaceEqually && !vertical,
    [customClassName ?? ""]: customClassName
  });
  if (controlledIndex !== prevControlledIndex) {
    setCurrentIndex(controlledIndex);
    setPrevControlledIndex(controlledIndex);
  }
  return import_react187.default.createElement("ul", _extends({
    className
  }, rest), import_react187.default.Children.map(children, (child, index3) => {
    if (!import_react187.default.isValidElement(child)) {
      return null;
    }
    const onClick = onChange ? () => onChange(index3) : void 0;
    if (index3 === currentIndex) {
      return import_react187.default.cloneElement(child, {
        complete: child.props.complete,
        current: child.props.complete ? false : true,
        index: index3,
        onClick
      });
    }
    if (index3 < currentIndex) {
      return import_react187.default.cloneElement(child, {
        complete: true,
        index: index3,
        onClick
      });
    }
    if (index3 > currentIndex) {
      return import_react187.default.cloneElement(child, {
        complete: child.props.complete || false,
        index: index3,
        onClick
      });
    }
    return null;
  }));
}
ProgressIndicator.propTypes = {
  /**
   * Provide `<ProgressStep>` components to be rendered in the
   * `<ProgressIndicator>`
   */
  children: import_prop_types142.default.node,
  /**
   * Provide an optional className to be applied to the containing node
   */
  className: import_prop_types142.default.string,
  /**
   * Optionally specify the current step array index
   */
  currentIndex: import_prop_types142.default.number,
  /**
   * Optional callback called if a ProgressStep is clicked on.  Returns the index of the step.
   */
  onChange: import_prop_types142.default.func,
  /**
   * Specify whether the progress steps should be split equally in size in the div
   */
  spaceEqually: import_prop_types142.default.bool,
  /**
   * Determines whether or not the ProgressIndicator should be rendered vertically.
   */
  vertical: import_prop_types142.default.bool
};
function ProgressStep({
  label,
  description,
  className,
  current,
  complete,
  invalid,
  secondaryLabel,
  disabled,
  onClick,
  translateWithId: t3 = translateWithId6,
  ...rest
}) {
  const prefix = usePrefix();
  const classes = (0, import_classnames120.default)({
    [`${prefix}--progress-step`]: true,
    [`${prefix}--progress-step--current`]: current,
    [`${prefix}--progress-step--complete`]: complete,
    [`${prefix}--progress-step--incomplete`]: !complete && !current,
    [`${prefix}--progress-step--disabled`]: disabled,
    [className ?? ""]: className
  });
  const handleKeyDown = (e2) => {
    if (matches(e2, [Enter, Space]) && onClick) {
      onClick(e2);
    }
  };
  const SVGIcon = ({
    complete: complete2,
    current: current2,
    description: description2,
    invalid: invalid2,
    prefix: prefix2
  }) => {
    if (invalid2) {
      return import_react187.default.createElement(Warning, {
        className: `${prefix2}--progress__warning`
      }, import_react187.default.createElement("title", null, description2));
    }
    if (current2) {
      return import_react187.default.createElement(Incomplete, null, import_react187.default.createElement("title", null, description2));
    }
    if (complete2) {
      return import_react187.default.createElement(CheckmarkOutline, null, import_react187.default.createElement("title", null, description2));
    }
    return import_react187.default.createElement(CircleDash, null, import_react187.default.createElement("title", null, description2));
  };
  let message = t3("carbon.progress-step.incomplete");
  if (current) {
    message = t3("carbon.progress-step.current");
  }
  if (complete) {
    message = t3("carbon.progress-step.complete");
  }
  if (invalid) {
    message = t3("carbon.progress-step.invalid");
  }
  return import_react187.default.createElement("li", {
    className: classes
  }, import_react187.default.createElement("button", _extends({
    type: "button",
    className: (0, import_classnames120.default)(`${prefix}--progress-step-button`, {
      [`${prefix}--progress-step-button--unclickable`]: !onClick || current
    }),
    disabled,
    "aria-disabled": disabled,
    tabIndex: !current && onClick && !disabled ? 0 : -1,
    onClick: !current ? onClick : void 0,
    onKeyDown: handleKeyDown,
    title: label
  }, rest), import_react187.default.createElement(SVGIcon, {
    complete,
    current,
    description,
    invalid,
    prefix
  }), import_react187.default.createElement("div", {
    className: `${prefix}--progress-text`
  }, import_react187.default.createElement(Text, {
    as: "p",
    className: `${prefix}--progress-label`
  }, label), secondaryLabel !== null && secondaryLabel !== void 0 ? import_react187.default.createElement(Text, {
    as: "p",
    className: `${prefix}--progress-optional`
  }, secondaryLabel) : null), import_react187.default.createElement("span", {
    className: `${prefix}--assistive-text`
  }, message), import_react187.default.createElement("span", {
    className: `${prefix}--progress-line`
  })));
}
ProgressStep.propTypes = {
  /**
   * Provide an optional className to be applied to the containing `<li>` node
   */
  className: import_prop_types142.default.string,
  /**
   * Specify whether the step has been completed
   */
  complete: import_prop_types142.default.bool,
  /**
   * Specify whether the step is the current step
   */
  current: import_prop_types142.default.bool,
  /**
   * Provide a description for the `<ProgressStep>`
   */
  description: import_prop_types142.default.string,
  /**
   * Specify whether the step is disabled
   */
  disabled: import_prop_types142.default.bool,
  /**
   * Index of the current step within the ProgressIndicator
   */
  index: import_prop_types142.default.number,
  /**
   * Specify whether the step is invalid
   */
  invalid: import_prop_types142.default.bool,
  /**
   * Provide the label for the `<ProgressStep>`
   */
  label: import_prop_types142.default.node.isRequired,
  /**
   * A callback called if the step is clicked or the enter key is pressed
   */
  onClick: import_prop_types142.default.func,
  /**
   * Provide the props that describe a progress step tooltip
   */
  overflowTooltipProps: import_prop_types142.default.object,
  /**
   * Provide an optional secondary label
   */
  secondaryLabel: import_prop_types142.default.string,
  /**
   * The ID of the tooltip content.
   */
  tooltipId: import_prop_types142.default.string,
  /**
   * Optional method that takes in a message id and returns an
   * internationalized string.
   */
  translateWithId: import_prop_types142.default.func
};

// node_modules/@carbon/react/es/components/RadioButton/RadioButton.Skeleton.js
var import_prop_types143 = __toESM(require_prop_types());
var import_react188 = __toESM(require_react());
var import_classnames121 = __toESM(require_classnames());
function RadioButtonSkeleton(props) {
  const {
    className,
    ...rest
  } = props;
  const prefix = usePrefix();
  return import_react188.default.createElement("div", _extends({
    className: (0, import_classnames121.default)(`${prefix}--radio-button-wrapper`, className)
  }, rest), import_react188.default.createElement("div", {
    className: `${prefix}--radio-button ${prefix}--skeleton`
  }), import_react188.default.createElement("span", {
    className: `${prefix}--radio-button__label ${prefix}--skeleton`
  }));
}
RadioButtonSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types143.default.string
};

// node_modules/@carbon/react/es/components/RadioButtonGroup/RadioButtonGroup.js
var import_prop_types144 = __toESM(require_prop_types());
var import_react189 = __toESM(require_react());
var import_classnames122 = __toESM(require_classnames());
var RadioButtonGroup = import_react189.default.forwardRef((props, ref) => {
  const {
    children,
    className,
    decorator,
    defaultSelected,
    disabled,
    helperText,
    invalid = false,
    invalidText,
    labelPosition = "right",
    legendText,
    name,
    onChange = () => {
    },
    orientation = "horizontal",
    readOnly,
    valueSelected,
    warn: warn2 = false,
    warnText,
    slug,
    required,
    ...rest
  } = props;
  const prefix = usePrefix();
  const [selected, setSelected] = (0, import_react189.useState)(valueSelected ?? defaultSelected);
  const [prevValueSelected, setPrevValueSelected] = (0, import_react189.useState)(valueSelected);
  const radioButtonGroupInstanceId = useId();
  if (valueSelected !== prevValueSelected) {
    setSelected(valueSelected);
    setPrevValueSelected(valueSelected);
  }
  function getRadioButtons() {
    const mappedChildren = import_react189.default.Children.map(children, (radioButton) => {
      if (!radioButton) {
        return;
      }
      const newProps = {
        name,
        key: radioButton.props.value,
        value: radioButton.props.value,
        onChange: handleOnChange,
        checked: radioButton.props.value === selected,
        required
      };
      if (!selected && radioButton.props.checked) {
        newProps.checked = true;
      }
      return import_react189.default.cloneElement(radioButton, newProps);
    });
    return mappedChildren;
  }
  function handleOnChange(newSelection, value, evt) {
    if (!readOnly) {
      if (newSelection !== selected) {
        setSelected(newSelection);
        onChange(newSelection, name, evt);
      }
    }
  }
  const showWarning = !readOnly && !invalid && warn2;
  const showHelper = !invalid && !disabled && !warn2;
  const wrapperClasses = (0, import_classnames122.default)(`${prefix}--form-item`, className);
  const fieldsetClasses = (0, import_classnames122.default)(`${prefix}--radio-button-group`, {
    [`${prefix}--radio-button-group--${orientation}`]: orientation === "vertical",
    [`${prefix}--radio-button-group--label-${labelPosition}`]: labelPosition,
    [`${prefix}--radio-button-group--readonly`]: readOnly,
    [`${prefix}--radio-button-group--invalid`]: !readOnly && invalid,
    [`${prefix}--radio-button-group--warning`]: showWarning,
    [`${prefix}--radio-button-group--slug`]: slug,
    [`${prefix}--radio-button-group--decorator`]: decorator
  });
  const helperClasses = (0, import_classnames122.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const helperId = !helperText ? void 0 : `radio-button-group-helper-text-${radioButtonGroupInstanceId}`;
  const helper = helperText ? import_react189.default.createElement("div", {
    id: helperId,
    className: helperClasses
  }, helperText) : null;
  const divRef = (0, import_react189.useRef)(null);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react189.cloneElement)(candidate, {
    size: "mini",
    kind: "default"
  }) : null;
  return import_react189.default.createElement("div", {
    className: wrapperClasses,
    ref: mergeRefs(divRef, ref)
  }, import_react189.default.createElement("fieldset", _extends({
    className: fieldsetClasses,
    disabled,
    "data-invalid": invalid ? true : void 0,
    "aria-describedby": showHelper && helperText ? helperId : void 0
  }, rest), legendText && import_react189.default.createElement(Legend, {
    className: `${prefix}--label`
  }, legendText, slug ? normalizedDecorator : decorator ? import_react189.default.createElement("div", {
    className: `${prefix}--radio-button-group-inner--decorator`
  }, normalizedDecorator) : ""), getRadioButtons()), import_react189.default.createElement("div", {
    className: `${prefix}--radio-button__validation-msg`
  }, !readOnly && invalid && import_react189.default.createElement(import_react189.default.Fragment, null, import_react189.default.createElement(WarningFilled, {
    className: `${prefix}--radio-button__invalid-icon`
  }), import_react189.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalidText)), showWarning && import_react189.default.createElement(import_react189.default.Fragment, null, import_react189.default.createElement(WarningAltFilled, {
    className: `${prefix}--radio-button__invalid-icon ${prefix}--radio-button__invalid-icon--warning`
  }), import_react189.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, warnText))), showHelper && helper);
});
RadioButtonGroup.propTypes = {
  /**
   * Provide a collection of `<RadioButton>` components to render in the group
   */
  children: import_prop_types144.default.node,
  /**
   * Provide an optional className to be applied to the container node
   */
  className: import_prop_types144.default.string,
  /**
   * **Experimental**: Provide a decorator component to be rendered inside the `RadioButtonGroup` component
   */
  decorator: import_prop_types144.default.node,
  /**
   * Specify the `<RadioButton>` to be selected by default
   */
  defaultSelected: import_prop_types144.default.oneOfType([import_prop_types144.default.string, import_prop_types144.default.number]),
  /**
   * Specify whether the group is disabled
   */
  disabled: import_prop_types144.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types144.default.node,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types144.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types144.default.node,
  /**
   * Provide where label text should be placed
   */
  labelPosition: import_prop_types144.default.oneOf(["left", "right"]),
  /**
   * Provide a legend to the RadioButtonGroup input that you are
   * exposing to the user
   */
  legendText: import_prop_types144.default.node,
  /**
   * Specify the name of the underlying `<input>` nodes
   */
  name: import_prop_types144.default.string.isRequired,
  /**
   * Provide an optional `onChange` hook that is called whenever the value of
   * the group changes
   */
  onChange: import_prop_types144.default.func,
  /**
   * Provide where radio buttons should be placed
   */
  orientation: import_prop_types144.default.oneOf(["horizontal", "vertical"]),
  /**
   * Whether the RadioButtonGroup should be read-only
   */
  readOnly: import_prop_types144.default.bool,
  /**
   * `true` to specify if radio selection in group is required.
   */
  required: import_prop_types144.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `RadioButtonGroup` component
   */
  slug: deprecate(import_prop_types144.default.node, "The `slug` prop has been deprecated and will be removed in the next major version. Use the decorator prop instead."),
  /**
   * Specify the value that is currently selected in the group
   */
  valueSelected: import_prop_types144.default.oneOfType([import_prop_types144.default.string, import_prop_types144.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types144.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types144.default.node
};
RadioButtonGroup.displayName = "RadioButtonGroup";

// node_modules/@carbon/react/es/components/RadioTile/RadioTile.js
var import_classnames123 = __toESM(require_classnames());
var import_prop_types145 = __toESM(require_prop_types());
var import_react190 = __toESM(require_react());
var _RadioButtonChecked;
var _RadioButton;
var _CheckmarkFilled;
var RadioTile = import_react190.default.forwardRef(function RadioTile2({
  children,
  className: customClassName,
  decorator,
  disabled,
  light,
  checked,
  name,
  value,
  id,
  onChange = noopFn,
  tabIndex = 0,
  hasRoundedCorners,
  slug,
  required,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const inputId = useFallbackId(id);
  const className = (0, import_classnames123.default)(customClassName, `${prefix}--tile`, `${prefix}--tile--selectable`, `${prefix}--tile--radio`, {
    [`${prefix}--tile--is-selected`]: checked,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--disabled`]: disabled,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  });
  const v12TileRadioIcons = useFeatureFlag("enable-v12-tile-radio-icons");
  function icon() {
    if (v12TileRadioIcons) {
      if (checked) {
        return _RadioButtonChecked || (_RadioButtonChecked = import_react190.default.createElement(RadioButtonChecked, null));
      } else {
        return _RadioButton || (_RadioButton = import_react190.default.createElement(RadioButton, null));
      }
    } else {
      return _CheckmarkFilled || (_CheckmarkFilled = import_react190.default.createElement(CheckmarkFilled, null));
    }
  }
  function handleOnChange(evt) {
    onChange(value, name, evt);
  }
  function handleOnKeyDown2(evt) {
    if (matches(evt, [Enter, Space])) {
      evt.preventDefault();
      onChange(value, name, evt);
    }
  }
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react190.cloneElement)(candidate, {
    size: "xs"
  }) : null;
  return import_react190.default.createElement("div", null, import_react190.default.createElement("input", {
    checked,
    className: `${prefix}--tile-input`,
    disabled,
    id: inputId,
    name,
    onChange: !disabled ? handleOnChange : void 0,
    onKeyDown: !disabled ? handleOnKeyDown2 : void 0,
    tabIndex: !disabled ? tabIndex : void 0,
    type: "radio",
    value,
    ref,
    required
  }), import_react190.default.createElement("label", _extends({}, rest, {
    htmlFor: inputId,
    className
  }), import_react190.default.createElement("span", {
    className: `${prefix}--tile__checkmark`
  }, icon()), import_react190.default.createElement(Text, {
    className: `${prefix}--tile-content`
  }, children), slug ? normalizedDecorator : decorator ? import_react190.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, normalizedDecorator) : ""));
});
RadioTile.displayName = "RadioTile";
RadioTile.propTypes = {
  /**
   * Specify whether the `RadioTile` should be checked.
   */
  checked: import_prop_types145.default.bool,
  /**
   * The `RadioTile` content.
   */
  children: import_prop_types145.default.node,
  /**
   * Provide an optional `className` to be applied to the underlying `<label>`.
   */
  className: import_prop_types145.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `RadioTile` component
   */
  decorator: import_prop_types145.default.node,
  /**
   * Specify whether the `RadioTile` should be disabled.
   */
  disabled: import_prop_types145.default.bool,
  /**
   * Specify if the `ExpandableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types145.default.bool,
  /**
   * Provide a unique id for the underlying `<input>`.
   */
  id: import_prop_types145.default.string,
  /**
   * `true` to use the light version. For use on `$layer-01` backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types145.default.bool, "The `light` prop for `RadioTile` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Provide a `name` for the underlying `<input>`.
   */
  name: import_prop_types145.default.string,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes.
   */
  onChange: import_prop_types145.default.func,
  /**
   * `true` to specify if the control is required.
   */
  required: import_prop_types145.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `RadioTile` component
   */
  slug: deprecate(import_prop_types145.default.node, "The `slug` prop for `RadioTile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Specify the tab index of the underlying `<input>`.
   */
  tabIndex: import_prop_types145.default.number,
  /**
   * Specify the value of the underlying `<input>`.
   */
  value: import_prop_types145.default.oneOfType([import_prop_types145.default.string, import_prop_types145.default.number]).isRequired
};

// node_modules/@carbon/react/es/components/SecondaryButton/SecondaryButton.js
var import_react191 = __toESM(require_react());
var SecondaryButton = (props) => import_react191.default.createElement(Button, _extends({
  kind: "secondary"
}, props));

// node_modules/@carbon/react/es/components/SelectItemGroup/SelectItemGroup.js
var import_prop_types146 = __toESM(require_prop_types());
var import_react192 = __toESM(require_react());
var import_classnames124 = __toESM(require_classnames());
var SelectItemGroup = ({
  children,
  className,
  disabled = false,
  label,
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames124.default)(`${prefix}--select-optgroup`, className);
  return import_react192.default.createElement("optgroup", _extends({
    className: classNames,
    label,
    disabled
  }, other), children);
};
SelectItemGroup.propTypes = {
  /**
   * Provide the contents of your <SelectItemGroup>
   */
  children: import_prop_types146.default.node,
  /**
   * Specify an optional className to be applied to the node
   */
  className: import_prop_types146.default.string,
  /**
   * Specify whether the <SelectItemGroup> should be disabled
   */
  disabled: import_prop_types146.default.bool,
  /**
   * Specify the label to be displayed
   */
  label: import_prop_types146.default.string.isRequired
};

// node_modules/@carbon/react/es/components/SkeletonIcon/SkeletonIcon.js
var import_prop_types147 = __toESM(require_prop_types());
var import_react193 = __toESM(require_react());
var import_classnames125 = __toESM(require_classnames());
var SkeletonIcon = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  const skeletonIconClasses = (0, import_classnames125.default)(className, {
    [`${prefix}--icon--skeleton`]: true
  });
  return import_react193.default.createElement("div", _extends({
    className: skeletonIconClasses
  }, other));
};
SkeletonIcon.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types147.default.string
};

// node_modules/@carbon/react/es/components/SkeletonPlaceholder/SkeletonPlaceholder.js
var import_react194 = __toESM(require_react());
var import_prop_types148 = __toESM(require_prop_types());
var import_classnames126 = __toESM(require_classnames());
var SkeletonPlaceholder = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  const skeletonPlaceholderClasses = (0, import_classnames126.default)({
    [`${prefix}--skeleton__placeholder`]: true
  }, className);
  return import_react194.default.createElement("div", _extends({
    className: skeletonPlaceholderClasses
  }, other));
};
SkeletonPlaceholder.propTypes = {
  /**
   * Add a custom class to the component
   * to set the height and width
   */
  className: import_prop_types148.default.string
};

// node_modules/@carbon/react/es/components/Slider/Slider.js
var import_react196 = __toESM(require_react());
var import_prop_types149 = __toESM(require_prop_types());
var import_classnames127 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/Slider/SliderHandles.js
var import_react195 = __toESM(require_react());
var _path;
var _path2;
var _path3;
var _path4;
var _path5;
var _path6;
var _path7;
var _path8;
var _path9;
var _path0;
var _path1;
var _path10;
var _path11;
var _path12;
var LowerHandle = (props) => import_react195.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react195.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--lower`
}, props), _path || (_path = import_react195.default.createElement("path", {
  d: "M15.08 6.46H16v11.08h-.92zM4.46 17.54c-.25 0-.46-.21-.46-.46V6.92a.465.465 0 0 1 .69-.4l8.77 5.08a.46.46 0 0 1 0 .8l-8.77 5.08c-.07.04-.15.06-.23.06Z"
})), _path2 || (_path2 = import_react195.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
}))));
var LowerHandleFocus = (props) => import_react195.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react195.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--lower ${prefix}--slider__thumb-icon--focus`
}, props), _path3 || (_path3 = import_react195.default.createElement("path", {
  d: "M15.08 6.46H16v11.08h-.92zM4.46 17.54c-.25 0-.46-.21-.46-.46V6.92a.465.465 0 0 1 .69-.4l8.77 5.08a.46.46 0 0 1 0 .8l-8.77 5.08c-.07.04-.15.06-.23.06Z"
})), _path4 || (_path4 = import_react195.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
})), _path5 || (_path5 = import_react195.default.createElement("path", {
  d: "M15.08 0H16v6.46h-.92z"
})), _path6 || (_path6 = import_react195.default.createElement("path", {
  d: "M0 0h.92v24H0zM15.08 0H16v24h-.92z"
})), _path7 || (_path7 = import_react195.default.createElement("path", {
  d: "M0 .92V0h16v.92zM0 24v-.92h16V24z"
}))));
var UpperHandle = (props) => import_react195.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react195.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--upper`
}, props), _path8 || (_path8 = import_react195.default.createElement("path", {
  d: "M0 6.46h.92v11.08H0zM11.54 6.46c.25 0 .46.21.46.46v10.15a.465.465 0 0 1-.69.4L2.54 12.4a.46.46 0 0 1 0-.8l8.77-5.08c.07-.04.15-.06.23-.06Z"
})), _path9 || (_path9 = import_react195.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
}))));
var UpperHandleFocus = (props) => import_react195.default.createElement(PrefixContext.Consumer, null, (prefix) => import_react195.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 16 24",
  className: `${prefix}--slider__thumb-icon ${prefix}--slider__thumb-icon--upper ${prefix}--slider__thumb-icon--focus`
}, props), _path0 || (_path0 = import_react195.default.createElement("path", {
  d: "M0 6.46h.92v11.08H0zM11.54 6.46c.25 0 .46.21.46.46v10.15a.465.465 0 0 1-.69.4L2.54 12.4a.46.46 0 0 1 0-.8l8.77-5.08c.07-.04.15-.06.23-.06Z"
})), _path1 || (_path1 = import_react195.default.createElement("path", {
  fill: "none",
  d: "M-4 0h24v24H-4z"
})), _path10 || (_path10 = import_react195.default.createElement("path", {
  d: "M.92 24H0v-6.46h.92z"
})), _path11 || (_path11 = import_react195.default.createElement("path", {
  d: "M16 24h-.92V0H16zM.92 24H0V0h.92z"
})), _path12 || (_path12 = import_react195.default.createElement("path", {
  d: "M16 23.08V24H0v-.92zM16 0v.92H0V0z"
}))));

// node_modules/@carbon/react/es/node_modules/es-toolkit/dist/compat/function/throttle.js
function throttle(func, throttleMs = 0, options = {}) {
  if (typeof options !== "object") {
    options = {};
  }
  const { leading = true, trailing = true, signal } = options;
  return debounce2(func, throttleMs, {
    leading,
    trailing,
    signal,
    maxWait: throttleMs
  });
}

// node_modules/@carbon/react/es/components/Slider/Slider.js
var ThumbWrapper = ({
  hasTooltip,
  className,
  style,
  children,
  ...rest
}) => {
  if (hasTooltip) {
    return (
      // eslint-disable-next-line react/forbid-component-props
      import_react196.default.createElement(Tooltip, _extends({
        className,
        style
      }, rest), children)
    );
  } else {
    return (
      // eslint-disable-next-line react/forbid-dom-props
      import_react196.default.createElement("div", {
        className,
        style
      }, children)
    );
  }
};
var translationIds5 = {
  autoCorrectAnnouncement: "carbon.slider.auto-correct-announcement"
};
function translateWithId7(translationId, translationState) {
  if (translationState == null ? void 0 : translationState.correctedValue) {
    const {
      correctedValue
    } = translationState;
    return `The inputted value "${correctedValue}" was corrected to the nearest allowed digit.`;
  }
  return "";
}
var defaultFormatLabel = (value, label) => {
  return `${value}${label ?? ""}`;
};
var EVENT_THROTTLE = 16;
var DRAG_EVENT_TYPES = /* @__PURE__ */ new Set(["mousemove", "touchmove"]);
var DRAG_STOP_EVENT_TYPES2 = /* @__PURE__ */ new Set(["mouseup", "touchend", "touchcancel"]);
var HandlePosition = function(HandlePosition2) {
  HandlePosition2["LOWER"] = "lower";
  HandlePosition2["UPPER"] = "upper";
  return HandlePosition2;
}(HandlePosition || {});
var Slider = class extends import_react196.PureComponent {
  constructor(props) {
    super(props);
    _defineProperty(this, "state", {
      value: this.props.value,
      valueUpper: this.props.unstable_valueUpper,
      left: 0,
      leftUpper: 0,
      needsOnRelease: false,
      isValid: true,
      isValidUpper: true,
      activeHandle: void 0,
      correctedValue: null,
      correctedPosition: null,
      isRtl: false
    });
    _defineProperty(this, "thumbRef", void 0);
    _defineProperty(this, "thumbRefUpper", void 0);
    _defineProperty(this, "filledTrackRef", void 0);
    _defineProperty(this, "element", null);
    _defineProperty(this, "inputId", "");
    _defineProperty(this, "track", void 0);
    _defineProperty(this, "handleDrag", (event) => {
      if (event instanceof globalThis.MouseEvent || event instanceof globalThis.TouchEvent) {
        this.onDrag(event);
      }
    });
    _defineProperty(this, "onDragStart", (evt) => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      evt.preventDefault();
      DRAG_STOP_EVENT_TYPES2.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.addEventListener(element, this.onDragStop);
      });
      DRAG_EVENT_TYPES.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.addEventListener(element, this.handleDrag);
      });
      const clientX = this.getClientXFromEvent(evt.nativeEvent);
      let activeHandle;
      if (this.hasTwoHandles()) {
        if (evt.target == this.thumbRef.current) {
          activeHandle = HandlePosition.LOWER;
        } else if (evt.target == this.thumbRefUpper.current) {
          activeHandle = HandlePosition.UPPER;
        } else if (clientX) {
          const distanceToLower = this.calcDistanceToHandle(HandlePosition.LOWER, clientX);
          const distanceToUpper = this.calcDistanceToHandle(HandlePosition.UPPER, clientX);
          if (distanceToLower <= distanceToUpper) {
            activeHandle = HandlePosition.LOWER;
          } else {
            activeHandle = HandlePosition.UPPER;
          }
        }
      }
      const focusOptions = {
        preventScroll: true
      };
      if (this.hasTwoHandles()) {
        if (this.thumbRef.current && activeHandle === HandlePosition.LOWER) {
          this.thumbRef.current.focus(focusOptions);
        } else if (this.thumbRefUpper.current && activeHandle === HandlePosition.UPPER) {
          this.thumbRefUpper.current.focus(focusOptions);
        }
      } else if (this.thumbRef.current) {
        this.thumbRef.current.focus(focusOptions);
      }
      this.setState({
        activeHandle
      });
      this.onDrag(evt.nativeEvent, activeHandle);
    });
    _defineProperty(this, "onDragStop", () => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      DRAG_STOP_EVENT_TYPES2.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.removeEventListener(element, this.onDragStop);
      });
      DRAG_EVENT_TYPES.forEach((element) => {
        var _a;
        (_a = this.element) == null ? void 0 : _a.ownerDocument.removeEventListener(element, this.handleDrag);
      });
      this.setState({
        needsOnRelease: true,
        isValid: true,
        isValidUpper: true
      });
    });
    _defineProperty(this, "_onDrag", (evt, activeHandle) => {
      activeHandle = activeHandle ?? this.state.activeHandle;
      if (this.props.disabled || this.props.readOnly || !evt) {
        return;
      }
      const clientX = this.getClientXFromEvent(evt);
      const {
        value,
        left
      } = this.calcValue({
        clientX,
        value: this.state.value
      });
      if (this.hasTwoHandles() && activeHandle) {
        this.setValueLeftForHandle(activeHandle, {
          value: this.nearestStepValue(value),
          left
        });
      } else {
        this.setState({
          value: this.nearestStepValue(value),
          left,
          isValid: true
        });
      }
      this.setState({
        correctedValue: null,
        correctedPosition: null
      });
    });
    _defineProperty(this, "onDrag", throttle(this._onDrag, EVENT_THROTTLE, {
      leading: true,
      trailing: false
    }));
    _defineProperty(this, "onKeyDown", (evt) => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      const {
        step = 1,
        stepMultiplier = 4
      } = this.props;
      let delta = 0;
      if (matches(evt, [ArrowDown, ArrowLeft])) {
        delta = -step;
      } else if (matches(evt, [ArrowUp2, ArrowRight2])) {
        delta = step;
      } else {
        return;
      }
      if (evt.shiftKey) {
        delta *= stepMultiplier;
      }
      if (this.hasTwoHandles() && this.state.activeHandle) {
        const currentValue = this.state.activeHandle === HandlePosition.LOWER ? this.state.value : this.state.valueUpper;
        const {
          value,
          left
        } = this.calcValue({
          value: this.calcValueForDelta(currentValue ?? this.props.min, delta, this.props.step)
        });
        this.setValueLeftForHandle(this.state.activeHandle, {
          value: this.nearestStepValue(value),
          left
        });
      } else {
        const {
          value,
          left
        } = this.calcValue({
          // Ensures custom value from `<input>` won't cause skipping next stepping
          // point with right arrow key, e.g. Typing 51 in `<input>`, moving focus
          // onto the thumb and the hitting right arrow key should yield 52 instead
          // of 54.
          value: this.calcValueForDelta(this.state.value, delta, this.props.step)
        });
        this.setState({
          value: this.nearestStepValue(value),
          left,
          isValid: true
        });
      }
      this.setState({
        correctedValue: null,
        correctedPosition: null
      });
    });
    _defineProperty(this, "onChange", (evt) => {
      if (this.props.disabled || this.props.readOnly) {
        return;
      }
      if (!evt || !("target" in evt) || typeof evt.target.value !== "string") {
        return;
      }
      const activeHandle = evt.target.dataset.handlePosition ?? HandlePosition.LOWER;
      const targetValue = Number.parseFloat(evt.target.value);
      if (this.hasTwoHandles()) {
        if (isNaN(targetValue)) {
          this.setValueForHandle(activeHandle, evt.target.value);
        } else if (this.isValidValueForPosition({
          handle: activeHandle,
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        })) {
          this.processNewInputValue(evt.target);
        } else {
          this.setValueForHandle(activeHandle, targetValue);
        }
      } else {
        if (isNaN(targetValue)) {
          this.setState({
            value: evt.target.value
          });
        } else if (this.isValidValue({
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        })) {
          this.processNewInputValue(evt.target);
        } else {
          this.setState({
            value: targetValue
          });
        }
      }
    });
    _defineProperty(this, "onBlur", (evt) => {
      var _a, _b;
      if (!evt || !("target" in evt) || typeof evt.target.value !== "string") {
        return;
      }
      const {
        value: targetValue
      } = evt.target;
      this.processNewInputValue(evt.target);
      (_b = (_a = this.props).onBlur) == null ? void 0 : _b.call(_a, {
        value: targetValue,
        handlePosition: evt.target.dataset.handlePosition
      });
    });
    _defineProperty(this, "onInputKeyDown", (evt) => {
      if (this.props.disabled || this.props.readOnly || !(evt.target instanceof HTMLInputElement)) {
        return;
      }
      if (!evt || !("target" in evt) || typeof evt.target.value !== "string") {
        return;
      }
      if (matches(evt, [Enter])) {
        this.processNewInputValue(evt.target);
      }
    });
    _defineProperty(this, "processNewInputValue", (input) => {
      this.setState({
        correctedValue: null,
        correctedPosition: null
      });
      const targetValue = Number.parseFloat(input.value);
      const validity = !isNaN(targetValue);
      const handlePosition = input.dataset.handlePosition;
      if (handlePosition === HandlePosition.LOWER) {
        this.setState({
          isValid: validity
        });
      } else if (handlePosition === HandlePosition.UPPER) {
        this.setState({
          isValidUpper: validity
        });
      }
      this.setState({
        isValid: validity
      });
      if (validity) {
        const adjustedValue = handlePosition ? this.getAdjustedValueForPosition({
          handle: handlePosition,
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        }) : this.getAdjustedValue({
          value: targetValue,
          min: this.props.min,
          max: this.props.max
        });
        if (adjustedValue !== targetValue) {
          this.setState({
            correctedValue: targetValue.toString(),
            correctedPosition: handlePosition
          });
        } else {
          this.setState({
            correctedValue: null,
            correctedPosition: null
          });
        }
        const {
          value,
          left
        } = this.calcValue({
          value: adjustedValue,
          useRawValue: true
        });
        if (handlePosition) {
          this.setValueLeftForHandle(handlePosition, {
            value: this.nearestStepValue(value),
            left
          });
        } else {
          this.setState({
            value,
            left
          });
        }
      }
    });
    _defineProperty(this, "calcLeftPercent", ({
      clientX,
      value,
      range
    }) => {
      var _a, _b;
      const boundingRect = (_b = (_a = this.element) == null ? void 0 : _a.getBoundingClientRect) == null ? void 0 : _b.call(_a);
      let width = boundingRect ? boundingRect.right - boundingRect.left : 0;
      if (width <= 0) {
        width = 1;
      }
      if (clientX) {
        const leftOffset = this.state.isRtl ? ((boundingRect == null ? void 0 : boundingRect.right) ?? 0) - clientX : clientX - ((boundingRect == null ? void 0 : boundingRect.left) ?? 0);
        return leftOffset / width;
      } else if (value !== null && typeof value !== "undefined" && range) {
        return range === 0 ? 0 : (value - this.props.min) / range;
      }
      return 0;
    });
    _defineProperty(this, "calcDiscreteValueAndPercent", ({
      leftPercent
    }) => {
      const {
        step = 1,
        min: min2,
        max: max2
      } = this.props;
      const numSteps = Math.floor((max2 - min2) / step) + ((max2 - min2) % step === 0 ? 1 : 2);
      const stepIndex = Math.round(leftPercent * (numSteps - 1));
      const discreteValue = stepIndex === numSteps - 1 ? max2 : min2 + step * stepIndex;
      const discretePercent = stepIndex / (numSteps - 1);
      return {
        discreteValue,
        discretePercent
      };
    });
    _defineProperty(this, "calcValue", ({
      clientX,
      value,
      useRawValue
    }) => {
      const range = this.props.max - this.props.min;
      const leftPercentRaw = this.calcLeftPercent({
        clientX,
        value,
        range
      });
      const leftPercent = clamp2(leftPercentRaw, 0, 1);
      if (useRawValue) {
        return {
          value,
          left: leftPercent * 100
        };
      }
      const {
        discreteValue,
        discretePercent
      } = this.calcDiscreteValueAndPercent({
        leftPercent
      });
      return {
        value: discreteValue,
        left: discretePercent * 100
      };
    });
    _defineProperty(this, "calcDistanceToHandle", (handle, clientX) => {
      const handleBoundingRect = this.getHandleBoundingRect(handle);
      const handleX = handleBoundingRect.left + handleBoundingRect.width / 2;
      return Math.abs(handleX - clientX);
    });
    _defineProperty(this, "calcValueForDelta", (currentValue, delta, step = 1) => {
      const base = delta > 0 ? Math.floor(currentValue / step) * step : currentValue;
      const newValue = base + delta;
      const decimals = (step.toString().split(".")[1] || "").length;
      return Number(newValue.toFixed(decimals));
    });
    _defineProperty(this, "setValueLeftForHandle", (handle, {
      value: newValue,
      left: newLeft
    }) => {
      const {
        value,
        valueUpper,
        left,
        leftUpper
      } = this.state;
      if (handle === HandlePosition.LOWER) {
        this.setState({
          value: valueUpper && newValue > valueUpper ? valueUpper : newValue,
          left: valueUpper && newValue > valueUpper ? leftUpper : newLeft,
          isValid: true
        });
      } else {
        this.setState({
          valueUpper: value && newValue < value ? value : newValue,
          leftUpper: value && newValue < value ? left : newLeft,
          isValidUpper: true
        });
      }
    });
    _defineProperty(this, "setValueForHandle", (handle, value) => {
      if (handle === HandlePosition.LOWER) {
        this.setState({
          value,
          isValid: true
        });
      } else {
        this.setState({
          valueUpper: value,
          isValidUpper: true
        });
      }
    });
    _defineProperty(this, "isValidValueForPosition", ({
      handle,
      value: newValue,
      min: min2,
      max: max2
    }) => {
      const {
        value,
        valueUpper
      } = this.state;
      if (!this.isValidValue({
        value: newValue,
        min: min2,
        max: max2
      })) {
        return false;
      }
      if (handle === HandlePosition.LOWER) {
        return !valueUpper || newValue <= valueUpper;
      } else if (handle === HandlePosition.UPPER) {
        return !value || newValue >= value;
      }
      return false;
    });
    _defineProperty(this, "isValidValue", ({
      value,
      min: min2,
      max: max2
    }) => {
      return !(value < min2 || value > max2);
    });
    _defineProperty(this, "getAdjustedValueForPosition", ({
      handle,
      value: newValue,
      min: min2,
      max: max2
    }) => {
      const {
        value,
        valueUpper
      } = this.state;
      newValue = this.getAdjustedValue({
        value: newValue,
        min: min2,
        max: max2
      });
      if (handle === HandlePosition.LOWER && valueUpper) {
        newValue = newValue > valueUpper ? valueUpper : newValue;
      } else if (handle === HandlePosition.UPPER && value) {
        newValue = newValue < value ? value : newValue;
      }
      return newValue;
    });
    _defineProperty(this, "getAdjustedValue", ({
      value,
      min: min2,
      max: max2
    }) => {
      if (value < min2) {
        value = min2;
      }
      if (value > max2) {
        value = max2;
      }
      return value;
    });
    _defineProperty(this, "getHandleBoundingRect", (handle) => {
      var _a, _b;
      let boundingRect;
      if (handle === HandlePosition.LOWER) {
        boundingRect = (_a = this.thumbRef.current) == null ? void 0 : _a.getBoundingClientRect();
      } else {
        boundingRect = (_b = this.thumbRefUpper.current) == null ? void 0 : _b.getBoundingClientRect();
      }
      return boundingRect ?? new DOMRect();
    });
    this.thumbRef = (0, import_react196.createRef)();
    this.thumbRefUpper = (0, import_react196.createRef)();
    this.filledTrackRef = (0, import_react196.createRef)();
  }
  /**
   * Sets up initial slider position and value in response to component mount.
   */
  componentDidMount() {
    if (this.element) {
      const isRtl = (document == null ? void 0 : document.dir) === "rtl";
      if (this.hasTwoHandles()) {
        const {
          value,
          left
        } = this.calcValue({
          value: this.state.value,
          useRawValue: true
        });
        const {
          value: valueUpper,
          left: leftUpper
        } = this.calcValue({
          value: this.state.valueUpper,
          useRawValue: true
        });
        this.setState({
          isRtl,
          value,
          left,
          valueUpper,
          leftUpper
        });
        if (this.filledTrackRef.current) {
          this.filledTrackRef.current.style.transform = this.state.isRtl ? `translate(${100 - this.state.leftUpper}%, -50%) scaleX(${(this.state.leftUpper - this.state.left) / 100})` : `translate(${this.state.left}%, -50%) scaleX(${(this.state.leftUpper - this.state.left) / 100})`;
        }
      } else {
        const {
          value,
          left
        } = this.calcValue({
          value: this.state.value,
          useRawValue: true
        });
        this.setState({
          isRtl,
          value,
          left
        });
        if (this.filledTrackRef.current) {
          this.filledTrackRef.current.style.transform = this.state.isRtl ? `translate(100%, -50%) scaleX(-${this.state.left / 100})` : `translate(0%, -50%) scaleX(${this.state.left / 100})`;
        }
      }
    }
  }
  /**
   * Handles firing of `onChange` and `onRelease` callbacks to parent in
   * response to state changes.
   *
   * @param {*} prevProps prevProps
   * @param {*} prevState The previous Slider state, used to see if callbacks
   * should be called.
   */
  componentDidUpdate(prevProps, prevState) {
    if (this.hasTwoHandles()) {
      if (this.filledTrackRef.current) {
        this.filledTrackRef.current.style.transform = this.state.isRtl ? `translate(${100 - this.state.leftUpper}%, -50%) scaleX(${(this.state.leftUpper - this.state.left) / 100})` : `translate(${this.state.left}%, -50%) scaleX(${(this.state.leftUpper - this.state.left) / 100})`;
      }
    } else {
      if (this.filledTrackRef.current) {
        this.filledTrackRef.current.style.transform = this.state.isRtl ? `translate(100%, -50%) scaleX(-${this.state.left / 100})` : `translate(0%, -50%) scaleX(${this.state.left / 100})`;
      }
    }
    if ((prevState.value !== this.state.value || prevState.valueUpper !== this.state.valueUpper) && typeof this.props.onChange === "function") {
      this.props.onChange({
        value: this.state.value,
        valueUpper: this.state.valueUpper
      });
    }
    if (this.state.needsOnRelease && typeof this.props.onRelease === "function") {
      this.props.onRelease({
        value: this.state.value,
        valueUpper: this.state.valueUpper
      });
      this.setState({
        needsOnRelease: false
      });
    }
    if (prevProps.value === this.props.value && prevProps.unstable_valueUpper === this.props.unstable_valueUpper && prevProps.max === this.props.max && prevProps.min === this.props.min) {
      return;
    }
    this.setState(this.calcValue({
      value: this.props.value,
      useRawValue: true
    }));
    if (typeof this.props.unstable_valueUpper !== "undefined") {
      const {
        value: valueUpper,
        left: leftUpper
      } = this.calcValue({
        value: this.props.unstable_valueUpper,
        useRawValue: true
      });
      this.setState({
        valueUpper,
        leftUpper
      });
    } else {
      this.setState({
        valueUpper: void 0,
        leftUpper: void 0
      });
    }
  }
  /**
   * Rounds a given value to the nearest step defined by the slider's `step`
   * prop.
   *
   * @param value - The value to adjust to the nearest step. Defaults to `0`.
   * @returns The value rounded to the precision determined by the step.
   */
  nearestStepValue(value = 0) {
    var _a;
    const decimals = (((_a = this.props.step) == null ? void 0 : _a.toString().split(".")[1]) || "").length;
    return Number(value.toFixed(decimals));
  }
  getClientXFromEvent(event) {
    let clientX;
    if ("clientX" in event) {
      clientX = event.clientX;
    } else if ("touches" in event && 0 in event.touches && "clientX" in event.touches[0]) {
      clientX = event.touches[0].clientX;
    }
    return clientX;
  }
  hasTwoHandles() {
    return typeof this.state.valueUpper !== "undefined";
  }
  // syncs invalid state and prop
  static getDerivedStateFromProps(props, state) {
    const {
      isValid,
      isValidUpper
    } = state;
    const derivedState = {};
    if (props.invalid === true) {
      if (isValid === true) derivedState.isValid = false;
      if (isValidUpper === true) derivedState.isValidUpper = false;
    } else if (props.invalid === false) {
      if (isValid === false) derivedState.isValid = true;
      if (isValidUpper === false) derivedState.isValidUpper = true;
    }
    return Object.keys(derivedState).length ? derivedState : null;
  }
  render() {
    var _Fragment, _Fragment2, _Fragment3, _Fragment4;
    const {
      ariaLabelInput,
      unstable_ariaLabelInputUpper: ariaLabelInputUpper,
      className,
      hideTextInput = false,
      id = this.inputId = this.inputId || // TODO:
      // 1. Why isn't `inputId` just set to this value instead of an empty
      //    string?
      // 2. Why this value instead of something else, like
      //    `crypto.randomUUID()` or `useId()`?
      `__carbon-slider_${Math.random().toString(36).substr(2)}`,
      min: min2,
      minLabel,
      max: max2,
      maxLabel,
      formatLabel = defaultFormatLabel,
      labelText,
      hideLabel,
      step = 1,
      // TODO: Other properties are deleted below. Why isn't this one?
      stepMultiplier: _stepMultiplier,
      inputType = "number",
      invalidText,
      required,
      disabled = false,
      name,
      unstable_nameUpper: nameUpper,
      light,
      readOnly = false,
      warn: warn2,
      warnText,
      translateWithId: t3 = translateWithId7,
      ...other
    } = this.props;
    const twoHandles = this.hasTwoHandles();
    delete other.onRelease;
    delete other.invalid;
    delete other.unstable_valueUpper;
    const {
      value,
      valueUpper,
      isValid,
      isValidUpper,
      correctedValue,
      correctedPosition,
      isRtl
    } = this.state;
    const showWarning = !readOnly && warn2 || // TODO: https://github.com/carbon-design-system/carbon/issues/18991#issuecomment-2795709637
    typeof correctedValue !== null && correctedPosition === HandlePosition.LOWER && isValid;
    const showWarningUpper = !readOnly && warn2 || // TODO: https://github.com/carbon-design-system/carbon/issues/18991#issuecomment-2795709637
    typeof correctedValue !== null && correctedPosition === (twoHandles ? HandlePosition.UPPER : HandlePosition.LOWER) && (twoHandles ? isValidUpper : isValid);
    return import_react196.default.createElement(PrefixContext.Consumer, null, (prefix) => {
      const labelId = `${id}-label`;
      const labelClasses = (0, import_classnames127.default)(`${prefix}--label`, {
        [`${prefix}--visually-hidden`]: hideLabel,
        [`${prefix}--label--disabled`]: disabled
      });
      const containerClasses = (0, import_classnames127.default)(`${prefix}--slider-container`, {
        [`${prefix}--slider-container--two-handles`]: twoHandles,
        [`${prefix}--slider-container--disabled`]: disabled,
        [`${prefix}--slider-container--readonly`]: readOnly,
        [`${prefix}--slider-container--rtl`]: isRtl
      });
      const sliderClasses = (0, import_classnames127.default)(`${prefix}--slider`, {
        [`${prefix}--slider--disabled`]: disabled,
        [`${prefix}--slider--readonly`]: readOnly
      });
      const fixedInputClasses = [`${prefix}--text-input`, `${prefix}--slider-text-input`];
      const conditionalInputClasses = {
        [`${prefix}--text-input--light`]: light
      };
      const lowerInputClasses = (0, import_classnames127.default)([...fixedInputClasses, `${prefix}--slider-text-input--lower`, conditionalInputClasses, {
        [`${prefix}--text-input--invalid`]: !readOnly && !isValid,
        [`${prefix}--slider-text-input--warn`]: showWarning
      }]);
      const upperInputClasses = (0, import_classnames127.default)([...fixedInputClasses, `${prefix}--slider-text-input--upper`, conditionalInputClasses, {
        [`${prefix}--text-input--invalid`]: !readOnly && (twoHandles ? !isValidUpper : !isValid),
        [`${prefix}--slider-text-input--warn`]: showWarningUpper
      }]);
      const lowerInputWrapperClasses = (0, import_classnames127.default)([`${prefix}--text-input-wrapper`, `${prefix}--slider-text-input-wrapper`, `${prefix}--slider-text-input-wrapper--lower`, {
        [`${prefix}--text-input-wrapper--readonly`]: readOnly,
        [`${prefix}--slider-text-input-wrapper--hidden`]: hideTextInput
      }]);
      const upperInputWrapperClasses = (0, import_classnames127.default)([`${prefix}--text-input-wrapper`, `${prefix}--slider-text-input-wrapper`, `${prefix}--slider-text-input-wrapper--upper`, {
        [`${prefix}--text-input-wrapper--readonly`]: readOnly,
        [`${prefix}--slider-text-input-wrapper--hidden`]: hideTextInput
      }]);
      const lowerThumbClasses = (0, import_classnames127.default)(`${prefix}--slider__thumb`, {
        [`${prefix}--slider__thumb--lower`]: twoHandles
      });
      const upperThumbClasses = (0, import_classnames127.default)(`${prefix}--slider__thumb`, {
        [`${prefix}--slider__thumb--upper`]: twoHandles
      });
      const lowerThumbWrapperClasses = (0, import_classnames127.default)([`${prefix}--icon-tooltip`, `${prefix}--slider__thumb-wrapper`, {
        [`${prefix}--slider__thumb-wrapper--lower`]: twoHandles
      }]);
      const upperThumbWrapperClasses = (0, import_classnames127.default)([`${prefix}--icon-tooltip`, `${prefix}--slider__thumb-wrapper`, {
        [`${prefix}--slider__thumb-wrapper--upper`]: twoHandles
      }]);
      const lowerThumbWrapperProps = {
        style: {
          insetInlineStart: `${this.state.left}%`
        }
      };
      const upperThumbWrapperProps = {
        style: {
          insetInlineStart: `${this.state.leftUpper}%`
        }
      };
      return import_react196.default.createElement("div", {
        className: (0, import_classnames127.default)(`${prefix}--form-item`, className)
      }, import_react196.default.createElement(Text, {
        as: "label",
        htmlFor: twoHandles ? void 0 : id,
        className: labelClasses,
        id: labelId
      }, labelText), import_react196.default.createElement("div", {
        className: containerClasses
      }, twoHandles ? import_react196.default.createElement("div", {
        className: lowerInputWrapperClasses
      }, import_react196.default.createElement("input", {
        type: hideTextInput ? "hidden" : inputType,
        id: `${id}-lower-input-for-slider`,
        name,
        className: lowerInputClasses,
        value,
        "aria-label": ariaLabelInput,
        disabled,
        required,
        min: min2,
        max: max2,
        step,
        onChange: this.onChange,
        onBlur: this.onBlur,
        onKeyUp: this.props.onInputKeyUp,
        onKeyDown: this.onInputKeyDown,
        "data-invalid": !isValid && !readOnly ? true : null,
        "data-handle-position": HandlePosition.LOWER,
        "aria-invalid": !isValid && !readOnly ? true : void 0,
        readOnly
      }), !readOnly && !isValid && import_react196.default.createElement(WarningFilled, {
        className: `${prefix}--slider__invalid-icon`
      }), showWarning && import_react196.default.createElement(WarningAltFilled, {
        className: `${prefix}--slider__invalid-icon ${prefix}--slider__invalid-icon--warning`
      })) : null, import_react196.default.createElement(Text, {
        className: `${prefix}--slider__range-label`
      }, formatLabel(min2, minLabel)), import_react196.default.createElement("div", _extends({
        className: sliderClasses,
        ref: (node) => {
          this.element = node;
        },
        onMouseDown: this.onDragStart,
        onTouchStart: this.onDragStart,
        onKeyDown: this.onKeyDown,
        role: "presentation",
        tabIndex: -1,
        "data-invalid": (twoHandles ? !isValid || !isValidUpper : !isValid) && !readOnly ? true : null
      }, other), import_react196.default.createElement(ThumbWrapper, _extends({
        hasTooltip: hideTextInput,
        className: lowerThumbWrapperClasses,
        label: formatLabel(value, void 0),
        align: "top"
      }, lowerThumbWrapperProps), import_react196.default.createElement("div", {
        className: lowerThumbClasses,
        role: "slider",
        id: twoHandles ? void 0 : id,
        tabIndex: readOnly || disabled ? void 0 : 0,
        "aria-valuetext": formatLabel(value, void 0),
        "aria-valuemax": twoHandles ? valueUpper : max2,
        "aria-valuemin": min2,
        "aria-valuenow": value,
        "aria-labelledby": twoHandles ? void 0 : labelId,
        "aria-label": twoHandles ? ariaLabelInput : void 0,
        ref: this.thumbRef,
        onFocus: () => this.setState({
          activeHandle: HandlePosition.LOWER
        })
      }, twoHandles && !isRtl ? _Fragment || (_Fragment = import_react196.default.createElement(import_react196.default.Fragment, null, import_react196.default.createElement(LowerHandle, {
        "aria-label": ariaLabelInput
      }), import_react196.default.createElement(LowerHandleFocus, {
        "aria-label": ariaLabelInput
      }))) : twoHandles && isRtl ? _Fragment2 || (_Fragment2 = import_react196.default.createElement(import_react196.default.Fragment, null, import_react196.default.createElement(UpperHandle, {
        "aria-label": ariaLabelInputUpper
      }), import_react196.default.createElement(UpperHandleFocus, {
        "aria-label": ariaLabelInputUpper
      }))) : void 0)), twoHandles ? import_react196.default.createElement(ThumbWrapper, _extends({
        hasTooltip: hideTextInput,
        className: upperThumbWrapperClasses,
        label: formatLabel(valueUpper ?? 0, void 0),
        align: "top"
      }, upperThumbWrapperProps), import_react196.default.createElement("div", {
        className: upperThumbClasses,
        role: "slider",
        tabIndex: readOnly || disabled ? void 0 : 0,
        "aria-valuemax": max2,
        "aria-valuemin": value,
        "aria-valuenow": valueUpper,
        "aria-label": ariaLabelInputUpper,
        ref: this.thumbRefUpper,
        onFocus: () => this.setState({
          activeHandle: HandlePosition.UPPER
        })
      }, twoHandles && !isRtl ? _Fragment3 || (_Fragment3 = import_react196.default.createElement(import_react196.default.Fragment, null, import_react196.default.createElement(UpperHandle, {
        "aria-label": ariaLabelInputUpper
      }), import_react196.default.createElement(UpperHandleFocus, {
        "aria-label": ariaLabelInputUpper
      }))) : twoHandles && isRtl ? _Fragment4 || (_Fragment4 = import_react196.default.createElement(import_react196.default.Fragment, null, import_react196.default.createElement(LowerHandle, {
        "aria-label": ariaLabelInput
      }), import_react196.default.createElement(LowerHandleFocus, {
        "aria-label": ariaLabelInput
      }))) : void 0)) : null, import_react196.default.createElement("div", {
        className: `${prefix}--slider__track`,
        ref: (node) => {
          this.track = node;
        }
      }), import_react196.default.createElement("div", {
        className: `${prefix}--slider__filled-track`,
        ref: this.filledTrackRef
      })), import_react196.default.createElement(Text, {
        className: `${prefix}--slider__range-label`
      }, formatLabel(max2, maxLabel)), import_react196.default.createElement("div", {
        className: upperInputWrapperClasses
      }, import_react196.default.createElement("input", {
        type: hideTextInput ? "hidden" : inputType,
        id: `${id}-${twoHandles ? "upper-" : ""}input-for-slider`,
        name: twoHandles ? nameUpper : name,
        className: upperInputClasses,
        value: twoHandles ? valueUpper : value,
        "aria-labelledby": !ariaLabelInput && !twoHandles ? labelId : void 0,
        "aria-label": twoHandles ? ariaLabelInputUpper : ariaLabelInput ? ariaLabelInput : void 0,
        disabled,
        required,
        min: min2,
        max: max2,
        step,
        onChange: this.onChange,
        onBlur: this.onBlur,
        onKeyDown: this.onInputKeyDown,
        onKeyUp: this.props.onInputKeyUp,
        "data-invalid": (twoHandles ? !isValidUpper : !isValid) && !readOnly ? true : null,
        "data-handle-position": twoHandles ? HandlePosition.UPPER : null,
        "aria-invalid": (twoHandles ? !isValidUpper : !isValid) && !readOnly ? true : void 0,
        readOnly
      }), !readOnly && (twoHandles ? !isValidUpper : !isValid) && import_react196.default.createElement(WarningFilled, {
        className: `${prefix}--slider__invalid-icon`
      }), showWarningUpper && import_react196.default.createElement(WarningAltFilled, {
        className: `${prefix}--slider__invalid-icon ${prefix}--slider__invalid-icon--warning`
      }))), !readOnly && (!isValid || !isValidUpper) && import_react196.default.createElement(Text, {
        as: "div",
        className: (0, import_classnames127.default)(`${prefix}--slider__validation-msg`, `${prefix}--slider__validation-msg--invalid`, `${prefix}--form-requirement`)
      }, invalidText), !readOnly && warn2 && isValid && isValidUpper && import_react196.default.createElement(Text, {
        as: "div",
        className: (0, import_classnames127.default)(`${prefix}--slider__validation-msg`, `${prefix}--form-requirement`)
      }, warnText), correctedValue && import_react196.default.createElement(Text, {
        as: "div",
        role: "alert",
        className: (0, import_classnames127.default)(`${prefix}--slider__status-msg`, `${prefix}--form-requirement`)
      }, t3(translationIds5.autoCorrectAnnouncement, {
        correctedValue
      })));
    });
  }
};
_defineProperty(Slider, "contextType", FeatureFlagContext);
_defineProperty(Slider, "translationIds", Object.values(translationIds5));
Slider.propTypes = {
  /**
   * The `ariaLabel` for the `<input>`.
   */
  ariaLabelInput: import_prop_types149.default.string,
  /**
   * The child nodes.
   */
  children: import_prop_types149.default.node,
  /**
   * The CSS class name for the slider.
   */
  className: import_prop_types149.default.string,
  /**
   * `true` to disable this slider.
   */
  disabled: import_prop_types149.default.bool,
  /**
   * The callback to format the label associated with the minimum/maximum value.
   */
  formatLabel: import_prop_types149.default.func,
  /**
   * `true` to hide the number input box.
   */
  hideTextInput: import_prop_types149.default.bool,
  /**
   * The ID of the `<input>`.
   */
  id: import_prop_types149.default.string,
  /**
   * The `type` attribute of the `<input>`.
   */
  inputType: import_prop_types149.default.string,
  /**
   * `Specify whether the Slider is currently invalid
   */
  invalid: import_prop_types149.default.bool,
  /**
   * Provide the text that is displayed when the Slider is in an invalid state
   */
  invalidText: import_prop_types149.default.node,
  /**
   * The label for the slider.
   */
  labelText: import_prop_types149.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types149.default.bool,
  /**
   * `true` to use the light version.
   */
  light: deprecate(import_prop_types149.default.bool, "The `light` prop for `Slider` is no longer needed and has been deprecated in v11 in favor of the new `Layer` component. It will be moved in the next major release."),
  /**
   * The maximum value.
   */
  max: import_prop_types149.default.number.isRequired,
  /**
   * The label associated with the maximum value.
   */
  maxLabel: import_prop_types149.default.string,
  /**
   * The minimum value.
   */
  min: import_prop_types149.default.number.isRequired,
  /**
   * The label associated with the minimum value.
   */
  minLabel: import_prop_types149.default.string,
  /**
   * The `name` attribute of the `<input>`.
   */
  name: import_prop_types149.default.string,
  /**
   * Provide an optional function to be called when the input element
   * loses focus
   */
  onBlur: import_prop_types149.default.func,
  /**
   * The callback to get notified of change in value.
   */
  onChange: import_prop_types149.default.func,
  /**
   * Provide an optional function to be called when a key is pressed in the number input.
   */
  onInputKeyUp: import_prop_types149.default.func,
  /**
   * The callback to get notified of value on handle release.
   */
  onRelease: import_prop_types149.default.func,
  /**
   * Whether the slider should be read-only
   */
  readOnly: import_prop_types149.default.bool,
  /**
   * `true` to specify if the control is required.
   */
  required: import_prop_types149.default.bool,
  /**
   * A value determining how much the value should increase/decrease by moving the thumb by mouse. If a value other than 1 is provided and the input is *not* hidden, the new step requirement should be added to a visible label. Values outside the `step` increment will be considered invalid.
   */
  step: import_prop_types149.default.number,
  /**
   * A value determining how much the value should increase/decrease by Shift+arrow keys,
   * which will be `(max - min) / stepMultiplier`.
   */
  stepMultiplier: import_prop_types149.default.number,
  /**
   * Supply a method to translate internal strings with your i18n tool of
   * choice. Translation keys are available on the `translationIds` field for
   * this component.
   */
  translateWithId: import_prop_types149.default.func,
  /**
   * The `ariaLabel` for the upper bound `<input>` when there are two handles.
   */
  unstable_ariaLabelInputUpper: import_prop_types149.default.string,
  /**
   * The `name` attribute of the upper bound `<input>` when there are two handles.
   */
  unstable_nameUpper: import_prop_types149.default.string,
  /**
   * The upper bound when there are two handles.
   */
  unstable_valueUpper: import_prop_types149.default.number,
  /**
   * The value of the slider. When there are two handles, value is the lower
   * bound.
   */
  value: import_prop_types149.default.number.isRequired,
  /**
   * `Specify whether the Slider is in a warn state
   */
  warn: import_prop_types149.default.bool,
  /**
   * Provide the text that is displayed when the Slider is in a warn state
   */
  warnText: import_prop_types149.default.node
};

// node_modules/@carbon/react/es/internal/createClassWrapper.js
var import_react197 = __toESM(require_react());
var createClassWrapper = (Component2) => {
  const ClassWrapper = (props) => {
    return import_react197.default.createElement(Component2, props);
  };
  const name = Component2.displayName || Component2.name;
  ClassWrapper.displayName = `ClassWrapper(${name})`;
  return ClassWrapper;
};

// node_modules/@carbon/react/es/components/Slider/Slider.Skeleton.js
var import_prop_types150 = __toESM(require_prop_types());
var import_react198 = __toESM(require_react());
var import_classnames128 = __toESM(require_classnames());
var SliderSkeleton = ({
  ariaLabel = "slider handle",
  unstable_ariaLabelHandleUpper: ariaLabelHandleUpper = "upper slider handle",
  hideLabel,
  className,
  twoHandles,
  ...rest
}) => {
  const prefix = usePrefix();
  const [isRtl, setIsRtl] = (0, import_react198.useState)(false);
  useIsomorphicEffect(() => {
    setIsRtl(document ? document.dir === "rtl" : false);
  }, []);
  const containerClasses = (0, import_classnames128.default)(`${prefix}--slider-container`, `${prefix}--skeleton`, {
    [`${prefix}--slider-container--two-handles`]: twoHandles,
    [`${prefix}--slider-container--rtl`]: isRtl
  });
  const lowerThumbClasses = (0, import_classnames128.default)(`${prefix}--slider__thumb`, {
    [`${prefix}--slider__thumb--lower`]: twoHandles
  });
  const upperThumbClasses = (0, import_classnames128.default)(`${prefix}--slider__thumb`, {
    [`${prefix}--slider__thumb--upper`]: twoHandles
  });
  const lowerThumbWrapperClasses = (0, import_classnames128.default)(`${prefix}--slider__thumb-wrapper`, {
    [`${prefix}--slider__thumb-wrapper--lower`]: twoHandles
  });
  const upperThumbWrapperClasses = (0, import_classnames128.default)(`${prefix}--slider__thumb-wrapper`, {
    [`${prefix}--slider__thumb-wrapper--upper`]: twoHandles
  });
  return import_react198.default.createElement("div", _extends({
    className: (0, import_classnames128.default)(`${prefix}--form-item`, className)
  }, rest), !hideLabel && import_react198.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react198.default.createElement("div", {
    className: containerClasses
  }, import_react198.default.createElement("span", {
    className: `${prefix}--slider__range-label`
  }), import_react198.default.createElement("div", {
    className: `${prefix}--slider`
  }, import_react198.default.createElement("div", {
    className: `${prefix}--slider__track`
  }), import_react198.default.createElement("div", {
    className: `${prefix}--slider__filled-track`
  }), import_react198.default.createElement("div", {
    className: lowerThumbWrapperClasses
  }, import_react198.default.createElement("div", {
    className: lowerThumbClasses
  }, twoHandles && !isRtl ? import_react198.default.createElement(LowerHandle, {
    "aria-label": ariaLabel
  }) : twoHandles && isRtl ? import_react198.default.createElement(UpperHandle, {
    "aria-label": ariaLabelHandleUpper
  }) : void 0)), twoHandles ? import_react198.default.createElement("div", {
    className: upperThumbWrapperClasses
  }, import_react198.default.createElement("div", {
    className: upperThumbClasses
  }, twoHandles && !isRtl ? import_react198.default.createElement(UpperHandle, {
    "aria-label": ariaLabelHandleUpper
  }) : twoHandles && isRtl ? import_react198.default.createElement(LowerHandle, {
    "aria-label": ariaLabel
  }) : void 0)) : void 0), import_react198.default.createElement("span", {
    className: `${prefix}--slider__range-label`
  })));
};
SliderSkeleton.propTypes = {
  /**
   * The `ariaLabel` for the handle icon.
   */
  ariaLabel: import_prop_types150.default.string,
  /**
   * The `ariaLabel` for the upper bound slider handle when there are two handles.
   */
  unstable_ariaLabelHandleUpper: import_prop_types150.default.string,
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types150.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types150.default.bool,
  /**
   * Turn the slider into a range slider.
   */
  twoHandles: import_prop_types150.default.bool
};

// node_modules/@carbon/react/es/components/Slider/index.js
var Slider2 = createClassWrapper(Slider);

// node_modules/@carbon/react/es/components/Stack/HStack.js
var import_react200 = __toESM(require_react());

// node_modules/@carbon/react/es/components/Stack/Stack.js
var import_react199 = __toESM(require_react());
var import_classnames129 = __toESM(require_classnames());
var import_prop_types151 = __toESM(require_prop_types());
var SPACING_STEPS = Array.from({
  length: spacing2.length - 1
}, (_, step) => step + 1);
var Stack = (0, import_react199.forwardRef)((props, ref) => {
  const {
    as: BaseComponent = "div",
    children,
    className: customClassName,
    gap,
    orientation = "vertical",
    ...rest
  } = props;
  const prefix = usePrefix();
  const className = (0, import_classnames129.default)(customClassName, {
    [`${prefix}--stack-${orientation}`]: true,
    [`${prefix}--stack-scale-${gap}`]: typeof gap === "number"
  });
  const style = {
    ...rest.style
  };
  if (typeof gap === "string") {
    style[`--${prefix}-stack-gap`] = gap;
  }
  return (
    // eslint-disable-next-line react/forbid-component-props
    import_react199.default.createElement(BaseComponent, _extends({}, rest, {
      ref,
      className,
      style
    }), children)
  );
});
Stack.propTypes = {
  /**
   * Provide a custom element type to render as the outermost element in
   * the Stack component. By default, this component will render a `div`.
   */
  as: import_prop_types151.default.elementType,
  /**
   * Provide the elements that will be rendered as children inside of the Stack
   * component. These elements will have having spacing between them according
   * to the `step` and `orientation` prop
   */
  children: import_prop_types151.default.node,
  /**
   * Provide a custom class name to be used by the outermost element rendered by
   * Stack
   */
  className: import_prop_types151.default.string,
  /**
   * Provide either a custom value or a step from the spacing scale to be used
   * as the gap in the layout
   */
  gap: import_prop_types151.default.oneOfType([import_prop_types151.default.string, import_prop_types151.default.oneOf(SPACING_STEPS)]),
  /**
   * Specify the orientation of them items in the Stack
   */
  orientation: import_prop_types151.default.oneOf(["horizontal", "vertical"])
};

// node_modules/@carbon/react/es/components/Stack/HStack.js
var HStack = (0, import_react200.forwardRef)((props, ref) => {
  return import_react200.default.createElement(Stack, _extends({}, props, {
    ref,
    orientation: "horizontal"
  }));
});
HStack.propTypes = Stack.propTypes;

// node_modules/@carbon/react/es/components/Stack/VStack.js
var import_react201 = __toESM(require_react());
var VStack = (0, import_react201.forwardRef)((props, ref) => {
  return import_react201.default.createElement(Stack, _extends({}, props, {
    ref,
    orientation: "vertical"
  }));
});
VStack.propTypes = Stack.propTypes;

// node_modules/@carbon/react/es/components/StructuredList/StructuredList.js
var import_react202 = __toESM(require_react());
var import_prop_types152 = __toESM(require_prop_types());
var import_classnames130 = __toESM(require_classnames());
var _StructuredListCell;
var GridSelectedRowStateContext = import_react202.default.createContext(null);
var GridSelectedRowDispatchContext = import_react202.default.createContext(null);
function StructuredListWrapper(props) {
  const {
    children,
    selection,
    className,
    ["aria-label"]: ariaLabel = "Structured list section",
    // @ts-expect-error: Deprecated prop
    ariaLabel: deprecatedAriaLabel,
    isCondensed,
    isFlush,
    selectedInitialRow,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames130.default)(`${prefix}--structured-list`, {
    [`${prefix}--structured-list--selection`]: selection,
    [`${prefix}--structured-list--condensed`]: isCondensed,
    [`${prefix}--structured-list--flush`]: isFlush && !selection
  }, className);
  const [selectedRow, setSelectedRow] = import_react202.default.useState(selectedInitialRow ?? null);
  return import_react202.default.createElement(GridSelectedRowStateContext.Provider, {
    value: selectedRow
  }, import_react202.default.createElement(GridSelectedRowDispatchContext.Provider, {
    value: setSelectedRow
  }, import_react202.default.createElement("div", _extends({
    role: "table",
    className: classes
  }, other, {
    "aria-label": deprecatedAriaLabel || ariaLabel
  }), children)));
}
StructuredListWrapper.propTypes = {
  /**
   * Specify a label to be read by screen readers on the container node
   */
  ["aria-label"]: import_prop_types152.default.string,
  /**
   * Deprecated, please use `aria-label` instead.
   * Specify a label to be read by screen readers on the container note.
   */
  ariaLabel: deprecate(import_prop_types152.default.string, "This prop syntax has been deprecated. Please use the new `aria-label`."),
  /**
   * Provide the contents of your StructuredListWrapper
   */
  children: import_prop_types152.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types152.default.string,
  /**
   * Specify if structured list is condensed, default is false
   */
  isCondensed: import_prop_types152.default.bool,
  /**
   * Specify if structured list is flush, not valid for selection variant, default is false
   */
  isFlush: import_prop_types152.default.bool,
  /**
   * Specify whether your StructuredListWrapper should have selections
   */
  selection: import_prop_types152.default.bool,
  /**
   * Specify which row will be selected initially
   */
  selectedInitialRow: import_prop_types152.default.string
};
function StructuredListHead(props) {
  const {
    children,
    className,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames130.default)(`${prefix}--structured-list-thead`, className);
  return import_react202.default.createElement("div", _extends({
    role: "rowgroup",
    className: classes
  }, other), children);
}
StructuredListHead.propTypes = {
  /**
   * Provide the contents of your StructuredListHead
   */
  children: import_prop_types152.default.node,
  /**
   * Specify an optional className to be applied to the node
   */
  className: import_prop_types152.default.string
};
function StructuredListBody(props) {
  const {
    children,
    className,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames130.default)(`${prefix}--structured-list-tbody`, className);
  return import_react202.default.createElement("div", _extends({
    className: classes,
    role: "rowgroup"
  }, other), children);
}
StructuredListBody.propTypes = {
  /**
   * Provide the contents of your StructuredListBody
   */
  children: import_prop_types152.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types152.default.string,
  head: import_prop_types152.default.bool,
  /**
   * Provide a handler that is invoked on the key down event for the control
   */
  onKeyDown: import_prop_types152.default.func
};
var GridRowContext = import_react202.default.createContext(null);
function StructuredListRow(props) {
  const {
    onKeyDown,
    children,
    className,
    head,
    onClick,
    selection,
    id,
    ...other
  } = props;
  const [hasFocusWithin, setHasFocusWithin] = (0, import_react202.useState)(false);
  const rowId = id ?? useId("grid-input");
  const selectedRow = import_react202.default.useContext(GridSelectedRowStateContext);
  const setSelectedRow = import_react202.default.useContext(GridSelectedRowDispatchContext);
  const prefix = usePrefix();
  const value = {
    id: rowId
  };
  const classes = (0, import_classnames130.default)(`${prefix}--structured-list-row`, {
    [`${prefix}--structured-list-row--header-row`]: head,
    [`${prefix}--structured-list-row--focused-within`]: hasFocusWithin && !selection || hasFocusWithin && selection && (selectedRow === rowId || selectedRow === null),
    // Ensure focus on the first item when navigating through Tab keys and no row is selected (selectedRow === null)
    [`${prefix}--structured-list-row--selected`]: selectedRow === rowId
  }, className);
  const itemRef = (0, import_react202.useRef)(null);
  const handleClick2 = () => {
    setHasFocusWithin(false);
  };
  useOutsideClick(itemRef, handleClick2);
  return head ? import_react202.default.createElement("div", _extends({
    role: "row"
  }, other, {
    className: classes
  }), selection && (_StructuredListCell || (_StructuredListCell = import_react202.default.createElement(StructuredListCell, {
    head: true
  }))), children) : (
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    import_react202.default.createElement("div", _extends({}, other, {
      role: "row",
      className: classes,
      ref: itemRef,
      onClick: (event) => {
        setSelectedRow == null ? void 0 : setSelectedRow(rowId);
        onClick && onClick(event);
        if (selection) {
          setHasFocusWithin(true);
        }
      },
      onFocus: (event) => {
        if (selection || event.currentTarget === event.target) {
          setHasFocusWithin(true);
        }
      },
      onBlur: () => {
        setHasFocusWithin(false);
      },
      onKeyDown
    }), import_react202.default.createElement(GridRowContext.Provider, {
      value
    }, selection && import_react202.default.createElement(StructuredListCell, null, selectedRow === rowId ? import_react202.default.createElement(RadioButtonChecked, {
      className: `${prefix}--structured-list__icon`
    }) : import_react202.default.createElement(RadioButton, {
      className: `${prefix}--structured-list__icon`
    })), children))
  );
}
StructuredListRow.propTypes = {
  /**
   * Provide the contents of your StructuredListRow
   */
  children: import_prop_types152.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types152.default.string,
  /**
   * Specify whether your StructuredListRow should be used as a header row
   */
  head: import_prop_types152.default.bool,
  /**
   * Specify whether a `<label>` should be used
   */
  label: deprecate(import_prop_types152.default.bool, `
The \`label\` prop is no longer needed and will be removed in the next major version of Carbon.`),
  /**
   * Provide a handler that is invoked on the click
   */
  onClick: import_prop_types152.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the control,
   */
  onKeyDown: import_prop_types152.default.func,
  /**
   * Mark if this row should be selectable
   */
  selection: import_prop_types152.default.bool,
  /**
   * Specify row id so that it can be used for initial selection
   */
  id: import_prop_types152.default.string
};
function StructuredListInput(props) {
  const defaultId2 = useId("structureListInput");
  const {
    className,
    name = `structured-list-input-${defaultId2}`,
    title,
    id,
    onChange,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames130.default)(`${prefix}--structured-list-input`, `${prefix}--visually-hidden`, className);
  const row = import_react202.default.useContext(GridRowContext);
  const selectedRow = import_react202.default.useContext(GridSelectedRowStateContext);
  const setSelectedRow = import_react202.default.useContext(GridSelectedRowDispatchContext);
  return import_react202.default.createElement("input", _extends({}, other, {
    type: "radio",
    tabIndex: 0,
    checked: !!row && row.id === selectedRow,
    value: (row == null ? void 0 : row.id) ?? "",
    onChange: (event) => {
      setSelectedRow == null ? void 0 : setSelectedRow(event.target.value);
      onChange && onChange(event);
    },
    id: id ?? defaultId2,
    className: classes,
    name,
    title
  }));
}
StructuredListInput.propTypes = {
  /**
   * Specify an optional className to be applied to the input
   */
  className: import_prop_types152.default.string,
  /**
   * Specify whether the underlying input should be checked by default
   */
  defaultChecked: deprecate(import_prop_types152.default.bool, `
The prop \`defaultChecked\` is no longer needed and will be removed in the next major version of Carbon.`),
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types152.default.string,
  /**
   * Provide a `name` for the input
   */
  name: import_prop_types152.default.string,
  /**
   * Provide an optional hook that is called each time the input is updated
   */
  onChange: import_prop_types152.default.func,
  /**
   * Provide a `title` for the input
   */
  title: import_prop_types152.default.string,
  /**
   * Specify the value of the input
   */
  value: deprecate(import_prop_types152.default.oneOfType([import_prop_types152.default.string, import_prop_types152.default.number]).isRequired, `
The prop \`value\` will be removed in the next major version of Carbon.`)
};
function StructuredListCell(props) {
  const {
    children,
    className,
    head,
    noWrap,
    ...other
  } = props;
  const prefix = usePrefix();
  const classes = (0, import_classnames130.default)({
    [`${prefix}--structured-list-th`]: head,
    [`${prefix}--structured-list-td`]: !head,
    [`${prefix}--structured-list-content--nowrap`]: noWrap
  }, className);
  if (head) {
    return import_react202.default.createElement(Text, _extends({
      className: classes,
      role: "columnheader"
    }, other), children);
  }
  return import_react202.default.createElement(Text, _extends({
    as: "div",
    className: classes,
    role: "cell"
  }, other), children);
}
StructuredListCell.propTypes = {
  /**
   * Provide the contents of your StructuredListCell
   */
  children: import_prop_types152.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types152.default.string,
  /**
   * Specify whether your StructuredListCell should be used as a header cell
   */
  head: import_prop_types152.default.bool,
  /**
   * Specify whether your StructuredListCell should have text wrapping
   */
  noWrap: import_prop_types152.default.bool
};

// node_modules/@carbon/react/es/components/StructuredList/StructuredList.Skeleton.js
var import_prop_types153 = __toESM(require_prop_types());
var import_react203 = __toESM(require_react());
var import_classnames131 = __toESM(require_classnames());
var _span6;
var _span23;
var _span32;
function StructuredListSkeleton({
  rowCount = 5,
  className,
  ...rest
}) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames131.default)(`${prefix}--skeleton`, `${prefix}--structured-list`, className);
  const rows = new Array(rowCount).fill(null).map((_, i) => import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-row`,
    key: i
  }, import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-td`
  }), import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-td`
  }), import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-td`
  })));
  return import_react203.default.createElement("div", _extends({
    className: classNames
  }, rest), import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-thead`
  }, import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-row ${prefix}--structured-list-row--header-row`
  }, import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-th`
  }, _span6 || (_span6 = import_react203.default.createElement("span", null))), import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-th`
  }, _span23 || (_span23 = import_react203.default.createElement("span", null))), import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-th`
  }, _span32 || (_span32 = import_react203.default.createElement("span", null))))), import_react203.default.createElement("div", {
    className: `${prefix}--structured-list-tbody`
  }, rows));
}
StructuredListSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types153.default.string,
  /**
   * number of table rows
   */
  rowCount: import_prop_types153.default.number
};

// node_modules/@carbon/react/es/components/Tabs/Tabs.js
var import_classnames132 = __toESM(require_classnames());
var import_prop_types154 = __toESM(require_prop_types());
var import_react205 = __toESM(require_react());
var import_react_is3 = __toESM(require_react_is2());

// node_modules/@carbon/react/es/components/Tabs/usePressable.js
var import_react204 = __toESM(require_react());
var usePressable = (ref, {
  onPress,
  onPressIn,
  onPressOut,
  onLongPress,
  delayLongPressMs = 500
} = {}) => {
  const savedOnPress = (0, import_react204.useRef)(onPress);
  const savedOnPressIn = (0, import_react204.useRef)(onPressIn);
  const savedOnPressOut = (0, import_react204.useRef)(onPressOut);
  const savedOnLongPress = (0, import_react204.useRef)(onLongPress);
  const [pendingLongPress, setPendingLongPress] = (0, import_react204.useState)(false);
  const [longPress, setLongPress] = (0, import_react204.useState)(false);
  const state = (0, import_react204.useRef)({
    longPress: false
  });
  (0, import_react204.useEffect)(() => {
    savedOnPress.current = onPress;
  }, [onPress]);
  (0, import_react204.useEffect)(() => {
    savedOnPressIn.current = onPressIn;
  }, [onPressIn]);
  (0, import_react204.useEffect)(() => {
    savedOnPressOut.current = onPressOut;
  }, [onPressOut]);
  (0, import_react204.useEffect)(() => {
    savedOnLongPress.current = onLongPress;
  }, [onLongPress]);
  (0, import_react204.useEffect)(() => {
    const element = ref.current;
    if (!element) return;
    const onPointerDown = (event) => {
      var _a;
      setPendingLongPress(true);
      (_a = savedOnPressIn.current) == null ? void 0 : _a.call(savedOnPressIn);
      event.preventDefault();
    };
    const onPointerUp = () => {
      var _a;
      setPendingLongPress(false);
      setLongPress(false);
      (_a = savedOnPressOut.current) == null ? void 0 : _a.call(savedOnPressOut, state.current);
    };
    const onPointerCancel = () => {
      var _a;
      setPendingLongPress(false);
      setLongPress(false);
      (_a = savedOnPressOut.current) == null ? void 0 : _a.call(savedOnPressOut, state.current);
      state.current.longPress = false;
    };
    const onPointerLeave = () => {
      var _a;
      setPendingLongPress(false);
      setLongPress(false);
      (_a = savedOnPressOut.current) == null ? void 0 : _a.call(savedOnPressOut, state.current);
      state.current.longPress = false;
    };
    const onClick = () => {
      var _a;
      setLongPress(false);
      setPendingLongPress(false);
      (_a = savedOnPress.current) == null ? void 0 : _a.call(savedOnPress, state.current);
      state.current.longPress = false;
    };
    const onContextMenu = (event) => {
      event.preventDefault();
    };
    element.addEventListener("pointerdown", onPointerDown);
    element.addEventListener("pointerup", onPointerUp);
    element.addEventListener("pointercancel", onPointerCancel);
    element.addEventListener("pointerleave", onPointerLeave);
    element.addEventListener("click", onClick);
    element.addEventListener("contextmenu", onContextMenu);
    return () => {
      element.removeEventListener("pointerdown", onPointerDown);
      element.removeEventListener("pointerup", onPointerUp);
      element.removeEventListener("pointercancel", onPointerCancel);
      element.removeEventListener("pointerleave", onPointerLeave);
      element.removeEventListener("click", onClick);
      element.removeEventListener("contextmenu", onContextMenu);
    };
  }, [ref]);
  (0, import_react204.useEffect)(() => {
    if (pendingLongPress) {
      const timeoutId = setTimeout(() => {
        setPendingLongPress(false);
        setLongPress(true);
      }, delayLongPressMs);
      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [pendingLongPress, delayLongPressMs]);
  (0, import_react204.useEffect)(() => {
    var _a;
    if (longPress) {
      state.current.longPress = true;
      return (_a = savedOnLongPress.current) == null ? void 0 : _a.call(savedOnLongPress);
    }
  }, [longPress]);
};

// node_modules/@carbon/react/es/components/Tabs/Tabs.js
var _ChevronLeft;
var _ChevronRight;
var _BadgeIndicator;
var verticalTabHeight = 64;
var TabsContext = import_react205.default.createContext({
  baseId: "",
  activeIndex: 0,
  defaultSelectedIndex: 0,
  dismissable: false,
  onTabCloseRequest() {
  },
  setActiveIndex() {
  },
  selectedIndex: 0,
  setSelectedIndex() {
  }
});
var TabContext = import_react205.default.createContext({
  index: 0,
  hasSecondaryLabel: false
});
var lgMediaQuery = `(min-width: ${breakpoints.lg.width})`;
var smMediaQuery = `(max-width: ${breakpoints.md.width})`;
var TabPanelContext = import_react205.default.createContext(0);
function Tabs({
  children,
  defaultSelectedIndex = 0,
  onChange,
  selectedIndex: controlledSelectedIndex,
  dismissable,
  onTabCloseRequest
}) {
  const baseId = useId("ccs");
  if (dismissable && !onTabCloseRequest) {
    console.error("dismissable property specified without also providing an onTabCloseRequest property.");
  }
  const [activeIndex, setActiveIndex] = (0, import_react205.useState)(defaultSelectedIndex);
  const [selectedIndex, setSelectedIndex] = useControllableState({
    value: controlledSelectedIndex,
    defaultValue: defaultSelectedIndex,
    onChange: (value2) => onChange == null ? void 0 : onChange({
      selectedIndex: value2
    })
  });
  const value = {
    baseId,
    activeIndex,
    defaultSelectedIndex,
    dismissable,
    onTabCloseRequest,
    setActiveIndex,
    selectedIndex,
    setSelectedIndex
  };
  return import_react205.default.createElement(TabsContext.Provider, {
    value
  }, children);
}
Tabs.propTypes = {
  /**
   * Provide child elements to be rendered inside the `Tabs`.
   * These elements should render either `TabsList` or `TabsPanels`
   */
  children: import_prop_types154.default.node,
  /**
   * Specify which content tab should be initially selected when the component
   * is first rendered
   */
  defaultSelectedIndex: import_prop_types154.default.number,
  /**
   * Whether the render Tab children should be dismissable.
   */
  dismissable: import_prop_types154.default.bool,
  /**
   * Provide an optional function which is called whenever the state of the
   * `Tabs` changes
   */
  onChange: import_prop_types154.default.func,
  /**
   * If specifying the `onTabCloseRequest` prop, provide a callback function
   * responsible for removing the tab when close button is pressed on one of the Tab elements
   */
  onTabCloseRequest: (props) => {
    if (props.dismissable && !props.onTabCloseRequest) {
      return new Error("dismissable property specified without also providing an onTabCloseRequest property.");
    }
    return void 0;
  },
  /**
   * Control which content panel is currently selected. This puts the component
   * in a controlled mode and should be used along with `onChange`
   */
  selectedIndex: import_prop_types154.default.number
};
function TabsVertical({
  children,
  height,
  defaultSelectedIndex = 0,
  onChange,
  selectedIndex: controlledSelectedIndex,
  ...rest
}) {
  const [selectedIndex, setSelectedIndex] = useControllableState({
    value: controlledSelectedIndex,
    defaultValue: defaultSelectedIndex,
    onChange: (value) => onChange == null ? void 0 : onChange({
      selectedIndex: value
    })
  });
  const props = {
    ...rest,
    selectedIndex,
    onChange: ({
      selectedIndex: selectedIndex2
    }) => setSelectedIndex(selectedIndex2)
  };
  const isSm = useMatchMedia(smMediaQuery);
  if (!isSm) {
    return (
      // eslint-disable-next-line react/forbid-component-props
      import_react205.default.createElement(GridAsGridComponent, {
        style: {
          height
        }
      }, import_react205.default.createElement(Tabs, props, children))
    );
  }
  return import_react205.default.createElement(Tabs, props, children);
}
TabsVertical.propTypes = {
  /**
   * Provide child elements to be rendered inside the `TabsVertical`.
   * These elements should render either `TabsListVertical` or `TabsPanels`
   */
  children: import_prop_types154.default.node,
  /**
   * Specify which content tab should be initially selected when the component
   * is first rendered
   */
  defaultSelectedIndex: import_prop_types154.default.number,
  /**
   * Option to set a height style only if using vertical variation
   */
  height: import_prop_types154.default.string,
  /**
   * Provide an optional function which is called whenever the state of the
   * `Tabs` changes
   */
  onChange: import_prop_types154.default.func,
  /**
   * Control which content panel is currently selected. This puts the component
   * in a controlled mode and should be used along with `onChange`
   */
  selectedIndex: import_prop_types154.default.number
};
function getNextIndex2(event, total, index3) {
  switch (true) {
    case match(event, ArrowRight2):
      return (index3 + 1) % total;
    case match(event, ArrowLeft):
      return (total + index3 - 1) % total;
    case match(event, Home):
      return 0;
    case match(event, End):
      return total - 1;
    default:
      return index3;
  }
}
function getNextIndexVertical(event, total, index3) {
  switch (true) {
    case match(event, ArrowDown):
      return (index3 + 1) % total;
    case match(event, ArrowUp2):
      return (total + index3 - 1) % total;
    case match(event, Home):
      return 0;
    case match(event, End):
      return total - 1;
    default:
      return index3;
  }
}
function TabList({
  activation = "automatic",
  "aria-label": label,
  children,
  className: customClassName,
  contained = false,
  fullWidth = false,
  iconSize,
  leftOverflowButtonProps,
  light,
  rightOverflowButtonProps,
  scrollDebounceWait = 200,
  scrollIntoView: scrollIntoView2,
  ...rest
}) {
  const {
    activeIndex,
    selectedIndex,
    setSelectedIndex,
    setActiveIndex,
    dismissable
  } = import_react205.default.useContext(TabsContext);
  const prefix = usePrefix();
  const ref = (0, import_react205.useRef)(null);
  const previousButton = (0, import_react205.useRef)(null);
  const nextButton = (0, import_react205.useRef)(null);
  const [isScrollable, setIsScrollable] = (0, import_react205.useState)(false);
  const [scrollLeft, setScrollLeft] = (0, import_react205.useState)(0);
  let hasSecondaryLabelTabs = false;
  if (contained) {
    hasSecondaryLabelTabs = import_react205.default.Children.toArray(children).some((child) => {
      const _child = child;
      return import_react205.default.isValidElement(child) && !!_child.props.secondaryLabel;
    });
  }
  const isLg = useMatchMedia(lgMediaQuery);
  const distributeWidth = fullWidth && contained && isLg && import_react205.default.Children.toArray(children).length < 9;
  const className = (0, import_classnames132.default)(`${prefix}--tabs`, {
    [`${prefix}--tabs--contained`]: contained,
    [`${prefix}--tabs--light`]: light,
    [`${prefix}--tabs__icon--default`]: iconSize === "default",
    [`${prefix}--tabs__icon--lg`]: iconSize === "lg",
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-lg`]: iconSize === "lg",
    [`${prefix}--tabs--tall`]: hasSecondaryLabelTabs,
    [`${prefix}--tabs--full-width`]: distributeWidth,
    [`${prefix}--tabs--dismissable`]: dismissable
  }, customClassName);
  const buttonWidth = 44;
  const [isNextButtonVisible, setIsNextButtonVisible] = (0, import_react205.useState)(ref.current ? scrollLeft + buttonWidth + ref.current.clientWidth < ref.current.scrollWidth : false);
  const isPreviousButtonVisible = ref.current ? isScrollable && scrollLeft > 0 : false;
  const previousButtonClasses = (0, import_classnames132.default)(`${prefix}--tab--overflow-nav-button`, `${prefix}--tab--overflow-nav-button--previous`, {
    [`${prefix}--tab--overflow-nav-button--hidden`]: !isPreviousButtonVisible
  });
  const nextButtonClasses = (0, import_classnames132.default)(`${prefix}--tab--overflow-nav-button`, `${prefix}--tab--overflow-nav-button--next`, {
    [`${prefix}--tab--overflow-nav-button--hidden`]: !isNextButtonVisible
  });
  const tabs = (0, import_react205.useRef)([]);
  const debouncedOnScroll = (0, import_react205.useCallback)(() => {
    const updateScroll = debounce2(() => {
      if (ref.current) {
        setScrollLeft(ref.current.scrollLeft);
      }
    }, scrollDebounceWait);
    updateScroll();
  }, [scrollDebounceWait]);
  function onKeyDown(event) {
    var _a;
    if (matches(event, [ArrowRight2, ArrowLeft, Home, End])) {
      event.preventDefault();
      const filteredTabs = tabs.current.filter((tab) => tab !== null);
      const activeTabs = filteredTabs.filter((tab) => !tab.disabled);
      const currentIndex = activeTabs.indexOf(tabs.current[activation === "automatic" ? selectedIndex : activeIndex]);
      const nextIndex = tabs.current.indexOf(activeTabs[getNextIndex2(event, activeTabs.length, currentIndex)]);
      if (activation === "automatic") {
        setSelectedIndex(nextIndex);
      } else if (activation === "manual") {
        setActiveIndex(nextIndex);
      }
      (_a = tabs.current[nextIndex]) == null ? void 0 : _a.focus();
    }
  }
  function handleBlur({
    relatedTarget: currentActiveNode
  }) {
    var _a;
    if ((_a = ref.current) == null ? void 0 : _a.contains(currentActiveNode)) {
      return;
    }
    if (activation === "manual") {
      setActiveIndex(selectedIndex);
    }
  }
  function scrollTabIntoView(tab) {
    if (!isScrollable || !ref.current) {
      return;
    }
    if (tab) {
      const {
        width: tabWidth
      } = tab.getBoundingClientRect();
      const start = tab.offsetLeft;
      const end = tab.offsetLeft + tabWidth;
      const visibleStart = ref.current.scrollLeft + buttonWidth;
      const visibleEnd = ref.current.scrollLeft + ref.current.clientWidth - buttonWidth;
      if (start < visibleStart) {
        setScrollLeft(start - buttonWidth);
      }
      if (end > visibleEnd) {
        setScrollLeft(end + buttonWidth - ref.current.clientWidth);
      }
    }
  }
  (0, import_react205.useEffect)(() => {
    const tab = tabs.current[selectedIndex];
    if (scrollIntoView2 && tab) {
      tab.scrollIntoView({
        block: "nearest",
        inline: "nearest"
      });
    }
  }, []);
  (0, import_react205.useEffect)(() => {
    setIsNextButtonVisible(ref.current ? scrollLeft + buttonWidth + ref.current.clientWidth + 1 < ref.current.scrollWidth : false);
    if (dismissable) {
      if (ref.current) {
        setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth);
      }
    }
  }, [scrollLeft, children, dismissable, isScrollable]);
  (0, import_react205.useEffect)(() => {
    var _a;
    if ((_a = tabs.current[selectedIndex]) == null ? void 0 : _a.disabled) {
      const activeTabs = tabs.current.filter((tab) => {
        return !tab.disabled;
      });
      if (activeTabs.length > 0) {
        const tab = activeTabs[0];
        setSelectedIndex(tabs.current.indexOf(tab));
      }
    }
  }, []);
  useIsomorphicEffect(() => {
    if (ref.current) {
      setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth + 1);
    }
    function handler() {
      if (ref.current) {
        setIsScrollable(ref.current.scrollWidth > ref.current.clientWidth + 1);
      }
    }
    const debouncedHandler = debounce2(handler, 200);
    window.addEventListener("resize", debouncedHandler);
    return () => {
      debouncedHandler.cancel();
      window.removeEventListener("resize", debouncedHandler);
    };
  }, []);
  useIsomorphicEffect(() => {
    if (scrollLeft !== null && ref.current) {
      ref.current.scrollLeft = scrollLeft;
    }
  }, [scrollLeft]);
  useIsomorphicEffect(() => {
    const tab = activation === "manual" ? tabs.current[activeIndex] : tabs.current[selectedIndex];
    scrollTabIntoView(tab);
  }, [activation, activeIndex]);
  useIsomorphicEffect(() => {
    const tab = tabs.current[selectedIndex];
    scrollTabIntoView(tab);
  }, [selectedIndex, isScrollable, children]);
  usePressable(previousButton, {
    onPress({
      longPress
    }) {
      if (!longPress && ref.current) {
        setScrollLeft(Math.max(scrollLeft - ref.current.scrollWidth / tabs.current.length * 1.5, 0));
      }
    },
    onLongPress() {
      return createLongPressBehavior(ref, "backward", setScrollLeft);
    }
  });
  usePressable(nextButton, {
    onPress({
      longPress
    }) {
      if (!longPress && ref.current) {
        setScrollLeft(Math.min(scrollLeft + ref.current.scrollWidth / tabs.current.length * 1.5, ref.current.scrollWidth - ref.current.clientWidth));
      }
    },
    onLongPress() {
      return createLongPressBehavior(ref, "forward", setScrollLeft);
    }
  });
  return import_react205.default.createElement("div", {
    className
  }, import_react205.default.createElement("button", _extends({
    "aria-hidden": "true",
    tabIndex: -1,
    "aria-label": "Scroll left",
    ref: previousButton,
    className: previousButtonClasses,
    type: "button"
  }, leftOverflowButtonProps), _ChevronLeft || (_ChevronLeft = import_react205.default.createElement(ChevronLeft, null))), import_react205.default.createElement("div", _extends({}, rest, {
    "aria-label": label,
    ref,
    role: "tablist",
    className: `${prefix}--tab--list`,
    onScroll: debouncedOnScroll,
    onKeyDown,
    onBlur: handleBlur
  }), import_react205.default.Children.map(children, (child, index3) => {
    return !(0, import_react_is3.isElement)(child) ? null : import_react205.default.createElement(TabContext.Provider, {
      value: {
        index: index3,
        hasSecondaryLabel: hasSecondaryLabelTabs,
        contained
      }
    }, import_react205.default.cloneElement(child, {
      ref: (node) => {
        tabs.current[index3] = node;
      }
    }));
  })), import_react205.default.createElement("button", _extends({
    "aria-hidden": "true",
    tabIndex: -1,
    "aria-label": "Scroll right",
    ref: nextButton,
    className: nextButtonClasses,
    type: "button"
  }, rightOverflowButtonProps), _ChevronRight || (_ChevronRight = import_react205.default.createElement(ChevronRight, null))));
}
TabList.propTypes = {
  /**
   * Specify whether the content tab should be activated automatically or
   * manually
   */
  activation: import_prop_types154.default.oneOf(["automatic", "manual"]),
  /**
   * Provide an accessible label to be read when a user interacts with this
   * component
   */
  "aria-label": import_prop_types154.default.string,
  /**
   * Provide child elements to be rendered inside `ContentTabs`.
   * These elements should render a `ContentTab`
   */
  children: import_prop_types154.default.node,
  /**
   * Specify an optional className to be added to the container node
   */
  className: import_prop_types154.default.string,
  /**
   * Specify whether component is contained type
   */
  contained: import_prop_types154.default.bool,
  /**
   * Used for tabs within a grid, this makes it so tabs span the full container width and have the same width. Only available on contained tabs with <9 children
   */
  fullWidth: import_prop_types154.default.bool,
  /**
   * If using `IconTab`, specify the size of the icon being used.
   */
  iconSize: import_prop_types154.default.oneOf(["default", "lg"]),
  /**
   * Provide the props that describe the left overflow button
   */
  leftOverflowButtonProps: import_prop_types154.default.object,
  /**
   * Specify whether to use the light component variant
   */
  light: deprecate(import_prop_types154.default.bool, "The `light` prop for `TabList` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Provide the props that describe the right overflow button
   */
  rightOverflowButtonProps: import_prop_types154.default.object,
  /**
   * Optionally provide a delay (in milliseconds) passed to the lodash
   * debounce of the onScroll handler. This will impact the responsiveness
   * of scroll arrow buttons rendering when scrolling to the first or last tab.
   */
  scrollDebounceWait: import_prop_types154.default.number,
  /**
   * Choose whether to automatically scroll
   * to newly selected tabs on component rerender
   */
  scrollIntoView: import_prop_types154.default.bool
};
function TabListVertical({
  activation = "automatic",
  "aria-label": label,
  children,
  className: customClassName,
  scrollIntoView: scrollIntoView2,
  ...rest
}) {
  const {
    activeIndex,
    selectedIndex,
    setSelectedIndex,
    setActiveIndex
  } = import_react205.default.useContext(TabsContext);
  const prefix = usePrefix();
  const ref = (0, import_react205.useRef)(null);
  const [isOverflowingBottom, setIsOverflowingBottom] = (0, import_react205.useState)(false);
  const [isOverflowingTop, setIsOverflowingTop] = (0, import_react205.useState)(false);
  const isSm = useMatchMedia(smMediaQuery);
  const className = (0, import_classnames132.default)(`${prefix}--tabs`, `${prefix}--tabs--vertical`, `${prefix}--tabs--contained`, customClassName);
  const tabs = (0, import_react205.useRef)([]);
  function onKeyDown(event) {
    var _a;
    if (matches(event, [ArrowDown, ArrowUp2, Home, End])) {
      event.preventDefault();
      const filteredTabs = tabs.current.filter((tab) => tab !== null);
      const activeTabs = filteredTabs.filter((tab) => !tab.disabled);
      const currentIndex = activeTabs.indexOf(tabs.current[activation === "automatic" ? selectedIndex : activeIndex]);
      const nextIndex = tabs.current.indexOf(activeTabs[getNextIndexVertical(event, activeTabs.length, currentIndex)]);
      if (activation === "automatic") {
        setSelectedIndex(nextIndex);
      } else if (activation === "manual") {
        setActiveIndex(nextIndex);
      }
      (_a = tabs.current[nextIndex]) == null ? void 0 : _a.focus();
    }
  }
  function handleBlur({
    relatedTarget: currentActiveNode
  }) {
    var _a;
    if ((_a = ref.current) == null ? void 0 : _a.contains(currentActiveNode)) {
      return;
    }
    if (activation === "manual") {
      setActiveIndex(selectedIndex);
    }
  }
  (0, import_react205.useEffect)(() => {
    var _a;
    if ((_a = tabs.current[selectedIndex]) == null ? void 0 : _a.disabled) {
      const activeTabs = tabs.current.filter((tab) => {
        return !tab.disabled;
      });
      if (activeTabs.length > 0) {
        const tab = activeTabs[0];
        setSelectedIndex(tabs.current.indexOf(tab));
      }
    }
  }, []);
  (0, import_react205.useEffect)(() => {
    function handler() {
      var _a, _b, _c;
      const containerHeight = (_a = ref.current) == null ? void 0 : _a.offsetHeight;
      const containerTop = (_b = ref.current) == null ? void 0 : _b.getBoundingClientRect().top;
      const selectedPositionTop = (_c = tabs.current[selectedIndex]) == null ? void 0 : _c.getBoundingClientRect().top;
      const halfTabHeight = verticalTabHeight / 2;
      if (containerTop && containerHeight) {
        if (selectedPositionTop - halfTabHeight < containerTop || selectedPositionTop - containerTop + verticalTabHeight + halfTabHeight > containerHeight) {
          ref.current && ref.current.scrollTo({
            top: (selectedIndex - 1) * verticalTabHeight,
            behavior: "smooth"
          });
        }
      }
    }
    window.addEventListener("resize", handler);
    handler();
    return () => {
      window.removeEventListener("resize", handler);
    };
  }, [selectedIndex, scrollIntoView2]);
  (0, import_react205.useEffect)(() => {
    const element = ref.current;
    if (!element) {
      return;
    }
    const handler = () => {
      const halfTabHeight = verticalTabHeight / 2;
      setIsOverflowingBottom(element.scrollTop + element.clientHeight + halfTabHeight <= element.scrollHeight);
      setIsOverflowingTop(element.scrollTop > halfTabHeight);
    };
    const resizeObserver = new ResizeObserver(() => handler());
    resizeObserver.observe(element);
    element.addEventListener("scroll", handler);
    return () => {
      resizeObserver.disconnect();
      element.removeEventListener("scroll", handler);
    };
  });
  if (isSm) {
    return import_react205.default.createElement(TabList, _extends({}, rest, {
      "aria-label": label,
      contained: true
    }), children);
  }
  return import_react205.default.createElement("div", {
    className
  }, isOverflowingTop && import_react205.default.createElement("div", {
    className: `${prefix}--tab--list-gradient_top`
  }), import_react205.default.createElement("div", _extends({}, rest, {
    "aria-label": label,
    ref,
    role: "tablist",
    className: `${prefix}--tab--list`,
    onKeyDown,
    onBlur: handleBlur
  }), import_react205.default.Children.map(children, (child, index3) => {
    return !(0, import_react_is3.isElement)(child) ? null : import_react205.default.createElement(TabContext.Provider, {
      value: {
        index: index3,
        hasSecondaryLabel: false
      }
    }, import_react205.default.cloneElement(child, {
      ref: (node) => {
        tabs.current[index3] = node;
      }
    }));
  })), isOverflowingBottom && import_react205.default.createElement("div", {
    className: `${prefix}--tab--list-gradient_bottom`
  }));
}
TabListVertical.propTypes = {
  /**
   * Specify whether the content tab should be activated automatically or
   * manually
   */
  activation: import_prop_types154.default.oneOf(["automatic", "manual"]),
  /**
   * Provide an accessible label to be read when a user interacts with this
   * component
   */
  "aria-label": import_prop_types154.default.string,
  /**
   * Provide child elements to be rendered inside `ContentTabs`.
   * These elements should render a `ContentTab`
   */
  children: import_prop_types154.default.node,
  /**
   * Specify an optional className to be added to the container node
   */
  className: import_prop_types154.default.string
};
function createLongPressBehavior(ref, direction, setScrollLeft) {
  const node = ref.current;
  if (!node) {
    return () => {
    };
  }
  const defaultScrollBehavior = node == null ? void 0 : node.style["scroll-behavior"];
  node.style["scroll-behavior"] = "auto";
  const scrollDelta = direction === "forward" ? 5 : -5;
  let frameId = null;
  function tick() {
    if (!node) {
      return;
    }
    node.scrollLeft = node.scrollLeft + scrollDelta;
    frameId = requestAnimationFrame(tick);
  }
  frameId = requestAnimationFrame(tick);
  return () => {
    node.style["scroll-behavior"] = defaultScrollBehavior;
    setScrollLeft(node.scrollLeft);
    if (frameId) {
      cancelAnimationFrame(frameId);
    }
  };
}
var Tab2 = (0, import_react205.forwardRef)(function Tab3({
  as = "button",
  children,
  className: customClassName,
  disabled,
  onClick,
  onKeyDown,
  secondaryLabel,
  renderIcon: Icon,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const {
    selectedIndex,
    setSelectedIndex,
    baseId,
    dismissable,
    onTabCloseRequest
  } = import_react205.default.useContext(TabsContext);
  const {
    index: index3,
    hasSecondaryLabel,
    contained
  } = import_react205.default.useContext(TabContext);
  const {
    badgeIndicator
  } = import_react205.default.useContext(IconTabContext) || {};
  const dismissIconRef = (0, import_react205.useRef)(null);
  const tabRef = (0, import_react205.useRef)(null);
  const ref = useMergedRefs([forwardRef36, tabRef]);
  const [ignoreHover, setIgnoreHover] = (0, import_react205.useState)(false);
  const id = `${baseId}-tab-${index3}`;
  const panelId = `${baseId}-tabpanel-${index3}`;
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react205.useState)(false);
  const isEllipsisActive2 = (element) => {
    setIsEllipsisApplied(element.offsetHeight < element.scrollHeight);
    return element.offsetHeight < element.scrollHeight;
  };
  const className = (0, import_classnames132.default)(`${prefix}--tabs__nav-item`, `${prefix}--tabs__nav-link`, {
    [`${prefix}--tabs__nav-item--selected`]: selectedIndex === index3,
    [`${prefix}--tabs__nav-item--disabled`]: disabled,
    [`${prefix}--tabs__nav-item--hover-off`]: ignoreHover
  }, customClassName);
  const BaseComponent = as;
  const onDismissIconMouseEnter = (evt) => {
    if (contained && tabRef.current) {
      evt.stopPropagation();
      setIgnoreHover(true);
      tabRef.current.classList.add(`${prefix}--tabs__nav-item--hover-off`);
    }
  };
  const onDismissIconMouseLeave = () => {
    if (contained && tabRef.current) {
      tabRef.current.classList.remove(`${prefix}--tabs__nav-item--hover-off`);
      setIgnoreHover(false);
    }
  };
  useEvent(dismissIconRef, "mouseover", onDismissIconMouseEnter);
  useEvent(dismissIconRef, "mouseleave", onDismissIconMouseLeave);
  useIsomorphicEffect(() => {
    function handler() {
      const elementTabId = document.getElementById(`${id}`) || tabRef.current;
      if (elementTabId == null ? void 0 : elementTabId.closest(`.${prefix}--tabs--vertical`)) {
        const newElement = elementTabId == null ? void 0 : elementTabId.getElementsByClassName(`${prefix}--tabs__nav-item-label`)[0];
        isEllipsisActive2(newElement);
      }
    }
    handler();
    window.addEventListener("resize", handler);
    return () => {
      window.removeEventListener("resize", handler);
    };
  }, [prefix, id]);
  const handleClose = (evt) => {
    var _a;
    evt.stopPropagation();
    onTabCloseRequest == null ? void 0 : onTabCloseRequest(index3);
    if (tabRef.current && tabRef.current.parentElement) {
      const tabCount = Array.from(tabRef.current.parentElement.childNodes).filter((node) => {
        const element = node;
        return element.classList.contains(`${prefix}--tabs__nav-link`) && !element.classList.contains(`${prefix}--tabs__nav-item--disabled`);
      }).length;
      if (tabRef.current && index3 + 1 !== tabCount) {
        tabRef.current.focus();
      } else {
        const prevTabIndex = (tabCount - 2) * 2;
        (_a = tabRef.current.parentElement.childNodes[prevTabIndex]) == null ? void 0 : _a.focus();
      }
    }
  };
  const handleKeyDown = (event) => {
    if (dismissable && match(event, Delete)) {
      handleClose(event);
    }
    onKeyDown == null ? void 0 : onKeyDown(event);
  };
  const DismissIcon = import_react205.default.createElement("div", {
    className: (0, import_classnames132.default)({
      [`${prefix}--tabs__nav-item--close`]: dismissable,
      [`${prefix}--tabs__nav-item--close--hidden`]: !dismissable
    })
  }, import_react205.default.createElement("button", {
    type: "button",
    tabIndex: selectedIndex === index3 && dismissable ? 0 : -1,
    "aria-disabled": disabled,
    "aria-hidden": selectedIndex === index3 && dismissable ? "false" : "true",
    disabled,
    className: (0, import_classnames132.default)({
      [`${prefix}--tabs__nav-item--close-icon`]: dismissable,
      [`${prefix}--visually-hidden`]: !dismissable,
      [`${prefix}--tabs__nav-item--close-icon--selected`]: selectedIndex === index3,
      [`${prefix}--tabs__nav-item--close-icon--disabled`]: disabled
    }),
    onClick: handleClose,
    title: `Remove ${typeof children === "string" ? children : ""} tab`,
    ref: dismissIconRef
  }, import_react205.default.createElement(Close, {
    "aria-hidden": selectedIndex === index3 && dismissable ? "false" : "true",
    "aria-label": `Press delete to remove ${typeof children === "string" ? children : ""} tab`
  })));
  const hasIcon = Icon ?? dismissable;
  if (isEllipsisApplied) {
    return import_react205.default.createElement(Tooltip, {
      label: children,
      align: "top",
      leaveDelayMs: 0,
      autoAlign: true,
      onMouseEnter: () => false,
      closeOnActivation: true
    }, import_react205.default.createElement(BaseComponent, _extends({}, rest, {
      "aria-controls": panelId,
      "aria-disabled": disabled,
      "aria-selected": selectedIndex === index3,
      ref,
      id,
      role: "tab",
      className,
      disabled,
      title: children,
      onClick: (evt) => {
        if (disabled) {
          return;
        }
        setSelectedIndex(index3);
        onClick == null ? void 0 : onClick(evt);
      },
      onKeyDown: handleKeyDown,
      tabIndex: selectedIndex === index3 ? "0" : "-1",
      type: "button"
    }), import_react205.default.createElement("div", {
      className: `${prefix}--tabs__nav-item-label-wrapper`
    }, import_react205.default.createElement(Text, {
      className: `${prefix}--tabs__nav-item-label`
    }, children)), hasSecondaryLabel && secondaryLabel && import_react205.default.createElement(Text, {
      as: "div",
      className: `${prefix}--tabs__nav-item-secondary-label`,
      title: secondaryLabel
    }, secondaryLabel)));
  }
  return import_react205.default.createElement(import_react205.default.Fragment, null, import_react205.default.createElement(BaseComponent, _extends({}, rest, {
    "aria-controls": panelId,
    "aria-disabled": disabled,
    "aria-selected": selectedIndex === index3,
    ref,
    id,
    role: "tab",
    className,
    disabled,
    onClick: (evt) => {
      if (disabled) {
        return;
      }
      setSelectedIndex(index3);
      onClick == null ? void 0 : onClick(evt);
    },
    onKeyDown: handleKeyDown,
    tabIndex: selectedIndex === index3 ? "0" : "-1",
    type: "button"
  }), import_react205.default.createElement("div", {
    className: `${prefix}--tabs__nav-item-label-wrapper`
  }, dismissable && Icon && import_react205.default.createElement("div", {
    className: `${prefix}--tabs__nav-item--icon-left`
  }, import_react205.default.createElement(Icon, {
    size: 16
  })), import_react205.default.createElement(Text, {
    className: `${prefix}--tabs__nav-item-label`
  }, children), !dismissable && Icon && import_react205.default.createElement("div", {
    className: (0, import_classnames132.default)(`${prefix}--tabs__nav-item--icon`, {
      [`${prefix}--visually-hidden`]: !hasIcon
    })
  }, !dismissable && Icon && import_react205.default.createElement(Icon, {
    size: 16
  }))), hasSecondaryLabel && secondaryLabel && import_react205.default.createElement(Text, {
    as: "div",
    className: `${prefix}--tabs__nav-item-secondary-label`,
    title: secondaryLabel
  }, secondaryLabel), !disabled && badgeIndicator && (_BadgeIndicator || (_BadgeIndicator = import_react205.default.createElement(BadgeIndicator, null)))), DismissIcon);
});
Tab2.propTypes = {
  /**
   * Provide a custom element to render instead of the default button
   */
  as: import_prop_types154.default.oneOfType([import_prop_types154.default.string, import_prop_types154.default.elementType]),
  /**
   * Provide child elements to be rendered inside `Tab`.
   */
  children: import_prop_types154.default.node,
  /**
   * Specify an optional className to be added to your Tab
   */
  className: import_prop_types154.default.string,
  /**
   * Whether your Tab is disabled.
   */
  disabled: import_prop_types154.default.bool,
  /**
   * Provide a handler that is invoked when a user clicks on the control
   */
  onClick: import_prop_types154.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the control
   */
  onKeyDown: import_prop_types154.default.func,
  /**
   * An optional parameter to allow overriding the anchor rendering.
   * Useful for using Tab along with react-router or other client
   * side router libraries.
   */
  renderButton: import_prop_types154.default.func,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types154.default.oneOfType([import_prop_types154.default.func, import_prop_types154.default.object]),
  /**
   * An optional label to render under the primary tab label.
   * Only useful for contained tabs.
   */
  secondaryLabel: import_prop_types154.default.string
};
var IconTabContext = (0, import_react205.createContext)(false);
var IconTab = import_react205.default.forwardRef(function IconTab2({
  badgeIndicator,
  children,
  className: customClassName,
  defaultOpen = false,
  enterDelayMs,
  leaveDelayMs,
  label,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const value = (0, import_react205.useMemo)(() => ({
    badgeIndicator
  }), [badgeIndicator]);
  const hasSize20 = (0, import_react205.isValidElement)(children) && children.props.size === 20;
  const classNames = (0, import_classnames132.default)(`${prefix}--tabs__nav-item--icon-only`, customClassName, {
    [`${prefix}--tabs__nav-item--icon-only__20`]: hasSize20
  });
  return import_react205.default.createElement(IconTabContext.Provider, {
    value
  }, import_react205.default.createElement(Tooltip, {
    align: "bottom",
    defaultOpen,
    className: `${prefix}--icon-tooltip`,
    enterDelayMs,
    label,
    leaveDelayMs
  }, import_react205.default.createElement(Tab2, _extends({
    className: classNames,
    ref
  }, rest), children)));
});
IconTab.propTypes = {
  /**
   * **Experimental**: Display an empty dot badge on the Tab.
   */
  badgeIndicator: import_prop_types154.default.bool,
  /**
   * Provide an icon to be rendered inside `IconTab` as the visual label for Tab.
   */
  children: import_prop_types154.default.node,
  /**
   * Specify an optional className to be added to your Tab
   */
  className: import_prop_types154.default.string,
  /**
   * Specify whether the tooltip for the icon should be open when it first renders
   */
  defaultOpen: import_prop_types154.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the tooltip for the icon.
   */
  enterDelayMs: import_prop_types154.default.number,
  /**
   * Provide the label to be rendered inside the Tooltip. The label will use
   * `aria-labelledby` and will fully describe the child node that is provided.
   * This means that if you have text in the child node it will not be
   * announced to the screen reader. If using the badgeIndicator then provide a
   * label with describing that there is a new notification.
   */
  label: import_prop_types154.default.node.isRequired,
  /**
   * Specify the duration in milliseconds to delay before hiding the tooltip
   */
  leaveDelayMs: import_prop_types154.default.number
};
var TabPanel = import_react205.default.forwardRef(function TabPanel2({
  children,
  className: customClassName,
  ...rest
}, forwardRef36) {
  const prefix = usePrefix();
  const panel = (0, import_react205.useRef)(null);
  const ref = useMergedRefs([forwardRef36, panel]);
  const [tabIndex, setTabIndex] = (0, import_react205.useState)(0);
  const [interactiveContent, setInteractiveContent] = (0, import_react205.useState)(false);
  const {
    selectedIndex,
    baseId
  } = import_react205.default.useContext(TabsContext);
  const index3 = import_react205.default.useContext(TabPanelContext);
  const id = `${baseId}-tabpanel-${index3}`;
  const tabId = `${baseId}-tab-${index3}`;
  const className = (0, import_classnames132.default)(`${prefix}--tab-content`, customClassName, {
    [`${prefix}--tab-content--interactive`]: interactiveContent
  });
  (0, import_react205.useEffect)(() => {
    if (!panel.current) {
      return;
    }
    const content = getInteractiveContent(panel.current);
    if (content) {
      setInteractiveContent(true);
      setTabIndex(-1);
    }
  }, []);
  (0, import_react205.useEffect)(() => {
    const node = panel.current;
    if (!node) {
      return;
    }
    function callback() {
      const content = getInteractiveContent(node);
      if (content) {
        setInteractiveContent(true);
        setTabIndex(-1);
      } else {
        setInteractiveContent(false);
        setTabIndex(0);
      }
    }
    const observer = new MutationObserver(callback);
    observer.observe(node, {
      childList: true,
      subtree: true
    });
    return () => observer.disconnect();
  }, []);
  return import_react205.default.createElement("div", _extends({}, rest, {
    "aria-labelledby": tabId,
    id,
    className,
    ref,
    role: "tabpanel",
    tabIndex,
    hidden: selectedIndex !== index3
  }), children);
});
TabPanel.propTypes = {
  /**
   * Provide child elements to be rendered inside `TabPanel`.
   */
  children: import_prop_types154.default.node,
  /**
   * Specify an optional className to be added to TabPanel.
   */
  className: import_prop_types154.default.string
};
function TabPanels({
  children
}) {
  const prefix = usePrefix();
  const refs = (0, import_react205.useRef)([]);
  const hiddenStates = (0, import_react205.useRef)([]);
  useIsomorphicEffect(() => {
    var _a, _b;
    const tabContainer = (_a = refs.current[0]) == null ? void 0 : _a.previousElementSibling;
    const isVertical = tabContainer == null ? void 0 : tabContainer.classList.contains(`${prefix}--tabs--vertical`);
    const parentHasHeight = (_b = tabContainer == null ? void 0 : tabContainer.parentElement) == null ? void 0 : _b.style.height;
    if (isVertical && !parentHasHeight) {
      hiddenStates.current = refs.current.map((ref) => (ref == null ? void 0 : ref.hidden) || false);
      refs.current.forEach((ref) => {
        if (ref) {
          ref.hidden = false;
        }
      });
      const heights = refs.current.map((ref) => (ref == null ? void 0 : ref.offsetHeight) || 0);
      const max2 = Math.max(...heights);
      tabContainer.style.height = max2 + "px";
      refs.current.forEach((ref, index3) => {
        if (ref) {
          ref.hidden = hiddenStates.current[index3];
        }
      });
    }
  });
  return import_react205.default.createElement(import_react205.default.Fragment, null, import_react205.default.Children.map(children, (child, index3) => {
    return !(0, import_react_is3.isElement)(child) ? null : import_react205.default.createElement(TabPanelContext.Provider, {
      value: index3
    }, import_react205.default.cloneElement(child, {
      ref: (element) => {
        refs.current[index3] = element;
      }
    }));
  }));
}
TabPanels.propTypes = {
  /**
   * Provide child elements to be rendered inside `TabPanels`.
   */
  children: import_prop_types154.default.node
};

// node_modules/@carbon/react/es/components/TabContent/TabContent.js
var import_prop_types155 = __toESM(require_prop_types());
var import_react206 = __toESM(require_react());
var import_classnames133 = __toESM(require_classnames());
function TabContent(props) {
  const {
    className,
    selected,
    children,
    ...other
  } = props;
  const prefix = usePrefix();
  const tabContentClasses = (0, import_classnames133.default)(`${prefix}--tab-content`, className);
  return import_react206.default.createElement("div", _extends({
    role: "tabpanel"
  }, other, {
    className: tabContentClasses,
    selected,
    hidden: !selected
  }), children);
}
TabContent.propTypes = {
  /**
   * Pass in content to render inside the TabContent
   */
  children: import_prop_types155.default.node,
  /**
   * Provide a className for the tab content container
   */
  className: import_prop_types155.default.string,
  /**
   * Specify whether the TabContent is selected
   */
  selected: import_prop_types155.default.bool
};

// node_modules/@carbon/react/es/components/Tabs/Tabs.Skeleton.js
var import_prop_types156 = __toESM(require_prop_types());
var import_react207 = __toESM(require_react());
var import_classnames134 = __toESM(require_classnames());
var _span7;
var _Tab;
var _Tab2;
var _Tab3;
var _Tab4;
var _Tab5;
function Tab4() {
  const prefix = usePrefix();
  return import_react207.default.createElement("li", {
    className: `${prefix}--tabs__nav-item`
  }, import_react207.default.createElement("div", {
    className: `${prefix}--tabs__nav-link`
  }, _span7 || (_span7 = import_react207.default.createElement("span", null))));
}
function TabsSkeleton({
  className,
  contained,
  ...rest
}) {
  const prefix = usePrefix();
  const tabClasses = (0, import_classnames134.default)(className, `${prefix}--tabs`, `${prefix}--skeleton`, {
    [`${prefix}--tabs--contained`]: contained
  });
  return import_react207.default.createElement("div", _extends({
    className: tabClasses
  }, rest), import_react207.default.createElement("ul", {
    className: `${prefix}--tabs__nav`
  }, _Tab || (_Tab = import_react207.default.createElement(Tab4, null)), _Tab2 || (_Tab2 = import_react207.default.createElement(Tab4, null)), _Tab3 || (_Tab3 = import_react207.default.createElement(Tab4, null)), _Tab4 || (_Tab4 = import_react207.default.createElement(Tab4, null)), _Tab5 || (_Tab5 = import_react207.default.createElement(Tab4, null))));
}
TabsSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types156.default.string,
  /**
   * Provide the type of Tab
   */
  contained: import_prop_types156.default.bool
};

// node_modules/@carbon/react/es/components/TextArea/TextArea.js
var import_prop_types157 = __toESM(require_prop_types());
var import_react208 = __toESM(require_react());
var import_classnames135 = __toESM(require_classnames());

// node_modules/@carbon/react/es/internal/getAnnouncement.js
var getAnnouncement = (count2, maxCount, singularEntityName = "character", pluralEntityName = "characters") => {
  if (typeof maxCount === "undefined") return null;
  const remaining = maxCount - count2;
  if (remaining <= 10 && remaining > 0) {
    const entityName = remaining === 1 ? singularEntityName : pluralEntityName;
    return `${remaining} ${entityName} left.`;
  }
  if (remaining <= 0) {
    return `Maximum ${pluralEntityName} reached.`;
  }
  return null;
};

// node_modules/@carbon/react/es/components/TextArea/TextArea.js
var frFn7 = import_react208.forwardRef;
var TextArea = frFn7((props, forwardRef36) => {
  const {
    className,
    decorator,
    disabled = false,
    id,
    labelText,
    hideLabel,
    onChange = noopFn,
    onClick = noopFn,
    onKeyDown = noopFn,
    invalid = false,
    invalidText = "",
    helperText = "",
    light,
    placeholder = "",
    enableCounter = false,
    maxCount,
    counterMode = "character",
    warn: warn2 = false,
    warnText = "",
    rows = 4,
    slug,
    ...other
  } = props;
  const prefix = usePrefix();
  const {
    isFluid
  } = (0, import_react208.useContext)(FormContext);
  const {
    defaultValue,
    value
  } = other;
  const textAreaInstanceId = useId();
  const wrapperRef = (0, import_react208.useRef)(null);
  const textareaRef = (0, import_react208.useRef)(null);
  const helperTextRef = (0, import_react208.useRef)(null);
  const errorTextRef = (0, import_react208.useRef)(null);
  const warnTextRef = (0, import_react208.useRef)(null);
  const ref = useMergedRefs([forwardRef36, textareaRef]);
  function getInitialTextCount() {
    var _a, _b;
    const targetValue = defaultValue || value || ((_a = textareaRef.current) == null ? void 0 : _a.value) || "";
    const strValue = targetValue.toString();
    if (counterMode === "character") {
      return strValue.length;
    } else {
      return ((_b = strValue.match(new RegExp("\\p{L}+", "gu"))) == null ? void 0 : _b.length) || 0;
    }
  }
  const [textCount, setTextCount] = (0, import_react208.useState)(getInitialTextCount());
  (0, import_react208.useEffect)(() => {
    setTextCount(getInitialTextCount());
  }, [value, defaultValue, counterMode]);
  useIsomorphicEffect(() => {
    var _a;
    const measuredWidth = (_a = wrapperRef.current) == null ? void 0 : _a.scrollWidth;
    if (other.cols && textareaRef.current) {
      textareaRef.current.style.width = "";
      textareaRef.current.style.resize = "none";
    } else if (textareaRef.current) {
      textareaRef.current.style.width = `100%`;
    }
    [helperTextRef, errorTextRef, warnTextRef].forEach((r2) => {
      if (r2.current) {
        r2.current.style.maxWidth = `${measuredWidth}px`;
        r2.current.style.overflowWrap = "break-word";
      }
    });
  }, [other.cols, invalid, warn2]);
  const textareaProps = {
    id,
    onKeyDown: (evt) => {
      if (!disabled && enableCounter && counterMode === "word") {
        const key = evt.which;
        if (maxCount && textCount >= maxCount && key === 32 || maxCount && textCount >= maxCount && key === 13) {
          evt.preventDefault();
        }
      }
      if (!disabled && onKeyDown) {
        onKeyDown(evt);
      }
    },
    onPaste: (evt) => {
      if (!disabled) {
        if (counterMode === "word" && enableCounter && typeof maxCount !== "undefined" && textareaRef.current !== null) {
          const existingWords = textareaRef.current.value.match(new RegExp("\\p{L}+", "gu")) || [];
          const pastedWords = evt.clipboardData.getData("Text").match(new RegExp("\\p{L}+", "gu")) || [];
          const totalWords = existingWords.length + pastedWords.length;
          if (totalWords > maxCount) {
            evt.preventDefault();
            const allowedWords = existingWords.concat(pastedWords).slice(0, maxCount);
            setTimeout(() => {
              setTextCount(maxCount);
            }, 0);
            textareaRef.current.value = allowedWords.join(" ");
          }
        }
      }
    },
    onChange: (evt) => {
      var _a, _b, _c;
      if (!disabled) {
        if (counterMode == "character") {
          (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
          setTimeout(() => {
            var _a2, _b2;
            setTextCount((_b2 = (_a2 = evt.target) == null ? void 0 : _a2.value) == null ? void 0 : _b2.length);
          }, 0);
        } else if (counterMode == "word") {
          if (!evt.target.value) {
            setTimeout(() => {
              setTextCount(0);
            }, 0);
            return;
          }
          if (enableCounter && typeof maxCount !== "undefined" && textareaRef.current !== null) {
            const matchedWords = (_c = (_b = evt.target) == null ? void 0 : _b.value) == null ? void 0 : _c.match(new RegExp("\\p{L}+", "gu"));
            if (matchedWords && matchedWords.length <= maxCount) {
              textareaRef.current.removeAttribute("maxLength");
              setTimeout(() => {
                setTextCount(matchedWords.length);
              }, 0);
            } else if (matchedWords && matchedWords.length > maxCount) {
              setTimeout(() => {
                setTextCount(matchedWords.length);
              }, 0);
            }
          }
        }
        if (onChange) {
          onChange(evt);
        }
      }
    },
    onClick: (evt) => {
      if (!disabled && onClick) {
        onClick(evt);
      }
    }
  };
  const formItemClasses = (0, import_classnames135.default)(`${prefix}--form-item`, className);
  const textAreaWrapperClasses = (0, import_classnames135.default)(`${prefix}--text-area__wrapper`, {
    [`${prefix}--text-area__wrapper--cols`]: other.cols,
    [`${prefix}--text-area__wrapper--readonly`]: other.readOnly,
    [`${prefix}--text-area__wrapper--warn`]: warn2,
    [`${prefix}--text-area__wrapper--slug`]: slug,
    [`${prefix}--text-area__wrapper--decorator`]: decorator
  });
  const labelClasses = (0, import_classnames135.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel && !isFluid,
    [`${prefix}--label--disabled`]: disabled
  });
  const textareaClasses = (0, import_classnames135.default)(`${prefix}--text-area`, {
    [`${prefix}--text-area--light`]: light,
    [`${prefix}--text-area--invalid`]: invalid,
    [`${prefix}--text-area--warn`]: warn2
  });
  const counterClasses = (0, import_classnames135.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--text-area__label-counter`]: true
  });
  const helperTextClasses = (0, import_classnames135.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: disabled
  });
  const label = labelText ? import_react208.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const counter = enableCounter && maxCount && (counterMode === "character" || counterMode === "word") ? import_react208.default.createElement(Text, {
    as: "div",
    className: counterClasses
  }, `${textCount}/${maxCount}`) : null;
  const helperId = !helperText ? void 0 : `text-area-helper-text-${textAreaInstanceId}`;
  const helper = helperText ? import_react208.default.createElement(Text, {
    as: "div",
    id: helperId,
    className: helperTextClasses,
    ref: helperTextRef
  }, helperText) : null;
  const errorId = id + "-error-msg";
  const error2 = invalid ? import_react208.default.createElement(Text, {
    as: "div",
    role: "alert",
    className: `${prefix}--form-requirement`,
    id: errorId,
    ref: errorTextRef
  }, invalidText, isFluid && import_react208.default.createElement(WarningFilled, {
    className: `${prefix}--text-area__invalid-icon`
  })) : null;
  const warnId = id + "-warn-msg";
  const warning2 = warn2 ? import_react208.default.createElement(Text, {
    as: "div",
    role: "alert",
    className: `${prefix}--form-requirement`,
    id: warnId,
    ref: warnTextRef
  }, warnText, isFluid && import_react208.default.createElement(WarningAltFilled, {
    className: `${prefix}--text-area__invalid-icon ${prefix}--text-area__invalid-icon--warning`
  })) : null;
  let ariaDescribedBy;
  if (invalid) {
    ariaDescribedBy = errorId;
  } else if (!invalid && !warn2 && !isFluid && helperText) {
    ariaDescribedBy = helperId;
  }
  if (enableCounter) {
    if (counterMode == "character") {
      textareaProps.maxLength = maxCount;
    }
  }
  const announcerRef = (0, import_react208.useRef)(null);
  const [prevAnnouncement, setPrevAnnouncement] = (0, import_react208.useState)("");
  const ariaAnnouncement = getAnnouncement(textCount, maxCount, counterMode === "word" ? "word" : void 0, counterMode === "word" ? "words" : void 0);
  (0, import_react208.useEffect)(() => {
    if (ariaAnnouncement && ariaAnnouncement !== prevAnnouncement) {
      const announcer = announcerRef.current;
      if (announcer) {
        announcer.textContent = "";
        const timeoutId = setTimeout(() => {
          if (announcer) {
            announcer.textContent = ariaAnnouncement;
            setPrevAnnouncement(ariaAnnouncement);
          }
        }, counterMode === "word" ? 2e3 : 1e3);
        return () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      }
    }
  }, [ariaAnnouncement, prevAnnouncement, counterMode]);
  const input = import_react208.default.createElement("textarea", _extends({}, other, textareaProps, {
    placeholder,
    "aria-readonly": other.readOnly ? true : false,
    className: textareaClasses,
    "aria-invalid": invalid,
    "aria-describedby": ariaDescribedBy,
    disabled,
    rows,
    readOnly: other.readOnly,
    ref
  }));
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react208.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  return import_react208.default.createElement("div", {
    className: formItemClasses
  }, import_react208.default.createElement("div", {
    className: `${prefix}--text-area__label-wrapper`
  }, label, counter), import_react208.default.createElement("div", {
    ref: wrapperRef,
    className: textAreaWrapperClasses,
    "data-invalid": invalid || null
  }, invalid && !isFluid && import_react208.default.createElement(WarningFilled, {
    className: `${prefix}--text-area__invalid-icon`
  }), warn2 && !invalid && !isFluid && import_react208.default.createElement(WarningAltFilled, {
    className: `${prefix}--text-area__invalid-icon ${prefix}--text-area__invalid-icon--warning`
  }), input, slug ? normalizedDecorator : decorator ? import_react208.default.createElement("div", {
    className: `${prefix}--text-area__inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react208.default.createElement("span", {
    className: `${prefix}--text-area__counter-alert`,
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true",
    ref: announcerRef
  }, ariaAnnouncement), isFluid && import_react208.default.createElement("hr", {
    className: `${prefix}--text-area__divider`
  }), isFluid && invalid ? error2 : null, isFluid && warn2 && !invalid ? warning2 : null), !invalid && !warn2 && !isFluid ? helper : null, invalid && !isFluid ? error2 : null, warn2 && !invalid && !isFluid ? warning2 : null);
});
TextArea.displayName = "TextArea";
TextArea.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<textarea>` node
   */
  className: import_prop_types157.default.string,
  /**
   * Specify the `cols` attribute for the underlying `<textarea>` node
   */
  cols: import_prop_types157.default.number,
  /**
   * Specify the method used for calculating the counter number
   */
  counterMode: import_prop_types157.default.oneOf(["character", "word"]),
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `TextArea` component
   */
  decorator: import_prop_types157.default.node,
  /**
   * Optionally provide the default value of the `<textarea>`
   */
  defaultValue: import_prop_types157.default.oneOfType([import_prop_types157.default.string, import_prop_types157.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types157.default.bool,
  /**
   * Specify whether to display the counter
   */
  enableCounter: import_prop_types157.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types157.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types157.default.bool,
  /**
   * Provide a unique identifier for the control
   */
  id: import_prop_types157.default.string,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types157.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types157.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types157.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types157.default.bool, "The `light` prop for `TextArea` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Max entity count allowed for the textarea. This is needed in order for enableCounter to display
   */
  maxCount: import_prop_types157.default.number,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<textarea>`
   * is updated
   */
  onChange: import_prop_types157.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<textarea>` is clicked
   */
  onClick: import_prop_types157.default.func,
  /**
   * Optionally provide an `onKeyDown` handler that is called whenever `<textarea>`
   * is keyed
   */
  onKeyDown: import_prop_types157.default.func,
  /**
   * Specify the placeholder attribute for the `<textarea>`
   */
  placeholder: import_prop_types157.default.string,
  /**
   * Whether the textarea should be read-only
   */
  readOnly: import_prop_types157.default.bool,
  /**
   * Specify the rows attribute for the `<textarea>`
   */
  rows: import_prop_types157.default.number,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `TextArea` component
   */
  slug: deprecate(import_prop_types157.default.node, "The `slug` prop for `TextArea` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Provide the current value of the `<textarea>`
   */
  value: import_prop_types157.default.oneOfType([import_prop_types157.default.string, import_prop_types157.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types157.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types157.default.node
};

// node_modules/@carbon/react/es/components/TextArea/TextArea.Skeleton.js
var import_prop_types158 = __toESM(require_prop_types());
var import_react209 = __toESM(require_react());
var import_classnames136 = __toESM(require_classnames());
var TextAreaSkeleton = (props) => {
  const {
    className,
    hideLabel,
    ...rest
  } = props;
  const prefix = usePrefix();
  return import_react209.default.createElement("div", _extends({
    className: (0, import_classnames136.default)(`${prefix}--form-item`, className)
  }, rest), !hideLabel && import_react209.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react209.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-area`
  }));
};
TextAreaSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types158.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types158.default.bool
};

// node_modules/@carbon/react/es/components/TextInput/TextInput.js
var import_prop_types159 = __toESM(require_prop_types());
var import_react210 = __toESM(require_react());
var import_classnames137 = __toESM(require_classnames());
var TextInput = import_react210.default.forwardRef(function TextInput2({
  className,
  decorator,
  disabled = false,
  helperText,
  hideLabel,
  id,
  inline: inline4 = false,
  invalid = false,
  invalidText,
  labelText,
  light,
  onChange = () => {
  },
  onClick = () => {
  },
  placeholder,
  readOnly,
  size: size4,
  type = "text",
  warn: warn2 = false,
  warnText,
  enableCounter = false,
  maxCount,
  slug,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const {
    defaultValue,
    value
  } = rest;
  const inputRef = (0, import_react210.useRef)(null);
  const mergedRef = useMergedRefs([ref, inputRef]);
  function getInitialTextCount() {
    var _a;
    const targetValue = defaultValue || value || ((_a = inputRef.current) == null ? void 0 : _a.value) || "";
    return targetValue.toString().length;
  }
  const [textCount, setTextCount] = (0, import_react210.useState)(getInitialTextCount());
  (0, import_react210.useEffect)(() => {
    setTextCount(getInitialTextCount());
  }, [value, defaultValue, enableCounter]);
  const normalizedProps = useNormalizedInputProps({
    id,
    readOnly,
    disabled,
    invalid,
    invalidText,
    warn: warn2,
    warnText
  });
  const textInputClasses = (0, import_classnames137.default)(`${prefix}--text-input`, {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--text-input--invalid`]: normalizedProps.invalid,
    [`${prefix}--text-input--warning`]: normalizedProps.warn,
    [`${prefix}--text-input--${size4}`]: size4,
    // TODO: V12 - Remove this class
    [`${prefix}--layout--size-${size4}`]: size4
  });
  const sharedTextInputProps = {
    id,
    onChange: (evt) => {
      var _a;
      if (!normalizedProps.disabled) {
        setTextCount((_a = evt.target.value) == null ? void 0 : _a.length);
        onChange(evt);
      }
    },
    onClick: (evt) => {
      if (!normalizedProps.disabled) {
        onClick(evt);
      }
    },
    placeholder,
    type,
    ref: mergedRef,
    className: textInputClasses,
    title: placeholder,
    disabled: normalizedProps.disabled,
    readOnly,
    ["aria-describedby"]: helperText && normalizedProps.helperId,
    ...rest
  };
  if (enableCounter) {
    sharedTextInputProps.maxLength = maxCount;
  }
  const inputWrapperClasses = (0, import_classnames137.default)([(0, import_classnames137.default)(`${prefix}--form-item`, className)], `${prefix}--text-input-wrapper`, {
    [`${prefix}--text-input-wrapper--readonly`]: readOnly,
    [`${prefix}--text-input-wrapper--light`]: light,
    [`${prefix}--text-input-wrapper--inline`]: inline4,
    [`${prefix}--text-input-wrapper--inline--invalid`]: inline4 && normalizedProps.invalid
  });
  const labelClasses = (0, import_classnames137.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: normalizedProps.disabled,
    [`${prefix}--label--inline`]: inline4,
    [`${prefix}--label--inline--${size4}`]: inline4 && !!size4
  });
  const helperTextClasses = (0, import_classnames137.default)(`${prefix}--form__helper-text`, {
    [`${prefix}--form__helper-text--disabled`]: normalizedProps.disabled,
    [`${prefix}--form__helper-text--inline`]: inline4
  });
  const fieldOuterWrapperClasses = (0, import_classnames137.default)(`${prefix}--text-input__field-outer-wrapper`, {
    [`${prefix}--text-input__field-outer-wrapper--inline`]: inline4
  });
  const fieldWrapperClasses = (0, import_classnames137.default)(`${prefix}--text-input__field-wrapper`, {
    [`${prefix}--text-input__field-wrapper--warning`]: normalizedProps.warn,
    [`${prefix}--text-input__field-wrapper--slug`]: slug,
    [`${prefix}--text-input__field-wrapper--decorator`]: decorator
  });
  const iconClasses = (0, import_classnames137.default)({
    [`${prefix}--text-input__invalid-icon`]: normalizedProps.invalid || normalizedProps.warn,
    [`${prefix}--text-input__invalid-icon--warning`]: normalizedProps.warn
  });
  const counterClasses = (0, import_classnames137.default)(`${prefix}--label`, {
    [`${prefix}--label--disabled`]: disabled,
    [`${prefix}--text-input__label-counter`]: true
  });
  const counter = enableCounter && maxCount ? import_react210.default.createElement(Text, {
    as: "div",
    className: counterClasses
  }, `${textCount}/${maxCount}`) : null;
  const label = labelText ? import_react210.default.createElement(Text, {
    as: "label",
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  const labelWrapper = import_react210.default.createElement("div", {
    className: `${prefix}--text-input__label-wrapper`
  }, label, counter);
  const helper = helperText ? import_react210.default.createElement(Text, {
    as: "div",
    id: normalizedProps.helperId,
    className: helperTextClasses
  }, helperText) : null;
  const input = import_react210.default.createElement("input", textInputProps({
    sharedTextInputProps,
    invalid: normalizedProps.invalid,
    invalidId: normalizedProps.invalidId,
    warn: normalizedProps.warn,
    warnId: normalizedProps.warnId
  }));
  const {
    isFluid
  } = (0, import_react210.useContext)(FormContext);
  const announcerRef = (0, import_react210.useRef)(null);
  const [prevAnnouncement, setPrevAnnouncement] = (0, import_react210.useState)("");
  const ariaAnnouncement = getAnnouncement(textCount, maxCount);
  (0, import_react210.useEffect)(() => {
    if (ariaAnnouncement && ariaAnnouncement !== prevAnnouncement) {
      const announcer = announcerRef.current;
      if (announcer) {
        announcer.textContent = "";
        const timeoutId = setTimeout(() => {
          if (announcer) {
            announcer.textContent = ariaAnnouncement;
            setPrevAnnouncement(ariaAnnouncement);
          }
        }, 1e3);
        return () => {
          if (timeoutId) {
            clearTimeout(timeoutId);
          }
        };
      }
    }
  }, [ariaAnnouncement, prevAnnouncement]);
  const Icon = normalizedProps.icon;
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react210.cloneElement)(candidate, {
    size: "mini"
  }) : null;
  return import_react210.default.createElement("div", {
    className: inputWrapperClasses
  }, !inline4 ? labelWrapper : import_react210.default.createElement("div", {
    className: `${prefix}--text-input__label-helper-wrapper`
  }, labelWrapper, !isFluid && (normalizedProps.validation || helper)), import_react210.default.createElement("div", {
    className: fieldOuterWrapperClasses
  }, import_react210.default.createElement("div", {
    className: fieldWrapperClasses,
    "data-invalid": normalizedProps.invalid || null
  }, Icon && import_react210.default.createElement(Icon, {
    className: iconClasses
  }), input, slug ? normalizedDecorator : decorator ? import_react210.default.createElement("div", {
    className: `${prefix}--text-input__field-inner-wrapper--decorator`
  }, normalizedDecorator) : "", import_react210.default.createElement("span", {
    className: `${prefix}--text-input__counter-alert`,
    role: "alert",
    "aria-live": "assertive",
    "aria-atomic": "true",
    ref: announcerRef
  }, ariaAnnouncement), isFluid && import_react210.default.createElement("hr", {
    className: `${prefix}--text-input__divider`
  }), isFluid && !inline4 && normalizedProps.validation), !isFluid && !inline4 && (normalizedProps.validation || helper)));
});
TextInput.displayName = "TextInput";
TextInput.propTypes = {
  /**
   * Specify an optional className to be applied to the `<input>` node
   */
  className: import_prop_types159.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `TextInput` component
   */
  decorator: import_prop_types159.default.node,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types159.default.oneOfType([import_prop_types159.default.string, import_prop_types159.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types159.default.bool,
  /**
   * Specify whether to display the character counter
   */
  enableCounter: import_prop_types159.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types159.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types159.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types159.default.string.isRequired,
  /**
   * `true` to use the inline version.
   */
  inline: import_prop_types159.default.bool,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types159.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types159.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types159.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types159.default.bool, "The `light` prop for `TextInput` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Max character count allowed for the input. This is needed in order for enableCounter to display
   */
  maxCount: import_prop_types159.default.number,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types159.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types159.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types159.default.string,
  /**
   * Whether the input should be read-only
   */
  readOnly: import_prop_types159.default.bool,
  /**
   * Specify the size of the Text Input. Currently supports the following:
   */
  size: import_prop_types159.default.oneOf(["sm", "md", "lg"]),
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `TextInput` component
   */
  slug: deprecate(import_prop_types159.default.node, "The `slug` prop for `TextInput` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Specify the type of the `<input>`
   */
  type: import_prop_types159.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types159.default.oneOfType([import_prop_types159.default.string, import_prop_types159.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types159.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types159.default.node
};

// node_modules/@carbon/react/es/components/TextInput/TextInput.Skeleton.js
var import_prop_types160 = __toESM(require_prop_types());
var import_react211 = __toESM(require_react());
var import_classnames138 = __toESM(require_classnames());
var TextInputSkeleton = ({
  hideLabel,
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  return import_react211.default.createElement("div", _extends({
    className: (0, import_classnames138.default)(`${prefix}--form-item`, className)
  }, rest), !hideLabel && import_react211.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react211.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  }));
};
TextInputSkeleton.propTypes = {
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types160.default.string,
  /**
   * Specify whether the label should be hidden, or not
   */
  hideLabel: import_prop_types160.default.bool
};

// node_modules/@carbon/react/es/components/Tile/Tile.js
var import_react212 = __toESM(require_react());
var import_prop_types161 = __toESM(require_prop_types());
var import_classnames139 = __toESM(require_classnames());
var _CheckboxCheckedFille;
var _Checkbox;
var _ChevronDown3;
var _ChevronDown22;
var Tile = import_react212.default.forwardRef(function Tile2({
  children,
  className,
  decorator,
  light = false,
  slug,
  hasRoundedCorners = false,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const tileClasses = (0, import_classnames139.default)(`${prefix}--tile`, {
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  return import_react212.default.createElement("div", _extends({
    className: tileClasses,
    ref
  }, rest), children, slug, decorator && import_react212.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, decorator));
});
Tile.displayName = "Tile";
Tile.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types161.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types161.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `Tile` component
   */
  decorator: import_prop_types161.default.node,
  /**
   * **Experimental**: Specify if the `Tile` component should be rendered with rounded corners. Only valid
   * when an AILabel is present
   */
  hasRoundedCorners: import_prop_types161.default.bool,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   *
   * @deprecated
   */
  light: deprecate(import_prop_types161.default.bool, "The `light` prop for `Tile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `Tile` component
   */
  slug: deprecate(import_prop_types161.default.node, "The `slug` prop for `Tile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release.")
};
var ClickableTile = import_react212.default.forwardRef(function ClickableTile2({
  children,
  className,
  clicked = false,
  decorator,
  disabled,
  href,
  light,
  onClick = () => {
  },
  onKeyDown = () => {
  },
  renderIcon: Icon,
  hasRoundedCorners,
  slug,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const classes = (0, import_classnames139.default)(`${prefix}--tile`, `${prefix}--tile--clickable`, {
    [`${prefix}--tile--is-clicked`]: clicked,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  const [isSelected, setIsSelected] = (0, import_react212.useState)(clicked);
  function handleOnClick(evt) {
    var _a;
    (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
    setIsSelected(!isSelected);
    onClick(evt);
  }
  function handleOnKeyDown2(evt) {
    var _a;
    (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
    if (matches(evt, [Enter, Space])) {
      setIsSelected(!isSelected);
    }
    onKeyDown(evt);
  }
  const v12DefaultIcons = useFeatureFlag("enable-v12-tile-default-icons");
  if (v12DefaultIcons) {
    if (!Icon) {
      Icon = ArrowRight;
    }
    if (disabled) {
      Icon = Error2;
    }
  }
  const iconClasses = (0, import_classnames139.default)({
    [`${prefix}--tile--icon`]: !v12DefaultIcons || v12DefaultIcons && !disabled,
    [`${prefix}--tile--disabled-icon`]: v12DefaultIcons && disabled
  });
  return import_react212.default.createElement(Link, _extends({
    className: classes,
    href,
    tabIndex: !href && !disabled ? 0 : void 0,
    onClick: !disabled ? handleOnClick : void 0,
    onKeyDown: handleOnKeyDown2,
    ref,
    disabled
  }, rest), slug || decorator ? import_react212.default.createElement("div", {
    className: `${prefix}--tile-content`
  }, children) : children, (slug === true || decorator === true) && import_react212.default.createElement(AiLabel, {
    size: "24",
    className: `${prefix}--tile--ai-label-icon`
  }), import_react212.default.isValidElement(decorator) && import_react212.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, decorator), Icon && import_react212.default.createElement(Icon, {
    className: iconClasses,
    "aria-hidden": "true"
  }));
});
ClickableTile.displayName = "ClickableTile";
ClickableTile.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types161.default.node,
  /**
   * The CSS class names.
   */
  className: import_prop_types161.default.string,
  /**
   * Boolean for whether a tile has been clicked.
   */
  clicked: import_prop_types161.default.bool,
  /**
   * **Experimental**: Provide a `decorator` component or set the boolean to True for an AILabel icon to be rendered inside the `ClickableTile` component
   */
  decorator: import_prop_types161.default.oneOfType([import_prop_types161.default.bool, import_prop_types161.default.node]),
  /**
   * Specify whether the ClickableTile should be disabled
   */
  disabled: import_prop_types161.default.bool,
  /**
   * **Experimental**: Specify if the `ClickableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types161.default.bool,
  /**
   * The href for the link.
   */
  href: import_prop_types161.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types161.default.bool, "The `light` prop for `ClickableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * Specify the function to run when the ClickableTile is clicked
   */
  onClick: import_prop_types161.default.func,
  /**
   * Specify the function to run when the ClickableTile is interacted with via a keyboard
   */
  onKeyDown: import_prop_types161.default.func,
  /**
   * The rel property for the link.
   */
  rel: import_prop_types161.default.string,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types161.default.oneOfType([import_prop_types161.default.func, import_prop_types161.default.object])
};
var SelectableTile = import_react212.default.forwardRef(function SelectableTile2({
  children,
  className,
  decorator,
  disabled,
  id,
  light,
  onClick = () => {
  },
  onChange = () => {
  },
  onKeyDown = () => {
  },
  selected = false,
  tabIndex = 0,
  title = "title",
  slug,
  hasRoundedCorners,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const clickHandler = onClick;
  const keyDownHandler = onKeyDown;
  const [isSelected, setIsSelected] = (0, import_react212.useState)(selected);
  (0, import_react212.useEffect)(() => {
    setIsSelected(selected);
  }, [selected]);
  const classes = (0, import_classnames139.default)(`${prefix}--tile`, `${prefix}--tile--selectable`, {
    [`${prefix}--tile--is-selected`]: isSelected,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--disabled`]: disabled,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  const handleSelectionChange = (0, import_react212.useCallback)((evt, newSelected) => {
    setIsSelected(newSelected);
    onChange(evt, newSelected, id);
  }, [onChange, id]);
  function handleClick2(evt) {
    var _a;
    evt.preventDefault();
    (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
    if (normalizedDecorator && decoratorRef.current && evt.target instanceof Node && decoratorRef.current.contains(evt.target)) {
      return;
    }
    const newSelected = !isSelected;
    handleSelectionChange(evt, newSelected);
    clickHandler(evt);
  }
  function handleKeyDown(evt) {
    var _a;
    (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
    if (matches(evt, [Enter, Space])) {
      evt.preventDefault();
      const newSelected = !isSelected;
      handleSelectionChange(evt, newSelected);
    }
    keyDownHandler(evt);
  }
  const decoratorRef = (0, import_react212.useRef)(null);
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react212.cloneElement)(candidate, {
    size: "xs",
    ref: decoratorRef
  }) : null;
  return (
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    import_react212.default.createElement("div", _extends({
      className: classes,
      onClick: !disabled ? handleClick2 : void 0,
      role: "checkbox",
      "aria-checked": isSelected,
      onKeyDown: !disabled ? handleKeyDown : void 0,
      tabIndex: !disabled ? tabIndex : void 0,
      ref,
      id,
      title
    }, rest), import_react212.default.createElement("span", {
      className: `${prefix}--tile__checkmark ${prefix}--tile__checkmark--persistent`
    }, isSelected ? _CheckboxCheckedFille || (_CheckboxCheckedFille = import_react212.default.createElement(CheckboxCheckedFilled, null)) : _Checkbox || (_Checkbox = import_react212.default.createElement(Checkbox, null))), import_react212.default.createElement(Text, {
      as: "label",
      htmlFor: id,
      className: `${prefix}--tile-content`
    }, children), slug ? normalizedDecorator : decorator ? import_react212.default.createElement("div", {
      className: `${prefix}--tile--inner-decorator`
    }, normalizedDecorator) : "")
  );
});
SelectableTile.propTypes = {
  children: import_prop_types161.default.node,
  className: import_prop_types161.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `SelectableTile` component
   */
  decorator: import_prop_types161.default.node,
  /**
   * Specify whether the SelectableTile should be disabled
   */
  disabled: import_prop_types161.default.bool,
  /**
   * **Experimental**: Specify if the `SelectableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types161.default.bool,
  /**
   * The ID of the `<input>`.
   */
  id: import_prop_types161.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types161.default.bool, "The `light` prop for `SelectableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * The `name` of the `<input>`.
   * @deprecated
   */
  name: deprecate(import_prop_types161.default.string, "The `name` property is no longer used.  It will be removed in the next major release."),
  /**
   * The empty handler of the `<input>`.
   */
  onChange: import_prop_types161.default.func,
  /**
   * Specify the function to run when the SelectableTile is clicked
   */
  onClick: import_prop_types161.default.func,
  /**
   * Specify the function to run when the SelectableTile is interacted with via a keyboard
   */
  onKeyDown: import_prop_types161.default.func,
  /**
   * `true` to select this tile.
   */
  selected: import_prop_types161.default.bool,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `SelectableTile` component
   */
  slug: deprecate(import_prop_types161.default.node, "The `slug` prop for `SelectableTile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * Specify the tab index of the wrapper element
   */
  tabIndex: import_prop_types161.default.number,
  /**
   * The `title` of the `<input>`.
   */
  title: import_prop_types161.default.string,
  /**
   * The value of the `<input>`.
   * @deprecated
   */
  value: deprecate(import_prop_types161.default.oneOfType([import_prop_types161.default.string, import_prop_types161.default.number]), "The `value` property is no longer used.  It will be removed in the next major release.`")
};
var ExpandableTile = import_react212.default.forwardRef(function ExpandableTile2({
  tabIndex = 0,
  className,
  children,
  decorator,
  expanded = false,
  tileMaxHeight = 0,
  // eslint-disable-line
  tilePadding = 0,
  // eslint-disable-line
  onClick,
  onKeyUp,
  tileCollapsedIconText = "Interact to expand Tile",
  tileExpandedIconText = "Interact to collapse Tile",
  tileCollapsedLabel,
  tileExpandedLabel,
  light,
  slug,
  hasRoundedCorners,
  ...rest
}, forwardRef36) {
  const [isTileMaxHeight, setIsTileMaxHeight] = (0, import_react212.useState)(tileMaxHeight);
  const [isTilePadding, setIsTilePadding] = (0, import_react212.useState)(tilePadding);
  const [prevExpanded, setPrevExpanded] = (0, import_react212.useState)(expanded);
  const [prevTileMaxHeight, setPrevTileMaxHeight] = (0, import_react212.useState)(tileMaxHeight);
  const [prevTilePadding, setPrevTilePadding] = (0, import_react212.useState)(tilePadding);
  const [isExpanded, setIsExpanded] = (0, import_react212.useState)(expanded);
  const [interactive, setInteractive] = (0, import_react212.useState)(true);
  const aboveTheFold = (0, import_react212.useRef)(null);
  const belowTheFold = (0, import_react212.useRef)(null);
  const chevronInteractiveRef = (0, import_react212.useRef)(null);
  const tileContent = (0, import_react212.useRef)(null);
  const tile = (0, import_react212.useRef)(null);
  const ref = useMergedRefs([forwardRef36, tile]);
  const prefix = usePrefix();
  if (expanded !== prevExpanded) {
    setIsExpanded(expanded);
    setPrevExpanded(expanded);
    setMaxHeight();
  }
  if (tileMaxHeight !== prevTileMaxHeight) {
    setIsTileMaxHeight(tileMaxHeight);
    setPrevTileMaxHeight(tileMaxHeight);
  }
  if (tilePadding !== prevTilePadding) {
    setIsTilePadding(tilePadding);
    setPrevTilePadding(tilePadding);
  }
  function setMaxHeight() {
    var _a;
    if (isExpanded && tileContent.current) {
      setIsTileMaxHeight((_a = tileContent.current.getBoundingClientRect()) == null ? void 0 : _a.height);
    }
    if (aboveTheFold.current) {
      setIsTileMaxHeight(aboveTheFold.current.getBoundingClientRect().height);
    }
  }
  function handleClick2(evt) {
    var _a;
    (_a = evt == null ? void 0 : evt.persist) == null ? void 0 : _a.call(evt);
    setIsExpanded(!isExpanded);
    setMaxHeight();
  }
  function handleKeyUp(evt) {
    if (evt.target !== tile.current && evt.target !== chevronInteractiveRef.current) {
      if (matches(evt, [Enter, Space])) {
        evt.preventDefault();
      }
    }
  }
  function getChildren() {
    return import_react212.default.Children.toArray(children);
  }
  const classNames = (0, import_classnames139.default)(`${prefix}--tile`, `${prefix}--tile--expandable`, {
    [`${prefix}--tile--is-expanded`]: isExpanded,
    [`${prefix}--tile--light`]: light
  }, className);
  const interactiveClassNames = (0, import_classnames139.default)(`${prefix}--tile`, `${prefix}--tile--expandable`, `${prefix}--tile--expandable--interactive`, {
    [`${prefix}--tile--is-expanded`]: isExpanded,
    [`${prefix}--tile--light`]: light,
    [`${prefix}--tile--slug`]: slug,
    [`${prefix}--tile--slug-rounded`]: slug && hasRoundedCorners,
    [`${prefix}--tile--decorator`]: decorator,
    [`${prefix}--tile--decorator-rounded`]: decorator && hasRoundedCorners
  }, className);
  const chevronInteractiveClassNames = (0, import_classnames139.default)(`${prefix}--tile__chevron`, `${prefix}--tile__chevron--interactive`);
  const childrenAsArray = getChildren();
  useIsomorphicEffect(() => {
    if (!tile.current || !aboveTheFold.current) {
      return;
    }
    const getStyle = window.getComputedStyle(tile.current, null);
    const {
      current: node
    } = aboveTheFold;
    const {
      height
    } = node.getBoundingClientRect();
    const paddingTop = parseInt(getStyle.getPropertyValue("padding-top"), 10);
    const paddingBottom = parseInt(getStyle.getPropertyValue("padding-bottom"), 10);
    setIsTileMaxHeight(height);
    setIsTilePadding(paddingTop + paddingBottom);
  }, [isTileMaxHeight]);
  useIsomorphicEffect(() => {
    if (!aboveTheFold.current || !belowTheFold.current) {
      return;
    }
    if (!getInteractiveContent(belowTheFold.current) && !getRoleContent(belowTheFold.current) && !getInteractiveContent(aboveTheFold.current) && !getRoleContent(aboveTheFold.current) && !(slug || decorator)) {
      setInteractive(false);
    }
  }, [slug, decorator]);
  useIsomorphicEffect(() => {
    if (!tile.current) {
      return;
    }
    if (isExpanded) {
      tile.current.style.maxHeight = "";
    } else {
      tile.current.style.maxHeight = isTileMaxHeight + isTilePadding + "px";
    }
  }, [isExpanded, isTileMaxHeight, isTilePadding]);
  (0, import_react212.useEffect)(() => {
    if (!aboveTheFold.current) {
      return;
    }
    const resizeObserver = new ResizeObserver((entries) => {
      const [aboveTheFold2] = entries;
      setIsTileMaxHeight(aboveTheFold2.contentRect.height);
    });
    resizeObserver.observe(aboveTheFold.current);
    return () => resizeObserver.disconnect();
  }, []);
  const belowTheFoldId = useId("expandable-tile-interactive");
  const candidate = slug ?? decorator;
  const candidateIsAILabel = isComponentElement(candidate, AILabel);
  const normalizedDecorator = candidateIsAILabel ? (0, import_react212.cloneElement)(candidate, {
    size: "xs"
  }) : null;
  return interactive ? import_react212.default.createElement("div", _extends({
    ref,
    className: interactiveClassNames
  }, rest), import_react212.default.createElement("div", {
    ref: tileContent
  }, slug ? normalizedDecorator : decorator ? import_react212.default.createElement("div", {
    className: `${prefix}--tile--inner-decorator`
  }, normalizedDecorator) : "", import_react212.default.createElement("div", {
    ref: aboveTheFold,
    className: `${prefix}--tile-content`
  }, childrenAsArray[0]), import_react212.default.createElement("button", {
    type: "button",
    "aria-expanded": isExpanded,
    "aria-controls": belowTheFoldId,
    onKeyUp: composeEventHandlers([onKeyUp, handleKeyUp]),
    onClick: composeEventHandlers([onClick, handleClick2]),
    "aria-label": isExpanded ? tileExpandedIconText : tileCollapsedIconText,
    ref: chevronInteractiveRef,
    className: chevronInteractiveClassNames
  }, _ChevronDown3 || (_ChevronDown3 = import_react212.default.createElement(ChevronDown, null))), import_react212.default.createElement("div", {
    ref: belowTheFold,
    className: `${prefix}--tile-content`,
    id: belowTheFoldId
  }, childrenAsArray[1]))) : import_react212.default.createElement("button", _extends({
    type: "button",
    ref,
    className: classNames,
    "aria-expanded": isExpanded,
    title: isExpanded ? tileExpandedIconText : tileCollapsedIconText
  }, rest, {
    onKeyUp: composeEventHandlers([onKeyUp, handleKeyUp]),
    onClick: composeEventHandlers([onClick, handleClick2]),
    tabIndex
  }), import_react212.default.createElement("div", {
    ref: tileContent
  }, import_react212.default.createElement("div", {
    ref: aboveTheFold,
    className: `${prefix}--tile-content`
  }, childrenAsArray[0]), import_react212.default.createElement("div", {
    className: `${prefix}--tile__chevron`
  }, import_react212.default.createElement("span", null, isExpanded ? tileExpandedLabel : tileCollapsedLabel), _ChevronDown22 || (_ChevronDown22 = import_react212.default.createElement(ChevronDown, null))), import_react212.default.createElement("div", {
    ref: belowTheFold,
    className: `${prefix}--tile-content`
  }, childrenAsArray[1])));
});
ExpandableTile.propTypes = {
  children: import_prop_types161.default.node,
  className: import_prop_types161.default.string,
  /**
   * **Experimental**: Provide a `decorator` component to be rendered inside the `ExpandableTile` component
   */
  decorator: import_prop_types161.default.node,
  /**
   * `true` if the tile is expanded.
   */
  expanded: import_prop_types161.default.bool,
  /**
   * Specify if the `ExpandableTile` component should be rendered with rounded corners.
   * Only valid when `slug` prop is present
   */
  hasRoundedCorners: import_prop_types161.default.bool,
  /**
   * An ID that can be provided to aria-labelledby
   */
  id: import_prop_types161.default.string,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types161.default.bool, "The `light` prop for `ExpandableTile` is no longer needed and has been deprecated. It will be removed in the next major release. Use the Layer component instead."),
  /**
   * Specify the function to run when the ExpandableTile is clicked
   */
  onClick: import_prop_types161.default.func,
  /**
   * optional handler to trigger a function when a key is pressed
   */
  onKeyUp: import_prop_types161.default.func,
  /**
   * **Experimental**: Provide a `Slug` component to be rendered inside the `ExpandableTile` component
   */
  slug: deprecate(import_prop_types161.default.node, "The `slug` prop for `ExpandableTile` has been deprecated in favor of the new `decorator` prop. It will be removed in the next major release."),
  /**
   * The `tabindex` attribute.
   */
  tabIndex: import_prop_types161.default.number,
  /**
   * The description of the "collapsed" icon that can be read by screen readers.
   */
  tileCollapsedIconText: import_prop_types161.default.string,
  /**
   * When "collapsed", a label to appear next to the chevron (e.g., "View more").
   */
  tileCollapsedLabel: import_prop_types161.default.string,
  /**
   * The description of the "expanded" icon that can be read by screen readers.
   */
  tileExpandedIconText: import_prop_types161.default.string,
  /**
   * When "expanded", a label to appear next to the chevron (e.g., "View less").
   */
  tileExpandedLabel: import_prop_types161.default.string
};
ExpandableTile.displayName = "ExpandableTile";
var TileAboveTheFoldContent = import_react212.default.forwardRef(function TilAboveTheFoldContent({
  children
}, ref) {
  const prefix = usePrefix();
  return import_react212.default.createElement("div", {
    ref,
    className: `${prefix}--tile-content__above-the-fold`
  }, children);
});
TileAboveTheFoldContent.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types161.default.node
};
TileAboveTheFoldContent.displayName = "TileAboveTheFoldContent";
var TileBelowTheFoldContent = import_react212.default.forwardRef(function TileBelowTheFoldContent2({
  children
}, ref) {
  const prefix = usePrefix();
  return import_react212.default.createElement("div", {
    ref,
    className: `${prefix}--tile-content__below-the-fold`
  }, children);
});
TileBelowTheFoldContent.propTypes = {
  /**
   * The child nodes.
   */
  children: import_prop_types161.default.node
};
TileBelowTheFoldContent.displayName = "TileBelowTheFoldContent";

// node_modules/@carbon/react/es/components/TileGroup/TileGroup.js
var import_prop_types162 = __toESM(require_prop_types());
var import_react213 = __toESM(require_react());
var TileGroup = ({
  children,
  className,
  defaultSelected,
  disabled,
  legend,
  name,
  onChange = noopFn,
  valueSelected,
  required
}) => {
  const prefix = usePrefix();
  const [selected, setSelected] = (0, import_react213.useState)(valueSelected ?? defaultSelected);
  (0, import_react213.useEffect)(() => {
    if (typeof valueSelected !== "undefined" && valueSelected !== selected) {
      setSelected(valueSelected);
    }
  }, [valueSelected, selected]);
  const handleChange = (value, name2, evt) => {
    if (value !== selected) {
      setSelected(value);
      onChange(value, name2 ?? "", evt);
    }
  };
  const getRadioTilesWithWrappers = (elements) => {
    const traverseAndModifyChildren = (elements2) => {
      return import_react213.Children.map(elements2, (child) => {
        if (!(0, import_react213.isValidElement)(child)) return child;
        if ((0, import_react213.isValidElement)(child) && child.type === RadioTile) {
          const {
            value,
            ...otherProps
          } = child.props;
          return import_react213.default.createElement(RadioTile, _extends({}, otherProps, {
            required,
            name,
            key: value,
            value,
            onChange: handleChange,
            checked: value === selected
          }));
        }
        const children2 = child.props.children;
        const hasChildren = import_react213.Children.count(children2) > 0;
        if (hasChildren) {
          return (0, import_react213.cloneElement)(child, void 0, traverseAndModifyChildren(children2));
        }
        return child;
      });
    };
    return import_react213.default.createElement(import_react213.default.Fragment, null, traverseAndModifyChildren(elements));
  };
  return import_react213.default.createElement("fieldset", {
    className: className ?? `${prefix}--tile-group`,
    disabled
  }, legend && import_react213.default.createElement("legend", {
    className: `${prefix}--label`
  }, legend), import_react213.default.createElement("div", null, getRadioTilesWithWrappers(children)));
};
TileGroup.displayName = "TileGroup";
TileGroup.propTypes = {
  /**
   * Provide a collection of <RadioTile> components to render in the group
   */
  children: import_prop_types162.default.node,
  /**
   * Provide an optional className to be applied to the container node
   */
  className: import_prop_types162.default.string,
  /**
   * Specify the the value of <RadioTile> to be selected by default
   */
  defaultSelected: import_prop_types162.default.oneOfType([import_prop_types162.default.string, import_prop_types162.default.number]),
  /**
   * Specify whether the group is disabled
   */
  disabled: import_prop_types162.default.bool,
  /**
   * Provide an optional legend for this group
   */
  legend: import_prop_types162.default.string,
  /**
   * Specify the name of the underlying `<input>` nodes
   */
  name: import_prop_types162.default.string.isRequired,
  /**
   * Provide an optional `onChange` hook that is called whenever the value of
   * the group changes
   */
  onChange: import_prop_types162.default.func,
  /**
   * `true` to specify if input selection in group is required.
   */
  required: import_prop_types162.default.bool,
  /**
   * Specify the value that is currently selected in the group
   */
  valueSelected: import_prop_types162.default.oneOfType([import_prop_types162.default.string, import_prop_types162.default.number])
};

// node_modules/@carbon/react/es/components/TimePicker/TimePicker.js
var import_classnames140 = __toESM(require_classnames());
var import_prop_types163 = __toESM(require_prop_types());
var import_react214 = __toESM(require_react());
var frFn8 = import_react214.forwardRef;
var TimePicker = frFn8((props, ref) => {
  const {
    children,
    className,
    inputClassName,
    pickerClassName,
    disabled = false,
    hideLabel,
    id,
    invalidText = "Invalid time format.",
    invalid = false,
    warningText = "Warning message.",
    warning: warning2 = false,
    labelText,
    light = false,
    maxLength = 5,
    onChange = () => {
    },
    onClick = () => {
    },
    onBlur = () => {
    },
    pattern = "(1[012]|[1-9]):[0-5][0-9](\\s)?",
    placeholder = "hh:mm",
    readOnly,
    size: size4 = "md",
    type = "text",
    value,
    ...rest
  } = props;
  const prefix = usePrefix();
  const [isValue, setValue] = import_react214.default.useState(value);
  const [prevValue, setPrevValue] = import_react214.default.useState(value);
  if (value !== prevValue) {
    setValue(value);
    setPrevValue(value);
  }
  function handleOnClick(evt) {
    if (!disabled) {
      if (!readOnly) {
        setValue(isValue);
      }
      onClick(evt);
    }
  }
  function handleOnChange(evt) {
    if (!disabled && !readOnly) {
      setValue(isValue);
      onChange(evt);
    }
  }
  function handleOnBlur(evt) {
    if (!disabled) {
      if (!readOnly) {
        setValue(isValue);
      }
      onBlur(evt);
    }
  }
  const timePickerInputClasses = (0, import_classnames140.default)(`${prefix}--time-picker__input-field`, `${prefix}--text-input`, [inputClassName], {
    [`${prefix}--text-input--light`]: light,
    [`${prefix}--time-picker__input-field-error`]: invalid || warning2
  });
  const timePickerClasses = (0, import_classnames140.default)({
    [`${prefix}--time-picker`]: true,
    [`${prefix}--time-picker--light`]: light,
    [`${prefix}--time-picker--invalid`]: invalid,
    [`${prefix}--time-picker--warning`]: warning2,
    [`${prefix}--time-picker--readonly`]: readOnly,
    [`${prefix}--time-picker--${size4}`]: size4,
    ...pickerClassName && {
      [pickerClassName]: true
    }
  });
  const labelClasses = (0, import_classnames140.default)(`${prefix}--label`, {
    [`${prefix}--visually-hidden`]: hideLabel,
    [`${prefix}--label--disabled`]: disabled
  });
  const label = labelText ? import_react214.default.createElement("label", {
    htmlFor: id,
    className: labelClasses
  }, labelText) : null;
  function getInternalPickerSelects() {
    const readOnlyEventHandlers = {
      onMouseDown: (evt) => {
        if (readOnly) {
          evt.preventDefault();
          evt.target.focus();
        }
      },
      onKeyDown: (evt) => {
        const selectAccessKeys = ["ArrowDown", "ArrowUp", " "];
        if (readOnly && selectAccessKeys.includes(evt.key)) {
          evt.preventDefault();
        }
      }
    };
    const mappedChildren = import_react214.default.Children.map(children, (pickerSelect) => {
      const item = pickerSelect;
      if (item) {
        return import_react214.default.cloneElement(item, {
          ...item.props,
          disabled: item.props.disabled ?? disabled,
          readOnly,
          ...readOnlyEventHandlers
        });
      }
    });
    return mappedChildren;
  }
  const readOnlyProps = {
    readOnly
  };
  return import_react214.default.createElement("div", {
    className: (0, import_classnames140.default)(`${prefix}--form-item`, className)
  }, label, import_react214.default.createElement("div", {
    className: timePickerClasses
  }, import_react214.default.createElement("div", {
    className: `${prefix}--time-picker__input`
  }, import_react214.default.createElement("input", _extends({
    className: timePickerInputClasses,
    "data-invalid": invalid ? invalid : void 0,
    disabled,
    id,
    maxLength,
    onClick: handleOnClick,
    onChange: handleOnChange,
    onBlur: handleOnBlur,
    placeholder,
    pattern,
    ref,
    type,
    value
  }, rest, readOnlyProps)), (invalid || warning2) && import_react214.default.createElement("div", {
    className: `${prefix}--time-picker__error__icon`
  }, invalid ? import_react214.default.createElement(WarningFilled, {
    className: `${prefix}--checkbox__invalid-icon`,
    size: 16
  }) : import_react214.default.createElement(WarningAltFilled, {
    className: `${prefix}--text-input__invalid-icon--warning`,
    size: 16
  }))), getInternalPickerSelects()), (invalid || warning2) && import_react214.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, invalid ? invalidText : warningText));
});
TimePicker.propTypes = {
  /**
   * Pass in the children that will be rendered next to the form control
   */
  children: import_prop_types163.default.node,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types163.default.string,
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types163.default.bool,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types163.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types163.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types163.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types163.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types163.default.node,
  /**
   * The `light` prop for `TimePicker` has been deprecated. It will be removed in v12. Use the `Layer` component instead.
   */
  light: deprecate(import_prop_types163.default.bool, "The `light` prop for `TimePicker` is no longer needed and has been deprecated. It will be removed in the next major release. Use the `Layer` component instead."),
  /**
   * Specify the maximum length of the time string in `<input>`
   */
  maxLength: import_prop_types163.default.number,
  /**
   * Optionally provide an `onBlur` handler that is called whenever the
   * `<input>` loses focus
   */
  onBlur: import_prop_types163.default.func,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types163.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types163.default.func,
  /**
   * Specify the regular expression working as the pattern of the time string in `<input>`
   */
  pattern: import_prop_types163.default.string,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types163.default.string,
  /**
   * Specify whether the TimePicker should be read-only
   */
  readOnly: import_prop_types163.default.bool,
  /**
   * Specify the size of the Time Picker.
   */
  size: import_prop_types163.default.oneOf(["sm", "md", "lg"]),
  /**
   * Specify the type of the `<input>`
   */
  type: import_prop_types163.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types163.default.string,
  /**
   * Specify a warning message
   */
  warning: import_prop_types163.default.bool,
  /**
   * Provide the text that is displayed when the control is in an warning state
   */
  warningText: import_prop_types163.default.node
};

// node_modules/@carbon/react/es/components/TimePickerSelect/TimePickerSelect.js
var import_classnames141 = __toESM(require_classnames());
var import_prop_types164 = __toESM(require_prop_types());
var import_react215 = __toESM(require_react());
var frFn9 = import_react215.forwardRef;
var TimePickerSelect = frFn9((props, ref) => {
  const {
    ["aria-label"]: ariaLabel = "open list of options",
    children,
    id,
    disabled = false,
    className,
    ...rest
  } = props;
  const prefix = usePrefix();
  const selectClasses = (0, import_classnames141.default)({
    [`${prefix}--select`]: true,
    [`${prefix}--time-picker__select`]: true,
    ...className && {
      [className]: true
    }
  });
  return import_react215.default.createElement("div", {
    className: selectClasses
  }, import_react215.default.createElement("select", _extends({
    "aria-label": ariaLabel,
    className: `${prefix}--select-input`,
    disabled,
    id,
    ref
  }, rest), children), import_react215.default.createElement(ChevronDown, {
    className: `${prefix}--select__arrow`,
    "aria-hidden": "true"
  }));
});
TimePickerSelect.propTypes = {
  /**
   * Provide the contents of your TimePickerSelect
   */
  children: import_prop_types164.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types164.default.string,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types164.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types164.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types164.default.string.isRequired
};

// node_modules/@carbon/react/es/components/Toggle/Toggle.js
var import_react216 = __toESM(require_react());
var import_prop_types165 = __toESM(require_prop_types());
var import_classnames142 = __toESM(require_classnames());
var _path13;
function Toggle({
  "aria-labelledby": ariaLabelledby,
  className,
  defaultToggled = false,
  disabled = false,
  hideLabel = false,
  id,
  labelA = "Off",
  labelB = "On",
  labelText,
  onClick,
  onToggle,
  readOnly,
  size: size4 = "md",
  toggled,
  ...other
}) {
  const prefix = usePrefix();
  const buttonElement = (0, import_react216.useRef)(null);
  const [checked, setChecked] = useControllableState({
    value: toggled,
    onChange: onToggle,
    defaultValue: defaultToggled
  });
  function handleClick2(e2) {
    if (!readOnly) {
      setChecked(!checked);
    }
    if (onClick) {
      onClick(e2);
    }
  }
  const isSm = size4 === "sm";
  const sideLabel = hideLabel ? labelText : checked ? labelB : labelA;
  const renderSideLabel = !(hideLabel && !labelText);
  const LabelComponent = labelText ? "label" : "div";
  const wrapperClasses = (0, import_classnames142.default)(`${prefix}--toggle`, {
    [`${prefix}--toggle--disabled`]: disabled,
    [`${prefix}--toggle--readonly`]: readOnly
  }, className);
  const labelTextClasses = (0, import_classnames142.default)(`${prefix}--toggle__label-text`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  const appearanceClasses = (0, import_classnames142.default)(`${prefix}--toggle__appearance`, {
    [`${prefix}--toggle__appearance--sm`]: isSm
  });
  const switchClasses = (0, import_classnames142.default)(`${prefix}--toggle__switch`, {
    [`${prefix}--toggle__switch--checked`]: checked
  });
  const labelId = `${id}_label`;
  return (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
    import_react216.default.createElement("div", {
      className: wrapperClasses,
      onClick: !labelText ? (e2) => {
        if (buttonElement.current && e2.target !== buttonElement.current && !disabled) {
          handleClick2(e2);
          buttonElement.current.focus();
        }
      } : void 0
    }, import_react216.default.createElement("button", _extends({}, other, {
      ref: buttonElement,
      id,
      className: `${prefix}--toggle__button`,
      role: "switch",
      type: "button",
      "aria-checked": checked,
      "aria-labelledby": ariaLabelledby ?? (labelText ? labelId : void 0),
      disabled,
      onClick: handleClick2
    })), import_react216.default.createElement(LabelComponent, {
      id: labelId,
      htmlFor: ariaLabelledby ? void 0 : id,
      className: `${prefix}--toggle__label`
    }, labelText && import_react216.default.createElement(Text, {
      className: labelTextClasses
    }, labelText), import_react216.default.createElement("div", {
      className: appearanceClasses
    }, import_react216.default.createElement("div", {
      className: switchClasses
    }, isSm && import_react216.default.createElement("svg", {
      "aria-hidden": "true",
      focusable: "false",
      className: `${prefix}--toggle__check`,
      width: "6px",
      height: "5px",
      viewBox: "0 0 6 5"
    }, _path13 || (_path13 = import_react216.default.createElement("path", {
      d: "M2.2 2.7L5 0 6 1 2.2 5 0 2.7 1 1.5z"
    })))), renderSideLabel && import_react216.default.createElement(Text, {
      className: `${prefix}--toggle__text`,
      "aria-hidden": "true"
    }, sideLabel))))
  );
}
Toggle.propTypes = {
  /**
   * Specify another element's id to be used as the label for this toggle
   */
  "aria-labelledby": import_prop_types165.default.string,
  /**
   * Specify a custom className to apply to the form-item node
   */
  className: import_prop_types165.default.string,
  /**
   * Specify whether the toggle should be on by default
   */
  defaultToggled: import_prop_types165.default.bool,
  /**
   * Whether this control should be disabled
   */
  disabled: import_prop_types165.default.bool,
  /**
   * If true, the side labels (props.labelA and props.labelB) will be replaced by
   * props.labelText (if passed), so that the toggle doesn't render a top label.
   */
  hideLabel: import_prop_types165.default.bool,
  /**
   * Provide an id that unique represents the underlying `<button>`
   */
  id: import_prop_types165.default.string.isRequired,
  /**
   * Specify the label for the "off" position
   */
  labelA: import_prop_types165.default.node,
  /**
   * Specify the label for the "on" position
   */
  labelB: import_prop_types165.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control. This should be provided unless 'aria-labelledby' is set instead
   * or you use an external <label> element with its "for" attribute set to the
   * toggle's id.
   */
  labelText: import_prop_types165.default.string,
  /**
   * Provide an event listener that is called when the control is clicked
   */
  onClick: import_prop_types165.default.func,
  /**
   * Provide an event listener that is called when the control is toggled
   */
  onToggle: import_prop_types165.default.func,
  /**
   * Whether the toggle should be read-only
   */
  readOnly: import_prop_types165.default.bool,
  /**
   * Specify the size of the Toggle. Currently only supports 'sm' or 'md' (default)
   */
  size: import_prop_types165.default.oneOf(["sm", "md"]),
  /**
   * Specify whether the control is toggled
   */
  toggled: import_prop_types165.default.bool
};

// node_modules/@carbon/react/es/components/Toggle/Toggle.Skeleton.js
var import_prop_types166 = __toESM(require_prop_types());
var import_react217 = __toESM(require_react());
var import_classnames143 = __toESM(require_classnames());
var ToggleSkeleton = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const skeletonClassNames = (0, import_classnames143.default)(`${prefix}--toggle ${prefix}--toggle--skeleton`, className);
  return import_react217.default.createElement("div", _extends({
    className: skeletonClassNames
  }, rest), import_react217.default.createElement("div", {
    className: `${prefix}--toggle__skeleton-circle`
  }), import_react217.default.createElement("div", {
    className: `${prefix}--toggle__skeleton-rectangle`
  }));
};
ToggleSkeleton.propTypes = {
  "aria-label": import_prop_types166.default.string,
  className: import_prop_types166.default.string
};

// node_modules/@carbon/react/es/components/ToggleSmall/ToggleSmall.Skeleton.js
var import_prop_types167 = __toESM(require_prop_types());
var import_react218 = __toESM(require_react());
var import_classnames144 = __toESM(require_classnames());
var _path14;
var ToggleSmallSkeleton = ({
  id,
  labelText,
  className,
  ...rest
}) => {
  const prefix = (0, import_react218.useContext)(PrefixContext);
  return import_react218.default.createElement("div", _extends({
    className: (0, import_classnames144.default)(`${prefix}--form-item`, className)
  }, rest), import_react218.default.createElement("input", {
    type: "checkbox",
    id,
    className: `${prefix}--toggle ${prefix}--toggle--small ${prefix}--skeleton`
  }), import_react218.default.createElement("label", {
    className: `${prefix}--toggle__label ${prefix}--skeleton`,
    htmlFor: id
  }, labelText && import_react218.default.createElement("span", {
    className: `${prefix}--toggle__label-text`
  }, labelText), import_react218.default.createElement("span", {
    className: `${prefix}--toggle__appearance`
  }, import_react218.default.createElement("svg", {
    className: `${prefix}--toggle__check`,
    width: "6px",
    height: "5px",
    viewBox: "0 0 6 5"
  }, _path14 || (_path14 = import_react218.default.createElement("path", {
    d: "M2.2403 2.7299L4.9245 0 6 1.1117 2.2384 5 0 2.6863 1.0612 1.511z"
  }))))));
};
ToggleSmallSkeleton.propTypes = {
  ["aria-label"]: import_prop_types167.default.string.isRequired,
  /**
   * Specify an optional className to add to the form item wrapper.
   */
  className: import_prop_types167.default.string,
  /**
   * Provide an id that unique represents the underlying `<input>`
   */
  id: import_prop_types167.default.string,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control. `aria-label` is always required but will be `null` if `labelText`
   * is also provided.
   */
  labelText: import_prop_types167.default.string
};

// node_modules/@carbon/react/es/components/TreeView/TreeNode.js
var import_classnames145 = __toESM(require_classnames());
var import_prop_types168 = __toESM(require_prop_types());
var import_react220 = __toESM(require_react());

// node_modules/@carbon/react/es/components/TreeView/TreeContext.js
var import_react219 = __toESM(require_react());
var TreeContext = (0, import_react219.createContext)(null);
var DepthContext = (0, import_react219.createContext)(-1);

// node_modules/@carbon/react/es/components/TreeView/TreeNode.js
var extractTextContent = (node) => {
  if (node === null || node === void 0) return "";
  if (typeof node === "string") return node;
  if (typeof node === "number") return String(node);
  if (typeof node === "boolean") return String(node);
  if (Array.isArray(node)) {
    return node.map(extractTextContent).join("");
  }
  if (import_react220.default.isValidElement(node)) {
    const element = node;
    const children = element.props.children;
    return extractTextContent(children);
  }
  return "";
};
var useEllipsisCheck = (label, detailsWrapperRef) => {
  const [isEllipsisApplied, setIsEllipsisApplied] = (0, import_react220.useState)(false);
  const labelTextRef = (0, import_react220.useRef)(null);
  const checkEllipsis = (0, import_react220.useCallback)(() => {
    const element = labelTextRef.current;
    if (!element) {
      setIsEllipsisApplied(false);
      return;
    }
    if (element.offsetWidth === 0) {
      setIsEllipsisApplied(false);
      return;
    }
    const checkElement = detailsWrapperRef.current || element;
    if (checkElement && checkElement.offsetWidth > 0) {
      const isTextTruncated = element.scrollWidth > checkElement.offsetWidth;
      setIsEllipsisApplied(isTextTruncated);
    } else {
      setIsEllipsisApplied(false);
    }
  }, [detailsWrapperRef]);
  (0, import_react220.useEffect)(() => {
    let animationFrameId;
    animationFrameId = requestAnimationFrame(checkEllipsis);
    let resizeObserver;
    if (typeof window !== "undefined" && typeof window.ResizeObserver !== "undefined" && labelTextRef.current) {
      resizeObserver = new window.ResizeObserver(() => {
        requestAnimationFrame(checkEllipsis);
      });
      resizeObserver.observe(labelTextRef.current);
      if (detailsWrapperRef.current) {
        resizeObserver.observe(detailsWrapperRef.current);
      }
    }
    return () => {
      cancelAnimationFrame(animationFrameId);
      if (resizeObserver) {
        if (labelTextRef.current) {
          resizeObserver.unobserve(labelTextRef.current);
        }
        if (detailsWrapperRef.current) {
          resizeObserver.unobserve(detailsWrapperRef.current);
        }
        resizeObserver.disconnect();
      }
    };
  }, [checkEllipsis, detailsWrapperRef]);
  return {
    labelTextRef,
    isEllipsisApplied,
    tooltipText: extractTextContent(label)
  };
};
var TreeNode = import_react220.default.forwardRef(({
  children,
  className,
  disabled,
  id: nodeId,
  isExpanded,
  defaultIsExpanded,
  label,
  onSelect: onNodeSelect,
  onToggle,
  renderIcon: Icon,
  value,
  href,
  align = "bottom",
  autoAlign = false,
  // These props are fallback props if the TreeContext is not available or only TreeNode is used as a standalone component
  active: propActive,
  depth: propDepth,
  selected: propSelected,
  onTreeSelect: propOnTreeSelect,
  onNodeFocusEvent,
  ...rest
}, forwardedRef) => {
  const treeContext = (0, import_react220.useContext)(TreeContext);
  const contextDepth = (0, import_react220.useContext)(DepthContext);
  const depth = propDepth ?? (contextDepth !== -1 ? contextDepth : 0);
  const active = propActive ?? (treeContext == null ? void 0 : treeContext.active);
  const selected = propSelected ?? (treeContext == null ? void 0 : treeContext.selected) ?? [];
  const onTreeSelect = propOnTreeSelect ?? (treeContext == null ? void 0 : treeContext.onTreeSelect);
  const detailsWrapperRef = (0, import_react220.useRef)(null);
  const {
    labelTextRef,
    isEllipsisApplied,
    tooltipText
  } = useEllipsisCheck(label, detailsWrapperRef);
  const enableTreeviewControllable = useFeatureFlag("enable-treeview-controllable");
  const {
    current: id
  } = (0, import_react220.useRef)(nodeId || useId());
  const controllableExpandedState = useControllableState({
    value: isExpanded,
    onChange: onToggle,
    defaultValue: defaultIsExpanded ?? false
  });
  const uncontrollableExpandedState = (0, import_react220.useState)(isExpanded ?? false);
  const [expanded, setExpanded] = enableTreeviewControllable ? controllableExpandedState : uncontrollableExpandedState;
  const currentNode = (0, import_react220.useRef)(null);
  const currentNodeLabel = (0, import_react220.useRef)(null);
  const prefix = usePrefix();
  const renderLabelText = () => {
    if (isEllipsisApplied && tooltipText) {
      return import_react220.default.createElement(IconButton, {
        label: tooltipText,
        kind: "ghost",
        align,
        autoAlign,
        className: `${prefix}--tree-node__label__text-button`,
        wrapperClasses: `${prefix}--popover-container`
      }, import_react220.default.createElement("span", {
        ref: labelTextRef,
        className: `${prefix}--tree-node__label__text`
      }, label));
    }
    return import_react220.default.createElement("span", {
      ref: labelTextRef,
      className: `${prefix}--tree-node__label__text`
    }, label);
  };
  const setRefs = (element) => {
    currentNode.current = element;
    if (typeof forwardedRef === "function") {
      forwardedRef(element);
    } else if (forwardedRef) {
      forwardedRef.current = element;
    }
  };
  const isActive = active === id;
  const isSelected = (selected == null ? void 0 : selected.includes(id)) ?? false;
  const treeNodeClasses = (0, import_classnames145.default)(className, `${prefix}--tree-node`, {
    [`${prefix}--tree-node--active`]: isActive,
    [`${prefix}--tree-node--disabled`]: disabled,
    [`${prefix}--tree-node--selected`]: isSelected,
    [`${prefix}--tree-node--with-icon`]: Icon,
    [`${prefix}--tree-leaf-node`]: !children,
    [`${prefix}--tree-parent-node`]: children
  });
  const toggleClasses = (0, import_classnames145.default)(`${prefix}--tree-parent-node__toggle-icon`, {
    [`${prefix}--tree-parent-node__toggle-icon--expanded`]: expanded
  });
  function handleToggleClick(event) {
    if (disabled) {
      return;
    }
    event.stopPropagation();
    if (href) {
      event.preventDefault();
    }
    if (!enableTreeviewControllable) {
      onToggle == null ? void 0 : onToggle(event, {
        id,
        isExpanded: !expanded,
        label,
        value
      });
    }
    setExpanded(!expanded);
  }
  function handleClick2(event) {
    var _a;
    event.stopPropagation();
    if (!disabled) {
      onTreeSelect == null ? void 0 : onTreeSelect(event, {
        id,
        label,
        value
      });
      onNodeSelect == null ? void 0 : onNodeSelect(event, {
        id,
        label,
        value
      });
      (_a = rest == null ? void 0 : rest.onClick) == null ? void 0 : _a.call(rest, event);
    }
  }
  function handleKeyDown(event) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    function getFocusableNode(node) {
      if (node == null ? void 0 : node.classList.contains(`${prefix}--tree-node`)) {
        return node;
      }
      return node == null ? void 0 : node.firstChild;
    }
    if (disabled) {
      return;
    }
    if (matches(event, [ArrowLeft, ArrowRight2, Enter])) {
      event.stopPropagation();
    }
    if (match(event, ArrowLeft)) {
      const findParentTreeNode = (node) => {
        if (!node) return null;
        if (node.classList.contains(`${prefix}--tree-parent-node`)) {
          return node;
        }
        if (node.classList.contains(`${prefix}--tree-node-link-parent`)) {
          return node.firstChild;
        }
        if (node.classList.contains(`${prefix}--tree`)) {
          return null;
        }
        return findParentTreeNode(node.parentElement);
      };
      if (children && expanded) {
        if (!enableTreeviewControllable) {
          onToggle == null ? void 0 : onToggle(event, {
            id,
            isExpanded: false,
            label,
            value
          });
        }
        setExpanded(false);
      } else {
        const parentNode = findParentTreeNode(href ? (_b = (_a = currentNode.current) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.parentElement : (_c = currentNode.current) == null ? void 0 : _c.parentElement);
        if (parentNode instanceof HTMLElement) {
          parentNode.focus();
        }
      }
    }
    if (children && match(event, ArrowRight2)) {
      if (expanded) {
        (_i = getFocusableNode(href ? (_f = (_e = (_d = currentNode.current) == null ? void 0 : _d.parentElement) == null ? void 0 : _e.lastChild) == null ? void 0 : _f.firstChild : (_h = (_g = currentNode.current) == null ? void 0 : _g.lastChild) == null ? void 0 : _h.firstChild)) == null ? void 0 : _i.focus();
      } else {
        if (!enableTreeviewControllable) {
          onToggle == null ? void 0 : onToggle(event, {
            id,
            isExpanded: true,
            label,
            value
          });
        }
        setExpanded(true);
      }
    }
    if (matches(event, [Enter, Space])) {
      event.preventDefault();
      if (match(event, Enter) && children) {
        if (!enableTreeviewControllable) {
          onToggle == null ? void 0 : onToggle(event, {
            id,
            isExpanded: !expanded,
            label,
            value
          });
        }
        setExpanded(!expanded);
      }
      if (href) {
        (_j = currentNode.current) == null ? void 0 : _j.click();
      }
      handleClick2(event);
    }
    (_k = rest == null ? void 0 : rest.onKeyDown) == null ? void 0 : _k.call(rest, event);
  }
  function handleFocusEvent(event) {
    var _a, _b;
    if (event.type === "focus") {
      (_a = rest == null ? void 0 : rest.onFocus) == null ? void 0 : _a.call(rest, event);
    }
    if (event.type === "blur") {
      (_b = rest == null ? void 0 : rest.onBlur) == null ? void 0 : _b.call(rest, event);
    }
    onNodeFocusEvent == null ? void 0 : onNodeFocusEvent(event);
  }
  (0, import_react220.useEffect)(() => {
    const calcOffset = () => {
      if (children && Icon) {
        return depth + 1 + depth * 0.5;
      }
      if (children) {
        return depth + 1;
      }
      if (Icon) {
        return depth + 2 + depth * 0.5;
      }
      return depth + 2.5;
    };
    if (currentNodeLabel.current) {
      currentNodeLabel.current.style.marginInlineStart = `-${calcOffset()}rem`;
      currentNodeLabel.current.style.paddingInlineStart = `${calcOffset()}rem`;
    }
    if (!enableTreeviewControllable) {
      setExpanded(isExpanded ?? false);
    }
  }, [children, depth, Icon, isExpanded, enableTreeviewControllable, setExpanded]);
  const tabIndex = disabled ? void 0 : rest.tabIndex ?? -1;
  const treeNodeProps = {
    ...rest,
    ["aria-current"]: !href ? isActive || void 0 : isActive ? "page" : void 0,
    ["aria-selected"]: !href ? disabled ? void 0 : isSelected : void 0,
    ["aria-disabled"]: disabled,
    ["aria-owns"]: children ? `${id}-subtree` : void 0,
    className: treeNodeClasses,
    id,
    onClick: handleClick2,
    onKeyDown: handleKeyDown,
    role: "treeitem",
    tabIndex,
    onFocus: handleFocusEvent,
    onBlur: handleFocusEvent
  };
  const nodeContent = import_react220.default.createElement("div", {
    className: `${prefix}--tree-node__label`,
    ref: currentNodeLabel
  }, children && import_react220.default.createElement("span", {
    className: `${prefix}--tree-parent-node__toggle`,
    onClick: handleToggleClick
  }, import_react220.default.createElement(CaretDown, {
    className: toggleClasses
  })), import_react220.default.createElement("span", {
    className: `${prefix}--tree-node__label__details`
  }, Icon && import_react220.default.createElement(Icon, {
    className: `${prefix}--tree-node__icon`
  }), renderLabelText()));
  if (href) {
    return import_react220.default.createElement("li", {
      role: "none",
      className: children ? `${prefix}--tree-node-link-parent` : ""
    }, import_react220.default.createElement("a", _extends({}, treeNodeProps, {
      "aria-expanded": !!expanded,
      ref: setRefs,
      href: !disabled ? href : void 0
    }), nodeContent), children && import_react220.default.createElement("ul", {
      id: `${id}-subtree`,
      role: "group",
      className: (0, import_classnames145.default)(`${prefix}--tree-node__children`, {
        [`${prefix}--tree-node--hidden`]: !expanded
      })
    }, import_react220.default.createElement(DepthContext.Provider, {
      value: depth + 1
    }, children)));
  }
  return import_react220.default.createElement("li", _extends({}, treeNodeProps, {
    "aria-expanded": children ? !!expanded : void 0,
    ref: setRefs
  }), nodeContent, children && import_react220.default.createElement("ul", {
    id: `${id}-subtree`,
    role: "group",
    className: (0, import_classnames145.default)(`${prefix}--tree-node__children`, {
      [`${prefix}--tree-node--hidden`]: !expanded
    })
  }, import_react220.default.createElement(DepthContext.Provider, {
    value: depth + 1
  }, children)));
});
TreeNode.propTypes = {
  /**
   * **Note:** this is controlled by the parent TreeView component, do not set manually.
   * The ID of the active node in the tree
   */
  active: import_prop_types168.default.oneOfType([import_prop_types168.default.string, import_prop_types168.default.number]),
  /**
   * Specify the children of the TreeNode
   */
  children: import_prop_types168.default.node,
  /**
   * Specify an optional className to be applied to the TreeNode
   */
  className: import_prop_types168.default.string,
  /**
   * **[Experimental]** The default expansion state of the node.
   * *This is only supported with the `enable-treeview-controllable` feature flag!*
   */
  defaultIsExpanded: import_prop_types168.default.bool,
  /**
   * **Note:** this is controlled by the parent TreeView component, do not set manually.
   * TreeNode depth to determine spacing
   */
  depth: import_prop_types168.default.number,
  /**
   * Specify if the TreeNode is disabled
   */
  disabled: import_prop_types168.default.bool,
  /**
   * Specify the TreeNode's ID. Must be unique in the DOM and is used for props.active, props.selected and aria-owns
   */
  id: import_prop_types168.default.string,
  /**
   * Specify if the TreeNode is expanded (only applicable to parent nodes)
   */
  isExpanded: import_prop_types168.default.bool,
  /**
   * Rendered label for the TreeNode
   */
  label: import_prop_types168.default.node,
  /**
   * Callback function for when the node receives or loses focus
   */
  onNodeFocusEvent: import_prop_types168.default.func,
  /**
   * Callback function for when the node is selected
   */
  onSelect: import_prop_types168.default.func,
  /**
   * Callback function for when a parent node is expanded or collapsed
   */
  onToggle: import_prop_types168.default.func,
  /**
   * Callback function for when any node in the tree is selected
   */
  onTreeSelect: import_prop_types168.default.func,
  /**
   * A component used to render an icon.
   */
  // @ts-ignore
  renderIcon: import_prop_types168.default.oneOfType([import_prop_types168.default.func, import_prop_types168.default.object]),
  /**
   * **Note:** this is controlled by the parent TreeView component, do not set manually.
   * Array containing all selected node IDs in the tree
   */
  // @ts-ignore
  selected: import_prop_types168.default.arrayOf(import_prop_types168.default.oneOfType([import_prop_types168.default.string, import_prop_types168.default.number])),
  /**
   * Specify the value of the TreeNode
   */
  value: import_prop_types168.default.string,
  /**
   * Optional: The URL the TreeNode is linking to
   */
  href: import_prop_types168.default.string,
  /**
   * Specify how the tooltip should align when text is truncated
   */
  align: import_prop_types168.default.oneOf(["top", "bottom", "left", "right", "top-start", "top-end", "bottom-start", "bottom-end", "left-end", "left-start", "right-end", "right-start"]),
  /**
   * **Experimental**: Will attempt to automatically align the floating
   * element to avoid collisions with the viewport and being clipped by
   * ancestor elements. Requires React v17+
   * @see https://github.com/carbon-design-system/carbon/issues/18714
   */
  autoAlign: import_prop_types168.default.bool
};
TreeNode.displayName = "TreeNode";

// node_modules/@carbon/react/es/components/TreeView/TreeView.js
var import_classnames146 = __toESM(require_classnames());
var import_prop_types169 = __toESM(require_prop_types());
var import_react221 = __toESM(require_react());
var TreeView = ({
  active: prespecifiedActive,
  children,
  className,
  hideLabel = false,
  label,
  multiselect = false,
  onActivate,
  onSelect,
  selected: preselected,
  size: size4 = "sm",
  ...rest
}) => {
  const enableTreeviewControllable = useFeatureFlag("enable-treeview-controllable");
  const {
    current: treeId
  } = (0, import_react221.useRef)(rest.id || useId());
  const prefix = usePrefix();
  const treeClasses = (0, import_classnames146.default)(className, `${prefix}--tree`, {
    // @ts-ignore - will always be false according to prop types
    [`${prefix}--tree--${size4}`]: size4 !== "default"
  });
  const treeRootRef = (0, import_react221.useRef)(null);
  const treeWalker = (0, import_react221.useRef)(null);
  const controllableSelectionState = useControllableState({
    value: preselected,
    onChange: onSelect,
    defaultValue: []
  });
  const uncontrollableSelectionState = (0, import_react221.useState)(preselected ?? []);
  const [selected, setSelected] = enableTreeviewControllable ? controllableSelectionState : uncontrollableSelectionState;
  const controllableActiveState = useControllableState({
    value: prespecifiedActive,
    onChange: onActivate,
    defaultValue: void 0
  });
  const uncontrollableActiveState = (0, import_react221.useState)(prespecifiedActive);
  const [active, setActive] = enableTreeviewControllable ? controllableActiveState : uncontrollableActiveState;
  function resetNodeTabIndices() {
    var _a;
    Array.prototype.forEach.call(((_a = treeRootRef == null ? void 0 : treeRootRef.current) == null ? void 0 : _a.querySelectorAll('[tabIndex="0"]')) ?? [], (item) => {
      item.tabIndex = -1;
    });
  }
  function handleTreeSelect(event, node) {
    const nodeId = node.id;
    if (nodeId) {
      if (multiselect && (event.metaKey || event.ctrlKey)) {
        if (!selected.includes(nodeId)) {
          setSelected(selected.concat(nodeId));
        } else {
          setSelected(selected.filter((selectedId) => selectedId !== nodeId));
        }
        if (!enableTreeviewControllable) {
          onSelect == null ? void 0 : onSelect(event, node);
        }
      } else {
        setSelected([nodeId]);
        setActive(nodeId);
        if (!enableTreeviewControllable) {
          onSelect == null ? void 0 : onSelect(event, {
            activeNodeId: nodeId,
            ...node
          });
        }
      }
    }
  }
  (0, import_react221.useEffect)(() => {
    var _a;
    const firstNode = (_a = treeRootRef.current) == null ? void 0 : _a.querySelector(`.${prefix}--tree-node:not(.${prefix}--tree-node--disabled)`);
    if (firstNode instanceof HTMLElement) {
      firstNode.tabIndex = 0;
    }
  }, [children, prefix]);
  function handleKeyDown(event) {
    var _a;
    event.stopPropagation();
    if (matches(event, [ArrowUp2, ArrowDown, Home, End])) {
      event.preventDefault();
    }
    if (!treeWalker.current) {
      return;
    }
    treeWalker.current.currentNode = event.target;
    let nextFocusNode = null;
    if (match(event, ArrowUp2)) {
      nextFocusNode = treeWalker.current.previousNode();
    }
    if (match(event, ArrowDown)) {
      nextFocusNode = treeWalker.current.nextNode();
    }
    if (matches(event, [Home, End, {
      code: "KeyA"
    }])) {
      const nodeIds = [];
      if (matches(event, [Home, End])) {
        if (multiselect && event.shiftKey && event.ctrlKey && treeWalker.current.currentNode instanceof Element && !treeWalker.current.currentNode.getAttribute("aria-disabled") && !treeWalker.current.currentNode.classList.contains(`${prefix}--tree-node--hidden`)) {
          nodeIds.push(treeWalker.current.currentNode.id);
        }
        while (match(event, Home) ? treeWalker.current.previousNode() : treeWalker.current.nextNode()) {
          nextFocusNode = treeWalker.current.currentNode;
          if (multiselect && event.shiftKey && event.ctrlKey && nextFocusNode instanceof Element && !nextFocusNode.getAttribute("aria-disabled") && !nextFocusNode.classList.contains(`${prefix}--tree-node--hidden`)) {
            nodeIds.push(nextFocusNode.id);
          }
        }
      }
      if (match(event, {
        code: "KeyA"
      }) && event.ctrlKey) {
        treeWalker.current.currentNode = treeWalker.current.root;
        while (treeWalker.current.nextNode()) {
          if (treeWalker.current.currentNode instanceof Element && !treeWalker.current.currentNode.getAttribute("aria-disabled") && !treeWalker.current.currentNode.classList.contains(`${prefix}--tree-node--hidden`)) {
            nodeIds.push(treeWalker.current.currentNode.id);
          }
        }
      }
      setSelected(selected.concat(nodeIds));
    }
    if (nextFocusNode && nextFocusNode !== event.target) {
      resetNodeTabIndices();
      if (nextFocusNode instanceof HTMLElement) {
        nextFocusNode.tabIndex = 0;
        nextFocusNode.focus();
      }
    }
    (_a = rest == null ? void 0 : rest.onKeyDown) == null ? void 0 : _a.call(rest, event);
  }
  (0, import_react221.useEffect)(() => {
    if (treeRootRef.current && !treeWalker.current) {
      treeWalker.current = document.createTreeWalker(treeRootRef.current, NodeFilter.SHOW_ELEMENT, {
        acceptNode: function(node) {
          if (!(node instanceof Element)) {
            return NodeFilter.FILTER_SKIP;
          }
          if (node.classList.contains(`${prefix}--tree-node--disabled`) || node.classList.contains(`${prefix}--tree-node--hidden`)) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.matches(`.${prefix}--tree-node`)) {
            return NodeFilter.FILTER_ACCEPT;
          }
          return NodeFilter.FILTER_SKIP;
        }
      });
    }
  }, [prefix]);
  const labelId = `${treeId}__label`;
  const TreeLabel = () => !hideLabel ? import_react221.default.createElement("label", {
    id: labelId,
    className: `${prefix}--label`
  }, label) : null;
  const treeContextValue = (0, import_react221.useMemo)(() => ({
    active,
    multiselect,
    onActivate: setActive,
    onTreeSelect: handleTreeSelect,
    selected,
    size: size4
  }), [active, multiselect, setActive, handleTreeSelect, selected, size4]);
  return import_react221.default.createElement(import_react221.default.Fragment, null, import_react221.default.createElement(TreeLabel, null), import_react221.default.createElement(TreeContext.Provider, {
    value: treeContextValue
  }, import_react221.default.createElement(DepthContext.Provider, {
    value: 0
  }, import_react221.default.createElement("ul", _extends({}, rest, {
    "aria-label": hideLabel ? label : void 0,
    "aria-labelledby": !hideLabel ? labelId : void 0,
    "aria-multiselectable": multiselect || void 0,
    className: treeClasses,
    onKeyDown: handleKeyDown,
    ref: treeRootRef,
    role: "tree"
  }), children))));
};
TreeView.propTypes = {
  /**
   * Mark the active node in the tree, represented by its ID
   */
  active: import_prop_types169.default.oneOfType([import_prop_types169.default.string, import_prop_types169.default.number]),
  /**
   * Specify the children of the TreeView
   */
  children: import_prop_types169.default.node,
  /**
   * Specify an optional className to be applied to the TreeView
   */
  className: import_prop_types169.default.string,
  /**
   * Specify whether or not the label should be hidden
   */
  hideLabel: import_prop_types169.default.bool,
  /**
   * Provide the label text that will be read by a screen reader
   */
  label: import_prop_types169.default.string.isRequired,
  /**
   * **[Experimental]** Specify the selection mode of the tree.
   * If `multiselect` is `false` then only one node can be selected at a time
   */
  multiselect: import_prop_types169.default.bool,
  /**
   * **[Experimental]** Callback function that is called when any node is activated.
   * *This is only supported with the `enable-treeview-controllable` feature flag!*
   */
  onActivate: import_prop_types169.default.func,
  /**
   * Callback function that is called when any node is selected
   */
  onSelect: import_prop_types169.default.func,
  /**
   * Array representing all selected node IDs in the tree
   */
  selected: import_prop_types169.default.arrayOf(import_prop_types169.default.oneOfType([import_prop_types169.default.string, import_prop_types169.default.number])),
  /**
   * Specify the size of the tree from a list of available sizes.
   */
  size: import_prop_types169.default.oneOf(["xs", "sm"])
};
TreeView.TreeNode = TreeNode;

// node_modules/@carbon/react/es/components/UIShell/Content.js
var import_classnames147 = __toESM(require_classnames());
var import_prop_types170 = __toESM(require_prop_types());
var import_react222 = __toESM(require_react());
var Content2 = ({
  className: customClassName,
  children,
  tagName = "main",
  ...rest
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames147.default)(`${prefix}--content`, customClassName);
  return import_react222.default.createElement(tagName, {
    ...rest,
    className
  }, children);
};
Content2.propTypes = {
  /**
   * Provide children nodes to be rendered in the content container
   */
  children: import_prop_types170.default.node,
  /**
   * Optionally provide a custom class name that is applied to the container
   */
  className: import_prop_types170.default.string,
  /**
   * Optionally specify the tag of the content node. Defaults to `main`
   */
  tagName: import_prop_types170.default.string
};

// node_modules/@carbon/react/es/components/UIShell/Header.js
var import_classnames148 = __toESM(require_classnames());
var import_prop_types171 = __toESM(require_prop_types());
var import_react223 = __toESM(require_react());
var Header = ({
  className: customClassName,
  children,
  ...rest
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames148.default)(`${prefix}--header`, customClassName);
  return import_react223.default.createElement("header", _extends({}, rest, {
    className
  }), children);
};
Header.propTypes = {
  /**
   * Optionally provide aria-label
   */
  "aria-label": import_prop_types171.default.string,
  /**
   * Optionally provide aria-labelledby
   */
  "aria-labelledby": import_prop_types171.default.string,
  /**
   * Optionally provide a custom class name that is applied to the underlying header
   */
  className: import_prop_types171.default.string
};

// node_modules/@carbon/react/es/components/UIShell/HeaderContainer.js
var import_prop_types172 = __toESM(require_prop_types());
var import_react224 = __toESM(require_react());
function HeaderContainer({
  render: Children10,
  isSideNavExpanded = false,
  ...rest
}) {
  const [isSideNavExpandedState, setIsSideNavExpandedState] = (0, import_react224.useState)(isSideNavExpanded);
  useWindowEvent("keydown", (event) => {
    if (match(event, Escape)) {
      setIsSideNavExpandedState(false);
    }
  });
  const handleHeaderMenuButtonClick = (0, import_react224.useCallback)(() => {
    setIsSideNavExpandedState((prevIsSideNavExpanded) => !prevIsSideNavExpanded);
  }, [setIsSideNavExpandedState]);
  return import_react224.default.createElement(Children10, _extends({}, rest, {
    isSideNavExpanded: isSideNavExpandedState,
    onClickSideNavExpand: handleHeaderMenuButtonClick
  }));
}
HeaderContainer.propTypes = {
  /**
   * Optionally provide a custom class name that is applied to the underlying <header>
   */
  isSideNavExpanded: import_prop_types172.default.bool,
  /**
   * A function or a component that is invoked with `isSideNavExpanded` and `onClickSideNavExpand`.
   * The function or component can then use those properties to within the components it
   * returns, such as with the HeaderMenuButton and SideNav components. Additional props will also be passed
   * into this component for convenience.
   */
  render: import_prop_types172.default.elementType.isRequired
};

// node_modules/@carbon/react/es/components/UIShell/HeaderGlobalAction.js
var import_classnames149 = __toESM(require_classnames());
var import_react225 = __toESM(require_react());
var import_prop_types174 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/prop-types/AriaPropTypes.js
var import_prop_types173 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/prop-types/isRequiredOneOf.js
var isRequiredOneOf = (propTypes2) => {
  const names = Object.keys(propTypes2);
  const checker = (propType) => (props, propName, componentName, ...rest) => {
    if (names.every((name) => typeof props[name] === "undefined")) {
      return new Error(`${componentName} requires one of the following props: ${names.join(", ")}`);
    }
    return propType(props, propName, componentName, ...rest);
  };
  return names.reduce((acc, name) => ({
    ...acc,
    [name]: checker(propTypes2[name])
  }), {});
};

// node_modules/@carbon/react/es/prop-types/AriaPropTypes.js
var AriaLabelPropType = isRequiredOneOf({
  "aria-label": import_prop_types173.default.string,
  "aria-labelledby": import_prop_types173.default.string
});

// node_modules/@carbon/react/es/components/UIShell/HeaderGlobalAction.js
var HeaderGlobalAction = import_react225.default.forwardRef(function HeaderGlobalAction2({
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledBy,
  children,
  className: customClassName,
  onClick,
  tooltipHighContrast = true,
  tooltipDropShadow,
  isActive,
  tooltipAlignment,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const className = (0, import_classnames149.default)({
    [customClassName]: !!customClassName,
    [`${prefix}--header__action`]: true,
    [`${prefix}--header__action--active`]: isActive
  });
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  return import_react225.default.createElement(Button, _extends({}, rest, accessibilityLabel, {
    className,
    onClick,
    type: "button",
    hasIconOnly: true,
    size: "lg",
    kind: "ghost",
    iconDescription: ariaLabel,
    tooltipPosition: "bottom",
    tooltipAlignment,
    tooltipDropShadow,
    tooltipHighContrast,
    ref
  }), children);
});
HeaderGlobalAction.propTypes = {
  /**
   * Required props for the accessibility label of the button
   */
  ...AriaLabelPropType,
  /**
   * Provide a custom icon for this global action
   */
  children: import_prop_types174.default.node.isRequired,
  /**
   * Optionally provide a custom class name that is applied to the underlying
   * button
   */
  className: import_prop_types174.default.string,
  /**
   * Specify whether the action is currently active
   */
  isActive: import_prop_types174.default.bool,
  /**
   * Optionally provide an onClick handler that is called when the underlying
   * button fires it's onclick event
   */
  onClick: import_prop_types174.default.func,
  /**
   * Specify the alignment of the tooltip to the icon-only button.
   * Can be one of: start, center, or end.
   */
  tooltipAlignment: import_prop_types174.default.oneOf(["start", "center", "end"]),
  /**
   * Enable drop shadow for tooltips for icon-only buttons.
   */
  tooltipDropShadow: import_prop_types174.default.bool,
  /**
   * Render the tooltip using the high-contrast theme
   * Default is true
   */
  tooltipHighContrast: import_prop_types174.default.bool
};
HeaderGlobalAction.displayName = "HeaderGlobalAction";

// node_modules/@carbon/react/es/components/UIShell/HeaderGlobalBar.js
var HeaderGlobalBar = wrapComponent({
  name: "HeaderGlobalBar",
  className: (prefix) => `${prefix}--header__global`,
  type: "div"
});

// node_modules/@carbon/react/es/components/UIShell/HeaderMenu.js
var import_classnames150 = __toESM(require_classnames());
var import_react226 = __toESM(require_react());
var import_prop_types175 = __toESM(require_prop_types());
var frFn10 = import_react226.forwardRef;
var HeaderMenu = frFn10((props, ref) => {
  const {
    isActive,
    isCurrentPage,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className: customClassName,
    children,
    renderMenuContent: MenuContent,
    menuLinkName,
    focusRef,
    onBlur,
    onClick,
    onKeyDown,
    ...rest
  } = props;
  const prefix = (0, import_react226.useContext)(PrefixContext);
  const [expanded, setExpanded] = (0, import_react226.useState)(false);
  const menuButtonRef = (0, import_react226.useRef)(null);
  const subMenusRef = (0, import_react226.useRef)(null);
  const itemRefs = (0, import_react226.useRef)([]);
  const mergedButtonRef = useMergedRefs([ref, focusRef, menuButtonRef]);
  const handleOnClick = (e2) => {
    if (!subMenusRef.current || e2.target instanceof Node && !subMenusRef.current.contains(e2.target)) {
      e2.preventDefault();
    }
    setExpanded((prev) => !prev);
  };
  const handleOnKeyDown2 = (event) => {
    if (matches(event, [Enter, Space])) {
      event.stopPropagation();
      event.preventDefault();
      setExpanded((prev) => !prev);
      return;
    }
  };
  const handleOnBlur = (event) => {
    var _a;
    const siblingItemBlurredTo = itemRefs.current.find((element) => element === event.relatedTarget);
    const childItemBlurredTo = (_a = subMenusRef.current) == null ? void 0 : _a.contains(event.relatedTarget);
    if (!siblingItemBlurredTo && !childItemBlurredTo) {
      setExpanded(false);
    }
  };
  const handleItemRef = (index3) => (node) => {
    itemRefs.current[index3] = node;
  };
  const handleMenuClose = (event) => {
    if (matches(event, [Escape]) && expanded) {
      event.stopPropagation();
      event.preventDefault();
      setExpanded(false);
      if (menuButtonRef.current) {
        menuButtonRef.current.focus();
      }
    }
  };
  const hasActiveDescendant2 = (childrenArg) => import_react226.Children.toArray(childrenArg).some((child) => {
    if (!(0, import_react226.isValidElement)(child)) {
      return false;
    }
    const {
      isActive: isActive2,
      isCurrentPage: isCurrentPage2,
      children: children2
    } = child.props;
    return isActive2 || isCurrentPage2 || Array.isArray(children2) && hasActiveDescendant2(children2);
  });
  const renderMenuItem = (item, index3) => {
    if ((0, import_react226.isValidElement)(item)) {
      return (0, import_react226.cloneElement)(item, {
        ref: handleItemRef(index3)
      });
    }
    return item;
  };
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  const itemClassName = (0, import_classnames150.default)({
    [`${prefix}--header__submenu`]: true,
    [`${customClassName}`]: !!customClassName
  });
  const isActivePage = isActive ? isActive : isCurrentPage;
  const linkClassName = (0, import_classnames150.default)({
    [`${prefix}--header__menu-item`]: true,
    [`${prefix}--header__menu-title`]: true,
    // We set the current class only if `isActive` is passed in and we do
    // not have an `aria-current="page"` set for the breadcrumb item
    [`${prefix}--header__menu-item--current`]: isActivePage || hasActiveDescendant2(children) && !expanded
  });
  return import_react226.default.createElement("li", _extends({}, rest, {
    className: itemClassName,
    onKeyDown: composeEventHandlers([onKeyDown, handleMenuClose]),
    onClick: composeEventHandlers([onClick, handleOnClick]),
    onBlur: composeEventHandlers([onBlur, handleOnBlur]),
    ref
  }), import_react226.default.createElement("a", _extends({
    // eslint-disable-line jsx-a11y/role-supports-aria-props,jsx-a11y/anchor-is-valid
    "aria-haspopup": "menu",
    "aria-expanded": expanded,
    className: linkClassName,
    href: "#",
    onKeyDown: handleOnKeyDown2,
    ref: mergedButtonRef,
    tabIndex: 0
  }, accessibilityLabel), menuLinkName, MenuContent ? import_react226.default.createElement(MenuContent, null) : import_react226.default.createElement(ChevronDown, {
    className: `${prefix}--header__menu-arrow`
  })), import_react226.default.createElement("ul", _extends({}, accessibilityLabel, {
    ref: subMenusRef,
    className: `${prefix}--header__menu`
  }), import_react226.Children.map(children, renderMenuItem)));
});
HeaderMenu.displayName = "HeaderMenu";
HeaderMenu.propTypes = {
  /**
   * Required props for the accessibility label of the menu
   */
  ...AriaLabelPropType,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types175.default.string,
  /**
   * Provide a custom ref handler for the menu button
   */
  focusRef: import_prop_types175.default.func,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   */
  isActive: import_prop_types175.default.bool,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   * @deprecated Please use `isActive` instead. This will be removed in the next major release.
   */
  isCurrentPage: deprecate(import_prop_types175.default.bool, "The `isCurrentPage` prop for `HeaderMenu` has been deprecated. Please use `isActive` instead. This will be removed in the next major release."),
  /**
   * Provide a label for the link text
   */
  menuLinkName: import_prop_types175.default.string.isRequired,
  /**
   * Optionally provide an onBlur handler that is called when the underlying
   * button fires it's onblur event
   */
  onBlur: import_prop_types175.default.func,
  /**
   * Optionally provide an onClick handler that is called when the underlying
   * button fires it's onclick event
   */
  onClick: import_prop_types175.default.func,
  /**
   * Optionally provide an onKeyDown handler that is called when the underlying
   * button fires it's onkeydown event
   */
  onKeyDown: import_prop_types175.default.func,
  /**
   * Optional component to render instead of string
   */
  renderMenuContent: import_prop_types175.default.func,
  /**
   * Optionally provide a tabIndex for the underlying menu button
   */
  tabIndex: import_prop_types175.default.number
};

// node_modules/@carbon/react/es/components/UIShell/HeaderMenuButton.js
var import_classnames151 = __toESM(require_classnames());
var import_react227 = __toESM(require_react());
var import_prop_types176 = __toESM(require_prop_types());
var _Menu;
var _Close8;
function HeaderMenuButton({
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledBy,
  className: customClassName,
  renderMenuIcon,
  renderCloseIcon,
  isActive,
  isCollapsible,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames151.default)({
    ...typeof customClassName === "string" && {
      [customClassName]: !!customClassName
    },
    [`${prefix}--header__action`]: true,
    [`${prefix}--header__menu-trigger`]: true,
    [`${prefix}--header__action--active`]: isActive,
    [`${prefix}--header__menu-toggle`]: true,
    [`${prefix}--header__menu-toggle__hidden`]: !isCollapsible
  });
  const menuIcon = renderMenuIcon ? renderMenuIcon : _Menu || (_Menu = import_react227.default.createElement(Menu, {
    size: 20
  }));
  const closeIcon = renderCloseIcon ? renderCloseIcon : _Close8 || (_Close8 = import_react227.default.createElement(Close, {
    size: 20
  }));
  return import_react227.default.createElement("button", _extends({}, rest, {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className,
    title: ariaLabel,
    type: "button"
  }), isActive ? closeIcon : menuIcon);
}
HeaderMenuButton.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu button
   */
  ...AriaLabelPropType,
  /**
   * Optionally provide a custom class name that is applied to the underlying
   * button
   */
  className: import_prop_types176.default.string,
  /**
   * Specify whether the menu button is "active".
   */
  isActive: import_prop_types176.default.bool,
  /**
   * Specify whether the menu button is collapsible.
   */
  isCollapsible: import_prop_types176.default.bool,
  /**
   * Optionally provide an onClick handler that is called when the underlying
   * button fires it's onclick event
   */
  onClick: import_prop_types176.default.func
};

// node_modules/@carbon/react/es/components/UIShell/HeaderMenuItem.js
var import_prop_types178 = __toESM(require_prop_types());
var import_react229 = __toESM(require_react());
var import_classnames152 = __toESM(require_classnames());

// node_modules/@carbon/react/es/components/UIShell/Link.js
var import_prop_types177 = __toESM(require_prop_types());
var import_react228 = __toESM(require_react());
var LinkBase2 = ({
  element,
  as: BaseComponent,
  // Captured here to prevent it from being passed into the created element.
  // See https://github.com/carbon-design-system/carbon/issues/3970
  isSideNavExpanded: _isSideNavExpanded,
  ...rest
}, ref) => {
  const BaseComponentAsAny = BaseComponent ?? element ?? "a";
  return import_react228.default.createElement(BaseComponentAsAny, _extends({
    ref
  }, rest));
};
var Link2 = import_react228.default.forwardRef(LinkBase2);
var LinkPropTypes = {
  /**
   * Provide a custom element or component to render the top-level node for the
   * component.
   */
  as: import_prop_types177.default.elementType,
  /**
   * The base element to use to build the link. Defaults to `a`, can also accept
   * alternative tag names or custom components like `Link` from `react-router`.
   * @deprecated Use `as` instead
   *
   */
  element: deprecate(import_prop_types177.default.elementType, "The `element` prop for `Link` has been deprecated. Please use `as` instead. This will be removed in the next major release."),
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types177.default.bool
};
Link2.displayName = "Link";
Link2.propTypes = LinkPropTypes;

// node_modules/@carbon/react/es/components/UIShell/HeaderMenuItem.js
var HeaderMenuItem = (0, import_react229.forwardRef)(function HeaderMenuItem2({
  className,
  isActive,
  isCurrentPage,
  "aria-current": ariaCurrent,
  children,
  role,
  tabIndex,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const resolvedTabIndex = tabIndex ?? 0;
  if (isCurrentPage) {
    isActive = isCurrentPage;
  }
  const hasCurrentClass = isActive && ariaCurrent !== "page";
  const linkClassName = (0, import_classnames152.default)({
    [`${prefix}--header__menu-item`]: true,
    [`${prefix}--header__menu-item--current`]: hasCurrentClass
  });
  return import_react229.default.createElement("li", {
    className,
    role
  }, import_react229.default.createElement(Link2, _extends({}, rest, {
    "aria-current": hasCurrentClass ? true : ariaCurrent,
    className: linkClassName,
    ref,
    tabIndex: resolvedTabIndex
  }), import_react229.default.createElement("span", {
    className: `${prefix}--text-truncate--end`
  }, children)));
});
HeaderMenuItem.displayName = "HeaderMenuItem";
HeaderMenuItem.propTypes = {
  /**
   * Pass in a valid `element` to replace the underlying `<a>` tag with a
   * custom `Link` element
   */
  ...LinkPropTypes,
  /**
   * Pass in children that are either a string or can be read as a string by
   * screen readers
   */
  children: import_prop_types178.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types178.default.string,
  /**
   * If `true` and `aria-current !== 'page'`, applies selected styles to the item and sets `aria-current="true"`.
   */
  isActive: import_prop_types178.default.bool,
  /**
   * Applies selected styles to the item if a user sets this to true and `aria-current !== 'page'`.
   * @deprecated Please use `isActive` instead. This will be removed in the next major release.
   */
  isCurrentPage: deprecate(import_prop_types178.default.bool, "The `isCurrentPage` prop for `HeaderMenuItem` has been deprecated. Please use `isActive` instead. This will be removed in the next major release."),
  /**
   * Optionally supply a role for the underlying `<li>` node. Useful for resetting
   * `<ul>` semantics for menus.
   */
  role: import_prop_types178.default.string,
  /**
   * Specify the tab index of the Link
   */
  tabIndex: import_prop_types178.default.number
};

// node_modules/@carbon/react/es/components/UIShell/HeaderName.js
var import_classnames153 = __toESM(require_classnames());
var import_react230 = __toESM(require_react());
var import_prop_types179 = __toESM(require_prop_types());
function HeaderName({
  children,
  className: customClassName,
  prefix = "IBM",
  ...rest
}) {
  const selectorPrefix = usePrefix();
  const className = (0, import_classnames153.default)(`${selectorPrefix}--header__name`, customClassName);
  return import_react230.default.createElement(Link2, _extends({}, rest, {
    className
  }), prefix && import_react230.default.createElement(import_react230.default.Fragment, null, import_react230.default.createElement("span", {
    className: `${selectorPrefix}--header__name--prefix`
  }, prefix), " "), children);
}
HeaderName.propTypes = {
  /**
   * Pass in a valid `element` to replace the underlying `<a>` tag with a
   * custom `Link` element
   */
  ...LinkPropTypes,
  /**
   * Pass in children that are either a string or can be read as a string by
   * screen readers
   */
  children: import_prop_types179.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types179.default.string,
  /**
   * Provide an href for the name to link to
   */
  href: import_prop_types179.default.string,
  /**
   * Optionally specify a prefix to your header name. Useful for companies, for
   * example: IBM [Product Name] versus solely [Product Name]
   */
  prefix: import_prop_types179.default.string
};

// node_modules/@carbon/react/es/components/UIShell/HeaderNavigation.js
var import_classnames154 = __toESM(require_classnames());
var import_react231 = __toESM(require_react());
var import_prop_types180 = __toESM(require_prop_types());
function HeaderNavigation({
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledBy,
  children,
  className: customClassName,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames154.default)(`${prefix}--header__nav`, customClassName);
  return import_react231.default.createElement("nav", _extends({}, rest, {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className
  }), import_react231.default.createElement("ul", {
    className: `${prefix}--header__menu-bar`
  }, children));
}
HeaderNavigation.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu
   */
  ...AriaLabelPropType,
  /**
   * Provide valid children of HeaderNavigation, for example `HeaderMenuItem`
   * or `HeaderMenu`
   */
  children: import_prop_types180.default.node,
  /**
   * Optionally provide a custom class to apply to the underlying <nav> node
   */
  className: import_prop_types180.default.string
};

// node_modules/@carbon/react/es/components/UIShell/HeaderPanel.js
var import_classnames173 = __toESM(require_classnames());
var import_prop_types199 = __toESM(require_prop_types());
var import_react250 = __toESM(require_react());

// node_modules/@carbon/react/es/components/UIShell/Switcher.js
var import_react249 = __toESM(require_react());
var import_classnames172 = __toESM(require_classnames());
var import_prop_types198 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/components/UIShell/HeaderSideNavItems.js
var import_classnames155 = __toESM(require_classnames());
var import_react232 = __toESM(require_react());
var import_prop_types181 = __toESM(require_prop_types());
function HeaderSideNavItems({
  className: customClassName,
  children,
  hasDivider = false
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames155.default)({
    [`${prefix}--side-nav__header-navigation`]: true,
    [`${prefix}--side-nav__header-divider`]: hasDivider
  }, customClassName);
  return import_react232.default.createElement("ul", {
    className
  }, children);
}
HeaderSideNavItems.propTypes = {
  /**
   * The child nodes to be rendered
   */
  children: import_prop_types181.default.node,
  /**
   * Optionally provide a custom class name that is applied to the underlying
   * button
   */
  className: import_prop_types181.default.string,
  /**
   * Optionally specify if container will have a bottom divider to differentiate
   * between original sidenav items and header menu items. False by default.
   */
  hasDivider: import_prop_types181.default.bool
};

// node_modules/@carbon/react/es/components/UIShell/SwitcherItem.js
var import_react233 = __toESM(require_react());
var import_classnames156 = __toESM(require_classnames());
var import_prop_types182 = __toESM(require_prop_types());
var SwitcherItem = (0, import_react233.forwardRef)(function SwitcherItem2(props, forwardRef36) {
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className: customClassName,
    children,
    isSelected,
    expanded,
    tabIndex = expanded ? 0 : -1,
    index: index3,
    handleSwitcherItemFocus,
    onKeyDown = () => {
    },
    href,
    target,
    rel,
    ...rest
  } = props;
  const prefix = usePrefix();
  const classNames = (0, import_classnames156.default)(`${prefix}--switcher__item`, {
    [customClassName || ""]: !!customClassName
  });
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  const linkClassName = (0, import_classnames156.default)(`${prefix}--switcher__item-link`, {
    [`${prefix}--switcher__item-link--selected`]: isSelected
  });
  function setTabFocus(evt) {
    if (match(evt, ArrowDown)) {
      evt.preventDefault();
      handleSwitcherItemFocus == null ? void 0 : handleSwitcherItemFocus({
        currentIndex: index3 || -1,
        direction: 1
      });
    }
    if (match(evt, ArrowUp2)) {
      evt.preventDefault();
      handleSwitcherItemFocus == null ? void 0 : handleSwitcherItemFocus({
        currentIndex: index3 || -1,
        direction: -1
      });
    }
  }
  return import_react233.default.createElement("li", {
    className: classNames
  }, import_react233.default.createElement(Link2, _extends({
    onKeyDown: (evt) => {
      setTabFocus(evt);
      onKeyDown(evt);
    },
    href,
    target,
    rel,
    ref: forwardRef36
  }, rest, {
    className: linkClassName,
    tabIndex
  }, accessibilityLabel), children));
});
SwitcherItem.displayName = "SwitcherItem";
SwitcherItem.propTypes = {
  ...AriaLabelPropType,
  /**
   * Specify the text content for the link
   */
  children: import_prop_types182.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types182.default.string,
  /**
   * event handlers
   */
  handleSwitcherItemFocus: import_prop_types182.default.func,
  /**
   * Optionally provide an href for the underlying li`
   */
  href: import_prop_types182.default.string,
  /**
   * Specify the index of the SwitcherItem
   */
  index: import_prop_types182.default.number,
  /**
   * event handlers
   */
  onClick: import_prop_types182.default.func,
  /**
   * event handlers
   */
  onKeyDown: import_prop_types182.default.func,
  /**
   * Specify the tab index of the Link
   */
  tabIndex: import_prop_types182.default.number,
  /**
   * Specify where to open the link.
   */
  target: import_prop_types182.default.string,
  /**
   * The rel property for the link.
   */
  rel: import_prop_types182.default.string
};

// node_modules/@carbon/react/es/components/UIShell/SwitcherDivider.js
var import_react234 = __toESM(require_react());
var import_classnames157 = __toESM(require_classnames());
var import_prop_types183 = __toESM(require_prop_types());
var SwitcherDivider = ({
  className: customClassName,
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames157.default)(`${prefix}--switcher__item--divider`, {
    [customClassName || ""]: !!customClassName
  });
  return import_react234.default.createElement("hr", _extends({}, other, {
    className: classNames
  }));
};
SwitcherDivider.propTypes = {
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types183.default.string
};

// node_modules/@carbon/react/es/components/UIShell/SkipToContent.js
var import_classnames158 = __toESM(require_classnames());
var import_react235 = __toESM(require_react());
var import_prop_types184 = __toESM(require_prop_types());
function SkipToContent({
  children = "Skip to main content",
  className: customClassName,
  href = "#main-content",
  tabIndex = 0,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames158.default)(`${prefix}--skip-to-content`, customClassName);
  return import_react235.default.createElement("a", _extends({}, rest, {
    className,
    href,
    tabIndex
  }), children);
}
SkipToContent.propTypes = {
  /**
   * A ReactNode to display in the SkipToContent `a` tag.
   * `'Skip to main content'` by default.
   */
  children: import_prop_types184.default.string,
  className: import_prop_types184.default.string,
  /**
   * Provide the `href` to the id of the element on your package that is the
   * main content. `#main-content` by default.
   */
  href: import_prop_types184.default.string,
  /**
   * Optionally override the default tabindex of 0
   */
  tabIndex: import_prop_types184.default.string
};

// node_modules/@carbon/react/es/components/UIShell/SideNav.js
var import_react236 = __toESM(require_react());
var import_classnames159 = __toESM(require_classnames());
var import_prop_types185 = __toESM(require_prop_types());

// node_modules/@carbon/react/es/components/UIShell/_utils.js
var CARBON_SIDENAV_ITEMS = ["SideNavFooter", "SideNavHeader", "SideNavItems", "SideNavMenu", "SideNavLink"];

// node_modules/@carbon/react/es/components/UIShell/SideNav.js
var SideNavContext = (0, import_react236.createContext)({});
function SideNavRenderFunction({
  expanded: expandedProp,
  defaultExpanded = false,
  isChildOfHeader = true,
  "aria-label": ariaLabel,
  "aria-labelledby": ariaLabelledBy,
  children,
  onToggle,
  className: customClassName,
  // TO-DO: comment back in when footer is added for rails
  // translateById: t = (id) => translations[id],
  href,
  isFixedNav = false,
  isRail,
  isPersistent = true,
  addFocusListeners = true,
  addMouseListeners = true,
  onOverlayClick,
  onSideNavBlur,
  enterDelayMs = 100,
  ...other
}, ref) {
  const prefix = usePrefix();
  const {
    current: controlled
  } = (0, import_react236.useRef)(expandedProp !== void 0);
  const [expandedState, setExpandedState] = useDelayedState(defaultExpanded);
  const [expandedViaHoverState, setExpandedViaHoverState] = useDelayedState(defaultExpanded);
  const expanded = controlled ? expandedProp : expandedState;
  const sideNavRef = (0, import_react236.useRef)(null);
  const navRef = useMergedRefs([sideNavRef, ref]);
  const handleToggle = (event, value = !expanded) => {
    if (!controlled) {
      setExpandedState(value, enterDelayMs);
    }
    if (onToggle) {
      onToggle(event, value);
    }
    if (controlled || isRail) {
      setExpandedViaHoverState(value, enterDelayMs);
    }
  };
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  const className = (0, import_classnames159.default)(customClassName, {
    [`${prefix}--side-nav`]: true,
    [`${prefix}--side-nav--expanded`]: expanded || expandedViaHoverState,
    [`${prefix}--side-nav--collapsed`]: !expanded && isFixedNav,
    [`${prefix}--side-nav--rail`]: isRail,
    [`${prefix}--side-nav--ux`]: isChildOfHeader,
    [`${prefix}--side-nav--hidden`]: !isPersistent
  });
  const overlayClassName = (0, import_classnames159.default)({
    [`${prefix}--side-nav__overlay`]: true,
    [`${prefix}--side-nav__overlay-active`]: expanded || expandedViaHoverState
  });
  let childrenToRender = children;
  childrenToRender = import_react236.default.Children.map(children, (child) => {
    var _a, _b;
    const currentExpansionState = controlled ? expandedViaHoverState || expanded : expanded;
    if ((0, import_react236.isValidElement)(child)) {
      const childJsxElement = child;
      return import_react236.default.cloneElement(childJsxElement, {
        ...CARBON_SIDENAV_ITEMS.includes(((_a = childJsxElement.type) == null ? void 0 : _a.displayName) ?? ((_b = childJsxElement.type) == null ? void 0 : _b.name)) ? {
          isSideNavExpanded: currentExpansionState
        } : {}
      });
    }
    return child;
  });
  const eventHandlers = {};
  if (addFocusListeners) {
    eventHandlers.onFocus = (event) => {
      if (!event.currentTarget.contains(event.relatedTarget) && isRail) {
        handleToggle(event, true);
      }
    };
    eventHandlers.onBlur = (event) => {
      if (!event.currentTarget.contains(event.relatedTarget)) {
        handleToggle(event, false);
      }
      if (!event.currentTarget.contains(event.relatedTarget) && expanded && !isFixedNav) {
        if (onSideNavBlur) {
          onSideNavBlur();
        }
      }
    };
    eventHandlers.onKeyDown = (event) => {
      if (match(event, Escape)) {
        handleToggle(event, false);
        if (href) {
          window.location.href = href;
        }
      }
    };
  }
  if (addMouseListeners && isRail) {
    eventHandlers.onMouseEnter = () => {
      handleToggle(true, true);
    };
    eventHandlers.onMouseLeave = () => {
      setExpandedState(false);
      setExpandedViaHoverState(false);
      handleToggle(false, false);
    };
    eventHandlers.onClick = () => {
      setExpandedState(true);
      setExpandedViaHoverState(true);
      handleToggle(true, true);
    };
  }
  useWindowEvent("keydown", (event) => {
    const focusedElement = document.activeElement;
    if (match(event, Tab) && expanded && !isFixedNav && sideNavRef.current && (focusedElement == null ? void 0 : focusedElement.classList.contains(`${prefix}--header__menu-toggle`)) && !focusedElement.closest("nav")) {
      sideNavRef.current.focus();
    }
  });
  const lgMediaQuery2 = `(min-width: ${breakpoints.lg.width})`;
  const isLg = useMatchMedia(lgMediaQuery2);
  return import_react236.default.createElement(SideNavContext.Provider, {
    value: {
      isRail
    }
  }, isFixedNav ? null : (
    // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
    import_react236.default.createElement("div", {
      className: overlayClassName,
      onClick: onOverlayClick
    })
  ), import_react236.default.createElement("nav", _extends({
    tabIndex: -1,
    ref: navRef,
    className: `${prefix}--side-nav__navigation ${className}`,
    inert: !isRail ? !(expanded || isLg) : void 0
  }, accessibilityLabel, eventHandlers, other), childrenToRender));
}
var SideNav = import_react236.default.forwardRef(SideNavRenderFunction);
SideNav.displayName = "SideNav";
SideNav.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu
   */
  ...AriaLabelPropType,
  /**
   * Specify whether focus and blur listeners are added. They are by default.
   */
  addFocusListeners: import_prop_types185.default.bool,
  /**
   * Specify whether mouse entry/exit listeners are added. They are by default.
   */
  addMouseListeners: import_prop_types185.default.bool,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types185.default.string,
  /**
   * If `true`, the SideNav will be open on initial render.
   */
  defaultExpanded: import_prop_types185.default.bool,
  /**
   * Specify the duration in milliseconds to delay before displaying the side navigation
   */
  enterDelayMs: import_prop_types185.default.number,
  /**
   * If `true`, the SideNav will be expanded, otherwise it will be collapsed.
   * Using this prop causes SideNav to become a controlled component.
   */
  expanded: import_prop_types185.default.bool,
  /**
   * Provide the `href` to the id of the element on your package that is the
   * main content.
   */
  href: import_prop_types185.default.string,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  isChildOfHeader: import_prop_types185.default.bool,
  /**
   * Specify if sideNav is standalone
   */
  isFixedNav: import_prop_types185.default.bool,
  /**
   * Specify if the sideNav will be persistent above the lg breakpoint
   */
  isPersistent: import_prop_types185.default.bool,
  /**
   * Optional prop to display the side nav rail.
   */
  isRail: import_prop_types185.default.bool,
  /**
   * An optional listener that is called when the SideNav overlay is clicked
   *
   * @param {object} event
   */
  onOverlayClick: import_prop_types185.default.func,
  /**
   * An optional listener that is called a callback to collapse the SideNav
   */
  onSideNavBlur: import_prop_types185.default.func,
  /**
   * An optional listener that is called when an event that would cause
   * toggling the SideNav occurs.
   *
   * @param {object} event
   * @param {boolean} value
   */
  onToggle: import_prop_types185.default.func
  /**
   * Provide a custom function for translating all message ids within this
   * component. This function will take in two arguments: the message Id and the
   * state of the component. From this, you should return a string representing
   * the label you want displayed or read by screen readers.
   */
  // translateById: PropTypes.func,
};

// node_modules/@carbon/react/es/components/UIShell/SideNavDetails.js
var import_classnames160 = __toESM(require_classnames());
var import_prop_types186 = __toESM(require_prop_types());
var import_react237 = __toESM(require_react());
var SideNavDetails = ({
  children,
  className: customClassName,
  title,
  ...rest
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames160.default)(`${prefix}--side-nav__details`, customClassName);
  return import_react237.default.createElement("div", _extends({
    className
  }, rest), import_react237.default.createElement("h2", {
    className: `${prefix}--side-nav__title`,
    title
  }, title), children);
};
SideNavDetails.propTypes = {
  /**
   * Provide optional children to render in `SideNavDetails`. Useful for
   * rendering the `SideNavSwitcher` component.
   */
  children: import_prop_types186.default.node,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types186.default.string,
  /**
   * Provide the text that will be rendered as the title in the component
   */
  title: import_prop_types186.default.string.isRequired
};

// node_modules/@carbon/react/es/components/UIShell/SideNavDivider.js
var import_classnames161 = __toESM(require_classnames());
var import_prop_types187 = __toESM(require_prop_types());
var import_react238 = __toESM(require_react());
var _hr;
var SideNavDivider = ({
  className
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames161.default)(`${prefix}--side-nav__divider`, className);
  return import_react238.default.createElement("li", {
    className: classNames
  }, _hr || (_hr = import_react238.default.createElement("hr", null)));
};
SideNavDivider.propTypes = {
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types187.default.string
};

// node_modules/@carbon/react/es/components/UIShell/SideNavFooter.js
var import_classnames162 = __toESM(require_classnames());
var import_react239 = __toESM(require_react());
var import_prop_types188 = __toESM(require_prop_types());
var _Close9;
var _ChevronRight2;
function SideNavFooter({
  assistiveText = "Toggle opening or closing the side navigation",
  className: customClassName,
  expanded,
  onToggle
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames162.default)(`${prefix}--side-nav__footer`, customClassName);
  return import_react239.default.createElement("footer", {
    className
  }, import_react239.default.createElement("button", {
    className: `${prefix}--side-nav__toggle`,
    type: "button",
    onClick: (evt) => onToggle(evt),
    title: assistiveText
  }, import_react239.default.createElement("div", {
    className: `${prefix}--side-nav__icon`
  }, expanded ? _Close9 || (_Close9 = import_react239.default.createElement(Close, {
    size: 20
  })) : _ChevronRight2 || (_ChevronRight2 = import_react239.default.createElement(ChevronRight, {
    size: 20
  }))), import_react239.default.createElement("span", {
    className: `${prefix}--assistive-text`
  }, assistiveText)));
}
SideNavFooter.displayName = "SideNavFooter";
SideNavFooter.propTypes = {
  /**
   * Provide text to be read to screen readers and shown as a tooltip when
   * interacting with the toggle button in the footer
   */
  assistiveText: import_prop_types188.default.string,
  className: import_prop_types188.default.string,
  /**
   * Specify whether the side navigation is expanded or collapsed
   */
  expanded: import_prop_types188.default.bool.isRequired,
  /**
   * Provide a function that is called when the toggle button is interacted
   * with. Useful for controlling the expansion state of the side navigation.
   */
  onToggle: import_prop_types188.default.func.isRequired
};

// node_modules/@carbon/react/es/components/UIShell/SideNavHeader.js
var import_classnames164 = __toESM(require_classnames());
var import_prop_types190 = __toESM(require_prop_types());
var import_react241 = __toESM(require_react());

// node_modules/@carbon/react/es/components/UIShell/SideNavIcon.js
var import_classnames163 = __toESM(require_classnames());
var import_prop_types189 = __toESM(require_prop_types());
var import_react240 = __toESM(require_react());
var SideNavIcon = ({
  children,
  className: customClassName,
  small = false
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames163.default)({
    [`${prefix}--side-nav__icon`]: true,
    [`${prefix}--side-nav__icon--small`]: small,
    [customClassName]: !!customClassName
  });
  return import_react240.default.createElement("div", {
    className
  }, children);
};
SideNavIcon.propTypes = {
  /**
   * Provide a single icon as the child to `SideNavIcon` to render in the
   * container
   */
  children: import_prop_types189.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types189.default.string,
  /**
   * Specify whether the icon should be placed in a smaller bounding box
   */
  small: import_prop_types189.default.bool
};

// node_modules/@carbon/react/es/components/UIShell/SideNavHeader.js
var SideNavHeader = ({
  children,
  className: customClassName,
  renderIcon: IconElement
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames164.default)(`${prefix}--side-nav__header`, customClassName);
  return import_react241.default.createElement("header", {
    className
  }, import_react241.default.createElement(SideNavIcon, null, import_react241.default.createElement(IconElement, null)), children);
};
SideNavHeader.displayName = "SideNavHeader";
SideNavHeader.propTypes = {
  /**
   * The child nodes to be rendered
   */
  children: import_prop_types190.default.node,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types190.default.string,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types190.default.bool,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types190.default.oneOfType([import_prop_types190.default.func, import_prop_types190.default.object]).isRequired
};

// node_modules/@carbon/react/es/components/UIShell/SideNavItem.js
var import_classnames165 = __toESM(require_classnames());
var import_prop_types191 = __toESM(require_prop_types());
var import_react242 = __toESM(require_react());
var SideNavItem = ({
  className: customClassName,
  children,
  large = false
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames165.default)({
    [`${prefix}--side-nav__item`]: true,
    [`${prefix}--side-nav__item--large`]: large,
    [customClassName]: !!customClassName
  });
  return import_react242.default.createElement("li", {
    className
  }, children);
};
SideNavItem.propTypes = {
  /**
   * Provide a single icon as the child to `SideNavItem` to render in the
   * container
   */
  children: import_prop_types191.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types191.default.string,
  /**
   * Specify if this is a large variation of the SideNavItem
   */
  large: import_prop_types191.default.bool
};

// node_modules/@carbon/react/es/components/UIShell/SideNavItems.js
var import_classnames166 = __toESM(require_classnames());
var import_prop_types192 = __toESM(require_prop_types());
var import_react243 = __toESM(require_react());
var SideNavItems = ({
  className: customClassName,
  children,
  isSideNavExpanded
}) => {
  const prefix = usePrefix();
  const className = (0, import_classnames166.default)([`${prefix}--side-nav__items`], customClassName);
  const childrenWithExpandedState = import_react243.default.Children.map(children, (child) => {
    var _a;
    if (import_react243.default.isValidElement(child)) {
      const childDisplayName = (_a = child.type) == null ? void 0 : _a.displayName;
      return import_react243.default.cloneElement(child, {
        ...CARBON_SIDENAV_ITEMS.includes(childDisplayName) ? {
          isSideNavExpanded
        } : {}
      });
    }
  });
  return import_react243.default.createElement("ul", {
    className
  }, childrenWithExpandedState);
};
SideNavItems.displayName = "SideNavItems";
SideNavItems.propTypes = {
  /**
   * Provide a single icon as the child to `SideNavIcon` to render in the
   * container
   */
  children: import_prop_types192.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types192.default.string,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types192.default.bool
};

// node_modules/@carbon/react/es/components/UIShell/SideNavLink.js
var import_classnames168 = __toESM(require_classnames());
var import_prop_types194 = __toESM(require_prop_types());
var import_react245 = __toESM(require_react());

// node_modules/@carbon/react/es/components/UIShell/SideNavLinkText.js
var import_classnames167 = __toESM(require_classnames());
var import_react244 = __toESM(require_react());
var import_prop_types193 = __toESM(require_prop_types());
function SideNavLinkText({
  className: customClassName,
  children,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames167.default)(`${prefix}--side-nav__link-text`, customClassName);
  return import_react244.default.createElement("span", _extends({}, rest, {
    className
  }), children);
}
SideNavLinkText.propTypes = {
  /**
   * Provide the content for the link text
   */
  children: import_prop_types193.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types193.default.string
};

// node_modules/@carbon/react/es/components/UIShell/SideNavLink.js
var SideNavLinkBase = ({
  children,
  className: customClassName,
  renderIcon: IconElement,
  isActive,
  isSideNavExpanded,
  large = false,
  tabIndex,
  ...rest
}, ref) => {
  const isRail = (0, import_react245.useContext)(SideNavContext);
  const prefix = usePrefix();
  const className = (0, import_classnames168.default)({
    [`${prefix}--side-nav__link`]: true,
    [`${prefix}--side-nav__link--current`]: isActive,
    [customClassName]: !!customClassName
  });
  return import_react245.default.createElement(SideNavItem, {
    large
  }, import_react245.default.createElement(Link2, _extends({}, rest, {
    className,
    ref,
    tabIndex: tabIndex === void 0 ? !isSideNavExpanded && !isRail ? -1 : 0 : tabIndex
  }), IconElement && import_react245.default.createElement(SideNavIcon, {
    small: true
  }, import_react245.default.createElement(IconElement, null)), import_react245.default.createElement(SideNavLinkText, null, children)));
};
var SideNavLink = (0, import_react245.forwardRef)(SideNavLinkBase);
SideNavLink.displayName = "SideNavLink";
SideNavLink.propTypes = {
  ...LinkPropTypes,
  /**
   * Specify the text content for the link
   */
  children: import_prop_types194.default.node.isRequired,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types194.default.string,
  /**
   * Specify whether the link is the current page
   */
  isActive: import_prop_types194.default.bool,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types194.default.bool,
  /**
   * Specify if this is a large variation of the SideNavLink
   */
  large: import_prop_types194.default.bool,
  /**
   * A component used to render an icon.
   */
  // @ts-expect-error - PropTypes are unable to cover this case.
  renderIcon: import_prop_types194.default.oneOfType([import_prop_types194.default.func, import_prop_types194.default.object]),
  /**
   * Optional prop to specify the tabIndex of the button. If undefined, it will be applied default validation
   */
  tabIndex: import_prop_types194.default.number
};

// node_modules/@carbon/react/es/components/UIShell/SideNavMenu.js
var import_classnames169 = __toESM(require_classnames());
var import_prop_types195 = __toESM(require_prop_types());
var import_react246 = __toESM(require_react());
var _ChevronDown4;
var SideNavMenu = import_react246.default.forwardRef(function SideNavMenu2({
  className: customClassName,
  children,
  defaultExpanded = false,
  isActive = false,
  large = false,
  renderIcon: IconElement,
  isSideNavExpanded,
  tabIndex,
  title
}, ref) {
  const {
    isRail
  } = (0, import_react246.useContext)(SideNavContext);
  const prefix = usePrefix();
  const [isExpanded, setIsExpanded] = (0, import_react246.useState)(defaultExpanded);
  const [prevExpanded, setPrevExpanded] = (0, import_react246.useState)(defaultExpanded);
  const className = (0, import_classnames169.default)({
    [`${prefix}--side-nav__item`]: true,
    [`${prefix}--side-nav__item--active`]: isActive || hasActiveDescendant(children) && !isExpanded,
    [`${prefix}--side-nav__item--icon`]: IconElement,
    [`${prefix}--side-nav__item--large`]: large,
    [customClassName]: !!customClassName
  });
  if (!isSideNavExpanded && isExpanded && isRail) {
    setIsExpanded(false);
    setPrevExpanded(true);
  } else if (isSideNavExpanded && prevExpanded && isRail) {
    setIsExpanded(true);
    setPrevExpanded(false);
  }
  return (
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    import_react246.default.createElement("li", {
      className,
      onKeyDown: (event) => {
        if (match(event, Escape)) {
          setIsExpanded(false);
        }
      }
    }, import_react246.default.createElement("button", {
      "aria-expanded": isExpanded,
      className: `${prefix}--side-nav__submenu`,
      onClick: () => {
        setIsExpanded(!isExpanded);
      },
      ref,
      type: "button",
      tabIndex: tabIndex === void 0 ? !isSideNavExpanded && !isRail ? -1 : 0 : tabIndex
    }, IconElement && import_react246.default.createElement(SideNavIcon, null, import_react246.default.createElement(IconElement, null)), import_react246.default.createElement("span", {
      className: `${prefix}--side-nav__submenu-title`
    }, title), import_react246.default.createElement(SideNavIcon, {
      className: `${prefix}--side-nav__submenu-chevron`,
      small: true
    }, _ChevronDown4 || (_ChevronDown4 = import_react246.default.createElement(ChevronDown, {
      size: 20
    })))), import_react246.default.createElement("ul", {
      className: `${prefix}--side-nav__menu`
    }, children))
  );
});
SideNavMenu.displayName = "SideNavMenu";
SideNavMenu.propTypes = {
  /**
   * Provide <SideNavMenuItem>'s inside of the `SideNavMenu`
   */
  children: import_prop_types195.default.node,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types195.default.string,
  /**
   * Specify whether the menu should default to expanded. By default, it will
   * be closed.
   */
  defaultExpanded: import_prop_types195.default.bool,
  /**
   * Specify whether the `SideNavMenu` is "active". `SideNavMenu` should be
   * considered active if one of its menu items are a link for the current
   * page.
   */
  isActive: import_prop_types195.default.bool,
  /**
   * Property to indicate if the side nav container is open (or not). Use to
   * keep local state and styling in step with the SideNav expansion state.
   */
  isSideNavExpanded: import_prop_types195.default.bool,
  /**
   * Specify if this is a large variation of the SideNavMenu
   */
  large: import_prop_types195.default.bool,
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types195.default.oneOfType([import_prop_types195.default.func, import_prop_types195.default.object]),
  /**
   * Optional prop to specify the tabIndex of the button. If undefined, it will be applied default validation
   */
  tabIndex: import_prop_types195.default.number,
  /**
   * Provide the text for the overall menu name
   */
  title: import_prop_types195.default.string.isRequired
};
function hasActiveDescendant(children) {
  if (Array.isArray(children)) {
    return children.some((child) => {
      if (!import_react246.default.isValidElement(child)) {
        return false;
      }
      const props = child.props;
      if (props.isActive === true || props["aria-current"] || props.children instanceof Array && hasActiveDescendant(props.children)) {
        return true;
      }
      return false;
    });
  }
  if (import_react246.default.isValidElement(children)) {
    const props = children.props;
    if (props.isActive === true || props["aria-current"]) {
      return true;
    }
  }
  return false;
}

// node_modules/@carbon/react/es/components/UIShell/SideNavMenuItem.js
var import_classnames170 = __toESM(require_classnames());
var import_prop_types196 = __toESM(require_prop_types());
var import_react247 = __toESM(require_react());
var SideNavMenuItem = import_react247.default.forwardRef(function SideNavMenuItem2(props, ref) {
  const prefix = usePrefix();
  const {
    children,
    className: customClassName,
    as: Component2 = Link2,
    isActive,
    ...rest
  } = props;
  const className = (0, import_classnames170.default)(`${prefix}--side-nav__menu-item`, customClassName);
  const linkClassName = (0, import_classnames170.default)({
    [`${prefix}--side-nav__link`]: true,
    [`${prefix}--side-nav__link--current`]: isActive
  });
  return import_react247.default.createElement("li", {
    className
  }, import_react247.default.createElement(Component2, _extends({}, rest, {
    className: linkClassName,
    ref
  }), import_react247.default.createElement(SideNavLinkText, null, children)));
});
SideNavMenuItem.displayName = "SideNavMenuItem";
SideNavMenuItem.propTypes = {
  /**
   * Optional component to render instead of default Link
   */
  as: import_prop_types196.default.elementType,
  /**
   * Specify the children to be rendered inside of the `SideNavMenuItem`
   */
  children: import_prop_types196.default.node,
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types196.default.string,
  /**
   * Optionally provide an href for the underlying li`
   */
  href: import_prop_types196.default.string,
  /**
   * Optionally specify whether the link is "active". An active link is one that
   * has an href that is the same as the current page. Can also pass in
   * `aria-current="page"`, as well.
   */
  isActive: import_prop_types196.default.bool
};

// node_modules/@carbon/react/es/components/UIShell/SideNavSwitcher.js
var import_classnames171 = __toESM(require_classnames());
var import_prop_types197 = __toESM(require_prop_types());
var import_react248 = __toESM(require_react());
var _ChevronDown5;
var SideNavSwitcher = (0, import_react248.forwardRef)(function SideNavSwitcher2(props, ref) {
  const id = useId("side-nav-switcher");
  const prefix = usePrefix();
  const {
    className: customClassName,
    labelText,
    onChange,
    options
  } = props;
  const className = (0, import_classnames171.default)(`${prefix}--side-nav__switcher`, customClassName);
  return import_react248.default.createElement("div", {
    className
  }, import_react248.default.createElement("label", {
    htmlFor: id,
    className: `${prefix}--assistive-text`
  }, labelText), import_react248.default.createElement("select", {
    id,
    className: `${prefix}--side-nav__select`,
    defaultValue: "",
    onBlur: onChange,
    onChange,
    ref
  }, import_react248.default.createElement("option", {
    className: `${prefix}--side-nav__option`,
    disabled: true,
    hidden: true,
    value: ""
  }, labelText), options.map((option) => import_react248.default.createElement("option", {
    key: option,
    className: `${prefix}--side-nav__option`,
    value: option
  }, option))), import_react248.default.createElement("div", {
    className: `${prefix}--side-nav__switcher-chevron`
  }, _ChevronDown5 || (_ChevronDown5 = import_react248.default.createElement(ChevronDown, {
    size: 20
  }))));
});
SideNavSwitcher.displayName = "SideNavSwitcher";
SideNavSwitcher.propTypes = {
  /**
   * Provide an optional class to be applied to the containing node
   */
  className: import_prop_types197.default.string,
  /**
   * Provide the label for the switcher. This will be the first visible option
   * when someone views this control
   */
  labelText: import_prop_types197.default.string.isRequired,
  /**
   * Provide a callback function that is called whenever the switcher value is
   * updated
   */
  onChange: import_prop_types197.default.func,
  /**
   * Provide an array of options to be rendered in the switcher as an
   * `<option>`. The text value will be what is displayed to the user and is set
   * as the `value` prop for each `<option>`.
   */
  options: import_prop_types197.default.arrayOf(import_prop_types197.default.string).isRequired
};

// node_modules/@carbon/react/es/components/UIShell/Switcher.js
var Switcher = (0, import_react249.forwardRef)(function Switcher2(props, forwardRef36) {
  const switcherRef = (0, import_react249.useRef)(null);
  const ref = useMergedRefs([switcherRef, forwardRef36]);
  const prefix = usePrefix();
  const {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    className: customClassName,
    children,
    expanded
  } = props;
  const accessibilityLabel = {
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy
  };
  const className = (0, import_classnames172.default)(`${prefix}--switcher`, {
    [customClassName || ""]: !!customClassName
  });
  const handleSwitcherItemFocus = ({
    currentIndex,
    direction
  }) => {
    var _a, _b;
    const enabledIndices = import_react249.Children.toArray(children).reduce((acc, child, i) => {
      if ((0, import_react249.isValidElement)(child) && child.type === SwitcherItem && Object.keys(child.props).length) {
        acc.push(i);
      }
      return acc;
    }, []);
    const nextValidIndex = (() => {
      const nextIndex = enabledIndices.indexOf(currentIndex) + direction;
      switch (enabledIndices[nextIndex]) {
        case void 0:
          if (direction === -1) {
            return enabledIndices[enabledIndices.length - 1];
          }
          return enabledIndices[0];
        case 0:
          if (direction === 1) {
            return enabledIndices[1];
          }
        default:
          return enabledIndices[nextIndex];
      }
    })();
    const switcherItem = (_b = (_a = switcherRef.current) == null ? void 0 : _a.children[nextValidIndex]) == null ? void 0 : _b.children[0];
    if (switcherItem) {
      switcherItem.focus();
    }
  };
  const childrenWithProps = import_react249.Children.toArray(children).map((child, index3) => {
    if ((0, import_react249.isValidElement)(child) && child.type === SwitcherItem) {
      return (0, import_react249.cloneElement)(child, {
        handleSwitcherItemFocus,
        index: index3,
        key: index3,
        expanded
      });
    }
    if ((0, import_react249.isValidElement)(child) && child.type === SwitcherDivider) {
      return (0, import_react249.cloneElement)(child, {
        key: index3
      });
    }
    return child;
  });
  return import_react249.default.createElement("ul", _extends({
    ref,
    className
  }, accessibilityLabel), childrenWithProps);
});
Switcher.displayName = "Switcher";
Switcher.propTypes = {
  /**
   * Required props for accessibility label on the underlying menu
   */
  ...AriaLabelPropType,
  /**
   * expects to receive <SwitcherItem />
   */
  children: import_prop_types198.default.node.isRequired,
  /**
   * Optionally provide a custom class to apply to the underlying `<ul>` node
   */
  className: import_prop_types198.default.string,
  /**
   * Specify whether the panel is expanded
   */
  expanded: import_prop_types198.default.bool
};

// node_modules/@carbon/react/es/components/UIShell/HeaderPanel.js
var HeaderPanel = import_react250.default.forwardRef(function HeaderPanel2({
  children,
  className: customClassName,
  expanded,
  addFocusListeners = true,
  onHeaderPanelFocus = noopFn,
  href,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const headerPanelReference = (0, import_react250.useRef)(null);
  const headerPanelRef = useMergedRefs([headerPanelReference, ref]);
  const controlled = (0, import_react250.useRef)(expanded !== void 0).current;
  const [expandedState, setExpandedState] = (0, import_react250.useState)(expanded);
  const expandedProp = controlled ? expanded : expandedState;
  const [lastClickedElement, setLastClickedElement] = (0, import_react250.useState)(null);
  const className = (0, import_classnames173.default)(`${prefix}--header-panel`, {
    [`${prefix}--header-panel--expanded`]: expandedProp,
    [customClassName]: !!customClassName
  });
  const eventHandlers = {};
  if (addFocusListeners) {
    eventHandlers.onBlur = (event) => {
      var _a;
      if (!event.currentTarget.contains(event.relatedTarget) && !((_a = lastClickedElement == null ? void 0 : lastClickedElement.classList) == null ? void 0 : _a.contains(`${prefix}--switcher__item-link`))) {
        setExpandedState(false);
        setLastClickedElement(null);
        if (expanded) {
          onHeaderPanelFocus();
        }
      }
    };
    eventHandlers.onKeyDown = (event) => {
      if (match(event, Escape)) {
        setExpandedState(false);
        onHeaderPanelFocus();
        if (href) {
          window.location.href = href;
        }
      }
    };
  }
  useWindowEvent("click", (event) => {
    var _a;
    const target = event.target;
    if (!(target instanceof HTMLElement)) return;
    setLastClickedElement(target);
    const isChildASwitcher = (0, import_react250.isValidElement)(children) && typeof children.type !== "string" && children.type === Switcher;
    if (isChildASwitcher && !target.closest(`.${prefix}--header-panel--expanded`) && !target.closest(`.${prefix}--header__action`) && !((_a = headerPanelReference == null ? void 0 : headerPanelReference.current) == null ? void 0 : _a.classList.contains(`${prefix}--switcher`)) && expanded) {
      setExpandedState(false);
      onHeaderPanelFocus();
    }
  });
  return import_react250.default.createElement("div", _extends({}, rest, {
    className,
    ref: headerPanelRef
  }, eventHandlers), children);
});
HeaderPanel.propTypes = {
  /**
   * Specify whether focus and blur listeners are added. They are by default.
   */
  addFocusListeners: import_prop_types199.default.bool,
  /**
   * The content that will render inside of the `HeaderPanel`
   */
  children: import_prop_types199.default.node,
  /**
   * Optionally provide a custom class to apply to the underlying `<li>` node
   */
  className: import_prop_types199.default.string,
  /**
   * Specify whether the panel is expanded
   */
  expanded: import_prop_types199.default.bool,
  /**
   * Provide the `href` to the id of the element on your package that could
   * be target.
   */
  href: import_prop_types199.default.string,
  /**
   * An optional listener that is called a callback to collapse the HeaderPanel
   */
  onHeaderPanelFocus: import_prop_types199.default.func
};
HeaderPanel.displayName = "HeaderPanel";

// node_modules/@carbon/react/es/components/UnorderedList/UnorderedList.js
var import_prop_types200 = __toESM(require_prop_types());
var import_react251 = __toESM(require_react());
var import_classnames174 = __toESM(require_classnames());
function UnorderedList({
  className,
  nested = false,
  isExpressive = false,
  ...other
}) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames174.default)(`${prefix}--list--unordered`, className, {
    [`${prefix}--list--nested`]: nested,
    [`${prefix}--list--expressive`]: isExpressive
  });
  return import_react251.default.createElement("ul", _extends({
    className: classNames
  }, other));
}
UnorderedList.propTypes = {
  /**
   * Specify a collection of ListItem's to be rendered in the UnorderedList
   */
  children: import_prop_types200.default.node,
  /**
   * Specify an optional className to be applied to the underlying `<ul>` node
   */
  className: import_prop_types200.default.string,
  /**
   * Specify whether this ordered list expressive or not
   */
  isExpressive: import_prop_types200.default.bool,
  /**
   * Specify whether the list is nested, or not
   */
  nested: import_prop_types200.default.bool
};

// node_modules/@carbon/react/es/components/FluidComboBox/FluidComboBox.js
var import_prop_types201 = __toESM(require_prop_types());
var import_react252 = __toESM(require_react());
var import_classnames175 = __toESM(require_classnames());
var FluidComboBox = import_react252.default.forwardRef(function FluidComboBox2({
  className,
  isCondensed,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames175.default)(`${prefix}--list-box__wrapper--fluid`, className, {
    [`${prefix}--list-box__wrapper--fluid--condensed`]: isCondensed
  });
  return import_react252.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react252.default.createElement(ComboBox, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidComboBox.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types201.default.string,
  /**
   * Specify the direction of the dropdown. Can be either top or bottom.
   */
  direction: import_prop_types201.default.oneOf(["top", "bottom"]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types201.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types201.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types201.default.oneOfType([import_prop_types201.default.object, import_prop_types201.default.string, import_prop_types201.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types201.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types201.default.node,
  /**
   * Specify if the `FluidComboBox` should render its menu items in condensed mode
   */
  isCondensed: import_prop_types201.default.bool,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types201.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types201.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types201.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types201.default.node.isRequired,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types201.default.func.isRequired,
  /**
   * An optional callback to render the currently selected item as a react element instead of only
   * as a string.
   */
  renderSelectedItem: import_prop_types201.default.func,
  /**
   * In the case you want to control the dropdown selection entirely.
   */
  selectedItem: import_prop_types201.default.oneOfType([import_prop_types201.default.object, import_prop_types201.default.string, import_prop_types201.default.number]),
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types201.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types201.default.func,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types201.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types201.default.node
};

// node_modules/@carbon/react/es/components/FluidComboBox/FluidComboBox.Skeleton.js
var import_prop_types202 = __toESM(require_prop_types());
var import_react253 = __toESM(require_react());
var import_classnames176 = __toESM(require_classnames());
var FluidComboBoxSkeleton = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames176.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react253.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest), import_react253.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react253.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react253.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidComboBoxSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types202.default.string
};

// node_modules/@carbon/react/es/components/FluidDatePicker/FluidDatePicker.js
var import_prop_types203 = __toESM(require_prop_types());
var import_classnames177 = __toESM(require_classnames());
var import_react254 = __toESM(require_react());
var FluidDatePicker = import_react254.default.forwardRef(function FluidDatePicker2({
  className,
  children,
  invalid,
  invalidText,
  readOnly,
  warn: warn2,
  warnText,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames177.default)(className, {
    [`${prefix}--date-picker--fluid`]: true,
    [`${prefix}--date-picker--fluid--invalid`]: invalid,
    [`${prefix}--date-picker--fluid--readonly`]: readOnly,
    [`${prefix}--date-picker--fluid--warn`]: warn2
  });
  return import_react254.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react254.default.createElement(DatePicker, _extends({
    invalid,
    invalidText,
    readOnly,
    warn: warn2,
    warnText,
    className: classNames,
    ref
  }, other), children));
});
FluidDatePicker.propTypes = {
  /**
   * The child node(s)
   */
  children: import_prop_types203.default.node,
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types203.default.string,
  /**
   * Specify whether or not the control is invalid
   */
  invalid: import_prop_types203.default.bool,
  /**
   * Provide the text that is displayed when the control is in error state
   */
  invalidText: import_prop_types203.default.node,
  /**
   * Whether the input should be read-only
   */
  readOnly: import_prop_types203.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types203.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types203.default.node
};

// node_modules/@carbon/react/es/components/FluidDatePicker/FluidDatePicker.Skeleton.js
var import_prop_types204 = __toESM(require_prop_types());
var import_react255 = __toESM(require_react());
var import_classnames178 = __toESM(require_classnames());
var FluidDatePickerSkeleton = ({
  className,
  datePickerType = "single",
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames178.default)(className, `${prefix}--form-item ${prefix}--date-picker--fluid__skeleton`, {
    [`${prefix}--date-picker--fluid__skeleton--range`]: datePickerType === "range"
  });
  return import_react255.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react255.default.createElement("div", _extends({
    className: classNames
  }, other), import_react255.default.createElement("div", {
    className: `${prefix}--date-picker--fluid__skeleton--container`
  }, import_react255.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react255.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  }), datePickerType !== "simple" && import_react255.default.createElement(Calendar, {
    className: `${prefix}--date-picker__icon`,
    role: "img",
    "aria-hidden": "true"
  })), datePickerType === "range" && import_react255.default.createElement("div", {
    className: `${prefix}--date-picker--fluid__skeleton--container`
  }, import_react255.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react255.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  }), import_react255.default.createElement(Calendar, {
    className: `${prefix}--date-picker__icon`,
    role: "img",
    "aria-hidden": "true"
  }))));
};
FluidDatePickerSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types204.default.string,
  /**
   * Specify which variant of the DatePicker the skeleton should mimic
   */
  datePickerType: import_prop_types204.default.oneOf(["simple", "single", "range"])
};

// node_modules/@carbon/react/es/components/FluidDatePickerInput/FluidDatePickerInput.js
var import_react256 = __toESM(require_react());
var frFn11 = import_react256.forwardRef;
var FluidDatePickerInput = frFn11((props, ref) => {
  return import_react256.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react256.default.createElement(DatePickerInput, _extends({
    ref
  }, props)));
});
FluidDatePickerInput.propTypes = DatePickerInput.propTypes;

// node_modules/@carbon/react/es/components/FluidDropdown/FluidDropdown.js
var import_prop_types205 = __toESM(require_prop_types());
var import_react257 = __toESM(require_react());
var import_classnames179 = __toESM(require_classnames());
var FluidDropdown = import_react257.default.forwardRef(function FluidDropdown2({
  className,
  isCondensed,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames179.default)(`${prefix}--list-box__wrapper--fluid`, className, {
    [`${prefix}--list-box__wrapper--fluid--condensed`]: isCondensed
  });
  return import_react257.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react257.default.createElement(Dropdown, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidDropdown.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types205.default.string,
  /**
   * Specify the direction of the dropdown. Can be either top or bottom.
   */
  direction: import_prop_types205.default.oneOf(["top", "bottom"]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types205.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types205.default.string.isRequired,
  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: import_prop_types205.default.oneOfType([import_prop_types205.default.object, import_prop_types205.default.string, import_prop_types205.default.number]),
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types205.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types205.default.node,
  /**
   * Specify if the `FluidDropdown` should render its menu items in condensed mode
   */
  isCondensed: import_prop_types205.default.bool,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types205.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list.
   */
  itemToString: import_prop_types205.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types205.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types205.default.node.isRequired,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types205.default.func,
  /**
   * An optional callback to render the currently selected item as a react element instead of only
   * as a string.
   */
  renderSelectedItem: import_prop_types205.default.func,
  /**
   * In the case you want to control the dropdown selection entirely.
   */
  selectedItem: import_prop_types205.default.oneOfType([import_prop_types205.default.object, import_prop_types205.default.string, import_prop_types205.default.number]),
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types205.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types205.default.func,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types205.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types205.default.node
};

// node_modules/@carbon/react/es/components/FluidDropdown/FluidDropdown.Skeleton.js
var import_prop_types206 = __toESM(require_prop_types());
var import_react258 = __toESM(require_react());
var import_classnames180 = __toESM(require_classnames());
var FluidDropdownSkeleton = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames180.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react258.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest), import_react258.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react258.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react258.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidDropdownSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types206.default.string
};

// node_modules/@carbon/react/es/components/FluidMultiSelect/FluidMultiSelect.js
var import_prop_types207 = __toESM(require_prop_types());
var import_react259 = __toESM(require_react());
var import_classnames181 = __toESM(require_classnames());
var FluidMultiSelect = import_react259.default.forwardRef(function FluidMultiSelect2({
  className,
  isCondensed,
  isFilterable,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames181.default)(`${prefix}--list-box__wrapper--fluid`, className, {
    [`${prefix}--list-box__wrapper--fluid--condensed`]: isCondensed
  });
  return import_react259.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, isFilterable ? (
    // @ts-ignore
    import_react259.default.createElement(FilterableMultiSelect, _extends({
      ref,
      className: classNames
    }, other))
  ) : (
    // @ts-ignore
    import_react259.default.createElement(MultiSelect, _extends({
      ref,
      className: classNames
    }, other))
  ));
});
FluidMultiSelect.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types207.default.string,
  /**
   * Specify the text that should be read for screen readers that describes total items selected
   */
  clearSelectionDescription: import_prop_types207.default.string,
  /**
   * Specify the text that should be read for screen readers to clear selection.
   */
  clearSelectionText: import_prop_types207.default.string,
  /**
   * Provide a compare function that is used to determine the ordering of
   * options. See 'sortItems' for more control. Consider declaring function
   * with `useCallback` to prevent unnecessary re-renders.
   */
  compareItems: import_prop_types207.default.func,
  /**
   * Specify the direction of the multiselect dropdown. Can be either top or bottom.
   */
  direction: import_prop_types207.default.oneOf(["top", "bottom"]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types207.default.bool,
  /**
   * Additional props passed to Downshift.
   *
   * **Use with caution:** anything you define here overrides the components'
   * internal handling of that prop. Downshift APIs and internals are subject to
   * change, and in some cases they can not be shimmed by Carbon to shield you
   * from potentially breaking changes.
   */
  downshiftProps: import_prop_types207.default.object,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types207.default.string.isRequired,
  /**
   * Allow users to pass in arbitrary items from their collection that are
   * pre-selected
   */
  initialSelectedItems: import_prop_types207.default.array,
  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: import_prop_types207.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types207.default.node,
  /**
   * Specify if the `FluidMultiSelect` should render its menu items in condensed mode
   */
  isCondensed: import_prop_types207.default.bool,
  /**
   * Specify if the `FluidMultiSelect` should render the `filterable` variant of `FluidMultiSelect`
   */
  isFilterable: import_prop_types207.default.bool,
  /**
   * Function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: import_prop_types207.default.func,
  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list. Consider
   * declaring function with `useCallback` to prevent unnecessary re-renders.
   */
  itemToString: import_prop_types207.default.func,
  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: import_prop_types207.default.array.isRequired,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types207.default.node.isRequired,
  /**
   * Specify the locale of the control. Used for the default `compareItems`
   * used for sorting the list of items in the control.
   */
  locale: import_prop_types207.default.string,
  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component what kind of internal state changes are occurring.
   */
  onChange: import_prop_types207.default.func,
  /**
   * **Filterable variant only** - `onInputValueChange` is a utility for this controlled component to communicate to
   * the currently typed input.
   */
  onInputValueChange: import_prop_types207.default.func,
  /**
   * `onMenuChange` is a utility for this controlled component to communicate to a
   * consuming component that the menu was open(`true`)/closed(`false`).
   */
  onMenuChange: import_prop_types207.default.func,
  /**
   * Whether or not the Multiselect is readonly
   */
  readOnly: import_prop_types207.default.bool,
  /**
   * For full control of the selected items
   */
  selectedItems: import_prop_types207.default.array,
  /**
   * Specify feedback (mode) of the selection.
   * `top`: selected item jumps to top
   * `fixed`: selected item stays at it's position
   * `top-after-reopen`: selected item jump to top after reopen dropdown
   */
  selectionFeedback: import_prop_types207.default.oneOf(["top", "fixed", "top-after-reopen"]),
  /**
   * Provide a method that sorts all options in the control. Overriding this
   * prop means that you also have to handle the sort logic for selected versus
   * un-selected items. If you just want to control ordering, consider the
   * `compareItems` prop instead.
   *
   * The return value should be a number whose sign indicates the relative order
   * of the two elements: negative if a is less than b, positive if a is greater
   * than b, and zero if they are equal.
   *
   * sortItems :
   *   (items: Array<Item>, {
   *     selectedItems: Array<Item>,
   *     itemToString: Item => string,
   *     compareItems: (itemA: string, itemB: string, {
   *       locale: string
   *     }) => number,
   *     locale: string,
   *   }) => Array<Item>
   */
  sortItems: import_prop_types207.default.func,
  /**
   * Provide the title text that will be read by a screen reader when
   * visiting this control
   */
  titleText: import_prop_types207.default.node,
  /**
   * Callback function for translating ListBoxMenuIcon SVG title
   */
  translateWithId: import_prop_types207.default.func,
  /**
   * Specify title to show title on hover
   */
  useTitleInItem: import_prop_types207.default.bool,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types207.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types207.default.node
};

// node_modules/@carbon/react/es/components/FluidMultiSelect/FluidMultiSelect.Skeleton.js
var import_prop_types208 = __toESM(require_prop_types());
var import_react260 = __toESM(require_react());
var import_classnames182 = __toESM(require_classnames());
var FluidMultiSelectSkeleton = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames182.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react260.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest), import_react260.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react260.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react260.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidMultiSelectSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types208.default.string
};

// node_modules/@carbon/react/es/components/FluidSelect/FluidSelect.js
var import_prop_types209 = __toESM(require_prop_types());
var import_react261 = __toESM(require_react());
var import_classnames183 = __toESM(require_classnames());
var FluidSelect = import_react261.default.forwardRef(function FluidSelect2({
  className,
  children,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames183.default)(`${prefix}--select--fluid`, className);
  return import_react261.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react261.default.createElement(Select, _extends({
    ref,
    className: classNames
  }, other), children));
});
FluidSelect.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types209.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types209.default.string,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types209.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types209.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types209.default.string.isRequired,
  /**
   * Specify if the currently value is invalid.
   */
  invalid: import_prop_types209.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types209.default.node,
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types209.default.node,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types209.default.func,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types209.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types209.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types209.default.bool
};

// node_modules/@carbon/react/es/components/FluidSelect/FluidSelect.Skeleton.js
var import_prop_types210 = __toESM(require_prop_types());
var import_react262 = __toESM(require_react());
var import_classnames184 = __toESM(require_classnames());
var FluidSelectSkeleton = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames184.default)(className, `${prefix}--list-box__wrapper--fluid`);
  return import_react262.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest), import_react262.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--list-box`
  }, import_react262.default.createElement("span", {
    className: `${prefix}--list-box__label`
  }), import_react262.default.createElement("div", {
    className: `${prefix}--list-box__field`
  })));
};
FluidSelectSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types210.default.string
};

// node_modules/@carbon/react/es/components/FluidSearch/FluidSearch.js
var import_prop_types211 = __toESM(require_prop_types());
var import_react263 = __toESM(require_react());
var import_classnames185 = __toESM(require_classnames());
var FluidSearch = import_react263.default.forwardRef(function FluidSearch2({
  className,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames185.default)(`${prefix}--search--fluid`, className);
  return import_react263.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react263.default.createElement(Search2, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidSearch.propTypes = {
  /**
   * Specify an optional value for the `autocomplete` property on the underlying
   * `<input>`, defaults to "off"
   */
  autoComplete: import_prop_types211.default.string,
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types211.default.string,
  /**
   * Specify a label to be read by screen readers on the "close" button
   */
  closeButtonLabelText: import_prop_types211.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types211.default.oneOfType([import_prop_types211.default.string, import_prop_types211.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types211.default.bool,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types211.default.string,
  /**
   * Provide the label text for the Search icon
   */
  labelText: import_prop_types211.default.node.isRequired,
  /**
   * Optional callback called when the search value changes.
   */
  onChange: import_prop_types211.default.func,
  /**
   * Optional callback called when the search value is cleared.
   */
  onClear: import_prop_types211.default.func,
  /**
   * Provide a handler that is invoked on the key down event for the input
   */
  onKeyDown: import_prop_types211.default.func,
  /**
   * Provide an optional placeholder text for the Search.
   * Note: if the label and placeholder differ,
   * VoiceOver on Mac will read both
   */
  placeholder: import_prop_types211.default.string,
  /**
   * Specify the role for the underlying `<input>`, defaults to `searchbox`
   */
  role: import_prop_types211.default.string,
  /**
   * Optional prop to specify the type of the `<input>`
   */
  type: import_prop_types211.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types211.default.oneOfType([import_prop_types211.default.string, import_prop_types211.default.number])
};

// node_modules/@carbon/react/es/components/FluidSearch/FluidSearch.Skeleton.js
var import_prop_types212 = __toESM(require_prop_types());
var import_react264 = __toESM(require_react());
var import_classnames186 = __toESM(require_classnames());
var FluidSearchSkeleton = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  return import_react264.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react264.default.createElement("div", _extends({
    className: (0, import_classnames186.default)(`${prefix}--form-item ${prefix}--text-input--fluid__skeleton`, className)
  }, other), import_react264.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react264.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  })));
};
FluidSearchSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types212.default.string
};

// node_modules/@carbon/react/es/components/FluidTextArea/FluidTextArea.js
var import_prop_types213 = __toESM(require_prop_types());
var import_react265 = __toESM(require_react());
var import_classnames187 = __toESM(require_classnames());
var FluidTextArea = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  const classNames = (0, import_classnames187.default)(`${prefix}--text-area--fluid`, className);
  return import_react265.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react265.default.createElement(TextArea, _extends({
    className: classNames
  }, other)));
};
FluidTextArea.propTypes = {
  /**
   * Provide a custom className that is applied directly to the underlying
   * `<textarea>` node
   */
  className: import_prop_types213.default.string,
  /**
   * Specify the `cols` attribute for the underlying `<textarea>` node
   */
  cols: import_prop_types213.default.number,
  /**
   * Optionally provide the default value of the `<textarea>`
   */
  defaultValue: import_prop_types213.default.oneOfType([import_prop_types213.default.string, import_prop_types213.default.number]),
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types213.default.bool,
  /**
   * Specify whether to display the character counter
   */
  enableCounter: import_prop_types213.default.bool,
  /**
   * Provide text that is used alongside the control label for additional help
   */
  helperText: import_prop_types213.default.node,
  /**
   * Specify whether you want the underlying label to be visually hidden
   */
  hideLabel: import_prop_types213.default.bool,
  /**
   * Provide a unique identifier for the control
   */
  id: import_prop_types213.default.string,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types213.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types213.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types213.default.node.isRequired,
  /**
   * `true` to use the light version. For use on $ui-01 backgrounds only.
   * Don't use this to make tile background color same as container background color.
   */
  light: deprecate(import_prop_types213.default.bool, "The `light` prop for `FluidTextArea` has been deprecated in favor of the new `Layer` component. It will be removed in the next major release."),
  /**
   * Max character count allowed for the textarea. This is needed in order for enableCounter to display
   */
  maxCount: import_prop_types213.default.number,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<textarea>`
   * is updated
   */
  onChange: import_prop_types213.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<textarea>` is clicked
   */
  onClick: import_prop_types213.default.func,
  /**
   * Specify the placeholder attribute for the `<textarea>`
   */
  placeholder: import_prop_types213.default.string,
  /**
   * Specify the rows attribute for the `<textarea>`
   */
  rows: import_prop_types213.default.number,
  /**
   * Provide the current value of the `<textarea>`
   */
  value: import_prop_types213.default.oneOfType([import_prop_types213.default.string, import_prop_types213.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types213.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types213.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types213.default.bool
};

// node_modules/@carbon/react/es/components/FluidTextArea/FluidTextArea.Skeleton.js
var import_prop_types214 = __toESM(require_prop_types());
var import_react266 = __toESM(require_react());
var import_classnames188 = __toESM(require_classnames());
var FluidTextAreaSkeleton = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  return import_react266.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react266.default.createElement("div", _extends({
    className: (0, import_classnames188.default)(`${prefix}--form-item ${prefix}--text-area--fluid__skeleton`, className)
  }, other), import_react266.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react266.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-area`
  })));
};
FluidTextAreaSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types214.default.string
};

// node_modules/@carbon/react/es/components/FluidTextInput/FluidTextInput.js
var import_prop_types215 = __toESM(require_prop_types());
var import_react267 = __toESM(require_react());
var import_classnames189 = __toESM(require_classnames());
var FluidTextInput = import_react267.default.forwardRef(function FluidTextInput2({
  className,
  isPassword,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames189.default)(className, {
    [`${prefix}--text-input--fluid`]: !isPassword
  });
  return import_react267.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, isPassword ? import_react267.default.createElement(PasswordInput, _extends({
    className: classNames,
    ref
  }, other)) : import_react267.default.createElement(TextInput, _extends({
    className: classNames,
    ref
  }, other)));
});
FluidTextInput.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types215.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types215.default.oneOfType([import_prop_types215.default.string, import_prop_types215.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types215.default.bool,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types215.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types215.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types215.default.node,
  /**
   * Specify whether the control is a password input
   */
  isPassword: import_prop_types215.default.bool,
  /**
   * Max character count allowed for the textInput. This is needed in order for enableCounter to display
   */
  maxCount: import_prop_types215.default.number,
  /**
   * Specify whether to display the character counter
   */
  enableCounter: import_prop_types215.default.bool,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types215.default.node.isRequired,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types215.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types215.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types215.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types215.default.oneOfType([import_prop_types215.default.string, import_prop_types215.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types215.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types215.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types215.default.bool
};

// node_modules/@carbon/react/es/components/FluidTextInput/FluidPasswordInput.js
var import_prop_types216 = __toESM(require_prop_types());
var import_react268 = __toESM(require_react());
var import_classnames190 = __toESM(require_classnames());
({
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types216.default.string,
  /**
   * Optionally provide the default value of the `<input>`
   */
  defaultValue: import_prop_types216.default.oneOfType([import_prop_types216.default.string, import_prop_types216.default.number]),
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types216.default.bool,
  /**
   * "Hide password" tooltip text on password visibility toggle
   */
  hidePasswordLabel: import_prop_types216.default.string,
  /**
   * Specify a custom `id` for the `<input>`
   */
  id: import_prop_types216.default.string.isRequired,
  /**
   * Specify whether the control is currently invalid
   */
  invalid: import_prop_types216.default.bool,
  /**
   * Provide the text that is displayed when the control is in an invalid state
   */
  invalidText: import_prop_types216.default.node,
  /**
   * Specify whether the control is a password input
   */
  isPassword: import_prop_types216.default.bool,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types216.default.node.isRequired,
  /**
   * Optionally provide an `onChange` handler that is called whenever `<input>`
   * is updated
   */
  onChange: import_prop_types216.default.func,
  /**
   * Optionally provide an `onClick` handler that is called whenever the
   * `<input>` is clicked
   */
  onClick: import_prop_types216.default.func,
  /**
   * Callback function that is called whenever the toggle password visibility
   * button is clicked
   */
  onTogglePasswordVisibility: import_prop_types216.default.func,
  /**
   * Specify the placeholder attribute for the `<input>`
   */
  placeholder: import_prop_types216.default.string,
  /**
   * "Show password" tooltip text on password visibility toggle
   */
  showPasswordLabel: import_prop_types216.default.string,
  /**
   * Specify the value of the `<input>`
   */
  value: import_prop_types216.default.oneOfType([import_prop_types216.default.string, import_prop_types216.default.number]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types216.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types216.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types216.default.bool
});

// node_modules/@carbon/react/es/components/FluidTextInput/FluidTextInput.Skeleton.js
var import_prop_types217 = __toESM(require_prop_types());
var import_react269 = __toESM(require_react());
var import_classnames191 = __toESM(require_classnames());
var FluidTextInputSkeleton = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  return import_react269.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react269.default.createElement("div", _extends({
    className: (0, import_classnames191.default)(`${prefix}--form-item ${prefix}--text-input--fluid__skeleton`, className)
  }, other), import_react269.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react269.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  })));
};
FluidTextInputSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types217.default.string
};

// node_modules/@carbon/react/es/components/FluidNumberInput/FluidNumberInput.js
var import_prop_types218 = __toESM(require_prop_types());
var import_react270 = __toESM(require_react());
var import_classnames192 = __toESM(require_classnames());
var FluidNumberInput = import_react270.default.forwardRef(function FluidNumberInput2({
  className,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames192.default)(`${prefix}--number-input--fluid`, className);
  return import_react270.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react270.default.createElement(NumberInput, _extends({
    ref,
    className: classNames
  }, other)));
});
FluidNumberInput.propTypes = {
  /**
   * `true` to allow empty string.
   */
  allowEmpty: import_prop_types218.default.bool,
  /**
   * Specify an optional className to be applied to the wrapper node
   */
  className: import_prop_types218.default.string,
  /**
   * Optional starting value for uncontrolled state
   */
  defaultValue: import_prop_types218.default.oneOfType([import_prop_types218.default.number, import_prop_types218.default.string]),
  /**
   * Specify if the wheel functionality for the input should be disabled, or not
   */
  disableWheel: import_prop_types218.default.bool,
  /**
   * Specify if the control should be disabled, or not
   */
  disabled: import_prop_types218.default.bool,
  /**
   * **Experimental:** Specify Intl.NumberFormat options applied to internal
   * number parsing and formatting. Use with `type="text"`, has no effect when
   * `type="number"`.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   */
  formatOptions: NumberFormatOptionsPropType,
  /**
   * Provide a description for up/down icons that can be read by screen readers
   */
  iconDescription: import_prop_types218.default.string,
  /**
   * Specify a custom `id` for the input
   */
  id: import_prop_types218.default.string.isRequired,
  /**
   * Instruct the browser which keyboard to display on mobile devices. Defaults
   * to `decimal`, but note that standard numeric keyboards vary across devices
   * and operating systems.
   * @see https://css-tricks.com/everything-you-ever-wanted-to-know-about-inputmode/
   */
  inputMode: import_prop_types218.default.oneOf(["none", "text", "tel", "url", "email", "numeric", "decimal", "search"]),
  /**
   * Specify if the currently value is invalid.
   */
  invalid: import_prop_types218.default.bool,
  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: import_prop_types218.default.node,
  /**
   * Generic `label` that will be used as the textual representation of what
   * this field is for
   */
  label: import_prop_types218.default.node,
  /**
   * **Experimental:** Specify a [BCP47](https://www.ietf.org/rfc/bcp/bcp47.txt)
   * language code for parsing and formatting. Use with `type="text"`, has no
   * effect when `type="number"`.
   */
  locale: import_prop_types218.default.string,
  /**
   * The maximum value.
   */
  max: import_prop_types218.default.number,
  /**
   * The minimum value.
   */
  min: import_prop_types218.default.number,
  /**
   * Provide an optional handler that is called when the internal state of
   * NumberInput changes. This handler is called with event and state info.
   * When type="number", this is called on every change of the input.
   * When type="text", this is only called on blur after the number has been
   * parsed and formatted.
   * `(event, { value, direction }) => void`
   */
  onChange: import_prop_types218.default.func,
  /**
   * Provide an optional function to be called when the up/down button is clicked
   */
  onClick: import_prop_types218.default.func,
  /**
   * Provide an optional function to be called when a key is pressed in the number input
   */
  onKeyUp: import_prop_types218.default.func,
  /**
   * When type="text", provide an optional pattern to restrict user input. Has
   * no effect when type="number".
   */
  pattern: import_prop_types218.default.string,
  /**
   * Specify how much the values should increase/decrease upon clicking on up/down button
   */
  step: import_prop_types218.default.number,
  /**
   * Provide custom text for the component for each translation id
   */
  translateWithId: import_prop_types218.default.func,
  /**
   * **Experimental**: Specify if the input should be of type text or number.
   * Use type="text" with `locale`, `formatOptions`, and guide user input with
   * `pattern` and `inputMode`.
   */
  type: import_prop_types218.default.oneOf(["number", "text"]),
  /**
   * Specify the value of the input
   */
  value: import_prop_types218.default.oneOfType([import_prop_types218.default.number, import_prop_types218.default.string]),
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types218.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types218.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types218.default.bool
};

// node_modules/@carbon/react/es/components/FluidNumberInput/FluidNumberInput.Skeleton.js
var import_prop_types219 = __toESM(require_prop_types());
var import_react271 = __toESM(require_react());
var import_classnames193 = __toESM(require_classnames());
var FluidNumberInputSkeleton = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  return import_react271.default.createElement(FormContext.Provider, {
    value: {
      isFluid: true
    }
  }, import_react271.default.createElement("div", _extends({
    className: (0, import_classnames193.default)(`${prefix}--form-item ${prefix}--text-input--fluid__skeleton`, className)
  }, other), import_react271.default.createElement("span", {
    className: `${prefix}--label ${prefix}--skeleton`
  }), import_react271.default.createElement("div", {
    className: `${prefix}--skeleton ${prefix}--text-input`
  })));
};
FluidNumberInputSkeleton.propTypes = {
  /**
   * Specify an optional className to be applied to the outer FluidForm wrapper
   */
  className: import_prop_types219.default.string
};

// node_modules/@carbon/react/es/components/FluidTimePicker/FluidTimePicker.js
var import_react272 = __toESM(require_react());
var import_prop_types220 = __toESM(require_prop_types());
var import_classnames194 = __toESM(require_classnames());
var FluidTimePicker = import_react272.default.forwardRef(function FluidTimePicker2({
  className,
  children,
  disabled,
  invalid,
  invalidText,
  warn: warn2,
  warnText,
  readOnly,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames194.default)(className, {
    [`${prefix}--time-picker--fluid`]: true,
    [`${prefix}--time-picker--equal-width`]: import_react272.default.Children.toArray(children).length !== 2,
    [`${prefix}--time-picker--fluid--disabled`]: disabled,
    [`${prefix}--time-picker--fluid--invalid`]: invalid,
    [`${prefix}--time-picker--fluid--warning`]: warn2
  });
  const errorText = () => {
    if (invalid) {
      return invalidText;
    }
    if (warn2) {
      return warnText;
    }
  };
  const error2 = invalid || warn2;
  const childrenWithProps = () => {
    if (disabled) {
      return import_react272.default.Children.toArray(children).map((child) => import_react272.default.cloneElement(child, {
        disabled: true
      }));
    }
    if (readOnly) {
      return import_react272.default.Children.toArray(children).map((child) => import_react272.default.cloneElement(child, {
        readOnly: true
      }));
    }
    return children;
  };
  return import_react272.default.createElement("div", {
    className: classNames
  }, import_react272.default.createElement("div", {
    className: `${prefix}--time-picker--fluid__wrapper`
  }, import_react272.default.createElement("div", {
    className: `${prefix}--time-picker__input`
  }, import_react272.default.createElement(FluidTextInput, _extends({
    ref,
    readOnly,
    disabled
  }, other))), childrenWithProps()), error2 && import_react272.default.createElement("hr", {
    className: `${prefix}--time-picker__divider`
  }), error2 && import_react272.default.createElement("div", {
    className: `${prefix}--form-requirement`
  }, errorText()), error2 && invalid ? import_react272.default.createElement(WarningFilled, {
    className: `${prefix}--time-picker__icon ${prefix}--time-picker__icon--invalid`
  }) : import_react272.default.createElement(WarningAltFilled, {
    className: `${prefix}--time-picker__icon ${prefix}--time-picker__icon--warn`
  }));
});
FluidTimePicker.propTypes = {
  /**
   * The child node(s)
   */
  children: import_prop_types220.default.node,
  /**
   * Specify an optional className to be applied to the outer FluidTimePicker wrapper
   */
  className: import_prop_types220.default.string,
  /**
   * Specify whether the `<input>` should be disabled
   */
  disabled: import_prop_types220.default.bool,
  /**
   * Specify whether or not the control is invalid
   */
  invalid: import_prop_types220.default.bool,
  /**
   * Provide the text that is displayed when the control is in error state
   */
  invalidText: import_prop_types220.default.node,
  /**
   * Provide the text that will be read by a screen reader when visiting this
   * control
   */
  labelText: import_prop_types220.default.node.isRequired,
  /**
   * Specify whether the control is currently in warning state
   */
  warn: import_prop_types220.default.bool,
  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: import_prop_types220.default.node,
  /**
   * Whether or not the component is readonly
   */
  readOnly: import_prop_types220.default.bool
};

// node_modules/@carbon/react/es/components/FluidTimePicker/FluidTimePicker.Skeleton.js
var import_prop_types221 = __toESM(require_prop_types());
var import_react273 = __toESM(require_react());
var import_classnames195 = __toESM(require_classnames());
var _FluidTextInputSkelet;
var _FluidSelectSkeleton;
var _FluidSelectSkeleton2;
var FluidTimePickerSkeleton = ({
  className,
  isOnlyTwo,
  ...rest
}) => {
  const prefix = usePrefix();
  const wrapperClasses = (0, import_classnames195.default)(className, `${prefix}--time-picker--fluid--skeleton`, {
    [`${prefix}--time-picker--equal-width`]: isOnlyTwo
  });
  return import_react273.default.createElement("div", _extends({
    className: wrapperClasses
  }, rest), _FluidTextInputSkelet || (_FluidTextInputSkelet = import_react273.default.createElement(FluidTextInputSkeleton, null)), _FluidSelectSkeleton || (_FluidSelectSkeleton = import_react273.default.createElement(FluidSelectSkeleton, null)), !isOnlyTwo ? _FluidSelectSkeleton2 || (_FluidSelectSkeleton2 = import_react273.default.createElement(FluidSelectSkeleton, null)) : null);
};
FluidTimePickerSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types221.default.string,
  /**
   * Specify if there are only two TimePicker elements
   */
  isOnlyTwo: import_prop_types221.default.bool
};

// node_modules/@carbon/react/es/components/FluidTimePickerSelect/FluidTimePickerSelect.js
var import_react274 = __toESM(require_react());
var import_prop_types222 = __toESM(require_prop_types());
var FluidTimePickerSelect = import_react274.default.forwardRef(function FluidTimePickerSelect2({
  children,
  className,
  ...other
}, ref) {
  return import_react274.default.createElement(FluidSelect, _extends({
    className,
    ref
  }, other), children);
});
FluidTimePickerSelect.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types222.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types222.default.string,
  /**
   * Optionally provide the default value of the `<select>`
   */
  defaultValue: import_prop_types222.default.any,
  /**
   * Specify whether the control is disabled
   */
  disabled: import_prop_types222.default.bool,
  /**
   * Specify a custom `id` for the `<select>`
   */
  id: import_prop_types222.default.string.isRequired,
  /**
   * Provide label text to be read by screen readers when interacting with the
   * control
   */
  labelText: import_prop_types222.default.node,
  /**
   * Provide an optional `onChange` hook that is called each time the value of
   * the underlying `<input>` changes
   */
  onChange: import_prop_types222.default.func
};

// node_modules/@carbon/react/es/components/OverflowMenuV2/index.js
var import_react275 = __toESM(require_react());
var didWarnAboutDeprecation5 = false;
function OverflowMenuV2(props) {
  if (true) {
    true ? warning(didWarnAboutDeprecation5, "`<OverflowMenuV2>` is deprecated and will be removed in the next major version. Use `<OverflowMenu>` with the `enable-v12-overflowmenu` feature flag instead.") : void 0;
    didWarnAboutDeprecation5 = true;
  }
  return import_react275.default.createElement(FeatureFlags2, {
    enableV12Overflowmenu: true
  }, import_react275.default.createElement(OverflowMenu4, props));
}

// node_modules/@carbon/react/es/components/ProgressBar/ProgressBar.js
var import_react276 = __toESM(require_react());
var import_prop_types223 = __toESM(require_prop_types());
var import_classnames196 = __toESM(require_classnames());
function ProgressBar({
  className,
  helperText,
  hideLabel,
  label,
  max: max2 = 100,
  size: size4 = "big",
  status = "active",
  type = "default",
  value
}) {
  const labelId = useId("progress-bar");
  const helperId = useId("progress-bar-helper");
  const helperTextId = useId("progress-bar-helper-text");
  const prefix = usePrefix();
  const isFinished = status === "finished";
  const isError = status === "error";
  const indeterminate = !isFinished && !isError && (value === null || value === void 0);
  let cappedValue = value;
  if (cappedValue && cappedValue > max2) {
    cappedValue = max2;
  }
  if (cappedValue && cappedValue < 0) {
    cappedValue = 0;
  }
  if (isError) {
    cappedValue = 0;
  } else if (isFinished) {
    cappedValue = max2;
  }
  const percentage = (cappedValue ?? NaN) / max2;
  const wrapperClasses = (0, import_classnames196.default)(`${prefix}--progress-bar`, `${prefix}--progress-bar--${size4}`, `${prefix}--progress-bar--${type}`, {
    [`${prefix}--progress-bar--indeterminate`]: indeterminate,
    [`${prefix}--progress-bar--finished`]: isFinished,
    [`${prefix}--progress-bar--error`]: isError
  }, className);
  const labelClasses = (0, import_classnames196.default)(`${prefix}--progress-bar__label`, {
    [`${prefix}--visually-hidden`]: hideLabel
  });
  let StatusIcon = null;
  if (isError) {
    StatusIcon = import_react276.default.forwardRef(function ErrorFilled16(props, ref2) {
      return import_react276.default.createElement(ErrorFilled, _extends({
        ref: ref2,
        size: 16
      }, props));
    });
  } else if (isFinished) {
    StatusIcon = import_react276.default.forwardRef(function CheckmarkFilled16(props, ref2) {
      return import_react276.default.createElement(CheckmarkFilled, _extends({
        ref: ref2,
        size: 16
      }, props));
    });
  }
  const ref = (0, import_react276.useRef)(null);
  useIsomorphicEffect(() => {
    if (ref.current) {
      if (!isFinished && !isError) {
        ref.current.style.transform = `scaleX(${percentage})`;
      } else {
        ref.current.style.transform = "";
      }
    }
  }, [percentage, isFinished, isError]);
  return import_react276.default.createElement("div", {
    className: wrapperClasses
  }, import_react276.default.createElement("div", {
    className: labelClasses,
    id: labelId
  }, import_react276.default.createElement("span", {
    className: `${prefix}--progress-bar__label-text`
  }, label), StatusIcon && import_react276.default.createElement(StatusIcon, {
    className: `${prefix}--progress-bar__status-icon`
  })), import_react276.default.createElement("div", {
    className: `${prefix}--progress-bar__track`,
    role: "progressbar",
    "aria-busy": !isFinished,
    "aria-invalid": isError,
    "aria-labelledby": labelId,
    "aria-describedby": helperText ? helperTextId : void 0,
    "aria-valuemin": !indeterminate ? 0 : void 0,
    "aria-valuemax": !indeterminate ? max2 : void 0,
    "aria-valuenow": !indeterminate ? cappedValue : void 0
  }, import_react276.default.createElement("div", {
    className: `${prefix}--progress-bar__bar`,
    ref
  })), helperText && import_react276.default.createElement("div", {
    id: helperTextId,
    className: `${prefix}--progress-bar__helper-text`
  }, helperText, import_react276.default.createElement("div", {
    className: `${prefix}--visually-hidden`,
    "aria-live": "polite",
    id: helperId
  }, isFinished ? "Done" : "Loading")));
}
ProgressBar.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: import_prop_types223.default.string,
  /**
   * The current progress as a textual representation.
   */
  helperText: import_prop_types223.default.string,
  /**
   * Whether the label should be visually hidden.
   */
  hideLabel: import_prop_types223.default.bool,
  /**
   * A label describing the progress bar.
   */
  label: import_prop_types223.default.string.isRequired,
  /**
   * The maximum value.
   */
  max: import_prop_types223.default.number,
  /**
   * Specify the size of the ProgressBar.
   */
  size: import_prop_types223.default.oneOf(["small", "big"]),
  /**
   * Specify the status.
   */
  status: import_prop_types223.default.oneOf(["active", "finished", "error"]),
  /**
   * Defines the alignment variant of the progress bar.
   */
  type: import_prop_types223.default.oneOf(["default", "inline", "indented"]),
  /**
   * The current value.
   */
  value: import_prop_types223.default.number
};

// node_modules/@carbon/react/es/components/IconIndicator/index.js
var import_prop_types224 = __toESM(require_prop_types());
var import_react277 = __toESM(require_react());
var import_classnames197 = __toESM(require_classnames());
var IconIndicatorKinds = ["failed", "caution-major", "caution-minor", "undefined", "succeeded", "normal", "in-progress", "incomplete", "not-started", "pending", "unknown", "informative"];
var iconTypes2 = {
  failed: ErrorFilled,
  ["caution-major"]: WarningAltInvertedFilled,
  ["caution-minor"]: WarningAltFilled,
  undefined: UndefinedFilled,
  succeeded: CheckmarkFilled,
  normal: CheckmarkOutline,
  ["in-progress"]: InProgress,
  incomplete: Incomplete,
  ["not-started"]: CircleDash,
  pending: PendingFilled,
  unknown: UnknownFilled,
  informative: WarningSquareFilled
};
var IconIndicator = import_react277.default.forwardRef(function IconIndicatorContent({
  className: customClassName,
  kind,
  label,
  size: size4 = 16,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames197.default)(`${prefix}--icon-indicator`, customClassName, {
    [`${prefix}--icon-indicator--20`]: size4 == 20
  });
  const IconForKind = iconTypes2[kind];
  if (!IconForKind) {
    return null;
  }
  return import_react277.default.createElement("div", {
    className: classNames,
    ref
  }, import_react277.default.createElement(IconForKind, {
    size: size4,
    className: `${prefix}--icon-indicator--${kind}`
  }), label);
});
IconIndicator.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types224.default.string,
  /**
   * Specify the kind of the Icon Indicator
   */
  kind: import_prop_types224.default.oneOf(IconIndicatorKinds).isRequired,
  /**
   * Label next to the icon.
   */
  label: import_prop_types224.default.string.isRequired,
  /**
   * Specify the size of the Icon Indicator. Defaults to 16.
   */
  size: import_prop_types224.default.oneOf([16, 20])
};

// node_modules/@carbon/react/es/components/ShapeIndicator/index.js
var import_prop_types225 = __toESM(require_prop_types());
var import_react278 = __toESM(require_react());
var import_classnames198 = __toESM(require_classnames());
var _path15;
var ShapeIndicatorKinds = ["failed", "critical", "high", "medium", "low", "cautious", "undefined", "stable", "informative", "incomplete", "draft"];
var incompleteIcon = (props) => import_react278.default.createElement("svg", _extends({
  xmlns: "http://www.w3.org/2000/svg",
  width: 16,
  height: 16,
  fill: "none",
  "aria-hidden": "true"
}, props), import_react278.default.createElement("path", {
  fill: "#fff",
  fillOpacity: 0.01,
  d: "M0 0h16v16H0z",
  style: {
    mixBlendMode: "multiply"
  }
}), _path15 || (_path15 = import_react278.default.createElement("path", {
  fill: "#161616",
  d: "M8 2a6 6 0 1 0 0 12A6 6 0 0 0 8 2Zm0 2a4.004 4.004 0 0 1 4 4H4a4.004 4.004 0 0 1 4-4Z"
})));
var shapeTypes = {
  failed: Critical,
  critical: CriticalSeverity,
  high: Caution,
  medium: DiamondFill,
  low: LowSeverity,
  cautious: Caution,
  undefined: DiamondFill,
  stable: CircleFill,
  informative: LowSeverity,
  incomplete: incompleteIcon,
  draft: CircleStroke
};
var ShapeIndicator = import_react278.default.forwardRef(function ShapeIndicatorContent({
  className: customClassName,
  kind,
  label,
  textSize = 12,
  ...rest
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames198.default)(`${prefix}--shape-indicator`, customClassName, {
    [`${prefix}--shape-indicator--14`]: textSize == 14
  });
  const ShapeForKind = shapeTypes[kind];
  if (!ShapeForKind) {
    return null;
  }
  return import_react278.default.createElement("div", {
    className: classNames,
    ref
  }, import_react278.default.createElement(ShapeForKind, {
    size: 16,
    className: `${prefix}--shape-indicator--${kind}`
  }), label);
});
ShapeIndicator.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types225.default.string,
  /**
   * Specify the kind of the Shape Indicator
   */
  kind: import_prop_types225.default.oneOf(ShapeIndicatorKinds).isRequired,
  /**
   * Label next to the shape.
   */
  label: import_prop_types225.default.string.isRequired,
  /**
   * Specify the text size of the Shape Indicator. Defaults to 12.
   */
  textSize: import_prop_types225.default.oneOf([12, 14])
};

// node_modules/@carbon/react/es/components/ChatButton/ChatButton.js
var import_react279 = __toESM(require_react());
var import_prop_types226 = __toESM(require_prop_types());
var import_classnames199 = __toESM(require_classnames());
var ChatButton = import_react279.default.forwardRef(function ChatButton2({
  className,
  children,
  disabled,
  isQuickAction,
  isSelected,
  kind,
  renderIcon,
  size: size4,
  ...other
}, ref) {
  const prefix = usePrefix();
  const classNames = (0, import_classnames199.default)(className, {
    [`${prefix}--chat-btn`]: true,
    [`${prefix}--chat-btn--with-icon`]: renderIcon,
    [`${prefix}--chat-btn--quick-action`]: isQuickAction,
    [`${prefix}--chat-btn--quick-action--selected`]: isSelected
  });
  const allowedSizes = ["sm", "md", "lg"];
  if (isQuickAction) {
    kind = "ghost";
    size4 = "sm";
  } else {
    if (size4 && !allowedSizes.includes(size4)) {
      console.error(`Invalid size "${size4}" provided to ChatButton. Size must be one of: ${allowedSizes.join(", ")}. Defaulting to "lg".`);
      size4 = "lg";
    }
  }
  return import_react279.default.createElement(Button, _extends({
    disabled,
    className: classNames,
    kind,
    ref,
    size: size4,
    renderIcon
  }, other), children);
});
ChatButton.propTypes = {
  /**
   * Provide the contents of your Select
   */
  children: import_prop_types226.default.node,
  /**
   * Specify an optional className to be applied to the node containing the label and the select box
   */
  className: import_prop_types226.default.string,
  /**
   * Specify whether the `ChatButton` should be disabled
   */
  disabled: import_prop_types226.default.bool,
  /**
   * Specify whether the `ChatButton` should be rendered as a quick action button
   */
  isQuickAction: import_prop_types226.default.bool,
  /**
   * Specify whether the quick action `ChatButton` should be rendered as selected. This disables the input
   */
  isSelected: import_prop_types226.default.bool,
  /**
   * Specify the kind of `ChatButton` you want to create
   */
  kind: import_prop_types226.default.oneOf(["primary", "secondary", "danger", "ghost", "tertiary"]),
  /**
   * A component used to render an icon.
   */
  renderIcon: import_prop_types226.default.oneOfType([import_prop_types226.default.func, import_prop_types226.default.object]),
  /**
   * Specify the size of the `ChatButton`, from the following list of sizes:
   */
  size: import_prop_types226.default.oneOf(["sm", "md", "lg"])
};

// node_modules/@carbon/react/es/components/ChatButton/ChatButton.Skeleton.js
var import_prop_types227 = __toESM(require_prop_types());
var import_react280 = __toESM(require_react());
var import_classnames200 = __toESM(require_classnames());
var ChatButtonSkeleton = ({
  className,
  size: size4,
  ...rest
}) => {
  const prefix = usePrefix();
  const skeletonClasses = (0, import_classnames200.default)(className, `${prefix}--skeleton`, `${prefix}--btn`, `${prefix}--chat-btn`, {
    [`${prefix}--layout--size-${size4}`]: size4
  });
  return import_react280.default.createElement("div", _extends({
    className: skeletonClasses
  }, rest));
};
ChatButtonSkeleton.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types227.default.string,
  /**
   * Specify the size of the `ChatButtonSkeleton`, from the following list of sizes:
   */
  size: import_prop_types227.default.oneOf(["sm", "md", "lg"])
};

// node_modules/@carbon/react/es/components/AISkeleton/AISkeletonPlaceholder.js
var import_react281 = __toESM(require_react());
var import_prop_types228 = __toESM(require_prop_types());
var import_classnames201 = __toESM(require_classnames());
var AISkeletonPlaceholder = ({
  className,
  ...other
}) => {
  const prefix = usePrefix();
  const AISkeletonPlaceholderClasses = (0, import_classnames201.default)({
    className,
    [`${prefix}--skeleton__placeholder--ai`]: true
  }, className);
  return import_react281.default.createElement(SkeletonPlaceholder, _extends({
    className: AISkeletonPlaceholderClasses
  }, other));
};
AISkeletonPlaceholder.propTypes = {
  /**
   * Add a custom class to the component
   * to set the height and width
   */
  className: import_prop_types228.default.string
};

// node_modules/@carbon/react/es/components/AISkeleton/AISkeletonIcon.js
var import_prop_types229 = __toESM(require_prop_types());
var import_react282 = __toESM(require_react());
var import_classnames202 = __toESM(require_classnames());
var AISkeletonIcon = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const AISkeletonIconClasses = (0, import_classnames202.default)(className, {
    [`${prefix}--skeleton__icon--ai`]: true
  });
  return import_react282.default.createElement(SkeletonIcon, _extends({
    className: AISkeletonIconClasses
  }, rest));
};
AISkeletonIcon.propTypes = {
  /**
   * Specify an optional className to add.
   */
  className: import_prop_types229.default.string,
  /**
   * The CSS styles.
   */
  style: import_prop_types229.default.object
};

// node_modules/@carbon/react/es/components/AISkeleton/AISkeletonText.js
var import_prop_types230 = __toESM(require_prop_types());
var import_react283 = __toESM(require_react());
var import_classnames203 = __toESM(require_classnames());
var AISkeletonText = ({
  className,
  ...rest
}) => {
  const prefix = usePrefix();
  const aiSkeletonTextClasses = (0, import_classnames203.default)(className, {
    [`${prefix}--skeleton__text--ai`]: true
  });
  return import_react283.default.createElement(SkeletonText, _extends({
    className: aiSkeletonTextClasses
  }, rest));
};
AISkeletonText.propTypes = {
  /**
   * Specify an optional className to be applied to the container node
   */
  className: import_prop_types230.default.string,
  /**
   * generates skeleton text at a larger size
   */
  heading: import_prop_types230.default.bool,
  /**
   * the number of lines shown if paragraph is true
   */
  lineCount: import_prop_types230.default.number,
  /**
   * will generate multiple lines of text
   */
  paragraph: import_prop_types230.default.bool,
  /**
   * width (in px or %) of single line of text or max-width of paragraph lines
   */
  width: import_prop_types230.default.string
};

// node_modules/@carbon/react/es/components/Theme/index.js
var import_classnames204 = __toESM(require_classnames());
var import_prop_types231 = __toESM(require_prop_types());
var import_react284 = __toESM(require_react());
var ThemeContext = import_react284.default.createContext({
  theme: "white"
});
var GlobalTheme = import_react284.default.forwardRef(function GlobalTheme2({
  children,
  theme
}, ref) {
  const value = (0, import_react284.useMemo)(() => {
    return {
      theme
    };
  }, [theme]);
  const childrenWithProps = import_react284.default.cloneElement(children, {
    ref
  });
  return import_react284.default.createElement(ThemeContext.Provider, {
    value
  }, childrenWithProps);
});
GlobalTheme.propTypes = {
  /**
   * Provide child elements to be rendered inside of `GlobalTheme`, this is
   * typically the root of your app
   */
  children: import_prop_types231.default.node,
  /**
   * Specify the global theme for your app
   */
  theme: import_prop_types231.default.oneOf(["white", "g10", "g90", "g100"])
};
function Theme({
  as: BaseComponent = "div",
  className: customClassName,
  theme,
  ...rest
}) {
  const prefix = usePrefix();
  const className = (0, import_classnames204.default)(customClassName, {
    [`${prefix}--white`]: theme === "white",
    [`${prefix}--g10`]: theme === "g10",
    [`${prefix}--g90`]: theme === "g90",
    [`${prefix}--g100`]: theme === "g100",
    [`${prefix}--layer-one`]: true
  });
  const value = import_react284.default.useMemo(() => {
    const isDark = theme && ["g90", "g100"].includes(theme);
    return {
      theme,
      isDark
    };
  }, [theme]);
  const BaseComponentAsAny = BaseComponent;
  return import_react284.default.createElement(ThemeContext.Provider, {
    value
  }, import_react284.default.createElement(LayerContext.Provider, {
    value: 1
  }, import_react284.default.createElement(BaseComponentAsAny, _extends({}, rest, {
    className
  }))));
}
Theme.propTypes = {
  /**
   * Specify a custom component or element to be rendered as the top-level
   * element in the component
   */
  as: import_prop_types231.default.oneOfType([import_prop_types231.default.func, import_prop_types231.default.string, import_prop_types231.default.elementType]),
  /**
   * Provide child elements to be rendered inside of `Theme`
   */
  children: import_prop_types231.default.node,
  /**
   * Provide a custom class name to be used on the outermost element rendered by
   * the component
   */
  className: import_prop_types231.default.string,
  /**
   * Specify the theme
   */
  theme: import_prop_types231.default.oneOf(["white", "g10", "g90", "g100"])
};
function useTheme() {
  return import_react284.default.useContext(ThemeContext);
}
function usePrefersDarkScheme() {
  return useMatchMedia("(prefers-color-scheme: dark)");
}

// node_modules/@carbon/react/es/components/Pagination/experimental/PageSelector.js
var import_react285 = __toESM(require_react());
var import_prop_types232 = __toESM(require_prop_types());
var import_classnames205 = __toESM(require_classnames());
function PageSelector({
  className = null,
  currentPage,
  id = 1,
  labelText = "Current page number",
  totalPages,
  ...other
}) {
  const prefix = usePrefix();
  const namespace = `${prefix}--unstable-pagination__page-selector`;
  const instanceId2 = `${namespace}__select-${useId()}`;
  const renderPages = (total) => {
    const pages = [];
    for (let counter = 1; counter <= total; counter += 1) {
      pages.push(import_react285.default.createElement(SelectItem, {
        key: counter,
        value: counter,
        text: String(counter)
      }));
    }
    return pages;
  };
  return import_react285.default.createElement(Select, _extends({
    className: (0, import_classnames205.default)(namespace, className),
    hideLabel: true,
    id: instanceId2 || id,
    inline: true,
    labelText,
    value: currentPage
  }, other), renderPages(totalPages));
}
PageSelector.propTypes = {
  /** Extra class names to add. */
  className: import_prop_types232.default.string,
  /** The current page. */
  currentPage: import_prop_types232.default.number.isRequired,
  /** The unique ID of this component instance. */
  id: import_prop_types232.default.oneOfType([import_prop_types232.default.string, import_prop_types232.default.number]),
  /** Translatable string to label the page selector element. */
  labelText: import_prop_types232.default.string,
  /**
   * Total number of pages.
   * This value is calculated using a valid `totalItems` prop passed to the parent `Unstable_Pagination`.
   */
  totalPages: import_prop_types232.default.number.isRequired
};

// node_modules/@carbon/react/es/components/Pagination/experimental/Pagination.js
var import_react286 = __toESM(require_react());
var import_prop_types233 = __toESM(require_prop_types());
var import_classnames206 = __toESM(require_classnames());
var _CaretLeft4;
var _CaretRight4;
function Pagination3({
  backwardText = "Previous page",
  children = void 0,
  className = null,
  disabled = false,
  forwardText = "Next page",
  id = 1,
  initialPage = 1,
  itemsPerPageText = "Items per page:",
  itemRangeText = (min2, max2, total) => `${min2}–${max2} of ${total} items`,
  itemText = (min2, max2) => `${min2}–${max2} items`,
  onChange,
  pageRangeText = (current, total) => `${current} of ${total} pages`,
  pageSize = 10,
  pageSizes = void 0,
  pageText = (page) => `page ${page}`,
  pagesUnknown = false,
  totalItems = void 0,
  ...other
}) {
  const [currentPage, setCurrentPage] = (0, import_react286.useState)(initialPage);
  const [currentPageSize, setCurrentPageSize] = (0, import_react286.useState)(pageSize);
  const prefix = usePrefix();
  const totalPages = totalItems ? Math.max(Math.ceil(totalItems / currentPageSize), 1) : void 0;
  const backButtonDisabled = disabled || currentPage === 1;
  const forwardButtonDisabled = disabled || currentPage === totalPages;
  function onSetPage(newPage) {
    setCurrentPage(Number(newPage));
  }
  function incrementPage() {
    const page = currentPage + 1;
    setCurrentPage(page);
    onChange({
      page,
      pageSize: currentPageSize
    });
  }
  function decrementPage() {
    const page = currentPage - 1;
    setCurrentPage(page);
    onChange({
      page,
      pageSize: currentPageSize
    });
  }
  const namespace = `${prefix}--unstable-pagination`;
  return import_react286.default.createElement("section", _extends({
    className: (0, import_classnames206.default)(namespace, className)
  }, other), import_react286.default.createElement("div", {
    className: `${namespace}__left`
  }, pageSizes && import_react286.default.createElement(import_react286.default.Fragment, null, import_react286.default.createElement("label", {
    id: `${namespace}__page-sizer__counter-${id}`,
    className: `${namespace}__text`,
    htmlFor: `${namespace}__page-sizer__input-${id}`
  }, itemsPerPageText), import_react286.default.createElement(Select, {
    id: `${namespace}__page-sizer__input-${id}`,
    className: `${namespace}__page-sizer`,
    labelText: "",
    hideLabel: true,
    noLabel: true,
    inline: true,
    onChange: (event) => setCurrentPageSize(Number(event.target.value)),
    value: currentPageSize
  }, pageSizes.map((size4) => import_react286.default.createElement(SelectItem, {
    key: size4,
    value: size4,
    text: String(size4)
  })))), import_react286.default.createElement("span", {
    className: `${namespace}__text`
  }, totalItems && !pagesUnknown && itemRangeText(Math.min(currentPageSize * (currentPage - 1) + 1, totalItems), Math.min(currentPage * currentPageSize, totalItems), totalItems), totalItems && pagesUnknown && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize), !totalItems && itemText(currentPageSize * (currentPage - 1) + 1, currentPage * currentPageSize))), import_react286.default.createElement("div", {
    className: `${namespace}__right`
  }, children && totalItems && children({
    currentPage,
    currentPageSize,
    onSetPage,
    totalPages
  }), children && totalItems && !pagesUnknown && import_react286.default.createElement("span", {
    className: `${namespace}__text`
  }, pageRangeText("", totalPages)), children && !totalItems && import_react286.default.createElement("span", {
    className: `${namespace}__text`
  }, pageText(currentPage)), !children && import_react286.default.createElement("span", {
    className: `${namespace}__text`
  }, !totalItems ? pageText(currentPage) : pageRangeText(currentPage, totalPages)), import_react286.default.createElement(import_react286.default.Fragment, null, import_react286.default.createElement(IconButton, {
    align: "top",
    disabled: backButtonDisabled,
    kind: "ghost",
    className: (0, import_classnames206.default)(`${namespace}__button`, `${namespace}__button--backward`, {
      [`${namespace}__button--no-index`]: backButtonDisabled
    }),
    label: backwardText,
    onClick: () => decrementPage()
  }, _CaretLeft4 || (_CaretLeft4 = import_react286.default.createElement(CaretLeft, null))), import_react286.default.createElement(IconButton, {
    align: "top-right",
    disabled: forwardButtonDisabled,
    kind: "ghost",
    className: (0, import_classnames206.default)(`${namespace}__button`, `${namespace}__button--forward`, {
      [`${namespace}__button--no-index`]: forwardButtonDisabled
    }),
    label: forwardText,
    onClick: () => incrementPage()
  }, _CaretRight4 || (_CaretRight4 = import_react286.default.createElement(CaretRight, null))))));
}
Pagination3.propTypes = {
  /**
   * The description for the backward icon.
   */
  backwardText: import_prop_types233.default.string,
  /**
   * The children of the pagination component.
   */
  children: import_prop_types233.default.oneOfType([import_prop_types233.default.node, import_prop_types233.default.func]),
  /**
   * Extra classes to add.
   */
  className: import_prop_types233.default.string,
  /**
   * `true` if the backward/forward buttons should be disabled.
   */
  disabled: import_prop_types233.default.bool,
  /**
   * The description for the forward icon.
   */
  forwardText: import_prop_types233.default.string,
  /** The unique ID of this component instance. */
  id: import_prop_types233.default.oneOfType([import_prop_types233.default.string, import_prop_types233.default.number]),
  /**
   * The initial active page when the component is first mounted.
   */
  initialPage: import_prop_types233.default.number,
  /**
   * The function returning a translatable text showing where the current page is,
   * in a manner of the range of items.
   */
  itemRangeText: import_prop_types233.default.func,
  /**
   * A variant of `itemRangeText`, used if the total number of items is unknown.
   */
  itemText: import_prop_types233.default.func,
  /**
   * The translatable text indicating the number of items per page.
   */
  itemsPerPageText: import_prop_types233.default.string,
  /**
   * The callback function called when the current page changes.
   */
  onChange: import_prop_types233.default.func,
  /**
   * The function returning a translatable text showing where the current page is,
   * in a manner of the total number of pages.
   */
  pageRangeText: import_prop_types233.default.func,
  /**
   * The number dictating how many items a page contains.
   */
  pageSize: import_prop_types233.default.number,
  /**
   * The choices for `pageSize`.
   */
  pageSizes: import_prop_types233.default.arrayOf(import_prop_types233.default.number),
  /**
   * The translatable text showing the current page.
   */
  pageText: import_prop_types233.default.func,
  /**
   * `true` if total number of pages is unknown.
   */
  pagesUnknown: import_prop_types233.default.bool,
  /**
   * The total number of items.
   * You need to provide total items to calculate total page,
   * which is required by a child like the `PageSelector`
   * to know how many pages to display.
   */
  totalItems: import_prop_types233.default.number
};
export {
  AILabel,
  AILabelActions,
  AILabelContent,
  AISkeletonIcon,
  AISkeletonPlaceholder,
  AISkeletonText,
  Accordion,
  AccordionItem,
  AccordionSkeleton,
  ActionableNotification,
  AspectRatio,
  Breadcrumb,
  BreadcrumbItem,
  BreadcrumbSkeleton,
  Button,
  ButtonKinds,
  ButtonSet,
  ButtonSizes,
  ButtonSkeleton,
  ButtonTooltipAlignments,
  ButtonTooltipPositions,
  Callout,
  Checkbox2 as Checkbox,
  CheckboxGroup,
  CheckboxSkeleton,
  ClassPrefix,
  ClickableTile,
  CodeSnippet,
  CodeSnippetSkeleton,
  Column,
  ColumnHangComponent as ColumnHang,
  ComboBox,
  ComboButton,
  ComposedModal,
  ContainedList,
  ContainedListItem,
  Content2 as Content,
  ContentSwitcher,
  ControlledPasswordInput,
  Copy2 as Copy,
  CopyButton,
  DangerButton,
  DataTable,
  DataTableSkeleton,
  DatePicker,
  DatePickerInput,
  DatePickerSkeleton,
  DefinitionTooltip,
  DismissibleTag,
  Dropdown,
  DropdownSkeleton,
  ErrorBoundary,
  ErrorBoundaryContext,
  ExpandableSearch,
  ExpandableTile,
  FeatureFlags2 as FeatureFlags,
  FileUploader,
  FileUploaderButton,
  FileUploaderDropContainer,
  FileUploaderItem,
  FileUploaderSkeleton,
  Filename,
  FilterableMultiSelect,
  FlexGridComponent as FlexGrid,
  FluidForm,
  Form,
  FormContext,
  FormGroup,
  FormItem,
  FormLabel,
  GlobalTheme,
  GridAsGridComponent as Grid,
  GridSettings,
  HStack,
  Header,
  HeaderContainer,
  HeaderGlobalAction,
  HeaderGlobalBar,
  HeaderMenu,
  HeaderMenuButton,
  HeaderMenuItem,
  HeaderName,
  HeaderNavigation,
  HeaderPanel,
  HeaderSideNavItems,
  Heading,
  IconButton,
  IconButtonKinds,
  IconSkeleton,
  IconSwitch,
  IconTab,
  IdPrefix,
  InlineLoading,
  InlineNotification,
  Layer,
  Link,
  ListItem,
  Loading,
  Menu2 as Menu,
  MenuButton,
  MenuItem,
  MenuItemDivider,
  MenuItemGroup,
  MenuItemRadioGroup,
  MenuItemSelectable,
  Modal,
  ModalBody,
  ModalFooter,
  ModalHeader,
  ModalWrapper,
  MultiSelect,
  NotificationActionButton,
  NotificationButton,
  NumberInput,
  NumberInputSkeleton,
  OperationalTag,
  OrderedList,
  OverflowMenu4 as OverflowMenu,
  OverflowMenuItem,
  Pagination,
  PaginationNav,
  PaginationSkeleton,
  PasswordInput,
  Popover,
  PopoverContent,
  PrefixContext,
  PrimaryButton,
  ProgressBar,
  ProgressIndicator,
  ProgressIndicatorSkeleton,
  ProgressStep,
  RadioButton2 as RadioButton,
  RadioButtonGroup,
  RadioButtonSkeleton,
  RadioTile,
  Row,
  Search2 as Search,
  SearchSkeleton,
  SecondaryButton,
  Section,
  Select,
  SelectItem,
  SelectItemGroup,
  SelectSkeleton,
  SelectableTag,
  SelectableTile,
  SideNav,
  SideNavDetails,
  SideNavDivider,
  SideNavFooter,
  SideNavHeader,
  SideNavIcon,
  SideNavItem,
  SideNavItems,
  SideNavLink,
  SideNavLinkText,
  SideNavMenu,
  SideNavMenuItem,
  SideNavSwitcher,
  SkeletonIcon,
  SkeletonPlaceholder,
  SkeletonText,
  SkipToContent,
  Slider2 as Slider,
  SliderSkeleton,
  Stack,
  StaticNotification,
  StructuredListBody,
  StructuredListCell,
  StructuredListHead,
  StructuredListInput,
  StructuredListRow,
  StructuredListSkeleton,
  StructuredListWrapper,
  Switch,
  Switcher,
  SwitcherDivider,
  SwitcherItem,
  Tab2 as Tab,
  TabContent,
  TabList,
  TabListVertical,
  TabPanel,
  TabPanels,
  Table,
  TableActionList,
  TableBatchAction,
  TableBatchActions,
  TableBody,
  TableCell,
  TableContainer,
  TableDecoratorRow,
  TableExpandHeader,
  TableExpandRow,
  TableExpandedRow,
  TableHead,
  TableHeader,
  TableRow,
  TableSelectAll,
  TableSelectRow,
  TableSlugRow,
  TableToolbar,
  TableToolbarAction,
  TableToolbarContent,
  TableToolbarMenu,
  TableToolbarSearch,
  Tabs,
  TabsSkeleton,
  TabsVertical,
  Tag,
  TagSkeleton,
  TextArea,
  TextAreaSkeleton,
  TextInput,
  TextInputSkeleton,
  Theme,
  ThemeContext,
  Tile,
  TileAboveTheFoldContent,
  TileBelowTheFoldContent,
  TileGroup,
  TimePicker,
  TimePickerSelect,
  ToastNotification,
  Toggle,
  ToggleSkeleton,
  ToggleSmallSkeleton,
  Toggletip,
  ToggletipActions,
  ToggletipButton,
  ToggletipContent,
  ToggletipLabel,
  Tooltip,
  TreeNode,
  TreeView,
  UnorderedList,
  VStack,
  Dialog_exports as preview__Dialog,
  FeatureFlags2 as unstable_FeatureFlags,
  Layout as unstable_Layout,
  LayoutDirection as unstable_LayoutDirection,
  OverflowMenuV2 as unstable_OverflowMenuV2,
  PageSelector as unstable_PageSelector,
  Pagination3 as unstable_Pagination,
  Text as unstable_Text,
  TextDirection as unstable_TextDirection,
  AISkeletonIcon as unstable__AiSkeletonIcon,
  AISkeletonPlaceholder as unstable__AiSkeletonPlaceholder,
  AISkeletonText as unstable__AiSkeletonText,
  ChatButton as unstable__ChatButton,
  ChatButtonSkeleton as unstable__ChatButtonSkeleton,
  FluidComboBox as unstable__FluidComboBox,
  FluidComboBoxSkeleton as unstable__FluidComboBoxSkeleton,
  FluidDatePicker as unstable__FluidDatePicker,
  FluidDatePickerInput as unstable__FluidDatePickerInput,
  FluidDatePickerSkeleton as unstable__FluidDatePickerSkeleton,
  FluidDropdown as unstable__FluidDropdown,
  FluidDropdownSkeleton as unstable__FluidDropdownSkeleton,
  FluidMultiSelect as unstable__FluidMultiSelect,
  FluidMultiSelectSkeleton as unstable__FluidMultiSelectSkeleton,
  FluidNumberInput as unstable__FluidNumberInput,
  FluidNumberInputSkeleton as unstable__FluidNumberInputSkeleton,
  FluidSearch as unstable__FluidSearch,
  FluidSearchSkeleton as unstable__FluidSearchSkeleton,
  FluidSelect as unstable__FluidSelect,
  FluidSelectSkeleton as unstable__FluidSelectSkeleton,
  FluidTextArea as unstable__FluidTextArea,
  FluidTextAreaSkeleton as unstable__FluidTextAreaSkeleton,
  FluidTextInput as unstable__FluidTextInput,
  FluidTextInputSkeleton as unstable__FluidTextInputSkeleton,
  FluidTimePicker as unstable__FluidTimePicker,
  FluidTimePickerSelect as unstable__FluidTimePickerSelect,
  FluidTimePickerSkeleton as unstable__FluidTimePickerSkeleton,
  IconIndicator as unstable__IconIndicator,
  PageHeader_exports as unstable__PageHeader,
  ShapeIndicator as unstable__ShapeIndicator,
  AILabel as unstable__Slug,
  AILabelActions as unstable__SlugActions,
  AILabelContent as unstable__SlugContent,
  useFeatureFlag as unstable_useFeatureFlag,
  useFeatureFlags as unstable_useFeatureFlags,
  useLayoutDirection as unstable_useLayoutDirection,
  useContextMenu,
  useFeatureFlag,
  useFeatureFlags,
  useIdPrefix,
  useLayer,
  usePrefersDarkScheme,
  usePrefix,
  useTheme
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

flatpickr/dist/l10n/index.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

flatpickr/dist/plugins/rangePlugin.js:
  (*! *****************************************************************************
      Copyright (c) Microsoft Corporation.
  
      Permission to use, copy, modify, and/or distribute this software for any
      purpose with or without fee is hereby granted.
  
      THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
      REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
      AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
      INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
      LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
      OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
      PERFORMANCE OF THIS SOFTWARE.
      ***************************************************************************** *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

@carbon/utilities/es/carousel/types.js:
  (**
   * @license
   *
   * Copyright IBM Corp. 2025
   *
   * This source code is licensed under the Apache-2.0 license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=@carbon_react.js.map
